{"/home/travis/build/npmtest/node-npmtest-jslint/test.js":"/* istanbul instrument in package npmtest_jslint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/lib.npmtest_jslint.js":"/* istanbul instrument in package npmtest_jslint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jslint = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jslint = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jslint && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jslint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jslint\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jslint.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_jslint.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jslint.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_jslint.__dirname +\n                    '/lib.npmtest_jslint.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/nodelint.js":"var con = console,\n    vm = require(\"vm\"),\n    fs = require(\"fs\"),\n    path = require('path'),\n    linter = require('./linter.js'),\n    main = require('./main.js'),\n    LintStream = require('./lintstream.js');\n\nexports.LintStream = LintStream;\n\nexports.linter = linter;\n\nexports.runMain = main.runMain;\n\nexports.setConsole = function (c) {\n    'use strict';\n    con = c;\n};\n\nfunction looksLikeFileName(edition) {\n    'use strict';\n\n    // contains .js or a path separator character '/' or '\\'\n    return (/\\.js|\\/|\\\\/).test(edition);\n}\nexports.looksLikeFileName = looksLikeFileName;\n\nexports.load = function (edition) {\n    'use strict';\n\n    var ctx = vm.createContext(),\n        fileName,\n        jslintSource;\n\n    function makePathFromName(name) {\n        return path.join(__dirname, name) + \".js\";\n    }\n\n    function makePathFromEdition(edition) {\n        return makePathFromName(\"jslint-\" + edition);\n    }\n\n    function read(name) {\n        return fs.readFileSync(name);\n    }\n\n\n    if (edition) {\n        if (looksLikeFileName(edition)) {\n            fileName = edition;\n        } else {\n            fileName = makePathFromEdition(edition);\n        }\n\n        try {\n            jslintSource = read(fileName);\n        } catch (err) {\n            con.warn(\"Unable to load edition \" + edition + \", reverting to default. \" + err);\n        }\n    }\n\n    if (!jslintSource) {\n        jslintSource = read(makePathFromName(\"jslint\"));\n    }\n\n    vm.runInContext(jslintSource, ctx);\n\n    if (!ctx.JSLINT) {\n        ctx.JSLINT = function JSLINT(script, options) {\n            var data = ctx.jslint(script, options, options.predef);\n            ctx.JSLINT.data = function () {\n                return data;\n            };\n        };\n        ctx.JSLINT.edition = ctx.jslint('').edition;\n    }\n\n    return ctx.JSLINT;\n\n};\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/linter.js":"function merge(source, add) {\n    'use strict';\n\n    var result = source || {};\n\n    if (!add) {\n        return result;\n    }\n\n    Object.keys(add).forEach(function (prop) {\n        if (!result.hasOwnProperty(prop)) {\n            result[prop] = add[prop];\n        }\n    });\n\n    return result;\n}\nexports.merge = merge;\n\nfunction preprocessScript(script) {\n    'use strict';\n\n    // Fix UTF8 with BOM\n    if (script.charCodeAt(0) === 0xFEFF) {\n        script = script.slice(1);\n    }\n\n    // remove shebang: replace it with empty line\n    script = script.replace(/^#!.*/, \"\");\n\n    return script;\n}\nexports.preprocessScript = preprocessScript;\n\nexports.doLint = function (jslint, script, options) {\n    'use strict';\n    var ok,\n        result;\n\n    script = preprocessScript(script);\n\n    ok = jslint(script, options);\n\n    result = jslint.data();\n    if (result.ok === undefined) {\n        result.ok = ok;\n    }\n    result.options = options;\n\n    // es6\n    result.errors = result.errors || result.warnings;\n\n    return result;\n};\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/main.js":"var nodelint = require('./nodelint');\nvar optModule = require('./options');\nvar nopt = require(\"nopt\");\nvar exit = require('exit'),\n    glob = require('glob');\n\nvar LintStream = require('./lintstream.js'),\n    ReportStream = require('./reportstream.js'),\n    CollectorStream = require('./collectorstream.js'),\n    JSONReportStream = require('./jsonreportstream.js'),\n    FileOpener = require('./fileopener.js');\n\nvar con = console;\nvar pro = process;\n\nexports.setConsole = function (c) {\n    'use strict';\n    con = c;\n};\n\nexports.setProcess = function (p) {\n    'use strict';\n    pro = p;\n    exit = pro.exit.bind(pro);\n};\n\nfunction commandOptions() {\n    'use strict';\n\n    var commandOpts = {\n            'indent': Number,\n            'maxerr': Number,\n            'maxlen': Number,\n            'predef': [String, Array],\n            'edition': String,\n            'config': String\n        },\n        /* flags defined in jslint-latest.js */\n        jslintFlags = [\n            'ass', 'bitwise', 'browser', 'closure', 'continue',\n            'debug', 'devel', 'eqeq', 'evil', 'forin', 'newcap',\n            'node', 'nomen', 'passfail', 'plusplus', 'properties',\n            'regexp', 'rhino', 'unparam', 'sloppy', 'stupid', 'sub',\n            'todo', 'vars', 'white'\n        ],\n        /* flags used by node-jslint to control output */\n        cliFlags = [\n            'json', 'color', 'terse', 'version', 'filter'\n        ],\n        /* not used by jslint-latest.js */\n        deprecatedFlags = [\n            'anon', 'es5', 'on', 'undef', 'windows'\n        ],\n        allFlags = jslintFlags.concat(cliFlags).concat(deprecatedFlags);\n\n    allFlags.forEach(function (option) {\n        commandOpts[option] = Boolean;\n    });\n\n    return commandOpts;\n}\nexports.commandOptions = commandOptions;\n\nfunction die(why) {\n    'use strict';\n    var o = commandOptions();\n    con.warn(why);\n    con.warn(\"Usage: \" + pro.argv[1] +\n            \" [--\" + Object.keys(o).sort().join(\"] [--\") +\n            \"] [--] <scriptfile>...\");\n    exit(1);\n}\n\nfunction parseArgs(argv) {\n    'use strict';\n    var args = nopt(commandOptions(), {}, argv);\n\n    if (args.filter === undefined) {\n        args.filter = true;\n    }\n\n    return args;\n}\nexports.parseArgs = parseArgs;\n\nexports.reportVersion = function reportVersion(callback, options) {\n    'use strict';\n    process.nextTick(function () {\n        var package_data = require('../package.json'),\n            version = package_data.version,\n            edition = nodelint.load(options.edition).edition;\n\n        callback(\"node-jslint version: \" + version + \"  JSLint edition \" + edition);\n    });\n\n};\n\nfunction expandGlob(glob) {\n    'use strict';\n\n    return function (pattern) {\n        return glob.sync(pattern);\n    };\n}\nexports.expandGlob = expandGlob;\n\nfunction noNodeModules(file) {\n    'use strict';\n    return file.indexOf('node_modules') === -1;\n}\nexports.noNodeModules = noNodeModules;\n\nfunction flatten(a, b) {\n    'use strict';\n\n    return a.concat(b);\n}\n\nfunction globFiles(list, glob, filter) {\n    'use strict';\n    var remain = [];\n\n    remain = list.map(expandGlob(glob))\n        .reduce(flatten, []);\n\n    if (filter) {\n        remain = remain.filter(noNodeModules);\n    }\n\n    return remain;\n}\nexports.globFiles = globFiles;\n\nfunction makeReporter(parsed) {\n    'use strict';\n    var reporter;\n\n    if (parsed.json) {\n        reporter = new JSONReportStream(parsed);\n    } else if (parsed.collector) {\n        reporter = new CollectorStream(parsed);\n    } else {\n        reporter = new ReportStream(parsed);\n    }\n\n    reporter.on('data', function (chunk) {\n        if (chunk === '.') {\n            pro.stderr.write(chunk);\n        } else {\n            con.log(chunk);\n        }\n    });\n\n    return reporter;\n}\nexports.makeReporter = makeReporter;\n\nexports.runMain = function (options, cb) {\n    'use strict';\n\n    if (options.version) {\n        exports.reportVersion(con.log, options);\n        return;\n    }\n\n    if (!options.argv.remain.length) {\n        die(\"No files specified.\");\n    }\n\n    var procOptions = optModule.getOptions(process.env.HOME, options),\n        files = globFiles(options.argv.remain, glob, options.filter),\n        opener = new FileOpener(),\n        linter = new LintStream(procOptions),\n        reporter = makeReporter(procOptions);\n\n    opener.pipe(linter);\n    linter.pipe(reporter);\n\n    reporter.on('finish', function () {\n        if (cb) {\n            return cb(null, reporter.lint);\n        }\n\n        if (reporter.allOK) {\n            return exit(0);\n        }\n        exit(1);\n    });\n\n    files.forEach(function (file) {\n        opener.write(file);\n    });\n    opener.end();\n};\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/options.js":"(function () {\n    'use strict';\n\n    var path = require('path'),\n        fs = require('fs'),\n        con = console;\n\n    exports.setConsole = function (c) {\n        con = c;\n    };\n\n    function merge(source, add) {\n        var result = source || {};\n\n        if (!add) {\n            return result;\n        }\n\n        Object.keys(add).forEach(function (prop) {\n            if (!result.hasOwnProperty(prop)) {\n                result[prop] = add[prop];\n            }\n        });\n\n        return result;\n    }\n    exports.merge = merge;\n\n    function loadAndParseConfig(filePath) {\n        try {\n            return JSON.parse(fs.readFileSync(filePath, \"utf-8\"));\n        } catch (err) {\n            if (filePath && err.code !== \"ENOENT\") {\n                con.warn('Error reading config file \"' + filePath + '\": ' + err);\n            }\n        }\n    }\n    exports.loadAndParseConfig = loadAndParseConfig;\n\n    function addDefaults(options) {\n\n        options = merge(options, {node: true, es5: true});\n\n        return options;\n    }\n\n    function notFalsy(n) {\n        return n;\n    }\n\n    function splitPredefs(options) {\n        if (!options.predef) {\n            return options;\n        }\n        if (Array.isArray(options.predef)) {\n            return options;\n        }\n\n        options.predef = options.predef.split(',').filter(notFalsy);\n\n        return options;\n    }\n\n    function preprocessOptions(options, config) {\n        options = merge({}, options);\n\n        options = merge(options, config);\n\n        options = addDefaults(options);\n\n        options = splitPredefs(options);\n\n        return options;\n    }\n\n    function mergeConfigs(home, project) {\n        var homeConfig,\n            cwdConfig,\n            config;\n\n        home.some(function (file) {\n            homeConfig = loadAndParseConfig(file);\n            return homeConfig;\n        });\n\n        project.some(function (file) {\n            cwdConfig = loadAndParseConfig(file);\n            return cwdConfig;\n        });\n\n        config = merge(cwdConfig, homeConfig);\n\n        return config;\n    }\n    exports.mergeConfigs = mergeConfigs;\n\n    function loadConfig(h, configFile) {\n        var home = h || '',\n            homeConfigs = ['.jslint.conf', '.jslintrc'],\n            projectConfigs = ['jslint.conf', '.jslint.conf', 'jslintrc', '.jslintrc'];\n\n        if (configFile) {\n            // explicitly specified config file overrides default config file name, path\n            homeConfigs = [configFile];\n        } else {\n            homeConfigs = homeConfigs.map(function (file) {\n                return path.join(home, file);\n            });\n        }\n\n        projectConfigs = projectConfigs.map(function (file) {\n            return path.join(process.cwd(), file);\n        });\n\n        return mergeConfigs(homeConfigs, projectConfigs);\n    }\n    exports.loadConfig = loadConfig;\n\n    function options_getOptions(homedir, options) {\n        var config = loadConfig(homedir, options.config);\n\n        return preprocessOptions(options, config);\n    }\n\n    exports.preprocessOptions = preprocessOptions;\n    exports.getOptions = options_getOptions;\n    exports.splitPredefs = splitPredefs;\n    exports.addDefaults = addDefaults;\n\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/lintstream.js":"// this file is lib/lintstream.js\n// provides a stream interface to JSLint\n//\n// Copyright 2014 Cubane Canada Inc.\n//\n// Released under modified MIT/BSD 3-clause license\n// See LICENSE for details.\n\n(function () {\n    'use strict';\n\n    var util = require('util'),\n        Transform = require('./stream').Transform,\n        nodelint = require('./nodelint'),\n        optModule = require('./options'),\n        linter = require('./linter'),\n        LintStream;\n\n    LintStream = function LintStream_constructor(options) {\n        if (!(this instanceof LintStream)) {\n            return new LintStream(options);\n        }\n        Transform.call(this, {objectMode: true});\n\n        // shallow copy options\n        options = optModule.merge({}, options);\n        this.JSlint = nodelint.load(options.edition);\n\n        // initialize members\n        this.options = options;\n        this.linter = linter;\n    };\n    util.inherits(LintStream, Transform);\n\n    function LintStream_transform(chunk, ignore, callback) {\n        var fileName = chunk.file,\n            body = chunk.body,\n            linted = this.linter.doLint(this.JSlint, body, this.options);\n\n        this.push({file: fileName, linted: linted});\n\n        callback();\n    }\n\n    LintStream.prototype._transform = LintStream_transform;\n\n    module.exports = LintStream;\n\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/stream.js":"module.exports = require('readable-stream');\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/reportstream.js":"// this file is lib/reportstream.js\n// provides a stream interface to JSLint\n//\n// Copyright 2014 Cubane Canada Inc.\n//\n// Released under modified MIT/BSD 3-clause license\n// See LICENSE for details.\n\n(function () {\n    'use strict';\n\n    var util = require('util'),\n        Transform = require('./stream').Transform,\n        reporter = require('./reporter'),\n        ReportStream;\n\n\n    ReportStream = function ReportStream_constructor(options) {\n        var stream = this;\n\n        if (!(this instanceof ReportStream)) {\n            return new ReportStream(options);\n        }\n\n        options = options || {};\n        options.objectMode = true;\n        Transform.call(this, options);\n\n        this.reporter = reporter.makeReporter(\n            {\n                log: function (s) {\n                    stream.emit('data', s);\n                },\n                err: function (s) {\n                    stream.emit('data', s);\n                }\n            },\n            options.color,\n            options.terse\n        );\n\n        this.allOK = true;\n\n    };\n    util.inherits(ReportStream, Transform);\n\n    function ReportStream_transform(chunk, ignore, callback) {\n        // chunk: a package of lint data from JSLint\n\n        this.reporter.report(chunk.file, chunk.linted);\n\n        this.allOK = this.allOK && chunk.linted.ok;\n\n        callback();\n    }\n\n    ReportStream.prototype._transform = ReportStream_transform;\n\n    module.exports = ReportStream;\n\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/reporter.js":"(function () {\n    'use strict';\n\n    var color = require(\"./color\");\n\n    exports.logger = {\n        log: (console.log).bind(console),\n        err: (process.stderr.write).bind(process.stderr)\n    };\n\n    exports.setLogger = function (l) {\n        this.logger = l;\n    };\n\n    exports.makeReporter = function (logger, colorize, terse) {\n        return {\n            logger: logger,\n            colorize: colorize,\n            terse: terse,\n            report: function (file, lint) {\n                return exports.report.call(this, file, lint, this.colorize, this.terse);\n            }\n        };\n    };\n\n    exports.report = function (file, lint, colorize, terse) {\n        var line,\n            pad,\n            errors,\n            fudge = Number(lint.option && lint.option.fudge) || 0,\n            logger = this.logger,\n            fileMessage;\n\n        function c(format, str) {\n            if (colorize) {\n                return color[format](str);\n            }\n            return str;\n        }\n\n        fileMessage = \"\\n\" + c('bold', file);\n\n        function row(e) {\n            return e.line + fudge;\n        }\n        function col(e) {\n            return (e.character || e.column) + fudge;\n        }\n        function evidence(e) {\n            return e.evidence || (lint.lines && lint.lines[e.line]) || '';\n        }\n        function message(e) {\n            return e.reason || e.message;\n        }\n\n        if (!lint.ok) {\n            // remove nulls\n            errors = lint.errors;// || lint.warnings;\n            errors = errors.filter(function (e) {\n                return e;\n            });\n\n            if (terse) {\n                errors.forEach(function (e) {\n                    logger.log(file + ':' + row(e) + ':' + col(e) + ': ' + message(e));\n                });\n            } else {\n                logger.log(fileMessage);\n                errors.forEach(function (e, i) {\n                    pad = \"#\" + String(i + 1);\n                    while (pad.length < 3) {\n                        pad = ' ' + pad;\n                    }\n                    line = ' // Line ' + row(e) + ', Pos ' + col(e);\n\n                    logger.log(pad + ' ' + c('yellow', message(e)));\n                    logger.log('    ' + evidence(e).trim() + c('grey', line));\n                });\n            }\n        } else {\n            if (terse) {\n                logger.err(\".\");\n            } else {\n                logger.log(fileMessage + \" is \" + c('green', 'OK') + \".\");\n            }\n        }\n\n        return lint.ok;\n    };\n\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/color.js":"function color(code, string) {\n    'use strict';\n    return \"\\u001b[\" + code + \"m\" + string + \"\\u001b[0m\";\n}\n\nfunction factory(code) {\n    'use strict';\n    return function (string) {\n        return color(code, string);\n    };\n}\n\nmodule.exports = {\n    bold: factory(1),\n    red: factory(31),\n    green: factory(32),\n    yellow: factory(33),\n    blue: factory(34),\n    grey: factory(90)\n};\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/collectorstream.js":"// this file is lib/collectorstream.js\n// provides a stream interface to JSLint\n//\n// Copyright 2014 Cubane Canada Inc.\n//\n// Released under modified MIT/BSD 3-clause license\n// See LICENSE for details.\n\n'use strict';\n\nvar util = require('util'),\n    Transform = require('./stream').Transform,\n    CollectorStream;\n\nCollectorStream = function CollectorStream_constructor(options) {\n    if (!(this instanceof CollectorStream)) {\n        return new CollectorStream(options);\n    }\n\n    Transform.call(this, {objectMode: true});\n\n    this.lint = [];\n\n    this.allOK = true;\n};\nutil.inherits(CollectorStream, Transform);\n\nfunction CollectorStream_transform(chunk, ignore, callback) {\n    // chunk: a package of lint data from JSLint\n    this.lint.push([chunk.file, chunk.linted.errors]);\n\n    this.allOK = this.allOK && chunk.linted.ok;\n\n    callback();\n}\n\nCollectorStream.prototype._transform = CollectorStream_transform;\n\nmodule.exports = CollectorStream;\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jsonreportstream.js":"// this file is lib/reportstream.js\n// provides a stream interface to JSLint\n//\n// Copyright 2014 Cubane Canada Inc.\n//\n// Released under modified MIT/BSD 3-clause license\n// See LICENSE for details.\n\n(function () {\n    'use strict';\n\n    var util = require('util'),\n        Transform = require('./stream').Transform,\n        JSONReportStream;\n\n    JSONReportStream = function JSONReportStream_constructor(options) {\n        if (!(this instanceof JSONReportStream)) {\n            return new JSONReportStream(options);\n        }\n\n        Transform.call(this, {objectMode: true});\n\n        this.allOK = true;\n    };\n    util.inherits(JSONReportStream, Transform);\n\n    function JSONReportStream_transform(chunk, ignore, callback) {\n        // chunk: a package of lint data from JSLint\n        this.emit('data', JSON.stringify([chunk.file, chunk.linted.errors]));\n\n        this.allOK = this.allOK && chunk.linted.ok;\n\n        callback();\n    }\n\n    JSONReportStream.prototype._transform = JSONReportStream_transform;\n\n    module.exports = JSONReportStream;\n\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/fileopener.js":"'use strict';\n\nvar util = require('util'),\n    Transform = require('./stream').Transform,\n    fs = require('fs');\n\nfunction FileOpener() {\n    Transform.call(this, {objectMode: true});\n}\n\nutil.inherits(FileOpener, Transform);\n\nfunction FileOpener_transform(file, ignore, callback) {\n    var stream = this;\n    fs.readFile(file, 'utf8', function (err, data) {\n        if (err) {\n            stream.emit('error', err);\n            return;\n        }\n\n        stream.push({file: file, body: data});\n        callback();\n    });\n}\n\nFileOpener.prototype._transform = FileOpener_transform;\n\nmodule.exports = FileOpener;\n\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jslint-2012-02-03.js":"// jslint.js\n// 2012-02-03\n\n// Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// The Software shall be used for Good, not Evil.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// WARNING: JSLint will hurt your feelings.\n\n// JSLINT is a global function. It takes two parameters.\n\n//     var myResult = JSLINT(source, option);\n\n// The first parameter is either a string or an array of strings. If it is a\n// string, it will be split on '\\n' or '\\r'. If it is an array of strings, it\n// is assumed that each string represents one line. The source can be a\n// JavaScript text, or HTML text, or a JSON text, or a CSS text.\n\n// The second parameter is an optional object of options that control the\n// operation of JSLINT. Most of the options are booleans: They are all\n// optional and have a default value of false. One of the options, predef,\n// can be an array of names, which will be used to declare global variables,\n// or an object whose keys are used as global names, with a boolean value\n// that determines if they are assignable.\n\n// If it checks out, JSLINT returns true. Otherwise, it returns false.\n\n// If false, you can inspect JSLINT.errors to find out the problems.\n// JSLINT.errors is an array of objects containing these properties:\n\n//  {\n//      line      : The line (relative to 0) at which the lint was found\n//      character : The character (relative to 0) at which the lint was found\n//      reason    : The problem\n//      evidence  : The text line in which the problem occurred\n//      raw       : The raw message before the details were inserted\n//      a         : The first detail\n//      b         : The second detail\n//      c         : The third detail\n//      d         : The fourth detail\n//  }\n\n// If a stopping error was found, a null will be the last element of the\n// JSLINT.errors array. A stopping error means that JSLint was not confident\n// enough to continue. It does not necessarily mean that the error was\n// especially heinous.\n\n// You can request a Function Report, which shows all of the functions\n// and the parameters and vars that they use. This can be used to find\n// implied global variables and other problems. The report is in HTML and\n// can be inserted in an HTML <body>.\n\n//     var myReport = JSLINT.report(errors_only);\n\n// If errors_only is true, then the report will be limited to only errors.\n\n// You can request a data structure that contains JSLint's results.\n\n//     var myData = JSLINT.data();\n\n// It returns a structure with this form:\n\n//     {\n//         errors: [\n//             {\n//                 line: NUMBER,\n//                 character: NUMBER,\n//                 reason: STRING,\n//                 evidence: STRING\n//             }\n//         ],\n//         functions: [\n//             {\n//                 name: STRING,\n//                 line: NUMBER,\n//                 last: NUMBER,\n//                 params: [\n//                     {\n//                         string: STRING\n//                     }\n//                 ],\n//                 closure: [\n//                     STRING\n//                 ],\n//                 var: [\n//                     STRING\n//                 ],\n//                 exception: [\n//                     STRING\n//                 ],\n//                 outer: [\n//                     STRING\n//                 ],\n//                 unused: [\n//                     STRING\n//                 ],\n//                 undef: [\n//                     STRING\n//                 ],\n//                 global: [\n//                     STRING\n//                 ],\n//                 label: [\n//                     STRING\n//                 ]\n//             }\n//         ],\n//         globals: [\n//             STRING\n//         ],\n//         member: {\n//             STRING: NUMBER\n//         },\n//         urls: [\n//             STRING\n//         ],\n//         json: BOOLEAN\n//     }\n\n// Empty arrays will not be included.\n\n// You can obtain the parse tree that JSLint constructed while parsing. The\n// latest tree is kept in JSLINT.tree. A nice stringication can be produced\n// with\n\n//     JSON.stringify(JSLINT.tree, [\n//         'string',  'arity', 'name',  'first',\n//         'second', 'third', 'block', 'else'\n//     ], 4));\n\n// JSLint provides three directives. They look like slashstar comments, and\n// allow for setting options, declaring global variables, and establishing a\n// set of allowed property names.\n\n// These directives respect function scope.\n\n// The jslint directive is a special comment that can set one or more options.\n// The current option set is\n\n//     anon       true, if the space may be omitted in anonymous function declarations\n//     bitwise    true, if bitwise operators should be allowed\n//     browser    true, if the standard browser globals should be predefined\n//     cap        true, if upper case HTML should be allowed\n//     'continue' true, if the continuation statement should be tolerated\n//     css        true, if CSS workarounds should be tolerated\n//     debug      true, if debugger statements should be allowed\n//     devel      true, if logging should be allowed (console, alert, etc.)\n//     eqeq       true, if == should be allowed\n//     es5        true, if ES5 syntax should be allowed\n//     evil       true, if eval should be allowed\n//     forin      true, if for in statements need not filter\n//     fragment   true, if HTML fragments should be allowed\n//     indent     the indentation factor\n//     maxerr     the maximum number of errors to allow\n//     maxlen     the maximum length of a source line\n//     newcap     true, if constructor names capitalization is ignored\n//     node       true, if Node.js globals should be predefined\n//     nomen      true, if names may have dangling _\n//     on         true, if HTML event handlers should be allowed\n//     passfail   true, if the scan should stop on first error\n//     plusplus   true, if increment/decrement should be allowed\n//     properties true, if all property names must be declared with /*properties*/\n//     regexp     true, if the . should be allowed in regexp literals\n//     rhino      true, if the Rhino environment globals should be predefined\n//     undef      true, if variables can be declared out of order\n//     unparam    true, if unused parameters should be tolerated\n//     sloppy     true, if the 'use strict'; pragma is optional\n//     sub        true, if all forms of subscript notation are tolerated\n//     vars       true, if multiple var statements per function should be allowed\n//     white      true, if sloppy whitespace is tolerated\n//     widget     true  if the Yahoo Widgets globals should be predefined\n//     windows    true, if MS Windows-specific globals should be predefined\n\n// For example:\n\n/*jslint\n    evil: true, nomen: true, regexp: true\n*/\n\n// The properties directive declares an exclusive list of property names.\n// Any properties named in the program that are not in the list will\n// produce a warning.\n\n// For example:\n\n/*properties\n    '\\b', '\\t', '\\n', '\\f', '\\r', '!=', '!==', '\"', '%', '\\'', '(begin)',\n    '(breakage)', '(context)', '(error)', '(identifier)', '(line)',\n    '(loopage)', '(name)', '(params)', '(scope)', '(token)', '(vars)',\n    '(verb)', '*', '+', '-', '/', '<', '<=', '==', '===', '>',\n    '>=', ADSAFE, Array, Date, E, Function, LN10, LN2, LOG10E, LOG2E,\n    MAX_VALUE, MIN_VALUE, NEGATIVE_INFINITY, Object, PI, POSITIVE_INFINITY,\n    SQRT1_2, SQRT2, '\\\\', a, a_label, a_not_allowed, a_not_defined, a_scope,\n    abbr, acronym, address, adsafe, adsafe_a, adsafe_autocomplete,\n    adsafe_bad_id, adsafe_div, adsafe_fragment, adsafe_go, adsafe_html,\n    adsafe_id, adsafe_id_go, adsafe_lib, adsafe_lib_second, adsafe_missing_id,\n    adsafe_name_a, adsafe_placement, adsafe_prefix_a, adsafe_script,\n    adsafe_source, adsafe_subscript_a, adsafe_tag, all, already_defined, and,\n    anon, applet, apply, approved, area, arity, article, aside, assign,\n    assign_exception, assignment_function_expression, at, attribute_case_a,\n    audio, autocomplete, avoid_a, b, background, 'background-attachment',\n    'background-color', 'background-image', 'background-position',\n    'background-repeat', bad_assignment, bad_color_a, bad_constructor,\n    bad_entity, bad_html, bad_id_a, bad_in_a, bad_invocation, bad_name_a,\n    bad_new, bad_number, bad_operand, bad_style, bad_type, bad_url_a, bad_wrap,\n    base, bdo, big, bind, bitwise, block, blockquote, body, border,\n    'border-bottom', 'border-bottom-color', 'border-bottom-left-radius',\n    'border-bottom-right-radius', 'border-bottom-style', 'border-bottom-width',\n    'border-collapse', 'border-color', 'border-left', 'border-left-color',\n    'border-left-style', 'border-left-width', 'border-radius', 'border-right',\n    'border-right-color', 'border-right-style', 'border-right-width',\n    'border-spacing', 'border-style', 'border-top', 'border-top-color',\n    'border-top-left-radius', 'border-top-right-radius', 'border-top-style',\n    'border-top-width', 'border-width', bottom, br, braille, browser, button,\n    c, call, canvas, cap, caption, 'caption-side', ceil, center, charAt,\n    charCodeAt, character, cite, clear, clip, closure, cm, code, col, colgroup,\n    color, combine_var, command, concat, conditional_assignment, confusing_a,\n    confusing_regexp, constructor, constructor_name_a, content, continue,\n    control_a, 'counter-increment', 'counter-reset', create, css, cursor, d,\n    dangerous_comment, dangling_a, data, datalist, dd, debug, defineProperties,\n    defineProperty, del, deleted, details, devel, dfn, dialog, dir, direction,\n    display, disrupt, div, dl, dt, duplicate_a, edge, edition, else, em, embed,\n    embossed, empty, 'empty-cells', empty_block, empty_case, empty_class,\n    entityify, eqeq, errors, es5, eval, every, evidence, evil, ex, exception,\n    exec, expected_a, expected_a_at_b_c, expected_a_b, expected_a_b_from_c_d,\n    expected_at_a, expected_attribute_a, expected_attribute_value_a,\n    expected_class_a, expected_fraction_a, expected_id_a,\n    expected_identifier_a, expected_identifier_a_reserved, expected_lang_a,\n    expected_linear_a, expected_media_a, expected_name_a,\n    expected_nonstandard_style_attribute, expected_number_a,\n    expected_operator_a, expected_percent_a, expected_positive_a,\n    expected_pseudo_a, expected_selector_a, expected_small_a,\n    expected_space_a_b, expected_string_a, expected_style_attribute,\n    expected_style_pattern, expected_tagname_a, expected_type_a, f, fieldset,\n    figure, filter, first, flag, float, floor, font, 'font-family',\n    'font-size', 'font-size-adjust', 'font-stretch', 'font-style',\n    'font-variant', 'font-weight', footer, for, forEach, for_if, forin, form,\n    fragment, frame, frameset, freeze, from, fromCharCode, fud, funct,\n    function, function_block, function_eval, function_loop, function_statement,\n    function_strict, functions, getDate, getDay, getFullYear, getHours,\n    getMilliseconds, getMinutes, getMonth, getOwnPropertyDescriptor,\n    getOwnPropertyNames, getPrototypeOf, getSeconds, getTime,\n    getTimezoneOffset, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours,\n    getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getYear,\n    global, globals, h1, h2, h3, h4, h5, h6, handheld, hasOwnProperty, head,\n    header, height, hgroup, hr, 'hta:application', html, html_confusion_a,\n    html_handlers, i, id, identifier, identifier_function, iframe, img, immed,\n    implied_evil, in, indent, indexOf, infix_in, init, input, ins, insecure_a,\n    isAlpha, isArray, isDigit, isExtensible, isFrozen, isNaN, isPrototypeOf,\n    isSealed, join, jslint, json, kbd, keygen, keys, label, label_a_b, labeled,\n    lang, lastIndex, lastIndexOf, lbp, leading_decimal_a, led, left, legend,\n    length, 'letter-spacing', li, lib, line, 'line-height', link, 'list-style',\n    'list-style-image', 'list-style-position', 'list-style-type', map, margin,\n    'margin-bottom', 'margin-left', 'margin-right', 'margin-top', mark,\n    'marker-offset', match, 'max-height', 'max-width', maxerr, maxlen, member,\n    menu, message, meta, meter, 'min-height', 'min-width', missing_a,\n    missing_a_after_b, missing_option, missing_property, missing_space_a_b,\n    missing_url, missing_use_strict, mixed, mm, mode, move_invocation,\n    move_var, n, name, name_function, nav, nested_comment, newcap, node,\n    noframes, nomen, noscript, not, not_a_constructor, not_a_defined,\n    not_a_function, not_a_label, not_a_scope, not_greater, now, nud, number,\n    object, octal_a, ol, on, opacity, open, optgroup, option, outer, outline,\n    'outline-color', 'outline-style', 'outline-width', output, overflow,\n    'overflow-x', 'overflow-y', p, padding, 'padding-bottom', 'padding-left',\n    'padding-right', 'padding-top', 'page-break-after', 'page-break-before',\n    param, parameter_a_get_b, parameter_set_a, params, paren, parent, parse,\n    passfail, pc, plusplus, pop, position, postscript, pre, predef,\n    preventExtensions, print, progress, projection, properties,\n    propertyIsEnumerable, prototype, pt, push, px, q, quote, quotes, r, radix,\n    range, raw, read_only, reason, redefinition_a, reduce, reduceRight, regexp,\n    replace, report, reserved, reserved_a, reverse, rhino, right, rp, rt, ruby,\n    safe, samp, scanned_a_b, screen, script, seal, search, second, section,\n    select, setDate, setDay, setFullYear, setHours, setMilliseconds,\n    setMinutes, setMonth, setSeconds, setTime, setTimezoneOffset, setUTCDate,\n    setUTCDay, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes,\n    setUTCMonth, setUTCSeconds, setYear, shift, slash_equal, slice, sloppy,\n    small, some, sort, source, span, speech, splice, split, src,\n    statement_block, stopping, strange_loop, strict, string, stringify, strong,\n    style, styleproperty, sub, subscript, substr, substring, sup, supplant, t,\n    table, 'table-layout', tag_a_in_b, tbody, td, test, 'text-align',\n    'text-decoration', 'text-indent', 'text-shadow', 'text-transform',\n    textarea, tfoot, th, thead, third, thru, time, title, toDateString,\n    toExponential, toFixed, toISOString, toJSON, toLocaleDateString,\n    toLocaleLowerCase, toLocaleString, toLocaleTimeString, toLocaleUpperCase,\n    toLowerCase, toPrecision, toString, toTimeString, toUTCString, toUpperCase,\n    token, too_long, too_many, top, tr, trailing_decimal_a, tree, trim, tt,\n    tty, tv, type, u, ul, unclosed, unclosed_comment, unclosed_regexp, undef,\n    undefined, unescaped_a, unexpected_a, unexpected_char_a_b,\n    unexpected_comment, unexpected_property_a, unexpected_space_a_b,\n    'unicode-bidi', unnecessary_initialize, unnecessary_use, unparam,\n    unreachable_a_b, unrecognized_style_attribute_a, unrecognized_tag_a,\n    unsafe, unshift, unused, url, urls, use_array, use_braces, use_charAt,\n    use_object, use_or, use_param, used_before_a, valueOf, var, var_a_not,\n    vars, 'vertical-align', video, visibility, warn, was, weird_assignment,\n    weird_condition, weird_new, weird_program, weird_relation, weird_ternary,\n    white, 'white-space', widget, width, windows, 'word-spacing', 'word-wrap',\n    wrap, wrap_immediate, wrap_regexp, write_is_wrong, writeable, 'z-index'\n*/\n\n// The global directive is used to declare global variables that can\n// be accessed by the program. If a declaration is true, then the variable\n// is writeable. Otherwise, it is read-only.\n\n// We build the application inside a function so that we produce only a single\n// global variable. That function will be invoked immediately, and its return\n// value is the JSLINT function itself. That function is also an object that\n// can contain data and other functions.\n\nvar JSLINT = (function () {\n    'use strict';\n\n    function array_to_object(array, value) {\n\n// Make an object from an array of keys and a common value.\n\n        var i, length = array.length, object = {};\n        for (i = 0; i < length; i += 1) {\n            object[array[i]] = value;\n        }\n        return object;\n    }\n\n\n    var adsafe_id,      // The widget's ADsafe id.\n        adsafe_may,     // The widget may load approved scripts.\n        adsafe_top,     // At the top of the widget script.\n        adsafe_went,    // ADSAFE.go has been called.\n        allowed_option = {\n            anon      : true,\n            bitwise   : true,\n            browser   : true,\n            cap       : true,\n            'continue': true,\n            css       : true,\n            debug     : true,\n            devel     : true,\n            eqeq      : true,\n            es5       : true,\n            evil      : true,\n            forin     : true,\n            fragment  : true,\n            indent    :   10,\n            maxerr    : 1000,\n            maxlen    :  256,\n            newcap    : true,\n            node      : true,\n            nomen     : true,\n            on        : true,\n            passfail  : true,\n            plusplus  : true,\n            properties: true,\n            regexp    : true,\n            rhino     : true,\n            undef     : true,\n            unparam   : true,\n            sloppy    : true,\n            sub       : true,\n            vars      : true,\n            white     : true,\n            widget    : true,\n            windows   : true\n        },\n        anonname,       // The guessed name for anonymous functions.\n        approved,       // ADsafe approved urls.\n\n// These are operators that should not be used with the ! operator.\n\n        bang = {\n            '<'  : true,\n            '<=' : true,\n            '==' : true,\n            '===': true,\n            '!==': true,\n            '!=' : true,\n            '>'  : true,\n            '>=' : true,\n            '+'  : true,\n            '-'  : true,\n            '*'  : true,\n            '/'  : true,\n            '%'  : true\n        },\n\n// These are property names that should not be permitted in the safe subset.\n\n        banned = array_to_object([\n            'arguments', 'callee', 'caller', 'constructor', 'eval', 'prototype',\n            'stack', 'unwatch', 'valueOf', 'watch'\n        ], true),\n        begin,          // The root token\n\n// browser contains a set of global names that are commonly provided by a\n// web browser environment.\n\n        browser = array_to_object([\n            'clearInterval', 'clearTimeout', 'document', 'event', 'frames',\n            'history', 'Image', 'localStorage', 'location', 'name', 'navigator',\n            'Option', 'parent', 'screen', 'sessionStorage', 'setInterval',\n            'setTimeout', 'Storage', 'window', 'XMLHttpRequest'\n        ], false),\n\n// bundle contains the text messages.\n\n        bundle = {\n            a_label: \"'{a}' is a statement label.\",\n            a_not_allowed: \"'{a}' is not allowed.\",\n            a_not_defined: \"'{a}' is not defined.\",\n            a_scope: \"'{a}' used out of scope.\",\n            adsafe_a: \"ADsafe violation: '{a}'.\",\n            adsafe_autocomplete: \"ADsafe autocomplete violation.\",\n            adsafe_bad_id: \"ADSAFE violation: bad id.\",\n            adsafe_div: \"ADsafe violation: Wrap the widget in a div.\",\n            adsafe_fragment: \"ADSAFE: Use the fragment option.\",\n            adsafe_go: \"ADsafe violation: Misformed ADSAFE.go.\",\n            adsafe_html: \"Currently, ADsafe does not operate on whole HTML \" +\n                \"documents. It operates on <div> fragments and .js files.\",\n            adsafe_id: \"ADsafe violation: id does not match.\",\n            adsafe_id_go: \"ADsafe violation: Missing ADSAFE.id or ADSAFE.go.\",\n            adsafe_lib: \"ADsafe lib violation.\",\n            adsafe_lib_second: \"ADsafe: The second argument to lib must be a function.\",\n            adsafe_missing_id: \"ADSAFE violation: missing ID_.\",\n            adsafe_name_a: \"ADsafe name violation: '{a}'.\",\n            adsafe_placement: \"ADsafe script placement violation.\",\n            adsafe_prefix_a: \"ADsafe violation: An id must have a '{a}' prefix\",\n            adsafe_script: \"ADsafe script violation.\",\n            adsafe_source: \"ADsafe unapproved script source.\",\n            adsafe_subscript_a: \"ADsafe subscript '{a}'.\",\n            adsafe_tag: \"ADsafe violation: Disallowed tag '{a}'.\",\n            already_defined: \"'{a}' is already defined.\",\n            and: \"The '&&' subexpression should be wrapped in parens.\",\n            assign_exception: \"Do not assign to the exception parameter.\",\n            assignment_function_expression: \"Expected an assignment or \" +\n                \"function call and instead saw an expression.\",\n            attribute_case_a: \"Attribute '{a}' not all lower case.\",\n            avoid_a: \"Avoid '{a}'.\",\n            bad_assignment: \"Bad assignment.\",\n            bad_color_a: \"Bad hex color '{a}'.\",\n            bad_constructor: \"Bad constructor.\",\n            bad_entity: \"Bad entity.\",\n            bad_html: \"Bad HTML string\",\n            bad_id_a: \"Bad id: '{a}'.\",\n            bad_in_a: \"Bad for in variable '{a}'.\",\n            bad_invocation: \"Bad invocation.\",\n            bad_name_a: \"Bad name: '{a}'.\",\n            bad_new: \"Do not use 'new' for side effects.\",\n            bad_number: \"Bad number '{a}'.\",\n            bad_operand: \"Bad operand.\",\n            bad_style: \"Bad style.\",\n            bad_type: \"Bad type.\",\n            bad_url_a: \"Bad url '{a}'.\",\n            bad_wrap: \"Do not wrap function literals in parens unless they \" +\n                \"are to be immediately invoked.\",\n            combine_var: \"Combine this with the previous 'var' statement.\",\n            conditional_assignment: \"Expected a conditional expression and \" +\n                \"instead saw an assignment.\",\n            confusing_a: \"Confusing use of '{a}'.\",\n            confusing_regexp: \"Confusing regular expression.\",\n            constructor_name_a: \"A constructor name '{a}' should start with \" +\n                \"an uppercase letter.\",\n            control_a: \"Unexpected control character '{a}'.\",\n            css: \"A css file should begin with @charset 'UTF-8';\",\n            dangling_a: \"Unexpected dangling '_' in '{a}'.\",\n            dangerous_comment: \"Dangerous comment.\",\n            deleted: \"Only properties should be deleted.\",\n            duplicate_a: \"Duplicate '{a}'.\",\n            empty_block: \"Empty block.\",\n            empty_case: \"Empty case.\",\n            empty_class: \"Empty class.\",\n            es5: \"This is an ES5 feature.\",\n            evil: \"eval is evil.\",\n            expected_a: \"Expected '{a}'.\",\n            expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n            expected_a_b_from_c_d: \"Expected '{a}' to match '{b}' from line \" +\n                \"{c} and instead saw '{d}'.\",\n            expected_at_a: \"Expected an at-rule, and instead saw @{a}.\",\n            expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n            expected_attribute_a: \"Expected an attribute, and instead saw [{a}].\",\n            expected_attribute_value_a: \"Expected an attribute value and \" +\n                \"instead saw '{a}'.\",\n            expected_class_a: \"Expected a class, and instead saw .{a}.\",\n            expected_fraction_a: \"Expected a number between 0 and 1 and \" +\n                \"instead saw '{a}'\",\n            expected_id_a: \"Expected an id, and instead saw #{a}.\",\n            expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n            expected_identifier_a_reserved: \"Expected an identifier and \" +\n                \"instead saw '{a}' (a reserved word).\",\n            expected_linear_a: \"Expected a linear unit and instead saw '{a}'.\",\n            expected_lang_a: \"Expected a lang code, and instead saw :{a}.\",\n            expected_media_a: \"Expected a CSS media type, and instead saw '{a}'.\",\n            expected_name_a: \"Expected a name and instead saw '{a}'.\",\n            expected_nonstandard_style_attribute: \"Expected a non-standard \" +\n                \"style attribute and instead saw '{a}'.\",\n            expected_number_a: \"Expected a number and instead saw '{a}'.\",\n            expected_operator_a: \"Expected an operator and instead saw '{a}'.\",\n            expected_percent_a: \"Expected a percentage and instead saw '{a}'\",\n            expected_positive_a: \"Expected a positive number and instead saw '{a}'\",\n            expected_pseudo_a: \"Expected a pseudo, and instead saw :{a}.\",\n            expected_selector_a: \"Expected a CSS selector, and instead saw {a}.\",\n            expected_small_a: \"Expected a small positive integer and instead saw '{a}'\",\n            expected_space_a_b: \"Expected exactly one space between '{a}' and '{b}'.\",\n            expected_string_a: \"Expected a string and instead saw {a}.\",\n            expected_style_attribute: \"Excepted a style attribute, and instead saw '{a}'.\",\n            expected_style_pattern: \"Expected a style pattern, and instead saw '{a}'.\",\n            expected_tagname_a: \"Expected a tagName, and instead saw {a}.\",\n            expected_type_a: \"Expected a type, and instead saw {a}.\",\n            for_if: \"The body of a for in should be wrapped in an if \" +\n                \"statement to filter unwanted properties from the prototype.\",\n            function_block: \"Function statements should not be placed in blocks. \" +\n                \"Use a function expression or move the statement to the top of \" +\n                \"the outer function.\",\n            function_eval: \"The Function constructor is eval.\",\n            function_loop: \"Don't make functions within a loop.\",\n            function_statement: \"Function statements are not invocable. \" +\n                \"Wrap the whole function invocation in parens.\",\n            function_strict: \"Use the function form of 'use strict'.\",\n            html_confusion_a: \"HTML confusion in regular expression '<{a}'.\",\n            html_handlers: \"Avoid HTML event handlers.\",\n            identifier_function: \"Expected an identifier in an assignment \" +\n                \"and instead saw a function invocation.\",\n            implied_evil: \"Implied eval is evil. Pass a function instead of a string.\",\n            infix_in: \"Unexpected 'in'. Compare with undefined, or use the \" +\n                \"hasOwnProperty method instead.\",\n            insecure_a: \"Insecure '{a}'.\",\n            isNaN: \"Use the isNaN function to compare with NaN.\",\n            label_a_b: \"Label '{a}' on '{b}' statement.\",\n            lang: \"lang is deprecated.\",\n            leading_decimal_a: \"A leading decimal point can be confused with a dot: '.{a}'.\",\n            missing_a: \"Missing '{a}'.\",\n            missing_a_after_b: \"Missing '{a}' after '{b}'.\",\n            missing_option: \"Missing option value.\",\n            missing_property: \"Missing property name.\",\n            missing_space_a_b: \"Missing space between '{a}' and '{b}'.\",\n            missing_url: \"Missing url.\",\n            missing_use_strict: \"Missing 'use strict' statement.\",\n            mixed: \"Mixed spaces and tabs.\",\n            move_invocation: \"Move the invocation into the parens that \" +\n                \"contain the function.\",\n            move_var: \"Move 'var' declarations to the top of the function.\",\n            name_function: \"Missing name in function statement.\",\n            nested_comment: \"Nested comment.\",\n            not: \"Nested not.\",\n            not_a_constructor: \"Do not use {a} as a constructor.\",\n            not_a_defined: \"'{a}' has not been fully defined yet.\",\n            not_a_function: \"'{a}' is not a function.\",\n            not_a_label: \"'{a}' is not a label.\",\n            not_a_scope: \"'{a}' is out of scope.\",\n            not_greater: \"'{a}' should not be greater than '{b}'.\",\n            octal_a: \"Don't use octal: '{a}'. Use '\\\\u....' instead.\",\n            parameter_a_get_b: \"Unexpected parameter '{a}' in get {b} function.\",\n            parameter_set_a: \"Expected parameter (value) in set {a} function.\",\n            radix: \"Missing radix parameter.\",\n            read_only: \"Read only.\",\n            redefinition_a: \"Redefinition of '{a}'.\",\n            reserved_a: \"Reserved name '{a}'.\",\n            scanned_a_b: \"{a} ({b}% scanned).\",\n            slash_equal: \"A regular expression literal can be confused with '/='.\",\n            statement_block: \"Expected to see a statement and instead saw a block.\",\n            stopping: \"Stopping. \",\n            strange_loop: \"Strange loop.\",\n            strict: \"Strict violation.\",\n            subscript: \"['{a}'] is better written in dot notation.\",\n            tag_a_in_b: \"A '<{a}>' must be within '<{b}>'.\",\n            too_long: \"Line too long.\",\n            too_many: \"Too many errors.\",\n            trailing_decimal_a: \"A trailing decimal point can be confused \" +\n                \"with a dot: '.{a}'.\",\n            type: \"type is unnecessary.\",\n            unclosed: \"Unclosed string.\",\n            unclosed_comment: \"Unclosed comment.\",\n            unclosed_regexp: \"Unclosed regular expression.\",\n            unescaped_a: \"Unescaped '{a}'.\",\n            unexpected_a: \"Unexpected '{a}'.\",\n            unexpected_char_a_b: \"Unexpected character '{a}' in {b}.\",\n            unexpected_comment: \"Unexpected comment.\",\n            unexpected_property_a: \"Unexpected /*property*/ '{a}'.\",\n            unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n            unnecessary_initialize: \"It is not necessary to initialize '{a}' \" +\n                \"to 'undefined'.\",\n            unnecessary_use: \"Unnecessary 'use strict'.\",\n            unreachable_a_b: \"Unreachable '{a}' after '{b}'.\",\n            unrecognized_style_attribute_a: \"Unrecognized style attribute '{a}'.\",\n            unrecognized_tag_a: \"Unrecognized tag '<{a}>'.\",\n            unsafe: \"Unsafe character.\",\n            url: \"JavaScript URL.\",\n            use_array: \"Use the array literal notation [].\",\n            use_braces: \"Spaces are hard to count. Use {{a}}.\",\n            use_charAt: \"Use the charAt method.\",\n            use_object: \"Use the object literal notation {}.\",\n            use_or: \"Use the || operator.\",\n            use_param: \"Use a named parameter.\",\n            used_before_a: \"'{a}' was used before it was defined.\",\n            var_a_not: \"Variable {a} was not declared correctly.\",\n            weird_assignment: \"Weird assignment.\",\n            weird_condition: \"Weird condition.\",\n            weird_new: \"Weird construction. Delete 'new'.\",\n            weird_program: \"Weird program.\",\n            weird_relation: \"Weird relation.\",\n            weird_ternary: \"Weird ternary.\",\n            wrap_immediate: \"Wrap an immediate function invocation in parentheses \" +\n                \"to assist the reader in understanding that the expression \" +\n                \"is the result of a function, and not the function itself.\",\n            wrap_regexp: \"Wrap the /regexp/ literal in parens to \" +\n                \"disambiguate the slash operator.\",\n            write_is_wrong: \"document.write can be a form of eval.\"\n        },\n        comments_off,\n        css_attribute_data,\n        css_any,\n\n        css_colorData = array_to_object([\n            \"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\",\n            \"bisque\", \"black\", \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\",\n            \"burlywood\", \"cadetblue\", \"chartreuse\", \"chocolate\", \"coral\",\n            \"cornflowerblue\", \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\",\n            \"darkcyan\", \"darkgoldenrod\", \"darkgray\", \"darkgreen\", \"darkkhaki\",\n            \"darkmagenta\", \"darkolivegreen\", \"darkorange\", \"darkorchid\",\n            \"darkred\", \"darksalmon\", \"darkseagreen\", \"darkslateblue\",\n            \"darkslategray\", \"darkturquoise\", \"darkviolet\", \"deeppink\",\n            \"deepskyblue\", \"dimgray\", \"dodgerblue\", \"firebrick\", \"floralwhite\",\n            \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\", \"gold\",\n            \"goldenrod\", \"gray\", \"green\", \"greenyellow\", \"honeydew\", \"hotpink\",\n            \"indianred\", \"indigo\", \"ivory\", \"khaki\", \"lavender\",\n            \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\",\n            \"lightcoral\", \"lightcyan\", \"lightgoldenrodyellow\", \"lightgreen\",\n            \"lightpink\", \"lightsalmon\", \"lightseagreen\", \"lightskyblue\",\n            \"lightslategray\", \"lightsteelblue\", \"lightyellow\", \"lime\",\n            \"limegreen\", \"linen\", \"magenta\", \"maroon\", \"mediumaquamarine\",\n            \"mediumblue\", \"mediumorchid\", \"mediumpurple\", \"mediumseagreen\",\n            \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\",\n            \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\",\n            \"moccasin\", \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\",\n            \"orange\", \"orangered\", \"orchid\", \"palegoldenrod\", \"palegreen\",\n            \"paleturquoise\", \"palevioletred\", \"papayawhip\", \"peachpuff\",\n            \"peru\", \"pink\", \"plum\", \"powderblue\", \"purple\", \"red\", \"rosybrown\",\n            \"royalblue\", \"saddlebrown\", \"salmon\", \"sandybrown\", \"seagreen\",\n            \"seashell\", \"sienna\", \"silver\", \"skyblue\", \"slateblue\", \"slategray\",\n            \"snow\", \"springgreen\", \"steelblue\", \"tan\", \"teal\", \"thistle\",\n            \"tomato\", \"turquoise\", \"violet\", \"wheat\", \"white\", \"whitesmoke\",\n            \"yellow\", \"yellowgreen\",\n\n            \"activeborder\", \"activecaption\", \"appworkspace\", \"background\",\n            \"buttonface\", \"buttonhighlight\", \"buttonshadow\", \"buttontext\",\n            \"captiontext\", \"graytext\", \"highlight\", \"highlighttext\",\n            \"inactiveborder\", \"inactivecaption\", \"inactivecaptiontext\",\n            \"infobackground\", \"infotext\", \"menu\", \"menutext\", \"scrollbar\",\n            \"threeddarkshadow\", \"threedface\", \"threedhighlight\",\n            \"threedlightshadow\", \"threedshadow\", \"window\", \"windowframe\",\n            \"windowtext\"\n        ], true),\n\n        css_border_style,\n        css_break,\n\n        css_lengthData = {\n            '%': true,\n            'cm': true,\n            'em': true,\n            'ex': true,\n            'in': true,\n            'mm': true,\n            'pc': true,\n            'pt': true,\n            'px': true\n        },\n\n        css_media,\n        css_overflow,\n\n        descapes = {\n            'b': '\\b',\n            't': '\\t',\n            'n': '\\n',\n            'f': '\\f',\n            'r': '\\r',\n            '\"': '\"',\n            '/': '/',\n            '\\\\': '\\\\'\n        },\n\n        devel = array_to_object([\n            'alert', 'confirm', 'console', 'Debug', 'opera', 'prompt', 'WSH'\n        ], false),\n        directive,\n        escapes = {\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\\'': '\\\\\\'',\n            '\"' : '\\\\\"',\n            '/' : '\\\\/',\n            '\\\\': '\\\\\\\\'\n        },\n\n        funct,          // The current function, including the labels used in\n                        // the function, as well as (breakage),\n                        // (context), (loopage), (name), (params), (token),\n                        // (vars), (verb)\n\n        functionicity = [\n            'closure', 'exception', 'global', 'label', 'outer', 'undef',\n            'unused', 'var'\n        ],\n\n        functions,      // All of the functions\n        global_funct,   // The global body\n        global_scope,   // The global scope\n        html_tag = {\n            a:        {},\n            abbr:     {},\n            acronym:  {},\n            address:  {},\n            applet:   {},\n            area:     {empty: true, parent: ' map '},\n            article:  {},\n            aside:    {},\n            audio:    {},\n            b:        {},\n            base:     {empty: true, parent: ' head '},\n            bdo:      {},\n            big:      {},\n            blockquote: {},\n            body:     {parent: ' html noframes '},\n            br:       {empty: true},\n            button:   {},\n            canvas:   {parent: ' body p div th td '},\n            caption:  {parent: ' table '},\n            center:   {},\n            cite:     {},\n            code:     {},\n            col:      {empty: true, parent: ' table colgroup '},\n            colgroup: {parent: ' table '},\n            command:  {parent: ' menu '},\n            datalist: {},\n            dd:       {parent: ' dl '},\n            del:      {},\n            details:  {},\n            dialog:   {},\n            dfn:      {},\n            dir:      {},\n            div:      {},\n            dl:       {},\n            dt:       {parent: ' dl '},\n            em:       {},\n            embed:    {},\n            fieldset: {},\n            figure:   {},\n            font:     {},\n            footer:   {},\n            form:     {},\n            frame:    {empty: true, parent: ' frameset '},\n            frameset: {parent: ' html frameset '},\n            h1:       {},\n            h2:       {},\n            h3:       {},\n            h4:       {},\n            h5:       {},\n            h6:       {},\n            head:     {parent: ' html '},\n            header:   {},\n            hgroup:   {},\n            hr:       {empty: true},\n            'hta:application':\n                      {empty: true, parent: ' head '},\n            html:     {parent: '*'},\n            i:        {},\n            iframe:   {},\n            img:      {empty: true},\n            input:    {empty: true},\n            ins:      {},\n            kbd:      {},\n            keygen:   {},\n            label:    {},\n            legend:   {parent: ' details fieldset figure '},\n            li:       {parent: ' dir menu ol ul '},\n            link:     {empty: true, parent: ' head '},\n            map:      {},\n            mark:     {},\n            menu:     {},\n            meta:     {empty: true, parent: ' head noframes noscript '},\n            meter:    {},\n            nav:      {},\n            noframes: {parent: ' html body '},\n            noscript: {parent: ' body head noframes '},\n            object:   {},\n            ol:       {},\n            optgroup: {parent: ' select '},\n            option:   {parent: ' optgroup select '},\n            output:   {},\n            p:        {},\n            param:    {empty: true, parent: ' applet object '},\n            pre:      {},\n            progress: {},\n            q:        {},\n            rp:       {},\n            rt:       {},\n            ruby:     {},\n            samp:     {},\n            script:   {empty: true, parent: ' body div frame head iframe p pre span '},\n            section:  {},\n            select:   {},\n            small:    {},\n            span:     {},\n            source:   {},\n            strong:   {},\n            style:    {parent: ' head ', empty: true},\n            sub:      {},\n            sup:      {},\n            table:    {},\n            tbody:    {parent: ' table '},\n            td:       {parent: ' tr '},\n            textarea: {},\n            tfoot:    {parent: ' table '},\n            th:       {parent: ' tr '},\n            thead:    {parent: ' table '},\n            time:     {},\n            title:    {parent: ' head '},\n            tr:       {parent: ' table tbody thead tfoot '},\n            tt:       {},\n            u:        {},\n            ul:       {},\n            'var':    {},\n            video:    {}\n        },\n\n        ids,            // HTML ids\n        in_block,\n        indent,\n        itself,         // JSLint itself\n        json_mode,\n        lex,            // the tokenizer\n        lines,\n        lookahead,\n        node = array_to_object([\n            'Buffer', 'clearInterval', 'clearTimeout', 'console', 'exports',\n            'global', 'module', 'process', 'querystring', 'require',\n            'setInterval', 'setTimeout', '__dirname', '__filename'\n        ], false),\n        node_js,\n        numbery = array_to_object(['indexOf', 'lastIndexOf', 'search'], true),\n        next_token,\n        option,\n        predefined,     // Global variables defined by option\n        prereg,\n        prev_token,\n        property,\n        regexp_flag = array_to_object(['g', 'i', 'm'], true),\n        return_this = function return_this() {\n            return this;\n        },\n        rhino = array_to_object([\n            'defineClass', 'deserialize', 'gc', 'help', 'load', 'loadClass',\n            'print', 'quit', 'readFile', 'readUrl', 'runCommand', 'seal',\n            'serialize', 'spawn', 'sync', 'toint32', 'version'\n        ], false),\n\n        scope,      // An object containing an object for each variable in scope\n        semicolon_coda = array_to_object([';', '\"', '\\'', ')'], true),\n        src,\n        stack,\n\n// standard contains the global names that are provided by the\n// ECMAScript standard.\n\n        standard = array_to_object([\n            'Array', 'Boolean', 'Date', 'decodeURI', 'decodeURIComponent',\n            'encodeURI', 'encodeURIComponent', 'Error', 'eval', 'EvalError',\n            'Function', 'isFinite', 'isNaN', 'JSON', 'Math', 'Number',\n            'Object', 'parseInt', 'parseFloat', 'RangeError', 'ReferenceError',\n            'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError'\n        ], false),\n\n        strict_mode,\n        syntax = {},\n        tab,\n        token,\n        urls,\n        var_mode,\n        warnings,\n\n// widget contains the global names which are provided to a Yahoo\n// (fna Konfabulator) widget.\n\n        widget = array_to_object([\n            'alert', 'animator', 'appleScript', 'beep', 'bytesToUIString',\n            'Canvas', 'chooseColor', 'chooseFile', 'chooseFolder',\n            'closeWidget', 'COM', 'convertPathToHFS', 'convertPathToPlatform',\n            'CustomAnimation', 'escape', 'FadeAnimation', 'filesystem', 'Flash',\n            'focusWidget', 'form', 'FormField', 'Frame', 'HotKey', 'Image',\n            'include', 'isApplicationRunning', 'iTunes', 'konfabulatorVersion',\n            'log', 'md5', 'MenuItem', 'MoveAnimation', 'openURL', 'play',\n            'Point', 'popupMenu', 'preferenceGroups', 'preferences', 'print',\n            'prompt', 'random', 'Rectangle', 'reloadWidget', 'ResizeAnimation',\n            'resolvePath', 'resumeUpdates', 'RotateAnimation', 'runCommand',\n            'runCommandInBg', 'saveAs', 'savePreferences', 'screen',\n            'ScrollBar', 'showWidgetPreferences', 'sleep', 'speak', 'Style',\n            'suppressUpdates', 'system', 'tellWidget', 'Text', 'TextArea',\n            'Timer', 'unescape', 'updateNow', 'URL', 'Web', 'widget', 'Window',\n            'XMLDOM', 'XMLHttpRequest', 'yahooCheckLogin', 'yahooLogin',\n            'yahooLogout'\n        ], true),\n\n        windows = array_to_object([\n            'ActiveXObject', 'CScript', 'Debug', 'Enumerator', 'System',\n            'VBArray', 'WScript', 'WSH'\n        ], false),\n\n//  xmode is used to adapt to the exceptions in html parsing.\n//  It can have these states:\n//      ''      .js script file\n//      'html'\n//      'outer'\n//      'script'\n//      'style'\n//      'scriptstring'\n//      'styleproperty'\n\n        xmode,\n        xquote,\n\n// Regular expressions. Some of these are stupidly long.\n\n// unsafe comment or string\n        ax = /@cc|<\\/?|script|\\]\\s*\\]|<\\s*!|&lt/i,\n// carriage return, or carriage return linefeed\n        crx = /\\r/g,\n        crlfx = /\\r\\n/g,\n// unsafe characters that are silently deleted by one or more browsers\n        cx = /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n// query characters for ids\n        dx = /[\\[\\]\\/\\\\\"'*<>.&:(){}+=#]/,\n// html token\n        hx = /^\\s*(['\"=>\\/&#]|<(?:\\/|\\!(?:--)?)?|[a-zA-Z][a-zA-Z0-9_\\-:]*|[0-9]+|--)/,\n// identifier\n        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,\n// javascript url\n        jx = /^(?:javascript|jscript|ecmascript|vbscript|mocha|livescript)\\s*:/i,\n// star slash\n        lx = /\\*\\/|\\/\\*/,\n// characters in strings that need escapement\n        nx = /[\\u0000-\\u001f'\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n// outer html token\n        ox = /[>&]|<[\\/!]?|--/,\n// attributes characters\n        qx = /[^a-zA-Z0-9+\\-_\\/ ]/,\n// style\n        sx = /^\\s*([{}:#%.=,>+\\[\\]@()\"';]|[*$\\^~]=|[a-zA-Z_][a-zA-Z0-9_\\-]*|[0-9]+|<\\/|\\/\\*)/,\n        ssx = /^\\s*([@#!\"'};:\\-%.=,+\\[\\]()*_]|[a-zA-Z][a-zA-Z0-9._\\-]*|\\/\\*?|\\d+(?:\\.\\d+)?|<\\/)/,\n// token\n        tx = /^\\s*([(){}\\[\\]\\?.,:;'\"~#@`]|={1,3}|\\/(\\*(jslint|properties|property|members?|globals?)?|=|\\/)?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|[\\^%]=?|&[&=]?|\\|[|=]?|>{1,3}=?|<(?:[\\/=!]|\\!(\\[|--)?|<=?)?|\\!={0,2}|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+(?:[xX][0-9a-fA-F]+|\\.[0-9]*)?(?:[eE][+\\-]?[0-9]+)?)/,\n// url badness\n        ux = /&|\\+|\\u00AD|\\.\\.|\\/\\*|%[^;]|base64|url|expression|data|mailto|script/i,\n\n        rx = {\n            outer: hx,\n            html: hx,\n            style: sx,\n            styleproperty: ssx\n        };\n\n\n    function F() {}     // Used by Object.create\n\n// Provide critical ES5 functions to ES3.\n\n    if (typeof Array.prototype.filter !== 'function') {\n        Array.prototype.filter = function (f) {\n            var i, length = this.length, result = [], value;\n            for (i = 0; i < length; i += 1) {\n                try {\n                    value = this[i];\n                    if (f(value)) {\n                        result.push(value);\n                    }\n                } catch (ignore) {\n                }\n            }\n            return result;\n        };\n    }\n\n    if (typeof Array.prototype.forEach !== 'function') {\n        Array.prototype.forEach = function (f) {\n            var i, length = this.length;\n            for (i = 0; i < length; i += 1) {\n                try {\n                    f(this[i]);\n                } catch (ignore) {\n                }\n            }\n        };\n    }\n\n    if (typeof Array.isArray !== 'function') {\n        Array.isArray = function (o) {\n            return Object.prototype.toString.apply(o) === '[object Array]';\n        };\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(Object, 'create')) {\n        Object.create = function (o) {\n            F.prototype = o;\n            return new F();\n        };\n    }\n\n    if (typeof Object.keys !== 'function') {\n        Object.keys = function (o) {\n            var array = [], key;\n            for (key in o) {\n                if (Object.prototype.hasOwnProperty.call(o, key)) {\n                    array.push(key);\n                }\n            }\n            return array;\n        };\n    }\n\n    if (typeof String.prototype.entityify !== 'function') {\n        String.prototype.entityify = function () {\n            return this\n                .replace(/&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;');\n        };\n    }\n\n    if (typeof String.prototype.isAlpha !== 'function') {\n        String.prototype.isAlpha = function () {\n            return (this >= 'a' && this <= 'z\\uffff') ||\n                (this >= 'A' && this <= 'Z\\uffff');\n        };\n    }\n\n    if (typeof String.prototype.isDigit !== 'function') {\n        String.prototype.isDigit = function () {\n            return (this >= '0' && this <= '9');\n        };\n    }\n\n    if (typeof String.prototype.supplant !== 'function') {\n        String.prototype.supplant = function (o) {\n            return this.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n                var replacement = o[b];\n                return typeof replacement === 'string' ||\n                    typeof replacement === 'number' ? replacement : a;\n            });\n        };\n    }\n\n\n    function sanitize(a) {\n\n//  Escapify a troublesome character.\n\n        return escapes[a] ||\n            '\\\\u' + ('0000' + a.charCodeAt().toString(16)).slice(-4);\n    }\n\n\n    function add_to_predefined(group) {\n        Object.keys(group).forEach(function (name) {\n            predefined[name] = group[name];\n        });\n    }\n\n\n    function assume() {\n        if (!option.safe) {\n            if (option.rhino) {\n                add_to_predefined(rhino);\n                option.rhino = false;\n            }\n            if (option.devel) {\n                add_to_predefined(devel);\n                option.devel = false;\n            }\n            if (option.browser) {\n                add_to_predefined(browser);\n                option.browser = false;\n            }\n            if (option.windows) {\n                add_to_predefined(windows);\n                option.windows = false;\n            }\n            if (option.node) {\n                add_to_predefined(node);\n                option.node = false;\n                node_js = true;\n            }\n            if (option.widget) {\n                add_to_predefined(widget);\n                option.widget = false;\n            }\n        }\n    }\n\n\n// Produce an error warning.\n\n    function artifact(tok) {\n        if (!tok) {\n            tok = next_token;\n        }\n        return tok.number || tok.string;\n    }\n\n    function quit(message, line, character) {\n        throw {\n            name: 'JSLintError',\n            line: line,\n            character: character,\n            message: bundle.scanned_a_b.supplant({\n                a: message,\n                b: Math.floor((line / lines.length) * 100)\n            })\n        };\n    }\n\n    function warn(message, offender, a, b, c, d) {\n        var character, line, warning;\n        offender = offender || next_token;  // ~~\n        line = offender.line || 0;\n        character = offender.from || 0;\n        warning = {\n            id: '(error)',\n            raw: bundle[message] || message,\n            evidence: lines[line - 1] || '',\n            line: line,\n            character: character,\n            a: a || (offender.id === '(number)'\n                ? String(offender.number)\n                : offender.string),\n            b: b,\n            c: c,\n            d: d\n        };\n        warning.reason = warning.raw.supplant(warning);\n        JSLINT.errors.push(warning);\n        if (option.passfail) {\n            quit(bundle.stopping, line, character);\n        }\n        warnings += 1;\n        if (warnings >= option.maxerr) {\n            quit(bundle.too_many, line, character);\n        }\n        return warning;\n    }\n\n    function warn_at(message, line, character, a, b, c, d) {\n        return warn(message, {\n            line: line,\n            from: character\n        }, a, b, c, d);\n    }\n\n    function stop(message, offender, a, b, c, d) {\n        var warning = warn(message, offender, a, b, c, d);\n        quit(bundle.stopping, warning.line, warning.character);\n    }\n\n    function stop_at(message, line, character, a, b, c, d) {\n        return stop(message, {\n            line: line,\n            from: character\n        }, a, b, c, d);\n    }\n\n    function expected_at(at) {\n        if (!option.white && next_token.from !== at) {\n            warn('expected_a_at_b_c', next_token, '', at,\n                next_token.from);\n        }\n    }\n\n    function aint(it, name, expected) {\n        if (it[name] !== expected) {\n            warn('expected_a_b', it, expected, it[name]);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n\n// lexical analysis and token construction\n\n    lex = (function lex() {\n        var character, c, from, length, line, pos, source_row;\n\n// Private lex methods\n\n        function next_line() {\n            var at;\n            if (line >= lines.length) {\n                return false;\n            }\n            character = 1;\n            source_row = lines[line];\n            line += 1;\n            at = source_row.search(/ \\t/);\n            if (at >= 0) {\n                warn_at('mixed', line, at + 1);\n            }\n            source_row = source_row.replace(/\\t/g, tab);\n            at = source_row.search(cx);\n            if (at >= 0) {\n                warn_at('unsafe', line, at);\n            }\n            if (option.maxlen && option.maxlen < source_row.length) {\n                warn_at('too_long', line, source_row.length);\n            }\n            return true;\n        }\n\n// Produce a token object.  The token inherits from a syntax symbol.\n\n        function it(type, value) {\n            var id, the_token;\n            if (type === '(string)' || type === '(range)') {\n                if (jx.test(value)) {\n                    warn_at('url', line, from);\n                }\n            }\n            the_token = Object.create(syntax[(\n                type === '(punctuator)' || (type === '(identifier)' &&\n                        Object.prototype.hasOwnProperty.call(syntax, value))\n                    ? value\n                    : type\n            )] || syntax['(error)']);\n            if (type === '(identifier)') {\n                the_token.identifier = true;\n                if (value === '__iterator__' || value === '__proto__') {\n                    stop_at('reserved_a', line, from, value);\n                } else if (!option.nomen &&\n                        (value.charAt(0) === '_' ||\n                        value.charAt(value.length - 1) === '_')) {\n                    warn_at('dangling_a', line, from, value);\n                }\n            }\n            if (type === '(number)') {\n                the_token.number = +value;\n            } else if (value !== undefined) {\n                the_token.string = String(value);\n            }\n            the_token.line = line;\n            the_token.from = from;\n            the_token.thru = character;\n            id = the_token.id;\n            prereg = id && (\n                ('(,=:[!&|?{};'.indexOf(id.charAt(id.length - 1)) >= 0) ||\n                id === 'return' || id === 'case'\n            );\n            return the_token;\n        }\n\n        function match(x) {\n            var exec = x.exec(source_row), first;\n            if (exec) {\n                length = exec[0].length;\n                first = exec[1];\n                c = first.charAt(0);\n                source_row = source_row.slice(length);\n                from = character + length - first.length;\n                character += length;\n                return first;\n            }\n        }\n\n        function string(x) {\n            var c, pos = 0, r = '', result;\n\n            function hex(n) {\n                var i = parseInt(source_row.substr(pos + 1, n), 16);\n                pos += n;\n                if (i >= 32 && i <= 126 &&\n                        i !== 34 && i !== 92 && i !== 39) {\n                    warn_at('unexpected_a', line, character, '\\\\');\n                }\n                character += n;\n                c = String.fromCharCode(i);\n            }\n\n            if (json_mode && x !== '\"') {\n                warn_at('expected_a', line, character, '\"');\n            }\n\n            if (xquote === x || (xmode === 'scriptstring' && !xquote)) {\n                return it('(punctuator)', x);\n            }\n\n            for (;;) {\n                while (pos >= source_row.length) {\n                    pos = 0;\n                    if (xmode !== 'html' || !next_line()) {\n                        stop_at('unclosed', line, from);\n                    }\n                }\n                c = source_row.charAt(pos);\n                if (c === x) {\n                    character += 1;\n                    source_row = source_row.slice(pos + 1);\n                    result = it('(string)', r);\n                    result.quote = x;\n                    return result;\n                }\n                if (c < ' ') {\n                    if (c === '\\n' || c === '\\r') {\n                        break;\n                    }\n                    warn_at('control_a', line, character + pos,\n                        source_row.slice(0, pos));\n                } else if (c === xquote) {\n                    warn_at('bad_html', line, character + pos);\n                } else if (c === '<') {\n                    if (option.safe && xmode === 'html') {\n                        warn_at('adsafe_a', line, character + pos, c);\n                    } else if (source_row.charAt(pos + 1) === '/' && (xmode || option.safe)) {\n                        warn_at('expected_a_b', line, character,\n                            '<\\\\/', '</');\n                    } else if (source_row.charAt(pos + 1) === '!' && (xmode || option.safe)) {\n                        warn_at('unexpected_a', line, character, '<!');\n                    }\n                } else if (c === '\\\\') {\n                    if (xmode === 'html') {\n                        if (option.safe) {\n                            warn_at('adsafe_a', line, character + pos, c);\n                        }\n                    } else if (xmode === 'styleproperty') {\n                        pos += 1;\n                        character += 1;\n                        c = source_row.charAt(pos);\n                        if (c !== x) {\n                            warn_at('unexpected_a', line, character, '\\\\');\n                        }\n                    } else {\n                        pos += 1;\n                        character += 1;\n                        c = source_row.charAt(pos);\n                        switch (c) {\n                        case '':\n                            if (!option.es5) {\n                                warn_at('es5', line, character);\n                            }\n                            next_line();\n                            pos = -1;\n                            break;\n                        case xquote:\n                            warn_at('bad_html', line, character + pos);\n                            break;\n                        case '\\'':\n                            if (json_mode) {\n                                warn_at('unexpected_a', line, character, '\\\\\\'');\n                            }\n                            break;\n                        case 'u':\n                            hex(4);\n                            break;\n                        case 'v':\n                            if (json_mode) {\n                                warn_at('unexpected_a', line, character, '\\\\v');\n                            }\n                            c = '\\v';\n                            break;\n                        case 'x':\n                            if (json_mode) {\n                                warn_at('unexpected_a', line, character, '\\\\x');\n                            }\n                            hex(2);\n                            break;\n                        default:\n                            if (typeof descapes[c] !== 'string') {\n                                warn_at(c >= '0' && c <= '7' ? 'octal_a' : 'unexpected_a',\n                                    line, character, '\\\\' + c);\n                            } else {\n                                c = descapes[c];\n                            }\n                        }\n                    }\n                }\n                r += c;\n                character += 1;\n                pos += 1;\n            }\n        }\n\n        function number(snippet) {\n            var digit;\n            if (xmode !== 'style' && xmode !== 'styleproperty' &&\n                    source_row.charAt(0).isAlpha()) {\n                warn_at('expected_space_a_b',\n                    line, character, c, source_row.charAt(0));\n            }\n            if (c === '0') {\n                digit = snippet.charAt(1);\n                if (digit.isDigit()) {\n                    if (token.id !== '.' && xmode !== 'styleproperty') {\n                        warn_at('unexpected_a', line, character, snippet);\n                    }\n                } else if (json_mode && (digit === 'x' || digit === 'X')) {\n                    warn_at('unexpected_a', line, character, '0x');\n                }\n            }\n            if (snippet.slice(snippet.length - 1) === '.') {\n                warn_at('trailing_decimal_a', line, character, snippet);\n            }\n            if (xmode !== 'style') {\n                digit = +snippet;\n                if (!isFinite(digit)) {\n                    warn_at('bad_number', line, character, snippet);\n                }\n                snippet = digit;\n            }\n            return it('(number)', snippet);\n        }\n\n        function comment(snippet) {\n            if (comments_off || src || (xmode && xmode !== 'script' &&\n                    xmode !== 'style' && xmode !== 'styleproperty')) {\n                warn_at('unexpected_comment', line, character);\n            } else if (xmode === 'script' && /<\\//i.test(source_row)) {\n                warn_at('unexpected_a', line, character, '<\\/');\n            } else if (option.safe && ax.test(snippet)) {\n                warn_at('dangerous_comment', line, character);\n            }\n        }\n\n        function regexp() {\n            var b,\n                bit,\n                captures = 0,\n                depth = 0,\n                flag = '',\n                high,\n                letter,\n                length = 0,\n                low,\n                potential,\n                quote,\n                result;\n            for (;;) {\n                b = true;\n                c = source_row.charAt(length);\n                length += 1;\n                switch (c) {\n                case '':\n                    stop_at('unclosed_regexp', line, from);\n                    return;\n                case '/':\n                    if (depth > 0) {\n                        warn_at('unescaped_a', line, from + length, '/');\n                    }\n                    c = source_row.slice(0, length - 1);\n                    potential = Object.create(regexp_flag);\n                    for (;;) {\n                        letter = source_row.charAt(length);\n                        if (potential[letter] !== true) {\n                            break;\n                        }\n                        potential[letter] = false;\n                        length += 1;\n                        flag += letter;\n                    }\n                    if (source_row.charAt(length).isAlpha()) {\n                        stop_at('unexpected_a', line, from, source_row.charAt(length));\n                    }\n                    character += length;\n                    source_row = source_row.slice(length);\n                    quote = source_row.charAt(0);\n                    if (quote === '/' || quote === '*') {\n                        stop_at('confusing_regexp', line, from);\n                    }\n                    result = it('(regexp)', c);\n                    result.flag = flag;\n                    return result;\n                case '\\\\':\n                    c = source_row.charAt(length);\n                    if (c < ' ') {\n                        warn_at('control_a', line, from + length, String(c));\n                    } else if (c === '<') {\n                        warn_at(bundle.unexpected_a, line, from + length, '\\\\');\n                    }\n                    length += 1;\n                    break;\n                case '(':\n                    depth += 1;\n                    b = false;\n                    if (source_row.charAt(length) === '?') {\n                        length += 1;\n                        switch (source_row.charAt(length)) {\n                        case ':':\n                        case '=':\n                        case '!':\n                            length += 1;\n                            break;\n                        default:\n                            warn_at(bundle.expected_a_b, line, from + length,\n                                ':', source_row.charAt(length));\n                        }\n                    } else {\n                        captures += 1;\n                    }\n                    break;\n                case '|':\n                    b = false;\n                    break;\n                case ')':\n                    if (depth === 0) {\n                        warn_at('unescaped_a', line, from + length, ')');\n                    } else {\n                        depth -= 1;\n                    }\n                    break;\n                case ' ':\n                    pos = 1;\n                    while (source_row.charAt(length) === ' ') {\n                        length += 1;\n                        pos += 1;\n                    }\n                    if (pos > 1) {\n                        warn_at('use_braces', line, from + length, pos);\n                    }\n                    break;\n                case '[':\n                    c = source_row.charAt(length);\n                    if (c === '^') {\n                        length += 1;\n                        if (!option.regexp) {\n                            warn_at('insecure_a', line, from + length, c);\n                        } else if (source_row.charAt(length) === ']') {\n                            stop_at('unescaped_a', line, from + length, '^');\n                        }\n                    }\n                    bit = false;\n                    if (c === ']') {\n                        warn_at('empty_class', line, from + length - 1);\n                        bit = true;\n                    }\nklass:              do {\n                        c = source_row.charAt(length);\n                        length += 1;\n                        switch (c) {\n                        case '[':\n                        case '^':\n                            warn_at('unescaped_a', line, from + length, c);\n                            bit = true;\n                            break;\n                        case '-':\n                            if (bit) {\n                                bit = false;\n                            } else {\n                                warn_at('unescaped_a', line, from + length, '-');\n                                bit = true;\n                            }\n                            break;\n                        case ']':\n                            if (!bit) {\n                                warn_at('unescaped_a', line, from + length - 1, '-');\n                            }\n                            break klass;\n                        case '\\\\':\n                            c = source_row.charAt(length);\n                            if (c < ' ') {\n                                warn_at(bundle.control_a, line, from + length, String(c));\n                            } else if (c === '<') {\n                                warn_at(bundle.unexpected_a, line, from + length, '\\\\');\n                            }\n                            length += 1;\n                            bit = true;\n                            break;\n                        case '/':\n                            warn_at('unescaped_a', line, from + length - 1, '/');\n                            bit = true;\n                            break;\n                        case '<':\n                            if (xmode === 'script') {\n                                c = source_row.charAt(length);\n                                if (c === '!' || c === '/') {\n                                    warn_at(bundle.html_confusion_a, line,\n                                        from + length, c);\n                                }\n                            }\n                            bit = true;\n                            break;\n                        default:\n                            bit = true;\n                        }\n                    } while (c);\n                    break;\n                case '.':\n                    if (!option.regexp) {\n                        warn_at('insecure_a', line, from + length, c);\n                    }\n                    break;\n                case ']':\n                case '?':\n                case '{':\n                case '}':\n                case '+':\n                case '*':\n                    warn_at('unescaped_a', line, from + length, c);\n                    break;\n                case '<':\n                    if (xmode === 'script') {\n                        c = source_row.charAt(length);\n                        if (c === '!' || c === '/') {\n                            warn_at(bundle.html_confusion_a, line, from + length, c);\n                        }\n                    }\n                    break;\n                }\n                if (b) {\n                    switch (source_row.charAt(length)) {\n                    case '?':\n                    case '+':\n                    case '*':\n                        length += 1;\n                        if (source_row.charAt(length) === '?') {\n                            length += 1;\n                        }\n                        break;\n                    case '{':\n                        length += 1;\n                        c = source_row.charAt(length);\n                        if (c < '0' || c > '9') {\n                            warn_at(bundle.expected_number_a, line,\n                                from + length, c);\n                        }\n                        length += 1;\n                        low = +c;\n                        for (;;) {\n                            c = source_row.charAt(length);\n                            if (c < '0' || c > '9') {\n                                break;\n                            }\n                            length += 1;\n                            low = +c + (low * 10);\n                        }\n                        high = low;\n                        if (c === ',') {\n                            length += 1;\n                            high = Infinity;\n                            c = source_row.charAt(length);\n                            if (c >= '0' && c <= '9') {\n                                length += 1;\n                                high = +c;\n                                for (;;) {\n                                    c = source_row.charAt(length);\n                                    if (c < '0' || c > '9') {\n                                        break;\n                                    }\n                                    length += 1;\n                                    high = +c + (high * 10);\n                                }\n                            }\n                        }\n                        if (source_row.charAt(length) !== '}') {\n                            warn_at(bundle.expected_a_b, line, from + length,\n                                '}', c);\n                        } else {\n                            length += 1;\n                        }\n                        if (source_row.charAt(length) === '?') {\n                            length += 1;\n                        }\n                        if (low > high) {\n                            warn_at(bundle.not_greater, line, from + length,\n                                low, high);\n                        }\n                        break;\n                    }\n                }\n            }\n            c = source_row.slice(0, length - 1);\n            character += length;\n            source_row = source_row.slice(length);\n            return it('(regexp)', c);\n        }\n\n// Public lex methods\n\n        return {\n            init: function (source) {\n                if (typeof source === 'string') {\n                    lines = source\n                        .replace(crlfx, '\\n')\n                        .replace(crx, '\\n')\n                        .split('\\n');\n                } else {\n                    lines = source;\n                }\n                line = 0;\n                next_line();\n                from = 1;\n            },\n\n            range: function (begin, end) {\n                var c, value = '';\n                from = character;\n                if (source_row.charAt(0) !== begin) {\n                    stop_at('expected_a_b', line, character, begin,\n                        source_row.charAt(0));\n                }\n                for (;;) {\n                    source_row = source_row.slice(1);\n                    character += 1;\n                    c = source_row.charAt(0);\n                    switch (c) {\n                    case '':\n                        stop_at('missing_a', line, character, c);\n                        break;\n                    case end:\n                        source_row = source_row.slice(1);\n                        character += 1;\n                        return it('(range)', value);\n                    case xquote:\n                    case '\\\\':\n                        warn_at('unexpected_a', line, character, c);\n                        break;\n                    }\n                    value += c;\n                }\n            },\n\n// token -- this is called by advance to get the next token.\n\n            token: function () {\n                var c, i, snippet;\n\n                for (;;) {\n                    while (!source_row) {\n                        if (!next_line()) {\n                            return it('(end)');\n                        }\n                    }\n                    while (xmode === 'outer') {\n                        i = source_row.search(ox);\n                        if (i === 0) {\n                            break;\n                        } else if (i > 0) {\n                            character += 1;\n                            source_row = source_row.slice(i);\n                            break;\n                        } else {\n                            if (!next_line()) {\n                                return it('(end)', '');\n                            }\n                        }\n                    }\n                    snippet = match(rx[xmode] || tx);\n                    if (!snippet) {\n                        if (source_row) {\n                            if (source_row.charAt(0) === ' ') {\n                                if (!option.white) {\n                                    warn_at('unexpected_a', line, character,\n                                        '(space)');\n                                }\n                                character += 1;\n                                source_row = '';\n                            } else {\n                                stop_at('unexpected_a', line, character,\n                                    source_row.charAt(0));\n                            }\n                        }\n                    } else {\n\n//      identifier\n\n                        c = snippet.charAt(0);\n                        if (c.isAlpha() || c === '_' || c === '$') {\n                            return it('(identifier)', snippet);\n                        }\n\n//      number\n\n                        if (c.isDigit()) {\n                            return number(snippet);\n                        }\n                        switch (snippet) {\n\n//      string\n\n                        case '\"':\n                        case \"'\":\n                            return string(snippet);\n\n//      // comment\n\n                        case '//':\n                            comment(source_row);\n                            source_row = '';\n                            break;\n\n//      /* comment\n\n                        case '/*':\n                            for (;;) {\n                                i = source_row.search(lx);\n                                if (i >= 0) {\n                                    break;\n                                }\n                                comment(source_row);\n                                if (!next_line()) {\n                                    stop_at('unclosed_comment', line, character);\n                                }\n                            }\n                            comment(source_row.slice(0, i));\n                            character += i + 2;\n                            if (source_row.charAt(i) === '/') {\n                                stop_at('nested_comment', line, character);\n                            }\n                            source_row = source_row.slice(i + 2);\n                            break;\n\n                        case '':\n                            break;\n//      /\n                        case '/':\n                            if (token.id === '/=') {\n                                stop_at(\n                                    bundle.slash_equal,\n                                    line,\n                                    from\n                                );\n                            }\n                            return prereg\n                                ? regexp()\n                                : it('(punctuator)', snippet);\n\n//      punctuator\n\n                        case '<!--':\n                            length = line;\n//                            c = character;\n                            for (;;) {\n                                i = source_row.indexOf('--');\n                                if (i >= 0) {\n                                    break;\n                                }\n                                i = source_row.indexOf('<!');\n                                if (i >= 0) {\n                                    stop_at('nested_comment',\n                                        line, character + i);\n                                }\n                                if (!next_line()) {\n                                    stop_at('unclosed_comment', length, c);\n                                }\n                            }\n                            length = source_row.indexOf('<!');\n                            if (length >= 0 && length < i) {\n                                stop_at('nested_comment',\n                                    line, character + length);\n                            }\n                            character += i;\n                            if (source_row.charAt(i + 2) !== '>') {\n                                stop_at('expected_a', line, character, '-->');\n                            }\n                            character += 3;\n                            source_row = source_row.slice(i + 3);\n                            break;\n                        case '#':\n                            if (xmode === 'html' || xmode === 'styleproperty') {\n                                for (;;) {\n                                    c = source_row.charAt(0);\n                                    if ((c < '0' || c > '9') &&\n                                            (c < 'a' || c > 'f') &&\n                                            (c < 'A' || c > 'F')) {\n                                        break;\n                                    }\n                                    character += 1;\n                                    source_row = source_row.slice(1);\n                                    snippet += c;\n                                }\n                                if (snippet.length !== 4 && snippet.length !== 7) {\n                                    warn_at('bad_color_a', line,\n                                        from + length, snippet);\n                                }\n                                return it('(color)', snippet);\n                            }\n                            return it('(punctuator)', snippet);\n\n                        default:\n                            if (xmode === 'outer' && c === '&') {\n                                character += 1;\n                                source_row = source_row.slice(1);\n                                for (;;) {\n                                    c = source_row.charAt(0);\n                                    character += 1;\n                                    source_row = source_row.slice(1);\n                                    if (c === ';') {\n                                        break;\n                                    }\n                                    if (!((c >= '0' && c <= '9') ||\n                                            (c >= 'a' && c <= 'z') ||\n                                            c === '#')) {\n                                        stop_at('bad_entity', line, from + length,\n                                            character);\n                                    }\n                                }\n                                break;\n                            }\n                            return it('(punctuator)', snippet);\n                        }\n                    }\n                }\n            }\n        };\n    }());\n\n\n    function add_label(token, kind, name) {\n\n// Define the symbol in the current function in the current scope.\n\n        name = name || token.string;\n\n// Global variables cannot be created in the safe subset. If a global variable\n// already exists, do nothing. If it is predefined, define it.\n\n        if (funct === global_funct) {\n            if (option.safe) {\n                warn('adsafe_a', token, name);\n            }\n            if (typeof global_funct[name] !== 'string') {\n                token.writeable = typeof predefined[name] === 'boolean'\n                    ? predefined[name]\n                    : true;\n                token.funct = funct;\n                global_scope[name] = token;\n            }\n            if (kind === 'becoming') {\n                kind = 'var';\n            }\n\n// Ordinary variables.\n\n        } else {\n\n// Warn if the variable already exists.\n\n            if (typeof funct[name] === 'string') {\n                if (funct[name] === 'undef') {\n                    if (!option.undef) {\n                        warn('used_before_a', token, name);\n                    }\n                    kind = 'var';\n                } else {\n                    warn('already_defined', token, name);\n                }\n            } else {\n\n// Add the symbol to the current function.\n\n                token.funct = funct;\n                token.writeable = true;\n                scope[name] = token;\n            }\n        }\n        funct[name] = kind;\n    }\n\n\n    function peek(distance) {\n\n// Peek ahead to a future token. The distance is how far ahead to look. The\n// default is the next token.\n\n        var found, slot = 0;\n\n        distance = distance || 0;\n        while (slot <= distance) {\n            found = lookahead[slot];\n            if (!found) {\n                found = lookahead[slot] = lex.token();\n            }\n            slot += 1;\n        }\n        return found;\n    }\n\n\n    function advance(id, match) {\n\n// Produce the next token, also looking for programming errors.\n\n        if (indent) {\n\n// If indentation checking was requested, then inspect all of the line breakings.\n// The var statement is tricky because the names might be aligned or not. We\n// look at the first line break after the var to determine the programmer's\n// intention.\n\n            if (var_mode && next_token.line !== token.line) {\n                if ((var_mode !== indent || !next_token.edge) &&\n                        next_token.from === indent.at -\n                        (next_token.edge ? option.indent : 0)) {\n                    var dent = indent;\n                    for (;;) {\n                        dent.at -= option.indent;\n                        if (dent === var_mode) {\n                            break;\n                        }\n                        dent = dent.was;\n                    }\n                    dent.open = false;\n                }\n                var_mode = null;\n            }\n            if (next_token.id === '?' && indent.mode === ':' &&\n                    token.line !== next_token.line) {\n                indent.at -= option.indent;\n            }\n            if (indent.open) {\n\n// If the token is an edge.\n\n                if (next_token.edge) {\n                    if (next_token.edge === 'label') {\n                        expected_at(1);\n                    } else if (next_token.edge === 'case' || indent.mode === 'statement') {\n                        expected_at(indent.at - option.indent);\n                    } else if (indent.mode !== 'array' || next_token.line !== token.line) {\n                        expected_at(indent.at);\n                    }\n\n// If the token is not an edge, but is the first token on the line.\n\n                } else if (next_token.line !== token.line) {\n                    if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                    indent.wrap = true;\n                }\n            } else if (next_token.line !== token.line) {\n                if (next_token.edge) {\n                    expected_at(indent.at);\n                } else {\n                    indent.wrap = true;\n                    if (indent.mode === 'statement' || indent.mode === 'var') {\n                        expected_at(indent.at + option.indent);\n                    } else if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                }\n            }\n        }\n\n        switch (token.id) {\n        case '(number)':\n            if (next_token.id === '.') {\n                warn('trailing_decimal_a');\n            }\n            break;\n        case '-':\n            if (next_token.id === '-' || next_token.id === '--') {\n                warn('confusing_a');\n            }\n            break;\n        case '+':\n            if (next_token.id === '+' || next_token.id === '++') {\n                warn('confusing_a');\n            }\n            break;\n        }\n        if (token.id === '(string)' || token.identifier) {\n            anonname = token.string;\n        }\n\n        if (id && next_token.id !== id) {\n            if (match) {\n                warn('expected_a_b_from_c_d', next_token, id,\n                    match.id, match.line, artifact());\n            } else if (!next_token.identifier || next_token.string !== id) {\n                warn('expected_a_b', next_token, id, artifact());\n            }\n        }\n        prev_token = token;\n        token = next_token;\n        next_token = lookahead.shift() || lex.token();\n    }\n\n\n    function advance_identifier(string) {\n        if (next_token.identifier && next_token.string === string) {\n            advance();\n        } else {\n            warn('expected_a_b', next_token, string, artifact());\n        }\n    }\n\n\n    function do_safe() {\n        if (option.adsafe) {\n            option.safe = true;\n        }\n        if (option.safe) {\n            option.browser     =\n                option['continue'] =\n                option.css     =\n                option.debug   =\n                option.devel   =\n                option.evil    =\n                option.forin   =\n                option.newcap  =\n                option.nomen   =\n                option.on      =\n                option.rhino   =\n                option.sloppy  =\n                option.sub     =\n                option.undef   =\n                option.widget  =\n                option.windows = false;\n\n\n            delete predefined.Array;\n            delete predefined.Date;\n            delete predefined.Function;\n            delete predefined.Object;\n            delete predefined['eval'];\n\n            add_to_predefined({\n                ADSAFE: false,\n                lib: false\n            });\n        }\n    }\n\n\n    function do_globals() {\n        var name, writeable;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            writeable = false;\n            if (next_token.id === ':') {\n                advance(':');\n                switch (next_token.id) {\n                case 'true':\n                    writeable = predefined[name] !== false;\n                    advance('true');\n                    break;\n                case 'false':\n                    advance('false');\n                    break;\n                default:\n                    stop('unexpected_a');\n                }\n            }\n            predefined[name] = writeable;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    function do_jslint() {\n        var name, value;\n        while (next_token.id === '(string)' || next_token.identifier) {\n            name = next_token.string;\n            if (!allowed_option[name]) {\n                stop('unexpected_a');\n            }\n            advance();\n            if (next_token.id !== ':') {\n                stop('expected_a_b', next_token, ':', artifact());\n            }\n            advance(':');\n            if (typeof allowed_option[name] === 'number') {\n                value = next_token.number;\n                if (value > allowed_option[name] || value <= 0 ||\n                        Math.floor(value) !== value) {\n                    stop('expected_small_a');\n                }\n                option[name] = value;\n            } else {\n                if (next_token.id === 'true') {\n                    option[name] = true;\n                } else if (next_token.id === 'false') {\n                    option[name] = false;\n                } else {\n                    stop('unexpected_a');\n                }\n            }\n            advance();\n            if (next_token.id === ',') {\n                advance(',');\n            }\n        }\n        assume();\n    }\n\n\n    function do_properties() {\n        var name;\n        option.properties = true;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            if (next_token.id === ':') {\n                for (;;) {\n                    advance();\n                    if (next_token.id !== '(string)' && !next_token.identifier) {\n                        break;\n                    }\n                }\n            }\n            property[name] = 0;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    directive = function directive() {\n        var command = this.id,\n            old_comments_off = comments_off,\n            old_indent = indent;\n        comments_off = true;\n        indent = null;\n        if (next_token.line === token.line && next_token.from === token.thru) {\n            warn('missing_space_a_b', next_token, artifact(token), artifact());\n        }\n        if (lookahead.length > 0) {\n            warn('unexpected_a', this);\n        }\n        switch (command) {\n        case '/*properties':\n        case '/*property':\n        case '/*members':\n        case '/*member':\n            do_properties();\n            break;\n        case '/*jslint':\n            if (option.safe) {\n                warn('adsafe_a', this);\n            }\n            do_jslint();\n            break;\n        case '/*globals':\n        case '/*global':\n            if (option.safe) {\n                warn('adsafe_a', this);\n            }\n            do_globals();\n            break;\n        default:\n            stop('unexpected_a', this);\n        }\n        comments_off = old_comments_off;\n        advance('*/');\n        indent = old_indent;\n    };\n\n\n// Indentation intention\n\n    function edge(mode) {\n        next_token.edge = indent ? indent.open && (mode || 'edge') : '';\n    }\n\n\n    function step_in(mode) {\n        var open;\n        if (typeof mode === 'number') {\n            indent = {\n                at: +mode,\n                open: true,\n                was: indent\n            };\n        } else if (!indent) {\n            indent = {\n                at: 1,\n                mode: 'statement',\n                open: true\n            };\n        } else if (mode === 'statement') {\n            indent = {\n                at: indent.at,\n                open: true,\n                was: indent\n            };\n        } else {\n            open = mode === 'var' || next_token.line !== token.line;\n            indent = {\n                at: (open || mode === 'control'\n                    ? indent.at + option.indent\n                    : indent.at) + (indent.wrap ? option.indent : 0),\n                mode: mode,\n                open: open,\n                was: indent\n            };\n            if (mode === 'var' && open) {\n                var_mode = indent;\n            }\n        }\n    }\n\n    function step_out(id, symbol) {\n        if (id) {\n            if (indent && indent.open) {\n                indent.at -= option.indent;\n                edge();\n            }\n            advance(id, symbol);\n        }\n        if (indent) {\n            indent = indent.was;\n        }\n    }\n\n// Functions for conformance of whitespace.\n\n    function one_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && !option.white &&\n                (token.line !== right.line ||\n                token.thru + 1 !== right.from)) {\n            warn('expected_space_a_b', right, artifact(token), artifact(right));\n        }\n    }\n\n    function one_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru + 1 !== right.from))) {\n            warn('expected_space_a_b', right, artifact(left), artifact(right));\n        }\n    }\n\n    function no_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if ((!option.white || xmode === 'styleproperty' || xmode === 'style') &&\n                left.thru !== right.from && left.line === right.line) {\n            warn('unexpected_space_a_b', right, artifact(left), artifact(right));\n        }\n    }\n\n    function no_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru !== right.from))) {\n            warn('unexpected_space_a_b', right, artifact(left), artifact(right));\n        }\n    }\n\n    function spaces(left, right) {\n        if (!option.white) {\n            left = left || token;\n            right = right || next_token;\n            if (left.thru === right.from && left.line === right.line) {\n                warn('missing_space_a_b', right, artifact(left), artifact(right));\n            }\n        }\n    }\n\n    function comma() {\n        if (next_token.id !== ',') {\n            warn_at('expected_a_b', token.line, token.thru, ',', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(',');\n            spaces();\n        }\n    }\n\n\n    function semicolon() {\n        if (next_token.id !== ';') {\n            warn_at('expected_a_b', token.line, token.thru, ';', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(';');\n            if (semicolon_coda[next_token.id] !== true) {\n                spaces();\n            }\n        }\n    }\n\n    function use_strict() {\n        if (next_token.string === 'use strict') {\n            if (strict_mode) {\n                warn('unnecessary_use');\n            }\n            edge();\n            advance();\n            semicolon();\n            strict_mode = true;\n            option.newcap = false;\n            option.undef = false;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n\n    function are_similar(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (Array.isArray(a)) {\n            if (Array.isArray(b) && a.length === b.length) {\n                var i;\n                for (i = 0; i < a.length; i += 1) {\n                    if (!are_similar(a[i], b[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n        if (Array.isArray(b)) {\n            return false;\n        }\n        if (a.id === '(number)' && b.id === '(number)') {\n            return a.number === b.number;\n        }\n        if (a.arity === b.arity && a.string === b.string) {\n            switch (a.arity) {\n            case 'prefix':\n            case 'suffix':\n            case undefined:\n                return a.id === b.id && are_similar(a.first, b.first);\n            case 'infix':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second);\n            case 'ternary':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second) &&\n                    are_similar(a.third, b.third);\n            case 'function':\n            case 'regexp':\n                return false;\n            default:\n                return true;\n            }\n        } else {\n            if (a.id === '.' && b.id === '[' && b.arity === 'infix') {\n                return a.second.string === b.second.string && b.second.id === '(string)';\n            } else if (a.id === '[' && a.arity === 'infix' && b.id === '.') {\n                return a.second.string === b.second.string && a.second.id === '(string)';\n            }\n        }\n        return false;\n    }\n\n\n// This is the heart of JSLINT, the Pratt parser. In addition to parsing, it\n// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is\n// like .nud except that it is only used on the first token of a statement.\n// Having .fud makes it much easier to define statement-oriented languages like\n// JavaScript. I retained Pratt's nomenclature.\n\n// .nud     Null denotation\n// .fud     First null denotation\n// .led     Left denotation\n//  lbp     Left binding power\n//  rbp     Right binding power\n\n// They are elements of the parsing method called Top Down Operator Precedence.\n\n    function expression(rbp, initial) {\n\n// rbp is the right binding power.\n// initial indicates that this is the first expression of a statement.\n\n        var left;\n        if (next_token.id === '(end)') {\n            stop('unexpected_a', token, next_token.id);\n        }\n        advance();\n        if (option.safe && scope[token.string] &&\n                scope[token.string] === global_scope[token.string] &&\n                (next_token.id !== '(' && next_token.id !== '.')) {\n            warn('adsafe_a', token);\n        }\n        if (initial) {\n            anonname = 'anonymous';\n            funct['(verb)'] = token.string;\n        }\n        if (initial === true && token.fud) {\n            left = token.fud();\n        } else {\n            if (token.nud) {\n                left = token.nud();\n            } else {\n                if (next_token.id === '(number)' && token.id === '.') {\n                    warn('leading_decimal_a', token, artifact());\n                    advance();\n                    return token;\n                } else {\n                    stop('expected_identifier_a', token, token.id);\n                }\n            }\n            while (rbp < next_token.lbp) {\n                advance();\n                if (token.led) {\n                    left = token.led(left);\n                } else {\n                    stop('expected_operator_a', token, token.id);\n                }\n            }\n        }\n        return left;\n    }\n\n\n// Functional constructors for making the symbols that will be inherited by\n// tokens.\n\n    function symbol(s, p) {\n        var x = syntax[s];\n        if (!x || typeof x !== 'object') {\n            syntax[s] = x = {\n                id: s,\n                lbp: p || 0,\n                string: s\n            };\n        }\n        return x;\n    }\n\n    function postscript(x) {\n        x.postscript = true;\n        return x;\n    }\n\n    function ultimate(s) {\n        var x = symbol(s, 0);\n        x.from = 1;\n        x.thru = 1;\n        x.line = 0;\n        x.edge = 'edge';\n        s.string = s;\n        return postscript(x);\n    }\n\n\n    function stmt(s, f) {\n        var x = symbol(s);\n        x.identifier = x.reserved = true;\n        x.fud = f;\n        return x;\n    }\n\n    function labeled_stmt(s, f) {\n        var x = stmt(s, f);\n        x.labeled = true;\n    }\n\n    function disrupt_stmt(s, f) {\n        var x = stmt(s, f);\n        x.disrupt = true;\n    }\n\n\n    function reserve_name(x) {\n        var c = x.id.charAt(0);\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            x.identifier = x.reserved = true;\n        }\n        return x;\n    }\n\n\n    function prefix(s, f) {\n        var x = symbol(s, 150);\n        reserve_name(x);\n        x.nud = typeof f === 'function'\n            ? f\n            : function () {\n                if (s === 'typeof') {\n                    one_space();\n                } else {\n                    no_space_only();\n                }\n                this.first = expression(150);\n                this.arity = 'prefix';\n                if (this.id === '++' || this.id === '--') {\n                    if (!option.plusplus) {\n                        warn('unexpected_a', this);\n                    } else if ((!this.first.identifier || this.first.reserved) &&\n                            this.first.id !== '.' && this.first.id !== '[') {\n                        warn('bad_operand', this);\n                    }\n                }\n                return this;\n            };\n        return x;\n    }\n\n\n    function type(s, t, nud) {\n        var x = symbol(s);\n        x.arity = t;\n        if (nud) {\n            x.nud = nud;\n        }\n        return x;\n    }\n\n\n    function reserve(s, f) {\n        var x = symbol(s);\n        x.identifier = x.reserved = true;\n        if (typeof f === 'function') {\n            x.nud = f;\n        }\n        return x;\n    }\n\n\n    function constant(name) {\n        var x = reserve(name);\n        x.string = name;\n        x.nud = return_this;\n        return x;\n    }\n\n\n    function reservevar(s, v) {\n        return reserve(s, function () {\n            if (typeof v === 'function') {\n                v(this);\n            }\n            return this;\n        });\n    }\n\n\n    function infix(s, p, f, w) {\n        var x = symbol(s, p);\n        reserve_name(x);\n        x.led = function (left) {\n            this.arity = 'infix';\n            if (!w) {\n                spaces(prev_token, token);\n                spaces();\n            }\n            if (!option.bitwise && this.bitwise) {\n                warn('unexpected_a', this);\n            }\n            if (typeof f === 'function') {\n                return f(left, this);\n            } else {\n                this.first = left;\n                this.second = expression(p);\n                return this;\n            }\n        };\n        return x;\n    }\n\n    function expected_relation(node, message) {\n        if (node.assign) {\n            warn(message || bundle.conditional_assignment, node);\n        }\n        return node;\n    }\n\n    function expected_condition(node, message) {\n        switch (node.id) {\n        case '[':\n        case '-':\n            if (node.arity !== 'infix') {\n                warn(message || bundle.weird_condition, node);\n            }\n            break;\n        case 'false':\n        case 'function':\n        case 'Infinity':\n        case 'NaN':\n        case 'null':\n        case 'true':\n        case 'undefined':\n        case 'void':\n        case '(number)':\n        case '(regexp)':\n        case '(string)':\n        case '{':\n            warn(message || bundle.weird_condition, node);\n            break;\n        case '(':\n            if (node.first.id === '.' && numbery[node.first.second.string] === true) {\n                warn(message || bundle.weird_condition, node);\n            }\n            break;\n        }\n        return node;\n    }\n\n    function check_relation(node) {\n        switch (node.arity) {\n        case 'prefix':\n            switch (node.id) {\n            case '{':\n            case '[':\n                warn('unexpected_a', node);\n                break;\n            case '!':\n                warn('confusing_a', node);\n                break;\n            }\n            break;\n        case 'function':\n        case 'regexp':\n            warn('unexpected_a', node);\n            break;\n        default:\n            if (node.id  === 'NaN') {\n                warn('isNaN', node);\n            }\n        }\n        return node;\n    }\n\n\n    function relation(s, eqeq) {\n        return infix(s, 100, function (left, that) {\n            check_relation(left);\n            if (eqeq && !option.eqeq) {\n                warn('expected_a_b', that, eqeq, that.id);\n            }\n            var right = expression(100);\n            if (are_similar(left, right) ||\n                    ((left.id === '(string)' || left.id === '(number)') &&\n                    (right.id === '(string)' || right.id === '(number)'))) {\n                warn('weird_relation', that);\n            }\n            that.first = left;\n            that.second = check_relation(right);\n            return that;\n        });\n    }\n\n\n    function assignop(s, op) {\n        var x = infix(s, 20, function (left, that) {\n            var l;\n            that.first = left;\n            if (left.identifier) {\n                if (scope[left.string]) {\n                    if (scope[left.string].writeable === false) {\n                        warn('read_only', left);\n                    }\n                } else {\n                    stop('read_only');\n                }\n            } else if (option.safe) {\n                l = left;\n                do {\n                    if (typeof predefined[l.string] === 'boolean') {\n                        warn('adsafe_a', l);\n                    }\n                    l = l.first;\n                } while (l);\n            }\n            if (left === syntax['function']) {\n                warn('identifier_function', token);\n            }\n            if (left.id === '.' || left.id === '[') {\n                if (!left.first || left.first.string === 'arguments') {\n                    warn('bad_assignment', that);\n                }\n            } else if (left.identifier) {\n                if (!left.reserved && funct[left.string] === 'exception') {\n                    warn('assign_exception', left);\n                }\n            } else {\n                warn('bad_assignment', that);\n            }\n            that.second = expression(19);\n            if (that.id === '=' && are_similar(that.first, that.second)) {\n                warn('weird_assignment', that);\n            }\n            return that;\n        });\n        x.assign = true;\n        if (op) {\n            if (syntax[op].bitwise) {\n                x.bitwise = true;\n            }\n        }\n        return x;\n    }\n\n\n    function bitwise(s, p) {\n        var x = infix(s, p, 'number');\n        x.bitwise = true;\n        return x;\n    }\n\n\n    function suffix(s) {\n        var x = symbol(s, 150);\n        x.led = function (left) {\n            no_space_only(prev_token, token);\n            if (!option.plusplus) {\n                warn('unexpected_a', this);\n            } else if ((!left.identifier || left.reserved) &&\n                    left.id !== '.' && left.id !== '[') {\n                warn('bad_operand', this);\n            }\n            this.first = left;\n            this.arity = 'suffix';\n            return this;\n        };\n        return x;\n    }\n\n\n    function optional_identifier() {\n        if (next_token.identifier) {\n            advance();\n            if (option.safe && banned[token.string]) {\n                warn('adsafe_a', token);\n            } else if (token.reserved && !option.es5) {\n                warn('expected_identifier_a_reserved', token);\n            }\n            return token.string;\n        }\n    }\n\n\n    function identifier() {\n        var i = optional_identifier();\n        if (!i) {\n            stop(token.id === 'function' && next_token.id === '('\n                ? 'name_function'\n                : 'expected_identifier_a');\n        }\n        return i;\n    }\n\n\n    function statement() {\n\n        var label, old_scope = scope, the_statement;\n\n// We don't like the empty statement.\n\n        if (next_token.id === ';') {\n            warn('unexpected_a');\n            semicolon();\n            return;\n        }\n\n// Is this a labeled statement?\n\n        if (next_token.identifier && !next_token.reserved && peek().id === ':') {\n            edge('label');\n            label = next_token;\n            advance();\n            advance(':');\n            scope = Object.create(old_scope);\n            add_label(label, 'label');\n            if (next_token.labeled !== true) {\n                warn('label_a_b', next_token, label.string, artifact());\n            } else if (jx.test(label.string + ':')) {\n                warn('url', label);\n            } else if (funct === global_funct) {\n                stop('unexpected_a', token);\n            }\n            next_token.label = label;\n        }\n\n// Parse the statement.\n\n        if (token.id !== 'else') {\n            edge();\n        }\n        step_in('statement');\n        the_statement = expression(0, true);\n        if (the_statement) {\n\n// Look for the final semicolon.\n\n            if (the_statement.arity === 'statement') {\n                if (the_statement.id === 'switch' ||\n                        (the_statement.block && the_statement.id !== 'do')) {\n                    spaces();\n                } else {\n                    semicolon();\n                }\n            } else {\n\n// If this is an expression statement, determine if it is acceptable.\n// We do not like\n//      new Blah();\n// statments. If it is to be used at all, new should only be used to make\n// objects, not side effects. The expression statements we do like do\n// assignment or invocation or delete.\n\n                if (the_statement.id === '(') {\n                    if (the_statement.first.id === 'new') {\n                        warn('bad_new');\n                    }\n                } else if (!the_statement.assign &&\n                        the_statement.id !== 'delete' &&\n                        the_statement.id !== '++' &&\n                        the_statement.id !== '--') {\n                    warn('assignment_function_expression', token);\n                }\n                semicolon();\n            }\n        }\n        step_out();\n        scope = old_scope;\n        return the_statement;\n    }\n\n\n    function statements() {\n        var array = [], disruptor, the_statement;\n\n// A disrupt statement may not be followed by any other statement.\n// If the last statement is disrupt, then the sequence is disrupt.\n\n        while (next_token.postscript !== true) {\n            if (next_token.id === ';') {\n                warn('unexpected_a', next_token);\n                semicolon();\n            } else {\n                if (next_token.string === 'use strict') {\n                    if ((!node_js && xmode !== 'script') || funct !== global_funct || array.length > 0) {\n                        warn('function_strict');\n                    }\n                    use_strict();\n                }\n                if (disruptor) {\n                    warn('unreachable_a_b', next_token, next_token.string,\n                        disruptor.string);\n                    disruptor = null;\n                }\n                the_statement = statement();\n                if (the_statement) {\n                    array.push(the_statement);\n                    if (the_statement.disrupt) {\n                        disruptor = the_statement;\n                        array.disrupt = true;\n                    }\n                }\n            }\n        }\n        return array;\n    }\n\n\n    function block(ordinary) {\n\n// array block is array sequence of statements wrapped in braces.\n// ordinary is false for function bodies and try blocks.\n// ordinary is true for if statements, while, etc.\n\n        var array,\n            curly = next_token,\n            old_in_block = in_block,\n            old_scope = scope,\n            old_strict_mode = strict_mode;\n\n        in_block = ordinary;\n        scope = Object.create(scope);\n        spaces();\n        if (next_token.id === '{') {\n            advance('{');\n            step_in();\n            if (!ordinary && !use_strict() && !old_strict_mode &&\n                    !option.sloppy && funct['(context)'] === global_funct) {\n                warn('missing_use_strict');\n            }\n            array = statements();\n            strict_mode = old_strict_mode;\n            step_out('}', curly);\n        } else if (!ordinary) {\n            stop('expected_a_b', next_token, '{', artifact());\n        } else {\n            warn('expected_a_b', next_token, '{', artifact());\n            array = [statement()];\n            array.disrupt = array[0].disrupt;\n        }\n        funct['(verb)'] = null;\n        scope = old_scope;\n        in_block = old_in_block;\n        if (ordinary && array.length === 0) {\n            warn('empty_block');\n        }\n        return array;\n    }\n\n\n    function tally_property(name) {\n        if (option.properties && typeof property[name] !== 'number') {\n            warn('unexpected_property_a', token, name);\n        }\n        if (typeof property[name] === 'number') {\n            property[name] += 1;\n        } else {\n            property[name] = 1;\n        }\n    }\n\n\n// ECMAScript parser\n\n    syntax['(identifier)'] = {\n        id: '(identifier)',\n        lbp: 0,\n        identifier: true,\n        nud: function () {\n            var name = this.string,\n                variable = scope[name],\n                site,\n                writeable;\n\n// If the variable is not in scope, then we may have an undeclared variable.\n// Check the predefined list. If it was predefined, create the global\n// variable.\n\n            if (typeof variable !== 'object') {\n                writeable = predefined[name];\n                if (typeof writeable === 'boolean') {\n                    global_scope[name] = variable = {\n                        string:    name,\n                        writeable: writeable,\n                        funct:     global_funct\n                    };\n                    global_funct[name] = 'var';\n\n// But if the variable is not in scope, and is not predefined, and if we are not\n// in the global scope, then we have an undefined variable error.\n\n                } else {\n                    if (!option.undef) {\n                        warn('used_before_a', token);\n                    }\n                    scope[name] = variable = {\n                        string: name,\n                        writeable: true,\n                        funct: funct\n                    };\n                    funct[name] = 'undef';\n                }\n\n            }\n            site = variable.funct;\n\n// The name is in scope and defined in the current function.\n\n            if (funct === site) {\n\n//      Change 'unused' to 'var', and reject labels.\n\n                switch (funct[name]) {\n                case 'becoming':\n                    warn('unexpected_a', token);\n                    funct[name] = 'var';\n                    break;\n                case 'unused':\n                    funct[name] = 'var';\n                    break;\n                case 'unparam':\n                    funct[name] = 'parameter';\n                    break;\n                case 'unction':\n                    funct[name] = 'function';\n                    break;\n                case 'label':\n                    warn('a_label', token, name);\n                    break;\n                }\n\n// If the name is already defined in the current\n// function, but not as outer, then there is a scope error.\n\n            } else {\n                switch (funct[name]) {\n                case 'closure':\n                case 'function':\n                case 'var':\n                case 'unused':\n                    warn('a_scope', token, name);\n                    break;\n                case 'label':\n                    warn('a_label', token, name);\n                    break;\n                case 'outer':\n                case 'global':\n                    break;\n                default:\n\n// If the name is defined in an outer function, make an outer entry, and if\n// it was unused, make it var.\n\n                    switch (site[name]) {\n                    case 'becoming':\n                    case 'closure':\n                    case 'function':\n                    case 'parameter':\n                    case 'unction':\n                    case 'unused':\n                    case 'var':\n                        site[name] = 'closure';\n                        funct[name] = site === global_funct\n                            ? 'global'\n                            : 'outer';\n                        break;\n                    case 'unparam':\n                        site[name] = 'parameter';\n                        funct[name] = 'outer';\n                        break;\n                    case 'undef':\n                        funct[name] = 'undef';\n                        break;\n                    case 'label':\n                        warn('a_label', token, name);\n                        break;\n                    }\n                }\n            }\n            return this;\n        },\n        led: function () {\n            stop('expected_operator_a');\n        }\n    };\n\n// Build the syntax table by declaring the syntactic elements.\n\n    type('(array)', 'array');\n    type('(color)', 'color');\n    type('(function)', 'function');\n    type('(number)', 'number', return_this);\n    type('(object)', 'object');\n    type('(string)', 'string', return_this);\n    type('(boolean)', 'boolean', return_this);\n    type('(range)', 'range');\n    type('(regexp)', 'regexp', return_this);\n\n    ultimate('(begin)');\n    ultimate('(end)');\n    ultimate('(error)');\n    postscript(symbol('</'));\n    symbol('<!');\n    symbol('<!--');\n    symbol('-->');\n    postscript(symbol('}'));\n    symbol(')');\n    symbol(']');\n    postscript(symbol('\"'));\n    postscript(symbol('\\''));\n    symbol(';');\n    symbol(':');\n    symbol(',');\n    symbol('#');\n    symbol('@');\n    symbol('*/');\n    postscript(reserve('case'));\n    reserve('catch');\n    postscript(reserve('default'));\n    reserve('else');\n    reserve('finally');\n\n    reservevar('arguments', function (x) {\n        if (strict_mode && funct === global_funct) {\n            warn('strict', x);\n        } else if (option.safe) {\n            warn('adsafe_a', x);\n        }\n    });\n    reservevar('eval', function (x) {\n        if (option.safe) {\n            warn('adsafe_a', x);\n        }\n    });\n    constant('false', 'boolean');\n    constant('Infinity', 'number');\n    constant('NaN', 'number');\n    constant('null', '');\n    reservevar('this', function (x) {\n        if (option.safe) {\n            warn('adsafe_a', x);\n        } else if (strict_mode && funct['(token)'].arity === 'statement' &&\n                funct['(name)'].charAt(0) > 'Z') {\n            warn('strict', x);\n        }\n    });\n    constant('true', 'boolean');\n    constant('undefined', '');\n\n    infix('?', 30, function (left, that) {\n        step_in('?');\n        that.first = expected_condition(expected_relation(left));\n        that.second = expression(0);\n        spaces();\n        step_out();\n        var colon = next_token;\n        advance(':');\n        step_in(':');\n        spaces();\n        that.third = expression(10);\n        that.arity = 'ternary';\n        if (are_similar(that.second, that.third)) {\n            warn('weird_ternary', colon);\n        } else if (are_similar(that.first, that.second)) {\n            warn('use_or', that);\n        }\n        step_out();\n        return that;\n    });\n\n    infix('||', 40, function (left, that) {\n        function paren_check(that) {\n            if (that.id === '&&' && !that.paren) {\n                warn('and', that);\n            }\n            return that;\n        }\n\n        that.first = paren_check(expected_condition(expected_relation(left)));\n        that.second = paren_check(expected_relation(expression(40)));\n        if (are_similar(that.first, that.second)) {\n            warn('weird_condition', that);\n        }\n        return that;\n    });\n\n    infix('&&', 50, function (left, that) {\n        that.first = expected_condition(expected_relation(left));\n        that.second = expected_relation(expression(50));\n        if (are_similar(that.first, that.second)) {\n            warn('weird_condition', that);\n        }\n        return that;\n    });\n\n    prefix('void', function () {\n        this.first = expression(0);\n        this.arity = 'prefix';\n        if (option.es5) {\n            warn('expected_a_b', this, 'undefined', 'void');\n        } else if (this.first.number !== 0) {\n            warn('expected_a_b', this.first, '0', artifact(this.first));\n        }\n        return this;\n    });\n\n    bitwise('|', 70);\n    bitwise('^', 80);\n    bitwise('&', 90);\n\n    relation('==', '===');\n    relation('===');\n    relation('!=', '!==');\n    relation('!==');\n    relation('<');\n    relation('>');\n    relation('<=');\n    relation('>=');\n\n    bitwise('<<', 120);\n    bitwise('>>', 120);\n    bitwise('>>>', 120);\n\n    infix('in', 120, function (left, that) {\n        warn('infix_in', that);\n        that.left = left;\n        that.right = expression(130);\n        return that;\n    });\n    infix('instanceof', 120);\n    infix('+', 130, function (left, that) {\n        if (left.id === '(number)') {\n            if (left.number === 0) {\n                warn('unexpected_a', left, '0');\n            }\n        } else if (left.id === '(string)') {\n            if (left.string === '') {\n                warn('expected_a_b', left, 'String', '\\'\\'');\n            }\n        }\n        var right = expression(130);\n        if (right.id === '(number)') {\n            if (right.number === 0) {\n                warn('unexpected_a', right, '0');\n            }\n        } else if (right.id === '(string)') {\n            if (right.string === '') {\n                warn('expected_a_b', right, 'String', '\\'\\'');\n            }\n        }\n        if (left.id === right.id) {\n            if (left.id === '(string)' || left.id === '(number)') {\n                if (left.id === '(string)') {\n                    left.string += right.string;\n                    if (jx.test(left.string)) {\n                        warn('url', left);\n                    }\n                } else {\n                    left.number += right.number;\n                }\n                left.thru = right.thru;\n                return left;\n            }\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('+', 'num');\n    prefix('+++', function () {\n        warn('confusing_a', token);\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('+++', 130, function (left) {\n        warn('confusing_a', token);\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('-', 130, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            warn('unexpected_a', left);\n        }\n        var right = expression(130);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            warn('unexpected_a', left);\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number -= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('-');\n    prefix('---', function () {\n        warn('confusing_a', token);\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('---', 130, function (left) {\n        warn('confusing_a', token);\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('*', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            warn('unexpected_a', left);\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            warn('unexpected_a', right);\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number *= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('/', 140, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            warn('unexpected_a', left);\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            warn('unexpected_a', right);\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number /= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('%', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            warn('unexpected_a', left);\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            warn('unexpected_a', right);\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number %= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n\n    suffix('++');\n    prefix('++');\n\n    suffix('--');\n    prefix('--');\n    prefix('delete', function () {\n        one_space();\n        var p = expression(0);\n        if (!p || (p.id !== '.' && p.id !== '[')) {\n            warn('deleted');\n        }\n        this.first = p;\n        return this;\n    });\n\n\n    prefix('~', function () {\n        no_space_only();\n        if (!option.bitwise) {\n            warn('unexpected_a', this);\n        }\n        expression(150);\n        return this;\n    });\n    prefix('!', function () {\n        no_space_only();\n        this.first = expected_condition(expression(150));\n        this.arity = 'prefix';\n        if (bang[this.first.id] === true || this.first.assign) {\n            warn('confusing_a', this);\n        }\n        return this;\n    });\n    prefix('typeof', null);\n    prefix('new', function () {\n        one_space();\n        var c = expression(160), n, p, v;\n        this.first = c;\n        if (c.id !== 'function') {\n            if (c.identifier) {\n                switch (c.string) {\n                case 'Object':\n                    warn('use_object', token);\n                    break;\n                case 'Array':\n                    if (next_token.id === '(') {\n                        p = next_token;\n                        p.first = this;\n                        advance('(');\n                        if (next_token.id !== ')') {\n                            n = expression(0);\n                            p.second = [n];\n                            if (n.id !== '(number)' || next_token.id === ',') {\n                                warn('use_array', p);\n                            }\n                            while (next_token.id === ',') {\n                                advance(',');\n                                p.second.push(expression(0));\n                            }\n                        } else {\n                            warn('use_array', token);\n                        }\n                        advance(')', p);\n                        return p;\n                    }\n                    warn('use_array', token);\n                    break;\n                case 'Number':\n                case 'String':\n                case 'Boolean':\n                case 'Math':\n                case 'JSON':\n                    warn('not_a_constructor', c);\n                    break;\n                case 'Function':\n                    if (!option.evil) {\n                        warn('function_eval');\n                    }\n                    break;\n                case 'Date':\n                case 'RegExp':\n                case 'this':\n                    break;\n                default:\n                    if (c.id !== 'function') {\n                        v = c.string.charAt(0);\n                        if (!option.newcap && (v < 'A' || v > 'Z')) {\n                            warn('constructor_name_a', token);\n                        }\n                    }\n                }\n            } else {\n                if (c.id !== '.' && c.id !== '[' && c.id !== '(') {\n                    warn('bad_constructor', token);\n                }\n            }\n        } else {\n            warn('weird_new', this);\n        }\n        if (next_token.id !== '(') {\n            warn('missing_a', next_token, '()');\n        }\n        return this;\n    });\n\n    infix('(', 160, function (left, that) {\n        var p;\n        if (indent && indent.mode === 'expression') {\n            no_space(prev_token, token);\n        } else {\n            no_space_only(prev_token, token);\n        }\n        if (!left.immed && left.id === 'function') {\n            warn('wrap_immediate');\n        }\n        p = [];\n        if (left.identifier) {\n            if (left.string.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {\n                if (left.string !== 'Number' && left.string !== 'String' &&\n                        left.string !== 'Boolean' && left.string !== 'Date') {\n                    if (left.string === 'Math' || left.string === 'JSON') {\n                        warn('not_a_function', left);\n                    } else if (left.string === 'Object') {\n                        warn('use_object', token);\n                    } else if (left.string === 'Array' || !option.newcap) {\n                        warn('missing_a', left, 'new');\n                    }\n                }\n            }\n        } else if (left.id === '.') {\n            if (option.safe && left.first.string === 'Math' &&\n                    left.second === 'random') {\n                warn('adsafe_a', left);\n            } else if (left.second.string === 'split' &&\n                    left.first.id === '(string)') {\n                warn('use_array', left.second);\n            }\n        }\n        step_in();\n        if (next_token.id !== ')') {\n            no_space();\n            for (;;) {\n                edge();\n                p.push(expression(10));\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', that);\n        if (typeof left === 'object') {\n            if (left.string === 'parseInt' && p.length === 1) {\n                warn('radix', left);\n            }\n            if (!option.evil) {\n                if (left.string === 'eval' || left.string === 'Function' ||\n                        left.string === 'execScript') {\n                    warn('evil', left);\n                } else if (p[0] && p[0].id === '(string)' &&\n                        (left.string === 'setTimeout' ||\n                        left.string === 'setInterval')) {\n                    warn('implied_evil', left);\n                }\n            }\n            if (!left.identifier && left.id !== '.' && left.id !== '[' &&\n                    left.id !== '(' && left.id !== '&&' && left.id !== '||' &&\n                    left.id !== '?') {\n                warn('bad_invocation', left);\n            }\n        }\n        that.first = left;\n        that.second = p;\n        return that;\n    }, true);\n\n    prefix('(', function () {\n        step_in('expression');\n        no_space();\n        edge();\n        if (next_token.id === 'function') {\n            next_token.immed = true;\n        }\n        var value = expression(0);\n        value.paren = true;\n        no_space();\n        step_out(')', this);\n        if (value.id === 'function') {\n            if (next_token.id === '(') {\n                warn('move_invocation');\n            } else {\n                warn('bad_wrap', this);\n            }\n        }\n        return value;\n    });\n\n    infix('.', 170, function (left, that) {\n        no_space(prev_token, token);\n        no_space();\n        var name = identifier();\n        if (typeof name === 'string') {\n            tally_property(name);\n        }\n        that.first = left;\n        that.second = token;\n        if (left && left.string === 'arguments' &&\n                (name === 'callee' || name === 'caller')) {\n            warn('avoid_a', left, 'arguments.' + name);\n        } else if (!option.evil && left && left.string === 'document' &&\n                (name === 'write' || name === 'writeln')) {\n            warn('write_is_wrong', left);\n        } else if (option.adsafe) {\n            if (!adsafe_top && left.string === 'ADSAFE') {\n                if (name === 'id' || name === 'lib') {\n                    warn('adsafe_a', that);\n                } else if (name === 'go') {\n                    if (xmode !== 'script') {\n                        warn('adsafe_a', that);\n                    } else if (adsafe_went || next_token.id !== '(' ||\n                            peek(0).id !== '(string)' ||\n                            peek(0).string !== adsafe_id ||\n                            peek(1).id !== ',') {\n                        stop('adsafe_a', that, 'go');\n                    }\n                    adsafe_went = true;\n                    adsafe_may = false;\n                }\n            }\n            adsafe_top = false;\n        }\n        if (!option.evil && (name === 'eval' || name === 'execScript')) {\n            warn('evil');\n        } else if (option.safe) {\n            for (;;) {\n                if (banned[name] === true) {\n                    warn('adsafe_a', token, name);\n                }\n                if (typeof predefined[left.string] !== 'boolean' ||    //// check for writeable\n                        next_token.id === '(') {\n                    break;\n                }\n                if (next_token.id !== '.') {\n                    warn('adsafe_a', that);\n                    break;\n                }\n                advance('.');\n                token.first = that;\n                token.second = name;\n                that = token;\n                name = identifier();\n                if (typeof name === 'string') {\n                    tally_property(name);\n                }\n            }\n        }\n        return that;\n    }, true);\n\n    infix('[', 170, function (left, that) {\n        var e, s;\n        no_space_only(prev_token, token);\n        no_space();\n        step_in();\n        edge();\n        e = expression(0);\n        switch (e.id) {\n        case '(number)':\n            if (e.id === '(number)' && left.id === 'arguments') {\n                warn('use_param', left);\n            }\n            break;\n        case '(string)':\n            if (option.safe && (banned[e.string] ||\n                    e.string.charAt(0) === '_' || e.string.slice(-1) === '_')) {\n                warn('adsafe_subscript_a', e);\n            } else if (!option.evil &&\n                    (e.string === 'eval' || e.string === 'execScript')) {\n                warn('evil', e);\n            } else if (!option.sub && ix.test(e.string)) {\n                s = syntax[e.string];\n                if (!s || !s.reserved) {\n                    warn('subscript', e);\n                }\n            }\n            tally_property(e.string);\n            break;\n        default:\n            if (option.safe) {\n                warn('adsafe_subscript_a', e);\n            }\n        }\n        step_out(']', that);\n        no_space(prev_token, token);\n        that.first = left;\n        that.second = e;\n        return that;\n    }, true);\n\n    prefix('[', function () {\n        this.arity = 'prefix';\n        this.first = [];\n        step_in('array');\n        while (next_token.id !== '(end)') {\n            while (next_token.id === ',') {\n                warn('unexpected_a', next_token);\n                advance(',');\n            }\n            if (next_token.id === ']') {\n                break;\n            }\n            indent.wrap = false;\n            edge();\n            this.first.push(expression(10));\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id === ']' && !option.es5) {\n                    warn('unexpected_a', token);\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        step_out(']', this);\n        return this;\n    }, 170);\n\n\n    function property_name() {\n        var id = optional_identifier(true);\n        if (!id) {\n            if (next_token.id === '(string)') {\n                id = next_token.string;\n                if (option.safe) {\n                    if (banned[id]) {\n                        warn('adsafe_a');\n                    } else if (id.charAt(0) === '_' ||\n                            id.charAt(id.length - 1) === '_') {\n                        warn('dangling_a');\n                    }\n                }\n                advance();\n            } else if (next_token.id === '(number)') {\n                id = next_token.number.toString();\n                advance();\n            }\n        }\n        return id;\n    }\n\n\n    function function_params() {\n        var id, paren = next_token, params = [];\n        advance('(');\n        step_in();\n        no_space();\n        if (next_token.id === ')') {\n            no_space();\n            step_out(')', paren);\n            return;\n        }\n        for (;;) {\n            edge();\n            id = identifier();\n            params.push(token);\n            add_label(token, option.unparam ? 'parameter' : 'unparam');\n            if (next_token.id === ',') {\n                comma();\n            } else {\n                no_space();\n                step_out(')', paren);\n                return params;\n            }\n        }\n    }\n\n\n\n    function do_function(func, name) {\n        var old_funct      = funct,\n            old_option     = option,\n            old_scope      = scope;\n        funct = {\n            '(name)'     : name || '\\'' + (anonname || '').replace(nx, sanitize) + '\\'',\n            '(line)'     : next_token.line,\n            '(context)'  : old_funct,\n            '(breakage)' : 0,\n            '(loopage)'  : 0,\n            '(scope)'    : scope,\n            '(token)'    : func\n        };\n        option = Object.create(old_option);\n        scope = Object.create(old_scope);\n        functions.push(funct);\n        func.name = name;\n        if (name) {\n            add_label(func, 'function', name);\n        }\n        func.writeable = false;\n        func.first = funct['(params)'] = function_params();\n        one_space();\n        func.block = block(false);\n        funct      = old_funct;\n        option     = old_option;\n        scope      = old_scope;\n    }\n\n\n    assignop('=');\n    assignop('+=', '+');\n    assignop('-=', '-');\n    assignop('*=', '*');\n    assignop('/=', '/').nud = function () {\n        stop('slash_equal');\n    };\n    assignop('%=', '%');\n    assignop('&=', '&');\n    assignop('|=', '|');\n    assignop('^=', '^');\n    assignop('<<=', '<<');\n    assignop('>>=', '>>');\n    assignop('>>>=', '>>>');\n\n\n    prefix('{', function () {\n        var get, i, j, name, p, set, seen = {};\n        this.arity = 'prefix';\n        this.first = [];\n        step_in();\n        while (next_token.id !== '}') {\n            indent.wrap = false;\n\n// JSLint recognizes the ES5 extension for get/set in object literals,\n// but requires that they be used in pairs.\n\n            edge();\n            if (next_token.string === 'get' && peek().id !== ':') {\n                if (!option.es5) {\n                    warn('es5');\n                }\n                get = next_token;\n                advance('get');\n                one_space_only();\n                name = next_token;\n                i = property_name();\n                if (!i) {\n                    stop('missing_property');\n                }\n                get.string = '';\n                do_function(get);\n                if (funct['(loopage)']) {\n                    warn('function_loop', get);\n                }\n                p = get.first;\n                if (p) {\n                    warn('parameter_a_get_b', p[0], p[0].string, i);\n                }\n                comma();\n                set = next_token;\n                spaces();\n                edge();\n                advance('set');\n                set.string = '';\n                one_space_only();\n                j = property_name();\n                if (i !== j) {\n                    stop('expected_a_b', token, i, j || next_token.string);\n                }\n                do_function(set);\n                if (set.block.length === 0) {\n                    warn('missing_a', token, 'throw');\n                }\n                p = set.first;\n                if (!p || p.length !== 1) {\n                    stop('parameter_set_a', set, 'value');\n                } else if (p[0].string !== 'value') {\n                    stop('expected_a_b', p[0], 'value', p[0].string);\n                }\n                name.first = [get, set];\n            } else {\n                name = next_token;\n                i = property_name();\n                if (typeof i !== 'string') {\n                    stop('missing_property');\n                }\n                advance(':');\n                spaces();\n                name.first = expression(10);\n            }\n            this.first.push(name);\n            if (seen[i] === true) {\n                warn('duplicate_a', next_token, i);\n            }\n            seen[i] = true;\n            tally_property(i);\n            if (next_token.id !== ',') {\n                break;\n            }\n            for (;;) {\n                comma();\n                if (next_token.id !== ',') {\n                    break;\n                }\n                warn('unexpected_a', next_token);\n            }\n            if (next_token.id === '}' && !option.es5) {\n                warn('unexpected_a', token);\n            }\n        }\n        step_out('}', this);\n        return this;\n    });\n\n    stmt('{', function () {\n        warn('statement_block');\n        this.arity = 'statement';\n        this.block = statements();\n        this.disrupt = this.block.disrupt;\n        advance('}', this);\n        return this;\n    });\n\n    stmt('/*global', directive);\n    stmt('/*globals', directive);\n    stmt('/*jslint', directive);\n    stmt('/*member', directive);\n    stmt('/*members', directive);\n    stmt('/*property', directive);\n    stmt('/*properties', directive);\n\n    stmt('var', function () {\n\n// JavaScript does not have block scope. It only has function scope. So,\n// declaring a variable in a block can have unexpected consequences.\n\n// var.first will contain an array, the array containing name tokens\n// and assignment tokens.\n\n        var assign, id, name;\n\n        if (funct['(vars)'] && !option.vars) {\n            warn('combine_var');\n        } else if (funct !== global_funct) {\n            funct['(vars)'] = true;\n        }\n        this.arity = 'statement';\n        this.first = [];\n        step_in('var');\n        for (;;) {\n            name = next_token;\n            id = identifier();\n            add_label(name, 'becoming');\n\n            if (next_token.id === '=') {\n                assign = next_token;\n                assign.first = name;\n                spaces();\n                advance('=');\n                spaces();\n                if (next_token.id === 'undefined') {\n                    warn('unnecessary_initialize', token, id);\n                }\n                if (peek(0).id === '=' && next_token.identifier) {\n                    stop('var_a_not');\n                }\n                assign.second = expression(0);\n                assign.arity = 'infix';\n                this.first.push(assign);\n            } else {\n                this.first.push(name);\n            }\n            if (funct[id] === 'becoming') {\n                funct[id] = 'unused';\n            }\n            if (next_token.id !== ',') {\n                break;\n            }\n            comma();\n            indent.wrap = false;\n            if (var_mode && next_token.line === token.line &&\n                    this.first.length === 1) {\n                var_mode = null;\n                indent.open = false;\n                indent.at -= option.indent;\n            }\n            spaces();\n            edge();\n        }\n        var_mode = null;\n        step_out();\n        return this;\n    });\n\n    stmt('function', function () {\n        one_space();\n        if (in_block) {\n            warn('function_block', token);\n        }\n        var name = next_token, id = identifier();\n        add_label(name, 'unction');\n        no_space();\n        this.arity = 'statement';\n        do_function(this, id);\n        if (next_token.id === '(' && next_token.line === token.line) {\n            stop('function_statement');\n        }\n        return this;\n    });\n\n    prefix('function', function () {\n        if (!option.anon) {\n            one_space();\n        }\n        var id = optional_identifier();\n        if (id) {\n            no_space();\n        } else {\n            id = '';\n        }\n        do_function(this, id);\n        if (funct['(loopage)']) {\n            warn('function_loop');\n        }\n        this.arity = 'function';\n        return this;\n    });\n\n    stmt('if', function () {\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block(true);\n        if (next_token.id === 'else') {\n            one_space();\n            advance('else');\n            one_space();\n            this['else'] = next_token.id === 'if' || next_token.id === 'switch'\n                ? statement(true)\n                : block(true);\n            if (this['else'].disrupt && this.block.disrupt) {\n                this.disrupt = true;\n            }\n        }\n        return this;\n    });\n\n    stmt('try', function () {\n\n// try.first    The catch variable\n// try.second   The catch clause\n// try.third    The finally clause\n// try.block    The try block\n\n        var exception_variable, old_scope, paren;\n        if (option.adsafe) {\n            warn('adsafe_a', this);\n        }\n        one_space();\n        this.arity = 'statement';\n        this.block = block(false);\n        if (next_token.id === 'catch') {\n            one_space();\n            advance('catch');\n            one_space();\n            paren = next_token;\n            advance('(');\n            step_in('control');\n            no_space();\n            edge();\n            old_scope = scope;\n            scope = Object.create(old_scope);\n            exception_variable = next_token.string;\n            this.first = exception_variable;\n            if (!next_token.identifier) {\n                warn('expected_identifier_a', next_token);\n            } else {\n                add_label(next_token, 'exception');\n            }\n            advance();\n            no_space();\n            step_out(')', paren);\n            one_space();\n            this.second = block(false);\n            scope = old_scope;\n        }\n        if (next_token.id === 'finally') {\n            one_space();\n            advance('finally');\n            one_space();\n            this.third = block(false);\n        } else if (!this.second) {\n            stop('expected_a_b', next_token, 'catch', artifact());\n        }\n        return this;\n    });\n\n    labeled_stmt('while', function () {\n        one_space();\n        var paren = next_token;\n        funct['(breakage)'] += 1;\n        funct['(loopage)'] += 1;\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_relation(expression(0));\n        if (this.first.id !== 'true') {\n            expected_condition(this.first, bundle.unexpected_a);\n        }\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block(true);\n        if (this.block.disrupt) {\n            warn('strange_loop', prev_token);\n        }\n        funct['(breakage)'] -= 1;\n        funct['(loopage)'] -= 1;\n        return this;\n    });\n\n    reserve('with');\n\n    labeled_stmt('switch', function () {\n\n// switch.first         the switch expression\n// switch.second        the array of cases. A case is 'case' or 'default' token:\n//    case.first        the array of case expressions\n//    case.second       the array of statements\n// If all of the arrays of statements are disrupt, then the switch is disrupt.\n\n        var cases = [],\n            old_in_block = in_block,\n            particular,\n            the_case = next_token,\n            unbroken = true;\n\n        function find_duplicate_case(value) {\n            if (are_similar(particular, value)) {\n                warn('duplicate_a', value);\n            }\n        }\n\n        funct['(breakage)'] += 1;\n        one_space();\n        advance('(');\n        no_space();\n        step_in();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', the_case);\n        one_space();\n        advance('{');\n        step_in();\n        in_block = true;\n        this.second = [];\n        while (next_token.id === 'case') {\n            the_case = next_token;\n            cases.forEach(find_duplicate_case);\n            the_case.first = [];\n            the_case.arity = 'case';\n            spaces();\n            edge('case');\n            advance('case');\n            for (;;) {\n                one_space();\n                particular = expression(0);\n                cases.forEach(find_duplicate_case);\n                cases.push(particular);\n                the_case.first.push(particular);\n                if (particular.id === 'NaN') {\n                    warn('unexpected_a', particular);\n                }\n                no_space_only();\n                advance(':');\n                if (next_token.id !== 'case') {\n                    break;\n                }\n                spaces();\n                edge('case');\n                advance('case');\n            }\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                particular = the_case.second[the_case.second.length - 1];\n                if (particular.disrupt) {\n                    if (particular.id === 'break') {\n                        unbroken = false;\n                    }\n                } else {\n                    warn('missing_a_after_b', next_token, 'break', 'case');\n                }\n            } else {\n                warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.second.length === 0) {\n            warn('missing_a', next_token, 'case');\n        }\n        if (next_token.id === 'default') {\n            spaces();\n            the_case = next_token;\n            the_case.arity = 'case';\n            edge('case');\n            advance('default');\n            no_space_only();\n            advance(':');\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                particular = the_case.second[the_case.second.length - 1];\n                if (unbroken && particular.disrupt && particular.id !== 'break') {\n                    this.disrupt = true;\n                }\n            }\n            this.second.push(the_case);\n        }\n        funct['(breakage)'] -= 1;\n        spaces();\n        step_out('}', this);\n        in_block = old_in_block;\n        return this;\n    });\n\n    stmt('debugger', function () {\n        if (!option.debug) {\n            warn('unexpected_a', this);\n        }\n        this.arity = 'statement';\n        return this;\n    });\n\n    labeled_stmt('do', function () {\n        funct['(breakage)'] += 1;\n        funct['(loopage)'] += 1;\n        one_space();\n        this.arity = 'statement';\n        this.block = block(true);\n        if (this.block.disrupt) {\n            warn('strange_loop', prev_token);\n        }\n        one_space();\n        advance('while');\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in();\n        no_space();\n        edge();\n        this.first = expected_condition(expected_relation(expression(0)), bundle.unexpected_a);\n        no_space();\n        step_out(')', paren);\n        funct['(breakage)'] -= 1;\n        funct['(loopage)'] -= 1;\n        return this;\n    });\n\n    labeled_stmt('for', function () {\n\n        var blok, filter, ok = false, paren = next_token, value;\n        this.arity = 'statement';\n        funct['(breakage)'] += 1;\n        funct['(loopage)'] += 1;\n        advance('(');\n        if (next_token.id === ';') {\n            no_space();\n            advance(';');\n            no_space();\n            advance(';');\n            no_space();\n            advance(')');\n            blok = block(true);\n        } else {\n            step_in('control');\n            spaces(this, paren);\n            no_space();\n            if (next_token.id === 'var') {\n                stop('move_var');\n            }\n            edge();\n            if (peek(0).id === 'in') {\n                this.forin = true;\n                value = next_token;\n                switch (funct[value.string]) {\n                case 'unused':\n                    funct[value.string] = 'var';\n                    break;\n                case 'closure':\n                case 'var':\n                    break;\n                default:\n                    warn('bad_in_a', value);\n                }\n                advance();\n                advance('in');\n                this.first = value;\n                this.second = expression(20);\n                step_out(')', paren);\n                blok = block(true);\n                if (!option.forin) {\n                    if (blok.length === 1 && typeof blok[0] === 'object' &&\n                            blok[0].string === 'if' && !blok[0]['else']) {\n                        filter = blok[0].first;\n                        while (filter.id === '&&') {\n                            filter = filter.first;\n                        }\n                        switch (filter.id) {\n                        case '===':\n                        case '!==':\n                            ok = filter.first.id === '['\n                                ? filter.first.first.string === this.second.string &&\n                                    filter.first.second.string === this.first.string\n                                : filter.first.id === 'typeof' &&\n                                    filter.first.first.id === '[' &&\n                                    filter.first.first.first.string === this.second.string &&\n                                    filter.first.first.second.string === this.first.string;\n                            break;\n                        case '(':\n                            ok = filter.first.id === '.' && ((\n                                filter.first.first.string === this.second.string &&\n                                filter.first.second.string === 'hasOwnProperty' &&\n                                filter.second[0].string === this.first.string\n                            ) || (\n                                filter.first.first.string === 'ADSAFE' &&\n                                filter.first.second.string === 'has' &&\n                                filter.second[0].string === this.second.string &&\n                                filter.second[1].string === this.first.string\n                            ) || (\n                                filter.first.first.id === '.' &&\n                                filter.first.first.first.id === '.' &&\n                                filter.first.first.first.first.string === 'Object' &&\n                                filter.first.first.first.second.string === 'prototype' &&\n                                filter.first.first.second.string === 'hasOwnProperty' &&\n                                filter.first.second.string === 'call' &&\n                                filter.second[0].string === this.second.string &&\n                                filter.second[1].string === this.first.string\n                            ));\n                            break;\n                        }\n                    }\n                    if (!ok) {\n                        warn('for_if', this);\n                    }\n                }\n            } else {\n                edge();\n                this.first = [];\n                for (;;) {\n                    this.first.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                semicolon();\n                edge();\n                this.second = expected_relation(expression(0));\n                if (this.second.id !== 'true') {\n                    expected_condition(this.second, bundle.unexpected_a);\n                }\n                semicolon(token);\n                if (next_token.id === ';') {\n                    stop('expected_a_b', next_token, ')', ';');\n                }\n                this.third = [];\n                edge();\n                for (;;) {\n                    this.third.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                no_space();\n                step_out(')', paren);\n                one_space();\n                blok = block(true);\n            }\n        }\n        if (blok.disrupt) {\n            warn('strange_loop', prev_token);\n        }\n        this.block = blok;\n        funct['(breakage)'] -= 1;\n        funct['(loopage)'] -= 1;\n        return this;\n    });\n\n    disrupt_stmt('break', function () {\n        var label = next_token.string;\n        this.arity = 'statement';\n        if (funct['(breakage)'] === 0) {\n            warn('unexpected_a', this);\n        }\n        if (next_token.identifier && token.line === next_token.line) {\n            one_space_only();\n            if (funct[label] !== 'label') {\n                warn('not_a_label', next_token);\n            } else if (scope[label].funct !== funct) {\n                warn('not_a_scope', next_token);\n            }\n            this.first = next_token;\n            advance();\n        }\n        return this;\n    });\n\n    disrupt_stmt('continue', function () {\n        if (!option['continue']) {\n            warn('unexpected_a', this);\n        }\n        var label = next_token.string;\n        this.arity = 'statement';\n        if (funct['(breakage)'] === 0) {\n            warn('unexpected_a', this);\n        }\n        if (next_token.identifier && token.line === next_token.line) {\n            one_space_only();\n            if (funct[label] !== 'label') {\n                warn('not_a_label', next_token);\n            } else if (scope[label].funct !== funct) {\n                warn('not_a_scope', next_token);\n            }\n            this.first = next_token;\n            advance();\n        }\n        return this;\n    });\n\n    disrupt_stmt('return', function () {\n        if (funct === global_funct && xmode !== 'scriptstring') {\n            warn('unexpected_a', this);\n        }\n        this.arity = 'statement';\n        if (next_token.id !== ';' && next_token.line === token.line) {\n            one_space_only();\n            if (next_token.id === '/' || next_token.id === '(regexp)') {\n                warn('wrap_regexp');\n            }\n            this.first = expression(20);\n        }\n        return this;\n    });\n\n    disrupt_stmt('throw', function () {\n        this.arity = 'statement';\n        one_space_only();\n        this.first = expression(20);\n        return this;\n    });\n\n\n//  Superfluous reserved words\n\n    reserve('class');\n    reserve('const');\n    reserve('enum');\n    reserve('export');\n    reserve('extends');\n    reserve('import');\n    reserve('super');\n\n// Harmony reserved words\n\n    reserve('implements');\n    reserve('interface');\n    reserve('let');\n    reserve('package');\n    reserve('private');\n    reserve('protected');\n    reserve('public');\n    reserve('static');\n    reserve('yield');\n\n\n// Parse JSON\n\n    function json_value() {\n\n        function json_object() {\n            var brace = next_token, object = {};\n            advance('{');\n            if (next_token.id !== '}') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        warn('unexpected_a', next_token);\n                        advance(',');\n                    }\n                    if (next_token.id !== '(string)') {\n                        warn('expected_string_a');\n                    }\n                    if (object[next_token.string] === true) {\n                        warn('duplicate_a');\n                    } else if (next_token.string === '__proto__') {\n                        warn('dangling_a');\n                    } else {\n                        object[next_token.string] = true;\n                    }\n                    advance();\n                    advance(':');\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === '}') {\n                        warn('unexpected_a', token);\n                        break;\n                    }\n                }\n            }\n            advance('}', brace);\n        }\n\n        function json_array() {\n            var bracket = next_token;\n            advance('[');\n            if (next_token.id !== ']') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        warn('unexpected_a', next_token);\n                        advance(',');\n                    }\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === ']') {\n                        warn('unexpected_a', token);\n                        break;\n                    }\n                }\n            }\n            advance(']', bracket);\n        }\n\n        switch (next_token.id) {\n        case '{':\n            json_object();\n            break;\n        case '[':\n            json_array();\n            break;\n        case 'true':\n        case 'false':\n        case 'null':\n        case '(number)':\n        case '(string)':\n            advance();\n            break;\n        case '-':\n            advance('-');\n            no_space_only();\n            advance('(number)');\n            break;\n        default:\n            stop('unexpected_a');\n        }\n    }\n\n\n// CSS parsing.\n\n    function css_name() {\n        if (next_token.identifier) {\n            advance();\n            return true;\n        }\n    }\n\n\n    function css_number() {\n        if (next_token.id === '-') {\n            advance('-');\n            no_space_only();\n        }\n        if (next_token.id === '(number)') {\n            advance('(number)');\n            return true;\n        }\n    }\n\n\n    function css_string() {\n        if (next_token.id === '(string)') {\n            advance();\n            return true;\n        }\n    }\n\n    function css_color() {\n        var i, number, paren, value;\n        if (next_token.identifier) {\n            value = next_token.string;\n            if (value === 'rgb' || value === 'rgba') {\n                advance();\n                paren = next_token;\n                advance('(');\n                for (i = 0; i < 3; i += 1) {\n                    if (i) {\n                        comma();\n                    }\n                    number = next_token.number;\n                    if (next_token.id !== '(number)' || number < 0) {\n                        warn('expected_positive_a', next_token);\n                        advance();\n                    } else {\n                        advance();\n                        if (next_token.id === '%') {\n                            advance('%');\n                            if (number > 100) {\n                                warn('expected_percent_a', token, number);\n                            }\n                        } else {\n                            if (number > 255) {\n                                warn('expected_small_a', token, number);\n                            }\n                        }\n                    }\n                }\n                if (value === 'rgba') {\n                    comma();\n                    number = next_token.number;\n                    if (next_token.id !== '(number)' || number < 0 || number > 1) {\n                        warn('expected_fraction_a', next_token);\n                    }\n                    advance();\n                    if (next_token.id === '%') {\n                        warn('unexpected_a');\n                        advance('%');\n                    }\n                }\n                advance(')', paren);\n                return true;\n            } else if (css_colorData[next_token.string] === true) {\n                advance();\n                return true;\n            }\n        } else if (next_token.id === '(color)') {\n            advance();\n            return true;\n        }\n        return false;\n    }\n\n\n    function css_length() {\n        if (next_token.id === '-') {\n            advance('-');\n            no_space_only();\n        }\n        if (next_token.id === '(number)') {\n            advance();\n            if (next_token.id !== '(string)' &&\n                    css_lengthData[next_token.string] === true) {\n                no_space_only();\n                advance();\n            } else if (+token.number !== 0) {\n                warn('expected_linear_a');\n            }\n            return true;\n        }\n        return false;\n    }\n\n\n    function css_line_height() {\n        if (next_token.id === '-') {\n            advance('-');\n            no_space_only();\n        }\n        if (next_token.id === '(number)') {\n            advance();\n            if (next_token.id !== '(string)' &&\n                    css_lengthData[next_token.string] === true) {\n                no_space_only();\n                advance();\n            }\n            return true;\n        }\n        return false;\n    }\n\n\n    function css_width() {\n        if (next_token.identifier) {\n            switch (next_token.string) {\n            case 'thin':\n            case 'medium':\n            case 'thick':\n                advance();\n                return true;\n            }\n        } else {\n            return css_length();\n        }\n    }\n\n\n    function css_margin() {\n        if (next_token.identifier) {\n            if (next_token.string === 'auto') {\n                advance();\n                return true;\n            }\n        } else {\n            return css_length();\n        }\n    }\n\n    function css_attr() {\n        if (next_token.identifier && next_token.string === 'attr') {\n            advance();\n            advance('(');\n            if (!next_token.identifier) {\n                warn('expected_name_a');\n            }\n            advance();\n            advance(')');\n            return true;\n        }\n        return false;\n    }\n\n\n    function css_comma_list() {\n        while (next_token.id !== ';') {\n            if (!css_name() && !css_string()) {\n                warn('expected_name_a');\n            }\n            if (next_token.id !== ',') {\n                return true;\n            }\n            comma();\n        }\n    }\n\n\n    function css_counter() {\n        if (next_token.identifier && next_token.string === 'counter') {\n            advance();\n            advance('(');\n            advance();\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id !== '(string)') {\n                    warn('expected_string_a');\n                }\n                advance();\n            }\n            advance(')');\n            return true;\n        }\n        if (next_token.identifier && next_token.string === 'counters') {\n            advance();\n            advance('(');\n            if (!next_token.identifier) {\n                warn('expected_name_a');\n            }\n            advance();\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id !== '(string)') {\n                    warn('expected_string_a');\n                }\n                advance();\n            }\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id !== '(string)') {\n                    warn('expected_string_a');\n                }\n                advance();\n            }\n            advance(')');\n            return true;\n        }\n        return false;\n    }\n\n\n    function css_radius() {\n        return css_length() && (next_token.id !== '(number)' || css_length());\n    }\n\n\n    function css_shape() {\n        var i;\n        if (next_token.identifier && next_token.string === 'rect') {\n            advance();\n            advance('(');\n            for (i = 0; i < 4; i += 1) {\n                if (!css_length()) {\n                    warn('expected_number_a');\n                    break;\n                }\n            }\n            advance(')');\n            return true;\n        }\n        return false;\n    }\n\n\n    function css_url() {\n        var c, url;\n        if (next_token.identifier && next_token.string === 'url') {\n            next_token = lex.range('(', ')');\n            url = next_token.string;\n            c = url.charAt(0);\n            if (c === '\"' || c === '\\'') {\n                if (url.slice(-1) !== c) {\n                    warn('bad_url_a');\n                } else {\n                    url = url.slice(1, -1);\n                    if (url.indexOf(c) >= 0) {\n                        warn('bad_url_a');\n                    }\n                }\n            }\n            if (!url) {\n                warn('missing_url');\n            }\n            if (ux.test(url)) {\n                stop('bad_url_a');\n            }\n            urls.push(url);\n            advance();\n            return true;\n        }\n        return false;\n    }\n\n\n    css_any = [css_url, function () {\n        for (;;) {\n            if (next_token.identifier) {\n                switch (next_token.string.toLowerCase()) {\n                case 'url':\n                    css_url();\n                    break;\n                case 'expression':\n                    warn('unexpected_a');\n                    advance();\n                    break;\n                default:\n                    advance();\n                }\n            } else {\n                if (next_token.id === ';' || next_token.id === '!'  ||\n                        next_token.id === '(end)' || next_token.id === '}') {\n                    return true;\n                }\n                advance();\n            }\n        }\n    }];\n\n\n    function font_face() {\n        advance_identifier('font-family');\n        advance(':');\n        if (!css_name() && !css_string()) {\n            stop('expected_name_a');\n        }\n        semicolon();\n        advance_identifier('src');\n        advance(':');\n        while (true) {\n            if (next_token.string === 'local') {\n                advance_identifier('local');\n                advance('(');\n                if (ux.test(next_token.string)) {\n                    stop('bad_url_a');\n                }\n\n                if (!css_name() && !css_string()) {\n                    stop('expected_name_a');\n                }\n                advance(')');\n            } else if (!css_url()) {\n                stop('expected_a_b', next_token, 'url', artifact());\n            }\n            if (next_token.id !== ',') {\n                break;\n            }\n            comma();\n        }\n        semicolon();\n    }\n\n\n    css_border_style = [\n        'none', 'dashed', 'dotted', 'double', 'groove',\n        'hidden', 'inset', 'outset', 'ridge', 'solid'\n    ];\n\n    css_break = [\n        'auto', 'always', 'avoid', 'left', 'right'\n    ];\n\n    css_media = {\n        'all': true,\n        'braille': true,\n        'embossed': true,\n        'handheld': true,\n        'print': true,\n        'projection': true,\n        'screen': true,\n        'speech': true,\n        'tty': true,\n        'tv': true\n    };\n\n    css_overflow = [\n        'auto', 'hidden', 'scroll', 'visible'\n    ];\n\n    css_attribute_data = {\n        background: [\n            true, 'background-attachment', 'background-color',\n            'background-image', 'background-position', 'background-repeat'\n        ],\n        'background-attachment': ['scroll', 'fixed'],\n        'background-color': ['transparent', css_color],\n        'background-image': ['none', css_url],\n        'background-position': [\n            2, [css_length, 'top', 'bottom', 'left', 'right', 'center']\n        ],\n        'background-repeat': [\n            'repeat', 'repeat-x', 'repeat-y', 'no-repeat'\n        ],\n        'border': [true, 'border-color', 'border-style', 'border-width'],\n        'border-bottom': [\n            true, 'border-bottom-color', 'border-bottom-style',\n            'border-bottom-width'\n        ],\n        'border-bottom-color': css_color,\n        'border-bottom-left-radius': css_radius,\n        'border-bottom-right-radius': css_radius,\n        'border-bottom-style': css_border_style,\n        'border-bottom-width': css_width,\n        'border-collapse': ['collapse', 'separate'],\n        'border-color': ['transparent', 4, css_color],\n        'border-left': [\n            true, 'border-left-color', 'border-left-style', 'border-left-width'\n        ],\n        'border-left-color': css_color,\n        'border-left-style': css_border_style,\n        'border-left-width': css_width,\n        'border-radius': function () {\n            function count(separator) {\n                var n = 1;\n                if (separator) {\n                    advance(separator);\n                }\n                if (!css_length()) {\n                    return false;\n                }\n                while (next_token.id === '(number)') {\n                    if (!css_length()) {\n                        return false;\n                    }\n                    n += 1;\n                }\n                if (n > 4) {\n                    warn('bad_style');\n                }\n                return true;\n            }\n\n            return count() && (next_token.id !== '/' || count('/'));\n        },\n        'border-right': [\n            true, 'border-right-color', 'border-right-style',\n            'border-right-width'\n        ],\n        'border-right-color': css_color,\n        'border-right-style': css_border_style,\n        'border-right-width': css_width,\n        'border-spacing': [2, css_length],\n        'border-style': [4, css_border_style],\n        'border-top': [\n            true, 'border-top-color', 'border-top-style', 'border-top-width'\n        ],\n        'border-top-color': css_color,\n        'border-top-left-radius': css_radius,\n        'border-top-right-radius': css_radius,\n        'border-top-style': css_border_style,\n        'border-top-width': css_width,\n        'border-width': [4, css_width],\n        bottom: [css_length, 'auto'],\n        'caption-side' : ['bottom', 'left', 'right', 'top'],\n        clear: ['both', 'left', 'none', 'right'],\n        clip: [css_shape, 'auto'],\n        color: css_color,\n        content: [\n            'open-quote', 'close-quote', 'no-open-quote', 'no-close-quote',\n            css_string, css_url, css_counter, css_attr\n        ],\n        'counter-increment': [\n            css_name, 'none'\n        ],\n        'counter-reset': [\n            css_name, 'none'\n        ],\n        cursor: [\n            css_url, 'auto', 'crosshair', 'default', 'e-resize', 'help', 'move',\n            'n-resize', 'ne-resize', 'nw-resize', 'pointer', 's-resize',\n            'se-resize', 'sw-resize', 'w-resize', 'text', 'wait'\n        ],\n        direction: ['ltr', 'rtl'],\n        display: [\n            'block', 'compact', 'inline', 'inline-block', 'inline-table',\n            'list-item', 'marker', 'none', 'run-in', 'table', 'table-caption',\n            'table-cell', 'table-column', 'table-column-group',\n            'table-footer-group', 'table-header-group', 'table-row',\n            'table-row-group'\n        ],\n        'empty-cells': ['show', 'hide'],\n        'float': ['left', 'none', 'right'],\n        font: [\n            'caption', 'icon', 'menu', 'message-box', 'small-caption',\n            'status-bar', true, 'font-size', 'font-style', 'font-weight',\n            'font-family'\n        ],\n        'font-family': css_comma_list,\n        'font-size': [\n            'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large',\n            'xx-large', 'larger', 'smaller', css_length\n        ],\n        'font-size-adjust': ['none', css_number],\n        'font-stretch': [\n            'normal', 'wider', 'narrower', 'ultra-condensed',\n            'extra-condensed', 'condensed', 'semi-condensed',\n            'semi-expanded', 'expanded', 'extra-expanded'\n        ],\n        'font-style': [\n            'normal', 'italic', 'oblique'\n        ],\n        'font-variant': [\n            'normal', 'small-caps'\n        ],\n        'font-weight': [\n            'normal', 'bold', 'bolder', 'lighter', css_number\n        ],\n        height: [css_length, 'auto'],\n        left: [css_length, 'auto'],\n        'letter-spacing': ['normal', css_length],\n        'line-height': ['normal', css_line_height],\n        'list-style': [\n            true, 'list-style-image', 'list-style-position', 'list-style-type'\n        ],\n        'list-style-image': ['none', css_url],\n        'list-style-position': ['inside', 'outside'],\n        'list-style-type': [\n            'circle', 'disc', 'square', 'decimal', 'decimal-leading-zero',\n            'lower-roman', 'upper-roman', 'lower-greek', 'lower-alpha',\n            'lower-latin', 'upper-alpha', 'upper-latin', 'hebrew', 'katakana',\n            'hiragana-iroha', 'katakana-oroha', 'none'\n        ],\n        margin: [4, css_margin],\n        'margin-bottom': css_margin,\n        'margin-left': css_margin,\n        'margin-right': css_margin,\n        'margin-top': css_margin,\n        'marker-offset': [css_length, 'auto'],\n        'max-height': [css_length, 'none'],\n        'max-width': [css_length, 'none'],\n        'min-height': css_length,\n        'min-width': css_length,\n        opacity: css_number,\n        outline: [true, 'outline-color', 'outline-style', 'outline-width'],\n        'outline-color': ['invert', css_color],\n        'outline-style': [\n            'dashed', 'dotted', 'double', 'groove', 'inset', 'none',\n            'outset', 'ridge', 'solid'\n        ],\n        'outline-width': css_width,\n        overflow: css_overflow,\n        'overflow-x': css_overflow,\n        'overflow-y': css_overflow,\n        padding: [4, css_length],\n        'padding-bottom': css_length,\n        'padding-left': css_length,\n        'padding-right': css_length,\n        'padding-top': css_length,\n        'page-break-after': css_break,\n        'page-break-before': css_break,\n        position: ['absolute', 'fixed', 'relative', 'static'],\n        quotes: [8, css_string],\n        right: [css_length, 'auto'],\n        'table-layout': ['auto', 'fixed'],\n        'text-align': ['center', 'justify', 'left', 'right'],\n        'text-decoration': [\n            'none', 'underline', 'overline', 'line-through', 'blink'\n        ],\n        'text-indent': css_length,\n        'text-shadow': ['none', 4, [css_color, css_length]],\n        'text-transform': ['capitalize', 'uppercase', 'lowercase', 'none'],\n        top: [css_length, 'auto'],\n        'unicode-bidi': ['normal', 'embed', 'bidi-override'],\n        'vertical-align': [\n            'baseline', 'bottom', 'sub', 'super', 'top', 'text-top', 'middle',\n            'text-bottom', css_length\n        ],\n        visibility: ['visible', 'hidden', 'collapse'],\n        'white-space': [\n            'normal', 'nowrap', 'pre', 'pre-line', 'pre-wrap', 'inherit'\n        ],\n        width: [css_length, 'auto'],\n        'word-spacing': ['normal', css_length],\n        'word-wrap': ['break-word', 'normal'],\n        'z-index': ['auto', css_number]\n    };\n\n    function style_attribute() {\n        var v;\n        while (next_token.id === '*' || next_token.id === '#' ||\n                next_token.string === '_') {\n            if (!option.css) {\n                warn('unexpected_a');\n            }\n            advance();\n        }\n        if (next_token.id === '-') {\n            if (!option.css) {\n                warn('unexpected_a');\n            }\n            advance('-');\n            if (!next_token.identifier) {\n                warn('expected_nonstandard_style_attribute');\n            }\n            advance();\n            return css_any;\n        } else {\n            if (!next_token.identifier) {\n                warn('expected_style_attribute');\n            } else {\n                if (Object.prototype.hasOwnProperty.call(css_attribute_data,\n                        next_token.string)) {\n                    v = css_attribute_data[next_token.string];\n                } else {\n                    v = css_any;\n                    if (!option.css) {\n                        warn('unrecognized_style_attribute_a');\n                    }\n                }\n            }\n            advance();\n            return v;\n        }\n    }\n\n\n    function style_value(v) {\n        var i = 0,\n            n,\n            once,\n            match,\n            round,\n            start = 0,\n            vi;\n        switch (typeof v) {\n        case 'function':\n            return v();\n        case 'string':\n            if (next_token.identifier && next_token.string === v) {\n                advance();\n                return true;\n            }\n            return false;\n        }\n        for (;;) {\n            if (i >= v.length) {\n                return false;\n            }\n            vi = v[i];\n            i += 1;\n            if (typeof vi === 'boolean') {\n                break;\n            } else if (typeof vi === 'number') {\n                n = vi;\n                vi = v[i];\n                i += 1;\n            } else {\n                n = 1;\n            }\n            match = false;\n            while (n > 0) {\n                if (style_value(vi)) {\n                    match = true;\n                    n -= 1;\n                } else {\n                    break;\n                }\n            }\n            if (match) {\n                return true;\n            }\n        }\n        start = i;\n        once = [];\n        for (;;) {\n            round = false;\n            for (i = start; i < v.length; i += 1) {\n                if (!once[i]) {\n                    if (style_value(css_attribute_data[v[i]])) {\n                        match = true;\n                        round = true;\n                        once[i] = true;\n                        break;\n                    }\n                }\n            }\n            if (!round) {\n                return match;\n            }\n        }\n    }\n\n    function style_child() {\n        if (next_token.id === '(number)') {\n            advance();\n            if (next_token.string === 'n' && next_token.identifier) {\n                no_space_only();\n                advance();\n                if (next_token.id === '+') {\n                    no_space_only();\n                    advance('+');\n                    no_space_only();\n                    advance('(number)');\n                }\n            }\n            return;\n        } else {\n            if (next_token.identifier &&\n                    (next_token.string === 'odd' || next_token.string === 'even')) {\n                advance();\n                return;\n            }\n        }\n        warn('unexpected_a');\n    }\n\n    function substyle() {\n        var v;\n        for (;;) {\n            if (next_token.id === '}' || next_token.id === '(end)' ||\n                    (xquote && next_token.id === xquote)) {\n                return;\n            }\n            v = style_attribute();\n            advance(':');\n            if (next_token.identifier && next_token.string === 'inherit') {\n                advance();\n            } else {\n                if (!style_value(v)) {\n                    warn('unexpected_a');\n                    advance();\n                }\n            }\n            if (next_token.id === '!') {\n                advance('!');\n                no_space_only();\n                if (next_token.identifier && next_token.string === 'important') {\n                    advance();\n                } else {\n                    warn('expected_a_b',\n                        next_token, 'important', artifact());\n                }\n            }\n            if (next_token.id === '}' || next_token.id === xquote) {\n                warn('expected_a_b', next_token, ';', artifact());\n            } else {\n                semicolon();\n            }\n        }\n    }\n\n    function style_selector() {\n        if (next_token.identifier) {\n            if (!Object.prototype.hasOwnProperty.call(html_tag, option.cap\n                    ? next_token.string.toLowerCase()\n                    : next_token.string)) {\n                warn('expected_tagname_a');\n            }\n            advance();\n        } else {\n            switch (next_token.id) {\n            case '>':\n            case '+':\n                advance();\n                style_selector();\n                break;\n            case ':':\n                advance(':');\n                switch (next_token.string) {\n                case 'active':\n                case 'after':\n                case 'before':\n                case 'checked':\n                case 'disabled':\n                case 'empty':\n                case 'enabled':\n                case 'first-child':\n                case 'first-letter':\n                case 'first-line':\n                case 'first-of-type':\n                case 'focus':\n                case 'hover':\n                case 'last-child':\n                case 'last-of-type':\n                case 'link':\n                case 'only-of-type':\n                case 'root':\n                case 'target':\n                case 'visited':\n                    advance_identifier(next_token.string);\n                    break;\n                case 'lang':\n                    advance_identifier('lang');\n                    advance('(');\n                    if (!next_token.identifier) {\n                        warn('expected_lang_a');\n                    }\n                    advance(')');\n                    break;\n                case 'nth-child':\n                case 'nth-last-child':\n                case 'nth-last-of-type':\n                case 'nth-of-type':\n                    advance_identifier(next_token.string);\n                    advance('(');\n                    style_child();\n                    advance(')');\n                    break;\n                case 'not':\n                    advance_identifier('not');\n                    advance('(');\n                    if (next_token.id === ':' && peek(0).string === 'not') {\n                        warn('not');\n                    }\n                    style_selector();\n                    advance(')');\n                    break;\n                default:\n                    warn('expected_pseudo_a');\n                }\n                break;\n            case '#':\n                advance('#');\n                if (!next_token.identifier) {\n                    warn('expected_id_a');\n                }\n                advance();\n                break;\n            case '*':\n                advance('*');\n                break;\n            case '.':\n                advance('.');\n                if (!next_token.identifier) {\n                    warn('expected_class_a');\n                }\n                advance();\n                break;\n            case '[':\n                advance('[');\n                if (!next_token.identifier) {\n                    warn('expected_attribute_a');\n                }\n                advance();\n                if (next_token.id === '=' || next_token.string === '~=' ||\n                        next_token.string === '$=' ||\n                        next_token.string === '|=' ||\n                        next_token.id === '*=' ||\n                        next_token.id === '^=') {\n                    advance();\n                    if (next_token.id !== '(string)') {\n                        warn('expected_string_a');\n                    }\n                    advance();\n                }\n                advance(']');\n                break;\n            default:\n                stop('expected_selector_a');\n            }\n        }\n    }\n\n    function style_pattern() {\n        if (next_token.id === '{') {\n            warn('expected_style_pattern');\n        }\n        for (;;) {\n            style_selector();\n            if (next_token.id === '</' || next_token.id === '{' ||\n                    next_token.id === '}' || next_token.id === '(end)') {\n                return '';\n            }\n            if (next_token.id === ',') {\n                comma();\n            }\n        }\n    }\n\n    function style_list() {\n        while (next_token.id !== '}' && next_token.id !== '</' &&\n                next_token.id !== '(end)') {\n            style_pattern();\n            xmode = 'styleproperty';\n            if (next_token.id === ';') {\n                semicolon();\n            } else {\n                advance('{');\n                substyle();\n                xmode = 'style';\n                advance('}');\n            }\n        }\n    }\n\n    function styles() {\n        var i;\n        while (next_token.id === '@') {\n            i = peek();\n            advance('@');\n            switch (next_token.string) {\n            case 'import':\n                advance_identifier('import');\n                if (!css_url()) {\n                    warn('expected_a_b',\n                        next_token, 'url', artifact());\n                    advance();\n                }\n                semicolon();\n                break;\n            case 'media':\n                advance_identifier('media');\n                for (;;) {\n                    if (!next_token.identifier || css_media[next_token.string] !== true) {\n                        stop('expected_media_a');\n                    }\n                    advance();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                advance('{');\n                style_list();\n                advance('}');\n                break;\n            case 'font-face':\n                advance_identifier('font-face');\n                advance('{');\n                font_face();\n                advance('}');\n                break;\n            default:\n                stop('expected_at_a');\n            }\n        }\n        style_list();\n    }\n\n\n// Parse HTML\n\n    function do_begin(n) {\n        if (n !== 'html' && !option.fragment) {\n            if (n === 'div' && option.adsafe) {\n                stop('adsafe_fragment');\n            } else {\n                stop('expected_a_b', token, 'html', n);\n            }\n        }\n        if (option.adsafe) {\n            if (n === 'html') {\n                stop('adsafe_html', token);\n            }\n            if (option.fragment) {\n                if (n !== 'div') {\n                    stop('adsafe_div', token);\n                }\n            } else {\n                stop('adsafe_fragment', token);\n            }\n        }\n        option.browser = true;\n    }\n\n    function do_attribute(a, v) {\n        var u, x;\n        if (a === 'id') {\n            u = typeof v === 'string' ? v.toUpperCase() : '';\n            if (ids[u] === true) {\n                warn('duplicate_a', next_token, v);\n            }\n            if (!/^[A-Za-z][A-Za-z0-9._:\\-]*$/.test(v)) {\n                warn('bad_id_a', next_token, v);\n            } else if (option.adsafe) {\n                if (adsafe_id) {\n                    if (v.slice(0, adsafe_id.length) !== adsafe_id) {\n                        warn('adsafe_prefix_a', next_token, adsafe_id);\n                    } else if (!/^[A-Z]+_[A-Z]+$/.test(v)) {\n                        warn('adsafe_bad_id');\n                    }\n                } else {\n                    adsafe_id = v;\n                    if (!/^[A-Z]+_$/.test(v)) {\n                        warn('adsafe_bad_id');\n                    }\n                }\n            }\n            x = v.search(dx);\n            if (x >= 0) {\n                warn('unexpected_char_a_b', token, v.charAt(x), a);\n            }\n            ids[u] = true;\n        } else if (a === 'class' || a === 'type' || a === 'name') {\n            x = v.search(qx);\n            if (x >= 0) {\n                warn('unexpected_char_a_b', token, v.charAt(x), a);\n            }\n            ids[u] = true;\n        } else if (a === 'href' || a === 'background' ||\n                a === 'content' || a === 'data' ||\n                a.indexOf('src') >= 0 || a.indexOf('url') >= 0) {\n            if (option.safe && ux.test(v)) {\n                stop('bad_url_a', next_token, v);\n            }\n            urls.push(v);\n        } else if (a === 'for') {\n            if (option.adsafe) {\n                if (adsafe_id) {\n                    if (v.slice(0, adsafe_id.length) !== adsafe_id) {\n                        warn('adsafe_prefix_a', next_token, adsafe_id);\n                    } else if (!/^[A-Z]+_[A-Z]+$/.test(v)) {\n                        warn('adsafe_bad_id');\n                    }\n                } else {\n                    warn('adsafe_bad_id');\n                }\n            }\n        } else if (a === 'name') {\n            if (option.adsafe && v.indexOf('_') >= 0) {\n                warn('adsafe_name_a', next_token, v);\n            }\n        }\n    }\n\n    function do_tag(name, attribute) {\n        var i, tag = html_tag[name], script, x;\n        src = false;\n        if (!tag) {\n            stop(\n                bundle.unrecognized_tag_a,\n                next_token,\n                name === name.toLowerCase()\n                    ? name\n                    : name + ' (capitalization error)'\n            );\n        }\n        if (stack.length > 0) {\n            if (name === 'html') {\n                stop('unexpected_a', token, name);\n            }\n            x = tag.parent;\n            if (x) {\n                if (x.indexOf(' ' + stack[stack.length - 1].name + ' ') < 0) {\n                    stop('tag_a_in_b', token, name, x);\n                }\n            } else if (!option.adsafe && !option.fragment) {\n                i = stack.length;\n                do {\n                    if (i <= 0) {\n                        stop('tag_a_in_b', token, name, 'body');\n                    }\n                    i -= 1;\n                } while (stack[i].name !== 'body');\n            }\n        }\n        switch (name) {\n        case 'div':\n            if (option.adsafe && stack.length === 1 && !adsafe_id) {\n                warn('adsafe_missing_id');\n            }\n            break;\n        case 'script':\n            xmode = 'script';\n            advance('>');\n            if (attribute.lang) {\n                warn('lang', token);\n            }\n            if (option.adsafe && stack.length !== 1) {\n                warn('adsafe_placement', token);\n            }\n            if (attribute.src) {\n                if (option.adsafe && (!adsafe_may || !approved[attribute.src])) {\n                    warn('adsafe_source', token);\n                }\n            } else {\n                step_in(next_token.from);\n                edge();\n                use_strict();\n                adsafe_top = true;\n                script = statements();\n\n// JSLint is also the static analyzer for ADsafe. See www.ADsafe.org.\n\n                if (option.adsafe) {\n                    if (adsafe_went) {\n                        stop('adsafe_script', token);\n                    }\n                    if (script.length !== 1 ||\n                            aint(script[0],             'id',     '(') ||\n                            aint(script[0].first,       'id',     '.') ||\n                            aint(script[0].first.first, 'string', 'ADSAFE') ||\n                            aint(script[0].second[0],   'string', adsafe_id)) {\n                        stop('adsafe_id_go');\n                    }\n                    switch (script[0].first.second.string) {\n                    case 'id':\n                        if (adsafe_may || adsafe_went ||\n                                script[0].second.length !== 1) {\n                            stop('adsafe_id', next_token);\n                        }\n                        adsafe_may = true;\n                        break;\n                    case 'go':\n                        if (adsafe_went) {\n                            stop('adsafe_go');\n                        }\n                        if (script[0].second.length !== 2 ||\n                                aint(script[0].second[1], 'id', 'function') ||\n                                !script[0].second[1].first ||\n                                aint(script[0].second[1].first[0], 'string', 'dom') ||\n                                script[0].second[1].first.length > 2 ||\n                                (script[0].second[1].first.length === 2 &&\n                                aint(script[0].second[1].first[1], 'string', 'lib'))) {\n                            stop('adsafe_go', next_token);\n                        }\n                        adsafe_went = true;\n                        break;\n                    default:\n                        stop('adsafe_id_go');\n                    }\n                }\n                indent = null;\n            }\n            xmode = 'html';\n            advance('</');\n            advance_identifier('script');\n            xmode = 'outer';\n            break;\n        case 'style':\n            xmode = 'style';\n            advance('>');\n            styles();\n            xmode = 'html';\n            advance('</');\n            advance_identifier('style');\n            break;\n        case 'input':\n            switch (attribute.type) {\n            case 'button':\n            case 'checkbox':\n            case 'radio':\n            case 'reset':\n            case 'submit':\n                break;\n            case 'file':\n            case 'hidden':\n            case 'image':\n            case 'password':\n            case 'text':\n                if (option.adsafe && attribute.autocomplete !== 'off') {\n                    warn('adsafe_autocomplete');\n                }\n                break;\n            default:\n                warn('bad_type');\n            }\n            break;\n        case 'applet':\n        case 'body':\n        case 'embed':\n        case 'frame':\n        case 'frameset':\n        case 'head':\n        case 'iframe':\n        case 'noembed':\n        case 'noframes':\n        case 'object':\n        case 'param':\n            if (option.adsafe) {\n                warn('adsafe_tag', next_token, name);\n            }\n            break;\n        }\n    }\n\n\n    function closetag(name) {\n        return '</' + name + '>';\n    }\n\n    function html() {\n        var attribute, attributes, is_empty, name, old_white = option.white,\n            quote, tag_name, tag, wmode;\n        xmode = 'html';\n        xquote = '';\n        stack = null;\n        for (;;) {\n            switch (next_token.string) {\n            case '<':\n                xmode = 'html';\n                advance('<');\n                attributes = {};\n                tag_name = next_token;\n                name = tag_name.string;\n                advance_identifier(name);\n                if (option.cap) {\n                    name = name.toLowerCase();\n                }\n                tag_name.name = name;\n                if (!stack) {\n                    stack = [];\n                    do_begin(name);\n                }\n                tag = html_tag[name];\n                if (typeof tag !== 'object') {\n                    stop('unrecognized_tag_a', tag_name, name);\n                }\n                is_empty = tag.empty;\n                tag_name.type = name;\n                for (;;) {\n                    if (next_token.id === '/') {\n                        advance('/');\n                        if (next_token.id !== '>') {\n                            warn('expected_a_b', next_token, '>', artifact());\n                        }\n                        break;\n                    }\n                    if (next_token.id && next_token.id.charAt(0) === '>') {\n                        break;\n                    }\n                    if (!next_token.identifier) {\n                        if (next_token.id === '(end)' || next_token.id === '(error)') {\n                            warn('expected_a_b', next_token, '>', artifact());\n                        }\n                        warn('bad_name_a');\n                    }\n                    option.white = false;\n                    spaces();\n                    attribute = next_token.string;\n                    option.white = old_white;\n                    advance();\n                    if (!option.cap && attribute !== attribute.toLowerCase()) {\n                        warn('attribute_case_a', token);\n                    }\n                    attribute = attribute.toLowerCase();\n                    xquote = '';\n                    if (Object.prototype.hasOwnProperty.call(attributes, attribute)) {\n                        warn('duplicate_a', token, attribute);\n                    }\n                    if (attribute.slice(0, 2) === 'on') {\n                        if (!option.on) {\n                            warn('html_handlers');\n                        }\n                        xmode = 'scriptstring';\n                        advance('=');\n                        quote = next_token.id;\n                        if (quote !== '\"' && quote !== '\\'') {\n                            stop('expected_a_b', next_token, '\"', artifact());\n                        }\n                        xquote = quote;\n                        wmode = option.white;\n                        option.white = true;\n                        advance(quote);\n                        use_strict();\n                        statements();\n                        option.white = wmode;\n                        if (next_token.id !== quote) {\n                            stop('expected_a_b', next_token, quote, artifact());\n                        }\n                        xmode = 'html';\n                        xquote = '';\n                        advance(quote);\n                        tag = false;\n                    } else if (attribute === 'style') {\n                        xmode = 'scriptstring';\n                        advance('=');\n                        quote = next_token.id;\n                        if (quote !== '\"' && quote !== '\\'') {\n                            stop('expected_a_b', next_token, '\"', artifact());\n                        }\n                        xmode = 'styleproperty';\n                        xquote = quote;\n                        advance(quote);\n                        substyle();\n                        xmode = 'html';\n                        xquote = '';\n                        advance(quote);\n                        tag = false;\n                    } else {\n                        if (next_token.id === '=') {\n                            advance('=');\n                            tag = next_token.string;\n                            if (!next_token.identifier &&\n                                    next_token.id !== '\"' &&\n                                    next_token.id !== '\\'' &&\n                                    next_token.id !== '(string)' &&\n                                    next_token.id !== '(string)' &&\n                                    next_token.id !== '(color)') {\n                                warn('expected_attribute_value_a', token, attribute);\n                            }\n                            advance();\n                        } else {\n                            tag = true;\n                        }\n                    }\n                    attributes[attribute] = tag;\n                    do_attribute(attribute, tag);\n                }\n                do_tag(name, attributes);\n                if (!is_empty) {\n                    stack.push(tag_name);\n                }\n                xmode = 'outer';\n                advance('>');\n                break;\n            case '</':\n                xmode = 'html';\n                advance('</');\n                if (!next_token.identifier) {\n                    warn('bad_name_a');\n                }\n                name = next_token.string;\n                if (option.cap) {\n                    name = name.toLowerCase();\n                }\n                advance();\n                if (!stack) {\n                    stop('unexpected_a', next_token, closetag(name));\n                }\n                tag_name = stack.pop();\n                if (!tag_name) {\n                    stop('unexpected_a', next_token, closetag(name));\n                }\n                if (tag_name.name !== name) {\n                    stop('expected_a_b',\n                        next_token, closetag(tag_name.name), closetag(name));\n                }\n                if (next_token.id !== '>') {\n                    stop('expected_a_b', next_token, '>', artifact());\n                }\n                xmode = 'outer';\n                advance('>');\n                break;\n            case '<!':\n                if (option.safe) {\n                    warn('adsafe_a');\n                }\n                xmode = 'html';\n                for (;;) {\n                    advance();\n                    if (next_token.id === '>' || next_token.id === '(end)') {\n                        break;\n                    }\n                    if (next_token.string.indexOf('--') >= 0) {\n                        stop('unexpected_a', next_token, '--');\n                    }\n                    if (next_token.string.indexOf('<') >= 0) {\n                        stop('unexpected_a', next_token, '<');\n                    }\n                    if (next_token.string.indexOf('>') >= 0) {\n                        stop('unexpected_a', next_token, '>');\n                    }\n                }\n                xmode = 'outer';\n                advance('>');\n                break;\n            case '(end)':\n                return;\n            default:\n                if (next_token.id === '(end)') {\n                    stop('missing_a', next_token,\n                        '</' + stack[stack.length - 1].string + '>');\n                } else {\n                    advance();\n                }\n            }\n            if (stack && stack.length === 0 && (option.adsafe ||\n                    !option.fragment || next_token.id === '(end)')) {\n                break;\n            }\n        }\n        if (next_token.id !== '(end)') {\n            stop('unexpected_a');\n        }\n    }\n\n\n// The actual JSLINT function itself.\n\n    itself = function JSLint(the_source, the_option) {\n\n        var i, predef, tree;\n        JSLINT.errors = [];\n        JSLINT.tree = '';\n        begin = prev_token = token = next_token =\n            Object.create(syntax['(begin)']);\n        predefined = {};\n        add_to_predefined(standard);\n        property = {};\n        if (the_option) {\n            option = Object.create(the_option);\n            predef = option.predef;\n            if (predef) {\n                if (Array.isArray(predef)) {\n                    for (i = 0; i < predef.length; i += 1) {\n                        predefined[predef[i]] = true;\n                    }\n                } else if (typeof predef === 'object') {\n                    add_to_predefined(predef);\n                }\n            }\n            do_safe();\n        } else {\n            option = {};\n        }\n        option.indent = +option.indent || 4;\n        option.maxerr = +option.maxerr || 50;\n        adsafe_id = '';\n        adsafe_may = adsafe_top = adsafe_went = false;\n        approved = {};\n        if (option.approved) {\n            for (i = 0; i < option.approved.length; i += 1) {\n                approved[option.approved[i]] = option.approved[i];\n            }\n        } else {\n            approved.test = 'test';\n        }\n        tab = '';\n        for (i = 0; i < option.indent; i += 1) {\n            tab += ' ';\n        }\n        global_scope = scope = {};\n        global_funct = funct = {\n            '(scope)': scope,\n            '(breakage)': 0,\n            '(loopage)': 0\n        };\n        functions = [funct];\n\n        comments_off = false;\n        ids = {};\n        in_block = false;\n        indent = null;\n        json_mode = false;\n        lookahead = [];\n        node_js = false;\n        prereg = true;\n        src = false;\n        stack = null;\n        strict_mode = false;\n        urls = [];\n        var_mode = null;\n        warnings = 0;\n        xmode = '';\n        lex.init(the_source);\n\n        assume();\n\n        try {\n            advance();\n            if (next_token.id === '(number)') {\n                stop('unexpected_a');\n            } else if (next_token.string.charAt(0) === '<') {\n                html();\n                if (option.adsafe && !adsafe_went) {\n                    warn('adsafe_go', this);\n                }\n            } else {\n                switch (next_token.id) {\n                case '{':\n                case '[':\n                    json_mode = true;\n                    json_value();\n                    break;\n                case '@':\n                case '*':\n                case '#':\n                case '.':\n                case ':':\n                    xmode = 'style';\n                    advance();\n                    if (token.id !== '@' || !next_token.identifier ||\n                            next_token.string !== 'charset' || token.line !== 1 ||\n                            token.from !== 1) {\n                        stop('css');\n                    }\n                    advance();\n                    if (next_token.id !== '(string)' &&\n                            next_token.string !== 'UTF-8') {\n                        stop('css');\n                    }\n                    advance();\n                    semicolon();\n                    styles();\n                    break;\n\n                default:\n                    if (option.adsafe && option.fragment) {\n                        stop('expected_a_b',\n                            next_token, '<div>', artifact());\n                    }\n\n// If the first token is a semicolon, ignore it. This is sometimes used when\n// files are intended to be appended to files that may be sloppy. A sloppy\n// file may be depending on semicolon insertion on its last line.\n\n                    step_in(1);\n                    if (next_token.id === ';' && !node_js) {\n                        semicolon();\n                    }\n                    adsafe_top = true;\n                    tree = statements();\n                    begin.first = tree;\n                    JSLINT.tree = begin;\n                    // infer_types(tree);\n                    if (option.adsafe && (tree.length !== 1 ||\n                            aint(tree[0], 'id', '(') ||\n                            aint(tree[0].first, 'id', '.') ||\n                            aint(tree[0].first.first, 'string', 'ADSAFE') ||\n                            aint(tree[0].first.second, 'string', 'lib') ||\n                            tree[0].second.length !== 2 ||\n                            tree[0].second[0].id !== '(string)' ||\n                            aint(tree[0].second[1], 'id', 'function'))) {\n                        stop('adsafe_lib');\n                    }\n                    if (tree.disrupt) {\n                        warn('weird_program', prev_token);\n                    }\n                }\n            }\n            indent = null;\n            advance('(end)');\n        } catch (e) {\n            if (e) {        // ~~\n                JSLINT.errors.push({\n                    reason    : e.message,\n                    line      : e.line || next_token.line,\n                    character : e.character || next_token.from\n                }, null);\n            }\n        }\n        return JSLINT.errors.length === 0;\n    };\n\n\n// Data summary.\n\n    itself.data = function () {\n        var data = {functions: []},\n            function_data,\n            globals,\n            i,\n            j,\n            kind,\n            members = [],\n            name,\n            the_function,\n            undef = [],\n            unused = [];\n        if (itself.errors.length) {\n            data.errors = itself.errors;\n        }\n\n        if (json_mode) {\n            data.json = true;\n        }\n\n        if (urls.length > 0) {\n            data.urls = urls;\n        }\n\n        globals = Object.keys(global_scope).filter(function (value) {\n            return value.charAt(0) !== '(' && typeof standard[value] !== 'boolean';\n        });\n        if (globals.length > 0) {\n            data.globals = globals;\n        }\n\n        for (i = 1; i < functions.length; i += 1) {\n            the_function = functions[i];\n            function_data = {};\n            for (j = 0; j < functionicity.length; j += 1) {\n                function_data[functionicity[j]] = [];\n            }\n            for (name in the_function) {\n                if (Object.prototype.hasOwnProperty.call(the_function, name)) {\n                    if (name.charAt(0) !== '(') {\n                        kind = the_function[name];\n                        if (kind === 'unction' || kind === 'unparam') {\n                            kind = 'unused';\n                        }\n                        if (Array.isArray(function_data[kind])) {\n                            function_data[kind].push(name);\n                            if (kind === 'unused') {\n                                unused.push({\n                                    name: name,\n                                    line: the_function['(line)'],\n                                    'function': the_function['(name)']\n                                });\n                            } else if (kind === 'undef') {\n                                undef.push({\n                                    name: name,\n                                    line: the_function['(line)'],\n                                    'function': the_function['(name)']\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            for (j = 0; j < functionicity.length; j += 1) {\n                if (function_data[functionicity[j]].length === 0) {\n                    delete function_data[functionicity[j]];\n                }\n            }\n            function_data.name = the_function['(name)'];\n            function_data.params = the_function['(params)'];\n            function_data.line = the_function['(line)'];\n            data.functions.push(function_data);\n        }\n\n        if (unused.length > 0) {\n            data.unused = unused;\n        }\n        if (undef.length > 0) {\n            data['undefined'] = undef;\n        }\n\n        members = [];\n        for (name in property) {\n            if (typeof property[name] === 'number') {\n                data.member = property;\n                break;\n            }\n        }\n\n        return data;\n    };\n\n\n    itself.report = function (errors_only) {\n        var data = itself.data(), err, evidence, i, italics, j, key, keys,\n            length, mem = '', name, names, output = [], snippets, the_function,\n            warning;\n\n        function detail(h, value) {\n            var comma_needed, singularity;\n            if (Array.isArray(value)) {\n                output.push('<div><i>' + h + '</i> ');\n                value.sort().forEach(function (item) {\n                    if (item !== singularity) {\n                        singularity = item;\n                        output.push((comma_needed ? ', ' : '') + singularity);\n                        comma_needed = true;\n                    }\n                });\n                output.push('</div>');\n            } else if (value) {\n                output.push('<div><i>' + h + '</i> ' + value + '</div>');\n            }\n        }\n\n        if (data.errors || data.unused || data['undefined']) {\n            err = true;\n            output.push('<div id=errors><i>Error:</i>');\n            if (data.errors) {\n                for (i = 0; i < data.errors.length; i += 1) {\n                    warning = data.errors[i];\n                    if (warning) {\n                        evidence = warning.evidence || '';\n                        output.push('<p>Problem' + (isFinite(warning.line)\n                            ? ' at line ' + String(warning.line) +\n                                ' character ' + String(warning.character)\n                            : '') +\n                            ': ' + warning.reason.entityify() +\n                            '</p><p class=evidence>' +\n                            (evidence && (evidence.length > 80\n                                ? evidence.slice(0, 77) + '...'\n                                : evidence).entityify()) + '</p>');\n                    }\n                }\n            }\n\n            if (data['undefined']) {\n                snippets = [];\n                for (i = 0; i < data['undefined'].length; i += 1) {\n                    snippets[i] = '<code><u>' + data['undefined'][i].name + '</u></code>&nbsp;<i>' +\n                        String(data['undefined'][i].line) + ' </i> <small>' +\n                        data['undefined'][i]['function'] + '</small>';\n                }\n                output.push('<p><i>Undefined variable:</i> ' + snippets.join(', ') + '</p>');\n            }\n            if (data.unused) {\n                snippets = [];\n                for (i = 0; i < data.unused.length; i += 1) {\n                    snippets[i] = '<code><u>' + data.unused[i].name + '</u></code>&nbsp;<i>' +\n                        String(data.unused[i].line) + ' </i> <small>' +\n                        data.unused[i]['function'] + '</small>';\n                }\n                output.push('<p><i>Unused variable:</i> ' + snippets.join(', ') + '</p>');\n            }\n            if (data.json) {\n                output.push('<p>JSON: bad.</p>');\n            }\n            output.push('</div>');\n        }\n\n        if (!errors_only) {\n\n            output.push('<br><div id=functions>');\n\n            if (data.urls) {\n                detail(\"URLs<br>\", data.urls, '<br>');\n            }\n\n            if (xmode === 'style') {\n                output.push('<p>CSS.</p>');\n            } else if (data.json && !err) {\n                output.push('<p>JSON: good.</p>');\n            } else if (data.globals) {\n                output.push('<div><i>Global</i> ' +\n                    data.globals.sort().join(', ') + '</div>');\n            } else {\n                output.push('<div><i>No new global variables introduced.</i></div>');\n            }\n\n            for (i = 0; i < data.functions.length; i += 1) {\n                the_function = data.functions[i];\n                names = [];\n                if (the_function.params) {\n                    for (j = 0; j < the_function.params.length; j += 1) {\n                        names[j] = the_function.params[j].string;\n                    }\n                }\n                output.push('<br><div class=function><i>' +\n                    String(the_function.line) + '</i> ' +\n                    the_function.name.entityify() +\n                    '(' + names.join(', ') + ')</div>');\n                detail('<big><b>Undefined</b></big>', the_function['undefined']);\n                detail('<big><b>Unused</b></big>', the_function.unused);\n                detail('Closure', the_function.closure);\n                detail('Variable', the_function['var']);\n                detail('Exception', the_function.exception);\n                detail('Outer', the_function.outer);\n                detail('Global', the_function.global);\n                detail('Label', the_function.label);\n            }\n\n            if (data.member) {\n                keys = Object.keys(data.member);\n                if (keys.length) {\n                    keys = keys.sort();\n                    output.push('<br><pre id=properties>/*properties<br>');\n                    mem = '    ';\n                    italics = 0;\n                    j = 0;\n                    for (i = 0; i < keys.length; i += 1) {\n                        key = keys[i];\n                        name = ix.test(key)\n                            ? key\n                            : '\\'' + key.entityify().replace(nx, sanitize) + '\\'';\n                        length += name.length + 2;\n                        if (data.member[key] === 1) {\n                            name = '<i>' + name + '</i>';\n                            italics += 1;\n                            j = 1;\n                        }\n                        if (i < keys.length - 1) {\n                            name += ', ';\n                        }\n                        if (mem.length + name.length - (italics * 7) > 80) {\n                            output.push(mem + '<br>');\n                            mem = '    ';\n                            italics = j;\n                        }\n                        mem += name;\n                        j = 0;\n                    }\n                    output.push(mem + '<br>*/</pre>');\n                }\n                output.push('</div>');\n            }\n        }\n        return output.join('');\n    };\n    itself.jslint = itself;\n\n    itself.edition = '2012-02-03';\n\n    return itself;\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jslint-2013-02-03.js":"// jslint.js\n// 2013-02-03\n\n// Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// The Software shall be used for Good, not Evil.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// WARNING: JSLint will hurt your feelings.\n\n// JSLINT is a global function. It takes two parameters.\n\n//     var myResult = JSLINT(source, option);\n\n// The first parameter is either a string or an array of strings. If it is a\n// string, it will be split on '\\n' or '\\r'. If it is an array of strings, it\n// is assumed that each string represents one line. The source can be a\n// JavaScript text, or HTML text, or a JSON text, or a CSS text.\n\n// The second parameter is an optional object of options that control the\n// operation of JSLINT. Most of the options are booleans: They are all\n// optional and have a default value of false. One of the options, predef,\n// can be an array of names, which will be used to declare global variables,\n// or an object whose keys are used as global names, with a boolean value\n// that determines if they are assignable.\n\n// If it checks out, JSLINT returns true. Otherwise, it returns false.\n\n// If false, you can inspect JSLINT.errors to find out the problems.\n// JSLINT.errors is an array of objects containing these properties:\n\n//  {\n//      line      : The line (relative to 0) at which the lint was found\n//      character : The character (relative to 0) at which the lint was found\n//      reason    : The problem\n//      evidence  : The text line in which the problem occurred\n//      raw       : The raw message before the details were inserted\n//      a         : The first detail\n//      b         : The second detail\n//      c         : The third detail\n//      d         : The fourth detail\n//  }\n\n// If a stopping error was found, a null will be the last element of the\n// JSLINT.errors array. A stopping error means that JSLint was not confident\n// enough to continue. It does not necessarily mean that the error was\n// especially heinous.\n\n// You can request a data structure that contains JSLint's results.\n\n//     var myData = JSLINT.data();\n\n// It returns a structure with this form:\n\n//     {\n//         errors: [\n//             {\n//                 line: NUMBER,\n//                 character: NUMBER,\n//                 reason: STRING,\n//                 evidence: STRING\n//             }\n//         ],\n//         functions: [\n//             {\n//                 name: STRING,\n//                 line: NUMBER,\n//                 last: NUMBER,\n//                 params: [\n//                     {\n//                         string: STRING\n//                     }\n//                 ],\n//                 closure: [\n//                     STRING\n//                 ],\n//                 var: [\n//                     STRING\n//                 ],\n//                 exception: [\n//                     STRING\n//                 ],\n//                 outer: [\n//                     STRING\n//                 ],\n//                 unused: [\n//                     STRING\n//                 ],\n//                 undef: [\n//                     STRING\n//                 ],\n//                 global: [\n//                     STRING\n//                 ],\n//                 label: [\n//                     STRING\n//                 ]\n//             }\n//         ],\n//         globals: [\n//             STRING\n//         ],\n//         member: {\n//             STRING: NUMBER\n//         },\n//         urls: [\n//             STRING\n//         ],\n//         json: BOOLEAN\n//     }\n\n// Empty arrays will not be included.\n\n// You can request a Function Report, which shows all of the functions\n// and the parameters and vars that they use. This can be used to find\n// implied global variables and other problems. The report is in HTML and\n// can be inserted in an HTML <body>. It should be given the result of the\n// JSLINT.data function.\n\n//     var myReport = JSLINT.report(data);\n\n// You can request an HTML error report.\n\n//     var myErrorReport = JSLINT.error_report(data);\n\n// You can request a properties report, which produces a list of the program's\n// properties in the form of a /*properties*/ declaration.\n\n//      var myPropertyReport = JSLINT.properties_report(JSLINT.property);\n\n// You can obtain the parse tree that JSLint constructed while parsing. The\n// latest tree is kept in JSLINT.tree. A nice stringification can be produced\n// with\n\n//     JSON.stringify(JSLINT.tree, [\n//         'string',  'arity', 'name',  'first',\n//         'second', 'third', 'block', 'else'\n//     ], 4));\n\n// JSLint provides three directives. They look like slashstar comments, and\n// allow for setting options, declaring global variables, and establishing a\n// set of allowed property names.\n\n// These directives respect function scope.\n\n// The jslint directive is a special comment that can set one or more options.\n// For example:\n\n/*jslint\n    evil: true, nomen: true, regexp: true, todo: true\n*/\n\n// The current option set is\n\n//     anon       true, if the space may be omitted in anonymous function declarations\n//     bitwise    true, if bitwise operators should be allowed\n//     browser    true, if the standard browser globals should be predefined\n//     'continue' true, if the continuation statement should be tolerated\n//     css        true, if CSS workarounds should be tolerated\n//     debug      true, if debugger statements should be allowed\n//     devel      true, if logging should be allowed (console, alert, etc.)\n//     eqeq       true, if == should be allowed\n//     es5        true, if ES5 syntax should be allowed\n//     evil       true, if eval should be allowed\n//     forin      true, if for in statements need not filter\n//     fragment   true, if HTML fragments should be allowed\n//     indent     the indentation factor\n//     maxerr     the maximum number of errors to allow\n//     maxlen     the maximum length of a source line\n//     newcap     true, if constructor names capitalization is ignored\n//     node       true, if Node.js globals should be predefined\n//     nomen      true, if names may have dangling _\n//     on         true, if HTML event handlers should be allowed\n//     passfail   true, if the scan should stop on first error\n//     plusplus   true, if increment/decrement should be allowed\n//     properties true, if all property names must be declared with /*properties*/\n//     regexp     true, if the . should be allowed in regexp literals\n//     rhino      true, if the Rhino environment globals should be predefined\n//     undef      true, if variables can be declared out of order\n//     unparam    true, if unused parameters should be tolerated\n//     sloppy     true, if the 'use strict'; pragma is optional\n//     stupid     true, if really stupid practices are tolerated\n//     sub        true, if all forms of subscript notation are tolerated\n//     todo       true, if TODO comments are tolerated\n//     vars       true, if multiple var statements per function should be allowed\n//     white      true, if sloppy whitespace is tolerated\n//     windows    true, if MS Windows-specific globals should be predefined\n\n// The properties directive declares an exclusive list of property names.\n// Any properties named in the program that are not in the list will\n// produce a warning.\n\n// For example:\n\n/*properties\n    '\\b', '\\t', '\\n', '\\f', '\\r', '!', '!=', '!==', '\"', '%', '\\'',\n    '(arguments)', '(begin)', '(breakage)', '(context)', '(error)',\n    '(identifier)', '(line)', '(loopage)', '(name)', '(params)', '(scope)',\n    '(token)', '(vars)', '(verb)', '*', '+', '-', '/', '<', '<=', '==', '===',\n    '>', '>=', ADSAFE, Array, Date, Function, Object, '\\\\', a, a_label,\n    a_not_allowed, a_not_defined, a_scope, abbr, acronym, address, adsafe,\n    adsafe_a, adsafe_autocomplete, adsafe_bad_id, adsafe_div, adsafe_fragment,\n    adsafe_go, adsafe_html, adsafe_id, adsafe_id_go, adsafe_lib,\n    adsafe_lib_second, adsafe_missing_id, adsafe_name_a, adsafe_placement,\n    adsafe_prefix_a, adsafe_script, adsafe_source, adsafe_subscript_a,\n    adsafe_tag, all, already_defined, and, anon, applet, apply, approved, area,\n    arity, article, aside, assign, assign_exception,\n    assignment_function_expression, at, attribute_case_a, audio, autocomplete,\n    avoid_a, b, background, 'background-attachment', 'background-color',\n    'background-image', 'background-position', 'background-repeat',\n    bad_assignment, bad_color_a, bad_constructor, bad_entity, bad_html, bad_id_a,\n    bad_in_a, bad_invocation, bad_name_a, bad_new, bad_number, bad_operand,\n    bad_style, bad_type, bad_url_a, bad_wrap, base, bdo, big, bitwise, block,\n    blockquote, body, border, 'border-bottom', 'border-bottom-color',\n    'border-bottom-left-radius', 'border-bottom-right-radius',\n    'border-bottom-style', 'border-bottom-width', 'border-collapse',\n    'border-color', 'border-left', 'border-left-color', 'border-left-style',\n    'border-left-width', 'border-radius', 'border-right', 'border-right-color',\n    'border-right-style', 'border-right-width', 'border-spacing', 'border-style',\n    'border-top', 'border-top-color', 'border-top-left-radius',\n    'border-top-right-radius', 'border-top-style', 'border-top-width',\n    'border-width', bottom, 'box-shadow', br, braille, browser, button, c, call,\n    canvas, caption, 'caption-side', center, charAt, charCodeAt, character,\n    cite, clear, clip, closure, cm, code, col, colgroup, color, combine_var,\n    command, conditional_assignment, confusing_a, confusing_regexp,\n    constructor_name_a, content, continue, control_a, 'counter-increment',\n    'counter-reset', create, css, cursor, d, dangerous_comment, dangling_a, data,\n    datalist, dd, debug, del, deleted, details, devel, dfn, dialog, dir,\n    direction, display, disrupt, div, dl, dt, duplicate_a, edge, edition, else,\n    em, embed, embossed, empty, 'empty-cells', empty_block, empty_case,\n    empty_class, entityify, eqeq, error_report, errors, es5, eval, evidence,\n    evil, ex, exception, exec, expected_a, expected_a_at_b_c, expected_a_b,\n    expected_a_b_from_c_d, expected_at_a, expected_attribute_a,\n    expected_attribute_value_a, expected_class_a, expected_fraction_a,\n    expected_id_a, expected_identifier_a, expected_identifier_a_reserved,\n    expected_lang_a, expected_linear_a, expected_media_a, expected_name_a,\n    expected_nonstandard_style_attribute, expected_number_a, expected_operator_a,\n    expected_percent_a, expected_positive_a, expected_pseudo_a,\n    expected_selector_a, expected_small_a, expected_space_a_b, expected_string_a,\n    expected_style_attribute, expected_style_pattern, expected_tagname_a,\n    expected_type_a, f, fieldset, figcaption, figure, filter, first, flag, float,\n    floor, font, 'font-family', 'font-size', 'font-size-adjust', 'font-stretch',\n    'font-style', 'font-variant', 'font-weight', footer, forEach, for_if, forin,\n    form, fragment, frame, frameset, from, fromCharCode, fud, funct, function,\n    function_block, function_eval, function_loop, function_statement,\n    function_strict, functions, global, globals, h1, h2, h3, h4, h5, h6,\n    handheld, hasOwnProperty, head, header, height, hgroup, hr,\n    'hta:application', html, html_confusion_a, html_handlers, i, id, identifier,\n    identifier_function, iframe, img, immed, implied_evil, in, indent, indexOf,\n    infix_in, init, input, ins, insecure_a, isAlpha, isArray, isDigit, isNaN,\n    join, jslint, json, kbd, keygen, keys, label, labeled, lang, lbp,\n    leading_decimal_a, led, left, legend, length, 'letter-spacing', li, lib,\n    line, 'line-height', link, 'list-style', 'list-style-image',\n    'list-style-position', 'list-style-type', map, margin, 'margin-bottom',\n    'margin-left', 'margin-right', 'margin-top', mark, 'marker-offset', match,\n    'max-height', 'max-width', maxerr, maxlen, menu, message, meta, meter,\n    'min-height', 'min-width', missing_a, missing_a_after_b, missing_option,\n    missing_property, missing_space_a_b, missing_url, missing_use_strict,\n    mm, mode, move_invocation, move_var, n, name, name_function, nav,\n    nested_comment, newcap, node, noframes, nomen, noscript, not,\n    not_a_constructor, not_a_defined, not_a_function, not_a_label, not_a_scope,\n    not_greater, nud, number, object, octal_a, ol, on, opacity, open, optgroup,\n    option, outer, outline, 'outline-color', 'outline-style', 'outline-width',\n    output, overflow, 'overflow-x', 'overflow-y', p, padding, 'padding-bottom',\n    'padding-left', 'padding-right', 'padding-top', 'page-break-after',\n    'page-break-before', param, parameter_a_get_b, parameter_arguments_a,\n    parameter_set_a, params, paren, parent, passfail, pc, plusplus, pop,\n    position, postscript, pre, predef, print, progress, projection, properties,\n    properties_report, property, prototype, pt, push, px, q, quote, quotes, r,\n    radix, range, raw, read_only, reason, redefinition_a, regexp, replace,\n    report, reserved, reserved_a, rhino, right, rp, rt, ruby, safe, samp,\n    scanned_a_b, screen, script, search, second, section, select, shift,\n    slash_equal, slice, sloppy, small, sort, source, span, speech, split, src,\n    statement_block, stopping, strange_loop, strict, string, strong, stupid,\n    style, styleproperty, sub, subscript, substr, summary, sup, supplant,\n    sync_a, t,table, 'table-layout', tag_a_in_b, tbody, td, test, 'text-align',\n    'text-decoration', 'text-indent', 'text-shadow', 'text-transform', textarea,\n    tfoot, th, thead, third, thru, time, title, todo, todo_comment, toLowerCase,\n    toString, toUpperCase, token, too_long, too_many, top, tr,\n    trailing_decimal_a, tree, tt, tty, tv, type, u, ul, unclosed,\n    unclosed_comment, unclosed_regexp, undef, undefined, unescaped_a,\n    unexpected_a, unexpected_char_a_b, unexpected_comment, unexpected_else,\n    unexpected_label_a, unexpected_property_a, unexpected_space_a_b,\n    unexpected_typeof_a, 'unicode-bidi', unnecessary_initialize,\n    unnecessary_use, unparam, unreachable_a_b, unrecognized_style_attribute_a,\n    unrecognized_tag_a, unsafe, unused, url, urls, use_array, use_braces,\n    use_charAt, use_object, use_or, use_param, use_spaces, used_before_a, var,\n    var_a_not, vars, 'vertical-align', video, visibility, was, weird_assignment,\n    weird_condition, weird_new, weird_program, weird_relation, weird_ternary,\n    white, 'white-space', width, windows, 'word-spacing', 'word-wrap', wrap,\n    wrap_immediate, wrap_regexp, write_is_wrong, writeable, 'z-index'\n*/\n\n// The global directive is used to declare global variables that can\n// be accessed by the program. If a declaration is true, then the variable\n// is writeable. Otherwise, it is read-only.\n\n// We build the application inside a function so that we produce only a single\n// global variable. That function will be invoked immediately, and its return\n// value is the JSLINT function itself. That function is also an object that\n// can contain data and other functions.\n\nvar JSLINT = (function () {\n    'use strict';\n\n    function array_to_object(array, value) {\n\n// Make an object from an array of keys and a common value.\n\n        var i, length = array.length, object = {};\n        for (i = 0; i < length; i += 1) {\n            object[array[i]] = value;\n        }\n        return object;\n    }\n\n\n    var adsafe_id,      // The widget's ADsafe id.\n        adsafe_may,     // The widget may load approved scripts.\n        adsafe_top,     // At the top of the widget script.\n        adsafe_went,    // ADSAFE.go has been called.\n        allowed_option = {\n            anon      : true,\n            bitwise   : true,\n            browser   : true,\n            'continue': true,\n            css       : true,\n            debug     : true,\n            devel     : true,\n            eqeq      : true,\n            es5       : true,\n            evil      : true,\n            forin     : true,\n            fragment  : true,\n            indent    :   10,\n            maxerr    : 1000,\n            maxlen    :  256,\n            newcap    : true,\n            node      : true,\n            nomen     : true,\n            on        : true,\n            passfail  : true,\n            plusplus  : true,\n            properties: true,\n            regexp    : true,\n            rhino     : true,\n            undef     : true,\n            unparam   : true,\n            sloppy    : true,\n            stupid    : true,\n            sub       : true,\n            todo      : true,\n            vars      : true,\n            white     : true,\n            windows   : true\n        },\n        anonname,       // The guessed name for anonymous functions.\n        approved,       // ADsafe approved urls.\n\n// These are operators that should not be used with the ! operator.\n\n        bang = {\n            '<'  : true,\n            '<=' : true,\n            '==' : true,\n            '===': true,\n            '!==': true,\n            '!=' : true,\n            '>'  : true,\n            '>=' : true,\n            '+'  : true,\n            '-'  : true,\n            '*'  : true,\n            '/'  : true,\n            '%'  : true\n        },\n\n// These are property names that should not be permitted in the safe subset.\n\n        banned = array_to_object([\n            'arguments', 'callee', 'caller', 'constructor', 'eval', 'prototype',\n            'stack', 'unwatch', 'valueOf', 'watch'\n        ], true),\n        begin,          // The root token\n\n// browser contains a set of global names that are commonly provided by a\n// web browser environment.\n\n        browser = array_to_object([\n            'clearInterval', 'clearTimeout', 'document', 'event', 'FormData',\n            'frames', 'history', 'Image', 'localStorage', 'location', 'name',\n            'navigator', 'Option', 'parent', 'screen', 'sessionStorage',\n            'setInterval', 'setTimeout', 'Storage', 'window', 'XMLHttpRequest'\n        ], false),\n\n// bundle contains the text messages.\n\n        bundle = {\n            a_label: \"'{a}' is a statement label.\",\n            a_not_allowed: \"'{a}' is not allowed.\",\n            a_not_defined: \"'{a}' is not defined.\",\n            a_scope: \"'{a}' used out of scope.\",\n            adsafe_a: \"ADsafe violation: '{a}'.\",\n            adsafe_autocomplete: \"ADsafe autocomplete violation.\",\n            adsafe_bad_id: \"ADSAFE violation: bad id.\",\n            adsafe_div: \"ADsafe violation: Wrap the widget in a div.\",\n            adsafe_fragment: \"ADSAFE: Use the fragment option.\",\n            adsafe_go: \"ADsafe violation: Misformed ADSAFE.go.\",\n            adsafe_html: \"Currently, ADsafe does not operate on whole HTML \" +\n                \"documents. It operates on <div> fragments and .js files.\",\n            adsafe_id: \"ADsafe violation: id does not match.\",\n            adsafe_id_go: \"ADsafe violation: Missing ADSAFE.id or ADSAFE.go.\",\n            adsafe_lib: \"ADsafe lib violation.\",\n            adsafe_lib_second: \"ADsafe: The second argument to lib must be a function.\",\n            adsafe_missing_id: \"ADSAFE violation: missing ID_.\",\n            adsafe_name_a: \"ADsafe name violation: '{a}'.\",\n            adsafe_placement: \"ADsafe script placement violation.\",\n            adsafe_prefix_a: \"ADsafe violation: An id must have a '{a}' prefix\",\n            adsafe_script: \"ADsafe script violation.\",\n            adsafe_source: \"ADsafe unapproved script source.\",\n            adsafe_subscript_a: \"ADsafe subscript '{a}'.\",\n            adsafe_tag: \"ADsafe violation: Disallowed tag '{a}'.\",\n            already_defined: \"'{a}' is already defined.\",\n            and: \"The '&&' subexpression should be wrapped in parens.\",\n            assign_exception: \"Do not assign to the exception parameter.\",\n            assignment_function_expression: \"Expected an assignment or \" +\n                \"function call and instead saw an expression.\",\n            attribute_case_a: \"Attribute '{a}' not all lower case.\",\n            avoid_a: \"Avoid '{a}'.\",\n            bad_assignment: \"Bad assignment.\",\n            bad_color_a: \"Bad hex color '{a}'.\",\n            bad_constructor: \"Bad constructor.\",\n            bad_entity: \"Bad entity.\",\n            bad_html: \"Bad HTML string\",\n            bad_id_a: \"Bad id: '{a}'.\",\n            bad_in_a: \"Bad for in variable '{a}'.\",\n            bad_invocation: \"Bad invocation.\",\n            bad_name_a: \"Bad name: '{a}'.\",\n            bad_new: \"Do not use 'new' for side effects.\",\n            bad_number: \"Bad number '{a}'.\",\n            bad_operand: \"Bad operand.\",\n            bad_style: \"Bad style.\",\n            bad_type: \"Bad type.\",\n            bad_url_a: \"Bad url '{a}'.\",\n            bad_wrap: \"Do not wrap function literals in parens unless they \" +\n                \"are to be immediately invoked.\",\n            combine_var: \"Combine this with the previous 'var' statement.\",\n            conditional_assignment: \"Expected a conditional expression and \" +\n                \"instead saw an assignment.\",\n            confusing_a: \"Confusing use of '{a}'.\",\n            confusing_regexp: \"Confusing regular expression.\",\n            constructor_name_a: \"A constructor name '{a}' should start with \" +\n                \"an uppercase letter.\",\n            control_a: \"Unexpected control character '{a}'.\",\n            css: \"A css file should begin with @charset 'UTF-8';\",\n            dangling_a: \"Unexpected dangling '_' in '{a}'.\",\n            dangerous_comment: \"Dangerous comment.\",\n            deleted: \"Only properties should be deleted.\",\n            duplicate_a: \"Duplicate '{a}'.\",\n            empty_block: \"Empty block.\",\n            empty_case: \"Empty case.\",\n            empty_class: \"Empty class.\",\n            es5: \"This is an ES5 feature.\",\n            evil: \"eval is evil.\",\n            expected_a: \"Expected '{a}'.\",\n            expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n            expected_a_b_from_c_d: \"Expected '{a}' to match '{b}' from line \" +\n                \"{c} and instead saw '{d}'.\",\n            expected_at_a: \"Expected an at-rule, and instead saw @{a}.\",\n            expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n            expected_attribute_a: \"Expected an attribute, and instead saw [{a}].\",\n            expected_attribute_value_a: \"Expected an attribute value and \" +\n                \"instead saw '{a}'.\",\n            expected_class_a: \"Expected a class, and instead saw .{a}.\",\n            expected_fraction_a: \"Expected a number between 0 and 1 and \" +\n                \"instead saw '{a}'\",\n            expected_id_a: \"Expected an id, and instead saw #{a}.\",\n            expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n            expected_identifier_a_reserved: \"Expected an identifier and \" +\n                \"instead saw '{a}' (a reserved word).\",\n            expected_linear_a: \"Expected a linear unit and instead saw '{a}'.\",\n            expected_lang_a: \"Expected a lang code, and instead saw :{a}.\",\n            expected_media_a: \"Expected a CSS media type, and instead saw '{a}'.\",\n            expected_name_a: \"Expected a name and instead saw '{a}'.\",\n            expected_nonstandard_style_attribute: \"Expected a non-standard \" +\n                \"style attribute and instead saw '{a}'.\",\n            expected_number_a: \"Expected a number and instead saw '{a}'.\",\n            expected_operator_a: \"Expected an operator and instead saw '{a}'.\",\n            expected_percent_a: \"Expected a percentage and instead saw '{a}'\",\n            expected_positive_a: \"Expected a positive number and instead saw '{a}'\",\n            expected_pseudo_a: \"Expected a pseudo, and instead saw :{a}.\",\n            expected_selector_a: \"Expected a CSS selector, and instead saw {a}.\",\n            expected_small_a: \"Expected a small positive integer and instead saw '{a}'\",\n            expected_space_a_b: \"Expected exactly one space between '{a}' and '{b}'.\",\n            expected_string_a: \"Expected a string and instead saw '{a}'.\",\n            expected_style_attribute: \"Excepted a style attribute, and instead saw '{a}'.\",\n            expected_style_pattern: \"Expected a style pattern, and instead saw '{a}'.\",\n            expected_tagname_a: \"Expected a tagName, and instead saw {a}.\",\n            expected_type_a: \"Expected a type, and instead saw {a}.\",\n            for_if: \"The body of a for in should be wrapped in an if \" +\n                \"statement to filter unwanted properties from the prototype.\",\n            function_block: \"Function statements should not be placed in blocks.\" +\n                \"Use a function expression or move the statement to the top of \" +\n                \"the outer function.\",\n            function_eval: \"The Function constructor is eval.\",\n            function_loop: \"Don't make functions within a loop.\",\n            function_statement: \"Function statements are not invocable.\" +\n                \"Wrap the whole function invocation in parens.\",\n            function_strict: \"Use the function form of 'use strict'.\",\n            html_confusion_a: \"HTML confusion in regular expression '<{a}'.\",\n            html_handlers: \"Avoid HTML event handlers.\",\n            identifier_function: \"Expected an identifier in an assignment \" +\n                \"and instead saw a function invocation.\",\n            implied_evil: \"Implied eval is evil. Pass a function instead of a string.\",\n            infix_in: \"Unexpected 'in'. Compare with undefined, or use the \" +\n                \"hasOwnProperty method instead.\",\n            insecure_a: \"Insecure '{a}'.\",\n            isNaN: \"Use the isNaN function to compare with NaN.\",\n            lang: \"lang is deprecated.\",\n            leading_decimal_a: \"A leading decimal point can be confused with a dot: '.{a}'.\",\n            missing_a: \"Missing '{a}'.\",\n            missing_a_after_b: \"Missing '{a}' after '{b}'.\",\n            missing_option: \"Missing option value.\",\n            missing_property: \"Missing property name.\",\n            missing_space_a_b: \"Missing space between '{a}' and '{b}'.\",\n            missing_url: \"Missing url.\",\n            missing_use_strict: \"Missing 'use strict' statement.\",\n            move_invocation: \"Move the invocation into the parens that \" +\n                \"contain the function.\",\n            move_var: \"Move 'var' declarations to the top of the function.\",\n            name_function: \"Missing name in function statement.\",\n            nested_comment: \"Nested comment.\",\n            not: \"Nested not.\",\n            not_a_constructor: \"Do not use {a} as a constructor.\",\n            not_a_defined: \"'{a}' has not been fully defined yet.\",\n            not_a_function: \"'{a}' is not a function.\",\n            not_a_label: \"'{a}' is not a label.\",\n            not_a_scope: \"'{a}' is out of scope.\",\n            not_greater: \"'{a}' should not be greater than '{b}'.\",\n            octal_a: \"Don't use octal: '{a}'. Use '\\\\u....' instead.\",\n            parameter_arguments_a: \"Do not mutate parameter '{a}' when using 'arguments'.\",\n            parameter_a_get_b: \"Unexpected parameter '{a}' in get {b} function.\",\n            parameter_set_a: \"Expected parameter (value) in set {a} function.\",\n            radix: \"Missing radix parameter.\",\n            read_only: \"Read only.\",\n            redefinition_a: \"Redefinition of '{a}'.\",\n            reserved_a: \"Reserved name '{a}'.\",\n            scanned_a_b: \"{a} ({b}% scanned).\",\n            slash_equal: \"A regular expression literal can be confused with '/='.\",\n            statement_block: \"Expected to see a statement and instead saw a block.\",\n            stopping: \"Stopping.\",\n            strange_loop: \"Strange loop.\",\n            strict: \"Strict violation.\",\n            subscript: \"['{a}'] is better written in dot notation.\",\n            sync_a: \"Unexpected sync method: '{a}'.\",\n            tag_a_in_b: \"A '<{a}>' must be within '<{b}>'.\",\n            todo_comment: \"Unexpected TODO comment.\",\n            too_long: \"Line too long.\",\n            too_many: \"Too many errors.\",\n            trailing_decimal_a: \"A trailing decimal point can be confused \" +\n                \"with a dot: '.{a}'.\",\n            type: \"type is unnecessary.\",\n            unclosed: \"Unclosed string.\",\n            unclosed_comment: \"Unclosed comment.\",\n            unclosed_regexp: \"Unclosed regular expression.\",\n            unescaped_a: \"Unescaped '{a}'.\",\n            unexpected_a: \"Unexpected '{a}'.\",\n            unexpected_char_a_b: \"Unexpected character '{a}' in {b}.\",\n            unexpected_comment: \"Unexpected comment.\",\n            unexpected_else: \"Unexpected 'else' after 'return'.\",\n            unexpected_label_a: \"Unexpected label '{a}'.\",\n            unexpected_property_a: \"Unexpected /*property*/ '{a}'.\",\n            unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n            unexpected_typeof_a: \"Unexpected 'typeof'. \" +\n                \"Use '===' to compare directly with {a}.\",\n            unnecessary_initialize: \"It is not necessary to initialize '{a}' \" +\n                \"to 'undefined'.\",\n            unnecessary_use: \"Unnecessary 'use strict'.\",\n            unreachable_a_b: \"Unreachable '{a}' after '{b}'.\",\n            unrecognized_style_attribute_a: \"Unrecognized style attribute '{a}'.\",\n            unrecognized_tag_a: \"Unrecognized tag '<{a}>'.\",\n            unsafe: \"Unsafe character.\",\n            url: \"JavaScript URL.\",\n            use_array: \"Use the array literal notation [].\",\n            use_braces: \"Spaces are hard to count. Use {{a}}.\",\n            use_charAt: \"Use the charAt method.\",\n            use_object: \"Use the object literal notation {}.\",\n            use_or: \"Use the || operator.\",\n            use_param: \"Use a named parameter.\",\n            use_spaces: \"Use spaces, not tabs.\",\n            used_before_a: \"'{a}' was used before it was defined.\",\n            var_a_not: \"Variable {a} was not declared correctly.\",\n            weird_assignment: \"Weird assignment.\",\n            weird_condition: \"Weird condition.\",\n            weird_new: \"Weird construction. Delete 'new'.\",\n            weird_program: \"Weird program.\",\n            weird_relation: \"Weird relation.\",\n            weird_ternary: \"Weird ternary.\",\n            wrap_immediate: \"Wrap an immediate function invocation in parentheses \" +\n                \"to assist the reader in understanding that the expression \" +\n                \"is the result of a function, and not the function itself.\",\n            wrap_regexp: \"Wrap the /regexp/ literal in parens to \" +\n                \"disambiguate the slash operator.\",\n            write_is_wrong: \"document.write can be a form of eval.\"\n        },\n        comments_off,\n        css_attribute_data,\n        css_any,\n\n        css_colorData = array_to_object([\n            \"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\",\n            \"bisque\", \"black\", \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\",\n            \"burlywood\", \"cadetblue\", \"chartreuse\", \"chocolate\", \"coral\",\n            \"cornflowerblue\", \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\",\n            \"darkcyan\", \"darkgoldenrod\", \"darkgray\", \"darkgreen\", \"darkkhaki\",\n            \"darkmagenta\", \"darkolivegreen\", \"darkorange\", \"darkorchid\",\n            \"darkred\", \"darksalmon\", \"darkseagreen\", \"darkslateblue\",\n            \"darkslategray\", \"darkturquoise\", \"darkviolet\", \"deeppink\",\n            \"deepskyblue\", \"dimgray\", \"dodgerblue\", \"firebrick\", \"floralwhite\",\n            \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\", \"gold\",\n            \"goldenrod\", \"gray\", \"green\", \"greenyellow\", \"honeydew\", \"hotpink\",\n            \"indianred\", \"indigo\", \"ivory\", \"khaki\", \"lavender\",\n            \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\",\n            \"lightcoral\", \"lightcyan\", \"lightgoldenrodyellow\", \"lightgreen\",\n            \"lightpink\", \"lightsalmon\", \"lightseagreen\", \"lightskyblue\",\n            \"lightslategray\", \"lightsteelblue\", \"lightyellow\", \"lime\",\n            \"limegreen\", \"linen\", \"magenta\", \"maroon\", \"mediumaquamarine\",\n            \"mediumblue\", \"mediumorchid\", \"mediumpurple\", \"mediumseagreen\",\n            \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\",\n            \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\",\n            \"moccasin\", \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\",\n            \"orange\", \"orangered\", \"orchid\", \"palegoldenrod\", \"palegreen\",\n            \"paleturquoise\", \"palevioletred\", \"papayawhip\", \"peachpuff\",\n            \"peru\", \"pink\", \"plum\", \"powderblue\", \"purple\", \"red\", \"rosybrown\",\n            \"royalblue\", \"saddlebrown\", \"salmon\", \"sandybrown\", \"seagreen\",\n            \"seashell\", \"sienna\", \"silver\", \"skyblue\", \"slateblue\", \"slategray\",\n            \"snow\", \"springgreen\", \"steelblue\", \"tan\", \"teal\", \"thistle\",\n            \"tomato\", \"turquoise\", \"violet\", \"wheat\", \"white\", \"whitesmoke\",\n            \"yellow\", \"yellowgreen\",\n\n            \"activeborder\", \"activecaption\", \"appworkspace\", \"background\",\n            \"buttonface\", \"buttonhighlight\", \"buttonshadow\", \"buttontext\",\n            \"captiontext\", \"graytext\", \"highlight\", \"highlighttext\",\n            \"inactiveborder\", \"inactivecaption\", \"inactivecaptiontext\",\n            \"infobackground\", \"infotext\", \"menu\", \"menutext\", \"scrollbar\",\n            \"threeddarkshadow\", \"threedface\", \"threedhighlight\",\n            \"threedlightshadow\", \"threedshadow\", \"window\", \"windowframe\",\n            \"windowtext\"\n        ], true),\n\n        css_border_style,\n        css_break,\n\n        css_lengthData = {\n            '%': true,\n            'cm': true,\n            'em': true,\n            'ex': true,\n            'in': true,\n            'mm': true,\n            'pc': true,\n            'pt': true,\n            'px': true\n        },\n\n        css_media,\n        css_overflow,\n\n        descapes = {\n            'b': '\\b',\n            't': '\\t',\n            'n': '\\n',\n            'f': '\\f',\n            'r': '\\r',\n            '\"': '\"',\n            '/': '/',\n            '\\\\': '\\\\',\n            '!': '!'\n        },\n\n        devel = array_to_object([\n            'alert', 'confirm', 'console', 'Debug', 'opera', 'prompt', 'WSH'\n        ], false),\n        directive,\n        escapes = {\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\\'': '\\\\\\'',\n            '\"' : '\\\\\"',\n            '/' : '\\\\/',\n            '\\\\': '\\\\\\\\'\n        },\n\n        funct,          // The current function, including the labels used in\n                        // the function, as well as (breakage),\n                        // (context), (loopage), (name), (params), (token),\n                        // (vars), (verb)\n\n        functionicity = [\n            'closure', 'exception', 'global', 'label', 'outer', 'undef',\n            'unused', 'var'\n        ],\n\n        functions,      // All of the functions\n        global_funct,   // The global body\n        global_scope,   // The global scope\n        html_tag = {\n            a:        {},\n            abbr:     {},\n            acronym:  {},\n            address:  {},\n            applet:   {},\n            area:     {empty: true, parent: ' map '},\n            article:  {},\n            aside:    {},\n            audio:    {},\n            b:        {},\n            base:     {empty: true, parent: ' head '},\n            bdo:      {},\n            big:      {},\n            blockquote: {},\n            body:     {parent: ' html noframes '},\n            br:       {empty: true},\n            button:   {},\n            canvas:   {parent: ' body p div th td '},\n            caption:  {parent: ' table '},\n            center:   {},\n            cite:     {},\n            code:     {},\n            col:      {empty: true, parent: ' table colgroup '},\n            colgroup: {parent: ' table '},\n            command:  {parent: ' menu '},\n            datalist: {},\n            dd:       {parent: ' dl '},\n            del:      {},\n            details:  {},\n            dialog:   {},\n            dfn:      {},\n            dir:      {},\n            div:      {},\n            dl:       {},\n            dt:       {parent: ' dl '},\n            em:       {},\n            embed:    {},\n            fieldset: {},\n            figcaption: {parent: ' figure '},\n            figure:   {},\n            font:     {},\n            footer:   {},\n            form:     {},\n            frame:    {empty: true, parent: ' frameset '},\n            frameset: {parent: ' html frameset '},\n            h1:       {},\n            h2:       {},\n            h3:       {},\n            h4:       {},\n            h5:       {},\n            h6:       {},\n            head:     {parent: ' html '},\n            header:   {},\n            hgroup:   {},\n            hr:       {empty: true},\n            'hta:application':\n                      {empty: true, parent: ' head '},\n            html:     {parent: '*'},\n            i:        {},\n            iframe:   {},\n            img:      {empty: true},\n            input:    {empty: true},\n            ins:      {},\n            kbd:      {},\n            keygen:   {},\n            label:    {},\n            legend:   {parent: ' details fieldset figure '},\n            li:       {parent: ' dir menu ol ul '},\n            link:     {empty: true, parent: ' head '},\n            map:      {},\n            mark:     {},\n            menu:     {},\n            meta:     {empty: true, parent: ' head noframes noscript '},\n            meter:    {},\n            nav:      {},\n            noframes: {parent: ' html body '},\n            noscript: {parent: ' body head noframes '},\n            object:   {},\n            ol:       {},\n            optgroup: {parent: ' select '},\n            option:   {parent: ' optgroup select '},\n            output:   {},\n            p:        {},\n            param:    {empty: true, parent: ' applet object '},\n            pre:      {},\n            progress: {},\n            q:        {},\n            rp:       {},\n            rt:       {},\n            ruby:     {},\n            samp:     {},\n            script:   {empty: true, parent: ' body div frame head iframe p pre span '},\n            section:  {},\n            select:   {},\n            small:    {},\n            span:     {},\n            source:   {},\n            strong:   {},\n            style:    {parent: ' head ', empty: true},\n            sub:      {},\n            summary:  {parent: ' details '},\n            sup:      {},\n            table:    {},\n            tbody:    {parent: ' table '},\n            td:       {parent: ' tr '},\n            textarea: {},\n            tfoot:    {parent: ' table '},\n            th:       {parent: ' tr '},\n            thead:    {parent: ' table '},\n            time:     {},\n            title:    {parent: ' head '},\n            tr:       {parent: ' table tbody thead tfoot '},\n            tt:       {},\n            u:        {},\n            ul:       {},\n            'var':    {},\n            video:    {}\n        },\n\n        ids,            // HTML ids\n        in_block,\n        indent,\n        itself,         // JSLint itself\n        json_mode,\n        lex,            // the tokenizer\n        lines,\n        lookahead,\n        node = array_to_object([\n            'Buffer', 'clearInterval', 'clearTimeout', 'console', 'exports',\n            'global', 'module', 'process', 'querystring', 'require',\n            'setInterval', 'setTimeout', '__dirname', '__filename'\n        ], false),\n        node_js,\n        numbery = array_to_object(['indexOf', 'lastIndexOf', 'search'], true),\n        next_token,\n        option,\n        predefined,     // Global variables defined by option\n        prereg,\n        prev_token,\n        property,\n        regexp_flag = array_to_object(['g', 'i', 'm'], true),\n        return_this = function return_this() {\n            return this;\n        },\n        rhino = array_to_object([\n            'defineClass', 'deserialize', 'gc', 'help', 'load', 'loadClass',\n            'print', 'quit', 'readFile', 'readUrl', 'runCommand', 'seal',\n            'serialize', 'spawn', 'sync', 'toint32', 'version'\n        ], false),\n\n        scope,      // An object containing an object for each variable in scope\n        semicolon_coda = array_to_object([';', '\"', '\\'', ')'], true),\n        src,\n        stack,\n\n// standard contains the global names that are provided by the\n// ECMAScript standard.\n\n        standard = array_to_object([\n            'Array', 'Boolean', 'Date', 'decodeURI', 'decodeURIComponent',\n            'encodeURI', 'encodeURIComponent', 'Error', 'eval', 'EvalError',\n            'Function', 'isFinite', 'isNaN', 'JSON', 'Math', 'Number',\n            'Object', 'parseInt', 'parseFloat', 'RangeError', 'ReferenceError',\n            'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError'\n        ], false),\n\n        strict_mode,\n        syntax = {},\n        tab,\n        token,\n        urls,\n        var_mode,\n        warnings,\n\n        windows = array_to_object([\n            'ActiveXObject', 'CScript', 'Debug', 'Enumerator', 'System',\n            'VBArray', 'WScript', 'WSH'\n        ], false),\n\n//  xmode is used to adapt to the exceptions in html parsing.\n//  It can have these states:\n//      ''      .js script file\n//      'html'\n//      'outer'\n//      'script'\n//      'style'\n//      'scriptstring'\n//      'styleproperty'\n\n        xmode,\n        xquote,\n\n// Regular expressions. Some of these are stupidly long.\n\n// unsafe comment or string\n        ax = /@cc|<\\/?|script|\\]\\s*\\]|<\\s*!|&lt/i,\n// carriage return, carriage return linefeed, or linefeed\n        crlfx = /\\r\\n?|\\n/,\n// unsafe characters that are silently deleted by one or more browsers\n        cx = /[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n// query characters for ids\n        dx = /[\\[\\]\\/\\\\\"'*<>.&:(){}+=#]/,\n// html token\n        hx = /^\\s*(['\"=>\\/&#]|<(?:\\/|\\!(?:--)?)?|[a-zA-Z][a-zA-Z0-9_\\-:]*|[0-9]+|--)/,\n// identifier\n        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,\n// javascript url\n        jx = /^(?:javascript|jscript|ecmascript|vbscript|mocha|livescript)\\s*:/i,\n// star slash\n        lx = /\\*\\/|\\/\\*/,\n// characters in strings that need escapement\n        nx = /[\\u0000-\\u001f'\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n// outer html token\n        ox = /[>&]|<[\\/!]?|--/,\n// attributes characters\n        qx = /[^a-zA-Z0-9+\\-_\\/. ]/,\n// style\n        ssx = /^\\s*([@#!\"'};:\\-%.=,+\\[\\]()*_]|[a-zA-Z][a-zA-Z0-9._\\-]*|\\/\\*?|\\d+(?:\\.\\d+)?|<\\/)/,\n        sx = /^\\s*([{}:#%.=,>+\\[\\]@()\"';]|[*$\\^~]=|[a-zA-Z_][a-zA-Z0-9_\\-]*|[0-9]+|<\\/|\\/\\*)/,\n\n// sync\n        syx = /Sync$/,\n// comment todo\n        tox = /^\\W*to\\s*do(?:\\W|$)/i,\n// token\n        tx = /^\\s*([(){}\\[\\]\\?.,:;'\"~#@`]|={1,3}|\\/(\\*(jslint|properties|property|members?|globals?)?|=|\\/)?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|[\\^%]=?|&[&=]?|\\|[|=]?|>{1,3}=?|<(?:[\\/=!]|\\!(\\[|--)?|<=?)?|\\!(\\!|==?)?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+(?:[xX][0-9a-fA-F]+|\\.[0-9]*)?(?:[eE][+\\-]?[0-9]+)?)/,\n// url badness\n        ux = /&|\\+|\\u00AD|\\.\\.|\\/\\*|%[^;]|base64|url|expression|data|mailto|script/i,\n\n        rx = {\n            outer: hx,\n            html: hx,\n            style: sx,\n            styleproperty: ssx\n        };\n\n\n    function F() {}     // Used by Object.create\n\n// Provide critical ES5 functions to ES3.\n\n    if (typeof Array.prototype.filter !== 'function') {\n        Array.prototype.filter = function (f) {\n            var i, length = this.length, result = [], value;\n            for (i = 0; i < length; i += 1) {\n                try {\n                    value = this[i];\n                    if (f(value)) {\n                        result.push(value);\n                    }\n                } catch (ignore) {\n                }\n            }\n            return result;\n        };\n    }\n\n    if (typeof Array.prototype.forEach !== 'function') {\n        Array.prototype.forEach = function (f) {\n            var i, length = this.length;\n            for (i = 0; i < length; i += 1) {\n                try {\n                    f(this[i]);\n                } catch (ignore) {\n                }\n            }\n        };\n    }\n\n    if (typeof Array.isArray !== 'function') {\n        Array.isArray = function (o) {\n            return Object.prototype.toString.apply(o) === '[object Array]';\n        };\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(Object, 'create')) {\n        Object.create = function (o) {\n            F.prototype = o;\n            return new F();\n        };\n    }\n\n    if (typeof Object.keys !== 'function') {\n        Object.keys = function (o) {\n            var array = [], key;\n            for (key in o) {\n                if (Object.prototype.hasOwnProperty.call(o, key)) {\n                    array.push(key);\n                }\n            }\n            return array;\n        };\n    }\n\n    if (typeof String.prototype.entityify !== 'function') {\n        String.prototype.entityify = function () {\n            return this\n                .replace(/&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;');\n        };\n    }\n\n    if (typeof String.prototype.isAlpha !== 'function') {\n        String.prototype.isAlpha = function () {\n            return (this >= 'a' && this <= 'z\\uffff') ||\n                (this >= 'A' && this <= 'Z\\uffff');\n        };\n    }\n\n    if (typeof String.prototype.isDigit !== 'function') {\n        String.prototype.isDigit = function () {\n            return (this >= '0' && this <= '9');\n        };\n    }\n\n    if (typeof String.prototype.supplant !== 'function') {\n        String.prototype.supplant = function (o) {\n            return this.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n                var replacement = o[b];\n                return typeof replacement === 'string' ||\n                    typeof replacement === 'number' ? replacement : a;\n            });\n        };\n    }\n\n\n    function sanitize(a) {\n\n//  Escapify a troublesome character.\n\n        return escapes[a] ||\n            '\\\\u' + ('0000' + a.charCodeAt().toString(16)).slice(-4);\n    }\n\n\n    function add_to_predefined(group) {\n        Object.keys(group).forEach(function (name) {\n            predefined[name] = group[name];\n        });\n    }\n\n\n    function assume() {\n        if (!option.safe) {\n            if (option.rhino) {\n                add_to_predefined(rhino);\n                option.rhino = false;\n            }\n            if (option.devel) {\n                add_to_predefined(devel);\n                option.devel = false;\n            }\n            if (option.browser) {\n                add_to_predefined(browser);\n                option.browser = false;\n            }\n            if (option.windows) {\n                add_to_predefined(windows);\n                option.windows = false;\n            }\n            if (option.node) {\n                add_to_predefined(node);\n                option.node = false;\n                node_js = true;\n            }\n        }\n    }\n\n\n// Produce an error warning.\n\n    function artifact(tok) {\n        if (!tok) {\n            tok = next_token;\n        }\n        return tok.number || tok.string;\n    }\n\n    function quit(message, line, character) {\n        throw {\n            name: 'JSLintError',\n            line: line,\n            character: character,\n            message: bundle.scanned_a_b.supplant({\n                a: message,\n                b: Math.floor((line / lines.length) * 100)\n            })\n        };\n    }\n\n    function warn(message, offender, a, b, c, d) {\n        var character, line, warning;\n        offender = offender || next_token;  // ~~\n        line = offender.line || 0;\n        character = offender.from || 0;\n        warning = {\n            id: '(error)',\n            raw: bundle[message] || message,\n            evidence: lines[line - 1] || '',\n            line: line,\n            character: character,\n            a: a || (offender.id === '(number)'\n                ? String(offender.number)\n                : offender.string),\n            b: b,\n            c: c,\n            d: d\n        };\n        warning.reason = warning.raw.supplant(warning);\n        JSLINT.errors.push(warning);\n        if (option.passfail) {\n            quit(bundle.stopping, line, character);\n        }\n        warnings += 1;\n        if (warnings >= option.maxerr) {\n            quit(bundle.too_many, line, character);\n        }\n        return warning;\n    }\n\n    function warn_at(message, line, character, a, b, c, d) {\n        return warn(message, {\n            line: line,\n            from: character\n        }, a, b, c, d);\n    }\n\n    function stop(message, offender, a, b, c, d) {\n        var warning = warn(message, offender, a, b, c, d);\n        quit(bundle.stopping, warning.line, warning.character);\n    }\n\n    function stop_at(message, line, character, a, b, c, d) {\n        return stop(message, {\n            line: line,\n            from: character\n        }, a, b, c, d);\n    }\n\n    function expected_at(at) {\n        if (!option.white && next_token.from !== at) {\n            warn('expected_a_at_b_c', next_token, '', at,\n                next_token.from);\n        }\n    }\n\n    function aint(it, name, expected) {\n        if (it[name] !== expected) {\n            warn('expected_a_b', it, expected, it[name]);\n            return true;\n        }\n        return false;\n    }\n\n\n// lexical analysis and token construction\n\n    lex = (function lex() {\n        var character, c, from, length, line, pos, source_row;\n\n// Private lex methods\n\n        function next_line() {\n            var at;\n            if (line >= lines.length) {\n                return false;\n            }\n            character = 1;\n            source_row = lines[line];\n            line += 1;\n            at = source_row.search(/\\t/);\n            if (at >= 0) {\n                if (option.white) {\n                    source_row = source_row.replace(/\\t/g, ' ');\n                } else {\n                    warn_at('use_spaces', line, at + 1);\n                }\n            }\n            at = source_row.search(cx);\n            if (at >= 0) {\n                warn_at('unsafe', line, at);\n            }\n            if (option.maxlen && option.maxlen < source_row.length) {\n                warn_at('too_long', line, source_row.length);\n            }\n            return true;\n        }\n\n// Produce a token object.  The token inherits from a syntax symbol.\n\n        function it(type, value) {\n            var id, the_token;\n            if (type === '(string)' || type === '(range)') {\n                if (jx.test(value)) {\n                    warn_at('url', line, from);\n                }\n            }\n            the_token = Object.create(syntax[(\n                type === '(punctuator)' || (type === '(identifier)' &&\n                        Object.prototype.hasOwnProperty.call(syntax, value))\n                    ? value\n                    : type\n            )] || syntax['(error)']);\n            if (type === '(identifier)') {\n                the_token.identifier = true;\n                if (value === '__iterator__' || value === '__proto__') {\n                    stop_at('reserved_a', line, from, value);\n                } else if (!option.nomen &&\n                        (value.charAt(0) === '_' ||\n                        value.charAt(value.length - 1) === '_')) {\n                    warn_at('dangling_a', line, from, value);\n                }\n            }\n            if (type === '(number)') {\n                the_token.number = +value;\n            } else if (value !== undefined) {\n                the_token.string = String(value);\n            }\n            the_token.line = line;\n            the_token.from = from;\n            the_token.thru = character;\n            id = the_token.id;\n            prereg = id && (\n                ('(,=:[!&|?{};~+-*%^<>'.indexOf(id.charAt(id.length - 1)) >= 0) ||\n                id === 'return' || id === 'case'\n            );\n            return the_token;\n        }\n\n        function match(x) {\n            var exec = x.exec(source_row), first;\n            if (exec) {\n                length = exec[0].length;\n                first = exec[1];\n                c = first.charAt(0);\n                source_row = source_row.slice(length);\n                from = character + length - first.length;\n                character += length;\n                return first;\n            }\n        }\n\n        function string(x) {\n            var c, pos = 0, r = '', result;\n\n            function hex(n) {\n                var i = parseInt(source_row.substr(pos + 1, n), 16);\n                pos += n;\n                if (i >= 32 && i <= 126 &&\n                        i !== 34 && i !== 92 && i !== 39) {\n                    warn_at('unexpected_a', line, character, '\\\\');\n                }\n                character += n;\n                c = String.fromCharCode(i);\n            }\n\n            if (json_mode && x !== '\"') {\n                warn_at('expected_a', line, character, '\"');\n            }\n\n            if (xquote === x || (xmode === 'scriptstring' && !xquote)) {\n                return it('(punctuator)', x);\n            }\n\n            for (;;) {\n                while (pos >= source_row.length) {\n                    pos = 0;\n                    if (xmode !== 'html' || !next_line()) {\n                        stop_at('unclosed', line, from);\n                    }\n                }\n                c = source_row.charAt(pos);\n                if (c === x) {\n                    character += 1;\n                    source_row = source_row.slice(pos + 1);\n                    result = it('(string)', r);\n                    result.quote = x;\n                    return result;\n                }\n                if (c < ' ') {\n                    if (c === '\\n' || c === '\\r') {\n                        break;\n                    }\n                    warn_at('control_a', line, character + pos,\n                        source_row.slice(0, pos));\n                } else if (c === xquote) {\n                    warn_at('bad_html', line, character + pos);\n                } else if (c === '<') {\n                    if (option.safe && xmode === 'html') {\n                        warn_at('adsafe_a', line, character + pos, c);\n                    } else if (source_row.charAt(pos + 1) === '/' && (xmode || option.safe)) {\n                        warn_at('expected_a_b', line, character,\n                            '<\\\\/', '</');\n                    } else if (source_row.charAt(pos + 1) === '!' && (xmode || option.safe)) {\n                        warn_at('unexpected_a', line, character, '<!');\n                    }\n                } else if (c === '\\\\') {\n                    if (xmode === 'html') {\n                        if (option.safe) {\n                            warn_at('adsafe_a', line, character + pos, c);\n                        }\n                    } else if (xmode === 'styleproperty') {\n                        pos += 1;\n                        character += 1;\n                        c = source_row.charAt(pos);\n                        if (c !== x) {\n                            warn_at('unexpected_a', line, character, '\\\\');\n                        }\n                    } else {\n                        pos += 1;\n                        character += 1;\n                        c = source_row.charAt(pos);\n                        switch (c) {\n                        case '':\n                            if (!option.es5) {\n                                warn_at('es5', line, character);\n                            }\n                            next_line();\n                            pos = -1;\n                            break;\n                        case xquote:\n                            warn_at('bad_html', line, character + pos);\n                            break;\n                        case '\\'':\n                            if (json_mode) {\n                                warn_at('unexpected_a', line, character, '\\\\\\'');\n                            }\n                            break;\n                        case 'u':\n                            hex(4);\n                            break;\n                        case 'v':\n                            if (json_mode) {\n                                warn_at('unexpected_a', line, character, '\\\\v');\n                            }\n                            c = '\\v';\n                            break;\n                        case 'x':\n                            if (json_mode) {\n                                warn_at('unexpected_a', line, character, '\\\\x');\n                            }\n                            hex(2);\n                            break;\n                        default:\n                            if (typeof descapes[c] !== 'string') {\n                                warn_at(c >= '0' && c <= '7' ? 'octal_a' : 'unexpected_a',\n                                    line, character, '\\\\' + c);\n                            } else {\n                                c = descapes[c];\n                            }\n                        }\n                    }\n                }\n                r += c;\n                character += 1;\n                pos += 1;\n            }\n        }\n\n        function number(snippet) {\n            var digit;\n            if (xmode !== 'style' && xmode !== 'styleproperty' &&\n                    source_row.charAt(0).isAlpha()) {\n                warn_at('expected_space_a_b',\n                    line, character, c, source_row.charAt(0));\n            }\n            if (c === '0') {\n                digit = snippet.charAt(1);\n                if (digit.isDigit()) {\n                    if (token.id !== '.' && xmode !== 'styleproperty') {\n                        warn_at('unexpected_a', line, character, snippet);\n                    }\n                } else if (json_mode && (digit === 'x' || digit === 'X')) {\n                    warn_at('unexpected_a', line, character, '0x');\n                }\n            }\n            if (snippet.slice(snippet.length - 1) === '.') {\n                warn_at('trailing_decimal_a', line, character, snippet);\n            }\n            if (xmode !== 'style') {\n                digit = +snippet;\n                if (!isFinite(digit)) {\n                    warn_at('bad_number', line, character, snippet);\n                }\n                snippet = digit;\n            }\n            return it('(number)', snippet);\n        }\n\n        function comment(snippet) {\n            if (comments_off || src || (xmode && xmode !== 'script' &&\n                    xmode !== 'style' && xmode !== 'styleproperty')) {\n                warn_at('unexpected_comment', line, character);\n            } else if (xmode === 'script' && /<\\//i.test(source_row)) {\n                warn_at('unexpected_a', line, character, '<\\/');\n            } else if (option.safe && ax.test(snippet)) {\n                warn_at('dangerous_comment', line, character);\n            } else if (!option.todo && tox.test(snippet)) {\n                warn_at('todo_comment', line, character);\n            }\n        }\n\n        function regexp() {\n            var b,\n                bit,\n                captures = 0,\n                depth = 0,\n                flag = '',\n                high,\n                letter,\n                length = 0,\n                low,\n                potential,\n                quote,\n                result;\n            for (;;) {\n                b = true;\n                c = source_row.charAt(length);\n                length += 1;\n                switch (c) {\n                case '':\n                    stop_at('unclosed_regexp', line, from);\n                    return;\n                case '/':\n                    if (depth > 0) {\n                        warn_at('unescaped_a', line, from + length, '/');\n                    }\n                    c = source_row.slice(0, length - 1);\n                    potential = Object.create(regexp_flag);\n                    for (;;) {\n                        letter = source_row.charAt(length);\n                        if (potential[letter] !== true) {\n                            break;\n                        }\n                        potential[letter] = false;\n                        length += 1;\n                        flag += letter;\n                    }\n                    if (source_row.charAt(length).isAlpha()) {\n                        stop_at('unexpected_a', line, from, source_row.charAt(length));\n                    }\n                    character += length;\n                    source_row = source_row.slice(length);\n                    quote = source_row.charAt(0);\n                    if (quote === '/' || quote === '*') {\n                        stop_at('confusing_regexp', line, from);\n                    }\n                    result = it('(regexp)', c);\n                    result.flag = flag;\n                    return result;\n                case '\\\\':\n                    c = source_row.charAt(length);\n                    if (c < ' ') {\n                        warn_at('control_a', line, from + length, String(c));\n                    } else if (c === '<') {\n                        warn_at(bundle.unexpected_a, line, from + length, '\\\\');\n                    }\n                    length += 1;\n                    break;\n                case '(':\n                    depth += 1;\n                    b = false;\n                    if (source_row.charAt(length) === '?') {\n                        length += 1;\n                        switch (source_row.charAt(length)) {\n                        case ':':\n                        case '=':\n                        case '!':\n                            length += 1;\n                            break;\n                        default:\n                            warn_at(bundle.expected_a_b, line, from + length,\n                                ':', source_row.charAt(length));\n                        }\n                    } else {\n                        captures += 1;\n                    }\n                    break;\n                case '|':\n                    b = false;\n                    break;\n                case ')':\n                    if (depth === 0) {\n                        warn_at('unescaped_a', line, from + length, ')');\n                    } else {\n                        depth -= 1;\n                    }\n                    break;\n                case ' ':\n                    pos = 1;\n                    while (source_row.charAt(length) === ' ') {\n                        length += 1;\n                        pos += 1;\n                    }\n                    if (pos > 1) {\n                        warn_at('use_braces', line, from + length, pos);\n                    }\n                    break;\n                case '[':\n                    c = source_row.charAt(length);\n                    if (c === '^') {\n                        length += 1;\n                        if (!option.regexp) {\n                            warn_at('insecure_a', line, from + length, c);\n                        } else if (source_row.charAt(length) === ']') {\n                            stop_at('unescaped_a', line, from + length, '^');\n                        }\n                    }\n                    bit = false;\n                    if (c === ']') {\n                        warn_at('empty_class', line, from + length - 1);\n                        bit = true;\n                    }\nklass:              do {\n                        c = source_row.charAt(length);\n                        length += 1;\n                        switch (c) {\n                        case '[':\n                        case '^':\n                            warn_at('unescaped_a', line, from + length, c);\n                            bit = true;\n                            break;\n                        case '-':\n                            if (bit) {\n                                bit = false;\n                            } else {\n                                warn_at('unescaped_a', line, from + length, '-');\n                                bit = true;\n                            }\n                            break;\n                        case ']':\n                            if (!bit) {\n                                warn_at('unescaped_a', line, from + length - 1, '-');\n                            }\n                            break klass;\n                        case '\\\\':\n                            c = source_row.charAt(length);\n                            if (c < ' ') {\n                                warn_at(bundle.control_a, line, from + length, String(c));\n                            } else if (c === '<') {\n                                warn_at(bundle.unexpected_a, line, from + length, '\\\\');\n                            }\n                            length += 1;\n                            bit = true;\n                            break;\n                        case '/':\n                            warn_at('unescaped_a', line, from + length - 1, '/');\n                            bit = true;\n                            break;\n                        case '<':\n                            if (xmode === 'script') {\n                                c = source_row.charAt(length);\n                                if (c === '!' || c === '/') {\n                                    warn_at(bundle.html_confusion_a, line,\n                                        from + length, c);\n                                }\n                            }\n                            bit = true;\n                            break;\n                        default:\n                            bit = true;\n                        }\n                    } while (c);\n                    break;\n                case '.':\n                    if (!option.regexp) {\n                        warn_at('insecure_a', line, from + length, c);\n                    }\n                    break;\n                case ']':\n                case '?':\n                case '{':\n                case '}':\n                case '+':\n                case '*':\n                    warn_at('unescaped_a', line, from + length, c);\n                    break;\n                case '<':\n                    if (xmode === 'script') {\n                        c = source_row.charAt(length);\n                        if (c === '!' || c === '/') {\n                            warn_at(bundle.html_confusion_a, line, from + length, c);\n                        }\n                    }\n                    break;\n                }\n                if (b) {\n                    switch (source_row.charAt(length)) {\n                    case '?':\n                    case '+':\n                    case '*':\n                        length += 1;\n                        if (source_row.charAt(length) === '?') {\n                            length += 1;\n                        }\n                        break;\n                    case '{':\n                        length += 1;\n                        c = source_row.charAt(length);\n                        if (c < '0' || c > '9') {\n                            warn_at(bundle.expected_number_a, line,\n                                from + length, c);\n                        }\n                        length += 1;\n                        low = +c;\n                        for (;;) {\n                            c = source_row.charAt(length);\n                            if (c < '0' || c > '9') {\n                                break;\n                            }\n                            length += 1;\n                            low = +c + (low * 10);\n                        }\n                        high = low;\n                        if (c === ',') {\n                            length += 1;\n                            high = Infinity;\n                            c = source_row.charAt(length);\n                            if (c >= '0' && c <= '9') {\n                                length += 1;\n                                high = +c;\n                                for (;;) {\n                                    c = source_row.charAt(length);\n                                    if (c < '0' || c > '9') {\n                                        break;\n                                    }\n                                    length += 1;\n                                    high = +c + (high * 10);\n                                }\n                            }\n                        }\n                        if (source_row.charAt(length) !== '}') {\n                            warn_at(bundle.expected_a_b, line, from + length,\n                                '}', c);\n                        } else {\n                            length += 1;\n                        }\n                        if (source_row.charAt(length) === '?') {\n                            length += 1;\n                        }\n                        if (low > high) {\n                            warn_at(bundle.not_greater, line, from + length,\n                                low, high);\n                        }\n                        break;\n                    }\n                }\n            }\n            c = source_row.slice(0, length - 1);\n            character += length;\n            source_row = source_row.slice(length);\n            return it('(regexp)', c);\n        }\n\n// Public lex methods\n\n        return {\n            init: function (source) {\n                if (typeof source === 'string') {\n                    lines = source.split(crlfx);\n                } else {\n                    lines = source;\n                }\n                line = 0;\n                next_line();\n                from = 1;\n            },\n\n            range: function (begin, end) {\n                var c, value = '';\n                from = character;\n                if (source_row.charAt(0) !== begin) {\n                    stop_at('expected_a_b', line, character, begin,\n                        source_row.charAt(0));\n                }\n                for (;;) {\n                    source_row = source_row.slice(1);\n                    character += 1;\n                    c = source_row.charAt(0);\n                    switch (c) {\n                    case '':\n                        stop_at('missing_a', line, character, c);\n                        break;\n                    case end:\n                        source_row = source_row.slice(1);\n                        character += 1;\n                        return it('(range)', value);\n                    case xquote:\n                    case '\\\\':\n                        warn_at('unexpected_a', line, character, c);\n                        break;\n                    }\n                    value += c;\n                }\n            },\n\n// token -- this is called by advance to get the next token.\n\n            token: function () {\n                var c, i, snippet;\n\n                for (;;) {\n                    while (!source_row) {\n                        if (!next_line()) {\n                            return it('(end)');\n                        }\n                    }\n                    while (xmode === 'outer') {\n                        i = source_row.search(ox);\n                        if (i === 0) {\n                            break;\n                        } else if (i > 0) {\n                            character += i;\n                            source_row = source_row.slice(i);\n                            break;\n                        } else {\n                            if (!next_line()) {\n                                return it('(end)', '');\n                            }\n                        }\n                    }\n                    snippet = match(rx[xmode] || tx);\n                    if (!snippet) {\n                        if (source_row) {\n                            if (source_row.charAt(0) === ' ') {\n                                if (!option.white) {\n                                    warn_at('unexpected_a', line, character,\n                                        '(space)');\n                                }\n                                character += 1;\n                                source_row = '';\n                            } else {\n                                stop_at('unexpected_a', line, character,\n                                    source_row.charAt(0));\n                            }\n                        }\n                    } else {\n\n//      identifier\n\n                        c = snippet.charAt(0);\n                        if (c.isAlpha() || c === '_' || c === '$') {\n                            return it('(identifier)', snippet);\n                        }\n\n//      number\n\n                        if (c.isDigit()) {\n                            return number(snippet);\n                        }\n                        switch (snippet) {\n\n//      string\n\n                        case '\"':\n                        case \"'\":\n                            return string(snippet);\n\n//      // comment\n\n                        case '//':\n                            comment(source_row);\n                            source_row = '';\n                            break;\n\n//      /* comment\n\n                        case '/*':\n                            for (;;) {\n                                i = source_row.search(lx);\n                                if (i >= 0) {\n                                    break;\n                                }\n                                comment(source_row);\n                                if (!next_line()) {\n                                    stop_at('unclosed_comment', line, character);\n                                }\n                            }\n                            comment(source_row.slice(0, i));\n                            character += i + 2;\n                            if (source_row.charAt(i) === '/') {\n                                stop_at('nested_comment', line, character);\n                            }\n                            source_row = source_row.slice(i + 2);\n                            break;\n\n                        case '':\n                            break;\n//      /\n                        case '/':\n                            if (token.id === '/=') {\n                                stop_at(\n                                    bundle.slash_equal,\n                                    line,\n                                    from\n                                );\n                            }\n                            return prereg\n                                ? regexp()\n                                : it('(punctuator)', snippet);\n\n//      punctuator\n\n                        case '<!--':\n                            length = line;\n//                            c = character;\n                            for (;;) {\n                                i = source_row.indexOf('--');\n                                if (i >= 0) {\n                                    break;\n                                }\n                                i = source_row.indexOf('<!');\n                                if (i >= 0) {\n                                    stop_at('nested_comment',\n                                        line, character + i);\n                                }\n                                if (!next_line()) {\n                                    stop_at('unclosed_comment', length, c);\n                                }\n                            }\n                            length = source_row.indexOf('<!');\n                            if (length >= 0 && length < i) {\n                                stop_at('nested_comment',\n                                    line, character + length);\n                            }\n                            character += i;\n                            if (source_row.charAt(i + 2) !== '>') {\n                                stop_at('expected_a', line, character, '-->');\n                            }\n                            character += 3;\n                            source_row = source_row.slice(i + 3);\n                            break;\n                        case '#':\n                            if (xmode === 'html' || xmode === 'styleproperty') {\n                                for (;;) {\n                                    c = source_row.charAt(0);\n                                    if ((c < '0' || c > '9') &&\n                                            (c < 'a' || c > 'f') &&\n                                            (c < 'A' || c > 'F')) {\n                                        break;\n                                    }\n                                    character += 1;\n                                    source_row = source_row.slice(1);\n                                    snippet += c;\n                                }\n                                if (snippet.length !== 4 && snippet.length !== 7) {\n                                    warn_at('bad_color_a', line,\n                                        from + length, snippet);\n                                }\n                                return it('(color)', snippet);\n                            }\n                            return it('(punctuator)', snippet);\n\n                        default:\n                            if (xmode === 'outer' && c === '&') {\n                                character += 1;\n                                source_row = source_row.slice(1);\n                                for (;;) {\n                                    c = source_row.charAt(0);\n                                    character += 1;\n                                    source_row = source_row.slice(1);\n                                    if (c === ';') {\n                                        break;\n                                    }\n                                    if (!((c >= '0' && c <= '9') ||\n                                            (c >= 'a' && c <= 'z') ||\n                                            c === '#')) {\n                                        stop_at('bad_entity', line, from + length,\n                                            character);\n                                    }\n                                }\n                                break;\n                            }\n                            return it('(punctuator)', snippet);\n                        }\n                    }\n                }\n            }\n        };\n    }());\n\n\n    function add_label(token, kind, name) {\n\n// Define the symbol in the current function in the current scope.\n\n        name = name || token.string;\n\n// Global variables cannot be created in the safe subset. If a global variable\n// already exists, do nothing. If it is predefined, define it.\n\n        if (funct === global_funct) {\n            if (option.safe) {\n                warn('adsafe_a', token, name);\n            }\n            if (typeof global_funct[name] !== 'string') {\n                token.writeable = typeof predefined[name] === 'boolean'\n                    ? predefined[name]\n                    : true;\n                token.funct = funct;\n                global_scope[name] = token;\n            }\n            if (kind === 'becoming') {\n                kind = 'var';\n            }\n\n// Ordinary variables.\n\n        } else {\n\n// Warn if the variable already exists.\n\n            if (typeof funct[name] === 'string') {\n                if (funct[name] === 'undef') {\n                    if (!option.undef) {\n                        warn('used_before_a', token, name);\n                    }\n                    kind = 'var';\n                } else {\n                    warn('already_defined', token, name);\n                }\n            } else {\n\n// Add the symbol to the current function.\n\n                token.funct = funct;\n                token.writeable = true;\n                scope[name] = token;\n            }\n        }\n        funct[name] = kind;\n    }\n\n\n    function peek(distance) {\n\n// Peek ahead to a future token. The distance is how far ahead to look. The\n// default is the next token.\n\n        var found, slot = 0;\n\n        distance = distance || 0;\n        while (slot <= distance) {\n            found = lookahead[slot];\n            if (!found) {\n                found = lookahead[slot] = lex.token();\n            }\n            slot += 1;\n        }\n        return found;\n    }\n\n\n    function advance(id, match) {\n\n// Produce the next token, also looking for programming errors.\n\n        if (indent) {\n\n// If indentation checking was requested, then inspect all of the line breakings.\n// The var statement is tricky because the names might be aligned or not. We\n// look at the first line break after the var to determine the programmer's\n// intention.\n\n            if (var_mode && next_token.line !== token.line) {\n                if ((var_mode !== indent || !next_token.edge) &&\n                        next_token.from === indent.at -\n                        (next_token.edge ? option.indent : 0)) {\n                    var dent = indent;\n                    for (;;) {\n                        dent.at -= option.indent;\n                        if (dent === var_mode) {\n                            break;\n                        }\n                        dent = dent.was;\n                    }\n                    dent.open = false;\n                }\n                var_mode = null;\n            }\n            if (next_token.id === '?' && indent.mode === ':' &&\n                    token.line !== next_token.line) {\n                indent.at -= option.indent;\n            }\n            if (indent.open) {\n\n// If the token is an edge.\n\n                if (next_token.edge) {\n                    if (next_token.edge === 'label') {\n                        expected_at(1);\n                    } else if (next_token.edge === 'case' || indent.mode === 'statement') {\n                        expected_at(indent.at - option.indent);\n                    } else if (indent.mode !== 'array' || next_token.line !== token.line) {\n                        expected_at(indent.at);\n                    }\n\n// If the token is not an edge, but is the first token on the line.\n\n                } else if (next_token.line !== token.line) {\n                    if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                    indent.wrap = true;\n                }\n            } else if (next_token.line !== token.line) {\n                if (next_token.edge) {\n                    expected_at(indent.at);\n                } else {\n                    indent.wrap = true;\n                    if (indent.mode === 'statement' || indent.mode === 'var') {\n                        expected_at(indent.at + option.indent);\n                    } else if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                }\n            }\n        }\n\n        switch (token.id) {\n        case '(number)':\n            if (next_token.id === '.') {\n                warn('trailing_decimal_a');\n            }\n            break;\n        case '-':\n            if (next_token.id === '-' || next_token.id === '--') {\n                warn('confusing_a');\n            }\n            break;\n        case '+':\n            if (next_token.id === '+' || next_token.id === '++') {\n                warn('confusing_a');\n            }\n            break;\n        }\n        if (token.id === '(string)' || token.identifier) {\n            anonname = token.string;\n        }\n\n        if (id && next_token.id !== id) {\n            if (match) {\n                warn('expected_a_b_from_c_d', next_token, id,\n                    match.id, match.line, artifact());\n            } else if (!next_token.identifier || next_token.string !== id) {\n                warn('expected_a_b', next_token, id, artifact());\n            }\n        }\n        prev_token = token;\n        token = next_token;\n        next_token = lookahead.shift() || lex.token();\n    }\n\n\n    function advance_identifier(string) {\n        if (next_token.identifier && next_token.string === string) {\n            advance();\n        } else {\n            warn('expected_a_b', next_token, string, artifact());\n        }\n    }\n\n\n    function do_safe() {\n        if (option.adsafe) {\n            option.safe = true;\n        }\n        if (option.safe) {\n            option.browser     =\n                option['continue'] =\n                option.css     =\n                option.debug   =\n                option.devel   =\n                option.evil    =\n                option.forin   =\n                option.newcap  =\n                option.nomen   =\n                option.on      =\n                option.rhino   =\n                option.sloppy  =\n                option.sub     =\n                option.undef   =\n                option.windows = false;\n\n\n            delete predefined.Array;\n            delete predefined.Date;\n            delete predefined.Function;\n            delete predefined.Object;\n            delete predefined['eval'];\n\n            add_to_predefined({\n                ADSAFE: false,\n                lib: false\n            });\n        }\n    }\n\n\n    function do_globals() {\n        var name, writeable;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            writeable = false;\n            if (next_token.id === ':') {\n                advance(':');\n                switch (next_token.id) {\n                case 'true':\n                    writeable = predefined[name] !== false;\n                    advance('true');\n                    break;\n                case 'false':\n                    advance('false');\n                    break;\n                default:\n                    stop('unexpected_a');\n                }\n            }\n            predefined[name] = writeable;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    function do_jslint() {\n        var name, value;\n        while (next_token.id === '(string)' || next_token.identifier) {\n            name = next_token.string;\n            if (!allowed_option[name]) {\n                stop('unexpected_a');\n            }\n            advance();\n            if (next_token.id !== ':') {\n                stop('expected_a_b', next_token, ':', artifact());\n            }\n            advance(':');\n            if (typeof allowed_option[name] === 'number') {\n                value = next_token.number;\n                if (value > allowed_option[name] || value <= 0 ||\n                        Math.floor(value) !== value) {\n                    stop('expected_small_a');\n                }\n                option[name] = value;\n            } else {\n                if (next_token.id === 'true') {\n                    option[name] = true;\n                } else if (next_token.id === 'false') {\n                    option[name] = false;\n                } else {\n                    stop('unexpected_a');\n                }\n            }\n            advance();\n            if (next_token.id === ',') {\n                advance(',');\n            }\n        }\n        assume();\n    }\n\n\n    function do_properties() {\n        var name;\n        option.properties = true;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            if (next_token.id === ':') {\n                for (;;) {\n                    advance();\n                    if (next_token.id !== '(string)' && !next_token.identifier) {\n                        break;\n                    }\n                }\n            }\n            property[name] = 0;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    directive = function directive() {\n        var command = this.id,\n            old_comments_off = comments_off,\n            old_indent = indent;\n        comments_off = true;\n        indent = null;\n        if (next_token.line === token.line && next_token.from === token.thru) {\n            warn('missing_space_a_b', next_token, artifact(token), artifact());\n        }\n        if (lookahead.length > 0) {\n            warn('unexpected_a', this);\n        }\n        switch (command) {\n        case '/*properties':\n        case '/*property':\n        case '/*members':\n        case '/*member':\n            do_properties();\n            break;\n        case '/*jslint':\n            if (option.safe) {\n                warn('adsafe_a', this);\n            }\n            do_jslint();\n            break;\n        case '/*globals':\n        case '/*global':\n            if (option.safe) {\n                warn('adsafe_a', this);\n            }\n            do_globals();\n            break;\n        default:\n            stop('unexpected_a', this);\n        }\n        comments_off = old_comments_off;\n        advance('*/');\n        indent = old_indent;\n    };\n\n\n// Indentation intention\n\n    function edge(mode) {\n        next_token.edge = indent ? indent.open && (mode || 'edge') : '';\n    }\n\n\n    function step_in(mode) {\n        var open;\n        if (typeof mode === 'number') {\n            indent = {\n                at: +mode,\n                open: true,\n                was: indent\n            };\n        } else if (!indent) {\n            indent = {\n                at: 1,\n                mode: 'statement',\n                open: true\n            };\n        } else if (mode === 'statement') {\n            indent = {\n                at: indent.at,\n                open: true,\n                was: indent\n            };\n        } else {\n            open = mode === 'var' || next_token.line !== token.line;\n            indent = {\n                at: (open || mode === 'control'\n                    ? indent.at + option.indent\n                    : indent.at) + (indent.wrap ? option.indent : 0),\n                mode: mode,\n                open: open,\n                was: indent\n            };\n            if (mode === 'var' && open) {\n                var_mode = indent;\n            }\n        }\n    }\n\n    function step_out(id, symbol) {\n        if (id) {\n            if (indent && indent.open) {\n                indent.at -= option.indent;\n                edge();\n            }\n            advance(id, symbol);\n        }\n        if (indent) {\n            indent = indent.was;\n        }\n    }\n\n// Functions for conformance of whitespace.\n\n    function one_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && !option.white &&\n                (token.line !== right.line ||\n                token.thru + 1 !== right.from)) {\n            warn('expected_space_a_b', right, artifact(token), artifact(right));\n        }\n    }\n\n    function one_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru + 1 !== right.from))) {\n            warn('expected_space_a_b', right, artifact(left), artifact(right));\n        }\n    }\n\n    function no_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if ((!option.white || xmode === 'styleproperty' || xmode === 'style') &&\n                left.thru !== right.from && left.line === right.line) {\n            warn('unexpected_space_a_b', right, artifact(left), artifact(right));\n        }\n    }\n\n    function no_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru !== right.from))) {\n            warn('unexpected_space_a_b', right, artifact(left), artifact(right));\n        }\n    }\n\n    function spaces(left, right) {\n        if (!option.white) {\n            left = left || token;\n            right = right || next_token;\n            if (left.thru === right.from && left.line === right.line) {\n                warn('missing_space_a_b', right, artifact(left), artifact(right));\n            }\n        }\n    }\n\n    function comma() {\n        if (next_token.id !== ',') {\n            warn_at('expected_a_b', token.line, token.thru, ',', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(',');\n            spaces();\n        }\n    }\n\n\n    function semicolon() {\n        if (next_token.id !== ';') {\n            warn_at('expected_a_b', token.line, token.thru, ';', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(';');\n            if (semicolon_coda[next_token.id] !== true) {\n                spaces();\n            }\n        }\n    }\n\n    function use_strict() {\n        if (next_token.string === 'use strict') {\n            if (strict_mode) {\n                warn('unnecessary_use');\n            }\n            edge();\n            advance();\n            semicolon();\n            strict_mode = true;\n            option.undef = false;\n            return true;\n        }\n        return false;\n    }\n\n\n    function are_similar(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (Array.isArray(a)) {\n            if (Array.isArray(b) && a.length === b.length) {\n                var i;\n                for (i = 0; i < a.length; i += 1) {\n                    if (!are_similar(a[i], b[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n        if (Array.isArray(b)) {\n            return false;\n        }\n        if (a.id === '(number)' && b.id === '(number)') {\n            return a.number === b.number;\n        }\n        if (a.arity === b.arity && a.string === b.string) {\n            switch (a.arity) {\n            case 'prefix':\n            case 'suffix':\n            case undefined:\n                return a.id === b.id && are_similar(a.first, b.first) &&\n                    a.id !== '{' && a.id !== '[';\n            case 'infix':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second);\n            case 'ternary':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second) &&\n                    are_similar(a.third, b.third);\n            case 'function':\n            case 'regexp':\n                return false;\n            default:\n                return true;\n            }\n        } else {\n            if (a.id === '.' && b.id === '[' && b.arity === 'infix') {\n                return a.second.string === b.second.string && b.second.id === '(string)';\n            }\n            if (a.id === '[' && a.arity === 'infix' && b.id === '.') {\n                return a.second.string === b.second.string && a.second.id === '(string)';\n            }\n        }\n        return false;\n    }\n\n\n// This is the heart of JSLINT, the Pratt parser. In addition to parsing, it\n// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is\n// like .nud except that it is only used on the first token of a statement.\n// Having .fud makes it much easier to define statement-oriented languages like\n// JavaScript. I retained Pratt's nomenclature.\n\n// .nud     Null denotation\n// .fud     First null denotation\n// .led     Left denotation\n//  lbp     Left binding power\n//  rbp     Right binding power\n\n// They are elements of the parsing method called Top Down Operator Precedence.\n\n    function expression(rbp, initial) {\n\n// rbp is the right binding power.\n// initial indicates that this is the first expression of a statement.\n\n        var left;\n        if (next_token.id === '(end)') {\n            stop('unexpected_a', token, next_token.id);\n        }\n        advance();\n        if (option.safe && scope[token.string] &&\n                scope[token.string] === global_scope[token.string] &&\n                (next_token.id !== '(' && next_token.id !== '.')) {\n            warn('adsafe_a', token);\n        }\n        if (initial) {\n            anonname = 'anonymous';\n            funct['(verb)'] = token.string;\n        }\n        if (initial === true && token.fud) {\n            left = token.fud();\n        } else {\n            if (token.nud) {\n                left = token.nud();\n            } else {\n                if (next_token.id === '(number)' && token.id === '.') {\n                    warn('leading_decimal_a', token, artifact());\n                    advance();\n                    return token;\n                }\n                stop('expected_identifier_a', token, token.id);\n            }\n            while (rbp < next_token.lbp) {\n                advance();\n                if (token.led) {\n                    left = token.led(left);\n                } else {\n                    stop('expected_operator_a', token, token.id);\n                }\n            }\n        }\n        return left;\n    }\n\n\n// Functional constructors for making the symbols that will be inherited by\n// tokens.\n\n    function symbol(s, p) {\n        var x = syntax[s];\n        if (!x || typeof x !== 'object') {\n            syntax[s] = x = {\n                id: s,\n                lbp: p || 0,\n                string: s\n            };\n        }\n        return x;\n    }\n\n    function postscript(x) {\n        x.postscript = true;\n        return x;\n    }\n\n    function ultimate(s) {\n        var x = symbol(s, 0);\n        x.from = 1;\n        x.thru = 1;\n        x.line = 0;\n        x.edge = 'edge';\n        x.string = s;\n        return postscript(x);\n    }\n\n\n    function stmt(s, f) {\n        var x = symbol(s);\n        x.identifier = x.reserved = true;\n        x.fud = f;\n        return x;\n    }\n\n    function labeled_stmt(s, f) {\n        var x = stmt(s, f);\n        x.labeled = true;\n    }\n\n    function disrupt_stmt(s, f) {\n        var x = stmt(s, f);\n        x.disrupt = true;\n    }\n\n\n    function reserve_name(x) {\n        var c = x.id.charAt(0);\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            x.identifier = x.reserved = true;\n        }\n        return x;\n    }\n\n\n    function prefix(s, f) {\n        var x = symbol(s, 150);\n        reserve_name(x);\n        x.nud = function () {\n            var that = this;\n            that.arity = 'prefix';\n            if (typeof f === 'function') {\n                that = f(that);\n                if (that.arity !== 'prefix') {\n                    return that;\n                }\n            } else {\n                if (s === 'typeof') {\n                    one_space();\n                } else {\n                    no_space_only();\n                }\n                that.first = expression(150);\n            }\n            switch (that.id) {\n            case '++':\n            case '--':\n                if (!option.plusplus) {\n                    warn('unexpected_a', that);\n                } else if ((!that.first.identifier || that.first.reserved) &&\n                        that.first.id !== '.' && that.first.id !== '[') {\n                    warn('bad_operand', that);\n                }\n                break;\n            default:\n                if (that.first.arity === 'prefix' ||\n                        that.first.arity === 'function') {\n                    warn('unexpected_a', that);\n                }\n            }\n            return that;\n        };\n        return x;\n    }\n\n\n    function type(s, t, nud) {\n        var x = symbol(s);\n        x.arity = t;\n        if (nud) {\n            x.nud = nud;\n        }\n        return x;\n    }\n\n\n    function reserve(s, f) {\n        var x = symbol(s);\n        x.identifier = x.reserved = true;\n        if (typeof f === 'function') {\n            x.nud = f;\n        }\n        return x;\n    }\n\n\n    function constant(name) {\n        var x = reserve(name);\n        x.string = name;\n        x.nud = return_this;\n        return x;\n    }\n\n\n    function reservevar(s, v) {\n        return reserve(s, function () {\n            if (typeof v === 'function') {\n                v(this);\n            }\n            return this;\n        });\n    }\n\n\n    function infix(s, p, f, w) {\n        var x = symbol(s, p);\n        reserve_name(x);\n        x.led = function (left) {\n            this.arity = 'infix';\n            if (!w) {\n                spaces(prev_token, token);\n                spaces();\n            }\n            if (!option.bitwise && this.bitwise) {\n                warn('unexpected_a', this);\n            }\n            if (typeof f === 'function') {\n                return f(left, this);\n            }\n            this.first = left;\n            this.second = expression(p);\n            return this;\n        };\n        return x;\n    }\n\n    function expected_relation(node, message) {\n        if (node.assign) {\n            warn(message || bundle.conditional_assignment, node);\n        }\n        return node;\n    }\n\n    function expected_condition(node, message) {\n        switch (node.id) {\n        case '[':\n        case '-':\n            if (node.arity !== 'infix') {\n                warn(message || bundle.weird_condition, node);\n            }\n            break;\n        case 'false':\n        case 'function':\n        case 'Infinity':\n        case 'NaN':\n        case 'null':\n        case 'true':\n        case 'undefined':\n        case 'void':\n        case '(number)':\n        case '(regexp)':\n        case '(string)':\n        case '{':\n            warn(message || bundle.weird_condition, node);\n            break;\n        case '(':\n            if (node.first.id === 'new' ||\n                    (node.first.string === 'Boolean') ||\n                    (node.first.id === '.' &&\n                        numbery[node.first.second.string] === true)) {\n                warn(message || bundle.weird_condition, node);\n            }\n            break;\n        }\n        return node;\n    }\n\n    function check_relation(node) {\n        switch (node.arity) {\n        case 'prefix':\n            switch (node.id) {\n            case '{':\n            case '[':\n                warn('unexpected_a', node);\n                break;\n            case '!':\n                warn('confusing_a', node);\n                break;\n            }\n            break;\n        case 'function':\n        case 'regexp':\n            warn('unexpected_a', node);\n            break;\n        default:\n            if (node.id  === 'NaN') {\n                warn('isNaN', node);\n            }\n        }\n        return node;\n    }\n\n\n    function relation(s, eqeq) {\n        return infix(s, 100, function (left, that) {\n            check_relation(left);\n            if (eqeq && !option.eqeq) {\n                warn('expected_a_b', that, eqeq, that.id);\n            }\n            var right = expression(100);\n            if (are_similar(left, right) ||\n                    ((left.id === '(string)' || left.id === '(number)') &&\n                    (right.id === '(string)' || right.id === '(number)'))) {\n                warn('weird_relation', that);\n            } else if (left.id === 'typeof') {\n                if (right.id !== '(string)') {\n                    warn(\"expected_string_a\", right, right.id === '(number)'\n                        ? right.number\n                        : right.string);\n                } else if (right.string === 'undefined' ||\n                        right.string === 'null') {\n                    warn(\"unexpected_typeof_a\", left, right.string);\n                }\n            } else if (right.id === 'typeof') {\n                if (left.id !== '(string)') {\n                    warn(\"expected_string_a\", left, left.id === '(number)'\n                        ? left.number\n                        : left.string);\n                } else if (left.string === 'undefined' ||\n                        left.string === 'null') {\n                    warn(\"unexpected_typeof_a\", right, left.string);\n                }\n            }\n            that.first = left;\n            that.second = check_relation(right);\n            return that;\n        });\n    }\n\n\n    function assignop(s, op) {\n        var x = infix(s, 20, function (left, that) {\n            var l;\n            that.first = left;\n            if (left.identifier) {\n                if (scope[left.string]) {\n                    if (scope[left.string].writeable === false) {\n                        warn('read_only', left);\n                    }\n                } else {\n                    stop('read_only');\n                }\n                if (funct['(params)']) {\n                    funct['(params)'].forEach(function (value) {\n                        if (value.string === left.string) {\n                            value.assign = true;\n                        }\n                    });\n                }\n            } else if (option.safe) {\n                l = left;\n                do {\n                    if (typeof predefined[l.string] === 'boolean') {\n                        warn('adsafe_a', l);\n                    }\n                    l = l.first;\n                } while (l);\n            }\n            if (left === syntax['function']) {\n                warn('identifier_function', token);\n            }\n            if (left.id === '.' || left.id === '[') {\n                if (!left.first || left.first.string === 'arguments') {\n                    warn('bad_assignment', that);\n                }\n            } else if (left.identifier) {\n                if (!left.reserved && funct[left.string] === 'exception') {\n                    warn('assign_exception', left);\n                }\n            } else {\n                warn('bad_assignment', that);\n            }\n            that.second = expression(19);\n            if (that.id === '=' && are_similar(that.first, that.second)) {\n                warn('weird_assignment', that);\n            }\n            return that;\n        });\n        x.assign = true;\n        if (op) {\n            if (syntax[op].bitwise) {\n                x.bitwise = true;\n            }\n        }\n        return x;\n    }\n\n\n    function bitwise(s, p) {\n        var x = infix(s, p, 'number');\n        x.bitwise = true;\n        return x;\n    }\n\n\n    function suffix(s) {\n        var x = symbol(s, 150);\n        x.led = function (left) {\n            no_space_only(prev_token, token);\n            if (!option.plusplus) {\n                warn('unexpected_a', this);\n            } else if ((!left.identifier || left.reserved) &&\n                    left.id !== '.' && left.id !== '[') {\n                warn('bad_operand', this);\n            }\n            this.first = left;\n            this.arity = 'suffix';\n            return this;\n        };\n        return x;\n    }\n\n\n    function optional_identifier(variable) {\n        if (next_token.identifier) {\n            advance();\n            if (option.safe && banned[token.string]) {\n                warn('adsafe_a', token);\n            } else if (token.reserved && (!option.es5 || variable)) {\n                warn('expected_identifier_a_reserved', token);\n            }\n            return token.string;\n        }\n    }\n\n\n    function identifier(variable) {\n        var i = optional_identifier(variable);\n        if (!i) {\n            stop(token.id === 'function' && next_token.id === '('\n                ? 'name_function'\n                : 'expected_identifier_a');\n        }\n        return i;\n    }\n\n\n    function statement() {\n\n        var label, old_scope = scope, the_statement;\n\n// We don't like the empty statement.\n\n        if (next_token.id === ';') {\n            warn('unexpected_a');\n            semicolon();\n            return;\n        }\n\n// Is this a labeled statement?\n\n        if (next_token.identifier && !next_token.reserved && peek().id === ':') {\n            edge('label');\n            label = next_token;\n            advance();\n            advance(':');\n            scope = Object.create(old_scope);\n            add_label(label, 'label');\n            if (next_token.labeled !== true || funct === global_funct) {\n                stop('unexpected_label_a', label);\n            } else if (jx.test(label.string + ':')) {\n                warn('url', label);\n            }\n            next_token.label = label;\n        }\n\n// Parse the statement.\n\n        if (token.id !== 'else') {\n            edge();\n        }\n        step_in('statement');\n        the_statement = expression(0, true);\n        if (the_statement) {\n\n// Look for the final semicolon.\n\n            if (the_statement.arity === 'statement') {\n                if (the_statement.id === 'switch' ||\n                        (the_statement.block && the_statement.id !== 'do')) {\n                    spaces();\n                } else {\n                    semicolon();\n                }\n            } else {\n\n// If this is an expression statement, determine if it is acceptable.\n// We do not like\n//      new Blah;\n// statments. If it is to be used at all, new should only be used to make\n// objects, not side effects. The expression statements we do like do\n// assignment or invocation or delete.\n\n                if (the_statement.id === '(') {\n                    if (the_statement.first.id === 'new') {\n                        warn('bad_new');\n                    }\n                } else if (!the_statement.assign &&\n                        the_statement.id !== 'delete' &&\n                        the_statement.id !== '++' &&\n                        the_statement.id !== '--') {\n                    warn('assignment_function_expression', the_statement);\n                }\n                semicolon();\n            }\n        }\n        step_out();\n        scope = old_scope;\n        return the_statement;\n    }\n\n\n    function statements() {\n        var array = [], disruptor, the_statement;\n\n// A disrupt statement may not be followed by any other statement.\n// If the last statement is disrupt, then the sequence is disrupt.\n\n        while (next_token.postscript !== true) {\n            if (next_token.id === ';') {\n                warn('unexpected_a', next_token);\n                semicolon();\n            } else {\n                if (next_token.string === 'use strict') {\n                    if ((!node_js && xmode !== 'script') || funct !== global_funct || array.length > 0) {\n                        warn('function_strict');\n                    }\n                    use_strict();\n                }\n                if (disruptor) {\n                    warn('unreachable_a_b', next_token, next_token.string,\n                        disruptor.string);\n                    disruptor = null;\n                }\n                the_statement = statement();\n                if (the_statement) {\n                    array.push(the_statement);\n                    if (the_statement.disrupt) {\n                        disruptor = the_statement;\n                        array.disrupt = true;\n                    }\n                }\n            }\n        }\n        return array;\n    }\n\n\n    function block(ordinary) {\n\n// array block is array sequence of statements wrapped in braces.\n// ordinary is false for function bodies and try blocks.\n// ordinary is true for if statements, while, etc.\n\n        var array,\n            curly = next_token,\n            old_in_block = in_block,\n            old_scope = scope,\n            old_strict_mode = strict_mode;\n\n        in_block = ordinary;\n        scope = Object.create(scope);\n        spaces();\n        if (next_token.id === '{') {\n            advance('{');\n            step_in();\n            if (!ordinary && !use_strict() && !old_strict_mode &&\n                    !option.sloppy && funct['(context)'] === global_funct) {\n                warn('missing_use_strict');\n            }\n            array = statements();\n            strict_mode = old_strict_mode;\n            step_out('}', curly);\n        } else if (!ordinary) {\n            stop('expected_a_b', next_token, '{', artifact());\n        } else {\n            warn('expected_a_b', next_token, '{', artifact());\n            array = [statement()];\n            array.disrupt = array[0].disrupt;\n        }\n        funct['(verb)'] = null;\n        scope = old_scope;\n        in_block = old_in_block;\n        if (ordinary && array.length === 0) {\n            warn('empty_block');\n        }\n        return array;\n    }\n\n\n    function tally_property(name) {\n        if (option.properties && typeof property[name] !== 'number') {\n            warn('unexpected_property_a', token, name);\n        }\n        if (typeof property[name] === 'number') {\n            property[name] += 1;\n        } else {\n            property[name] = 1;\n        }\n    }\n\n\n// ECMAScript parser\n\n    syntax['(identifier)'] = {\n        id: '(identifier)',\n        lbp: 0,\n        identifier: true,\n        nud: function () {\n            var name = this.string,\n                variable = scope[name],\n                site,\n                writeable;\n\n// If the variable is not in scope, then we may have an undeclared variable.\n// Check the predefined list. If it was predefined, create the global\n// variable.\n\n            if (typeof variable !== 'object') {\n                writeable = predefined[name];\n                if (typeof writeable === 'boolean') {\n                    global_scope[name] = variable = {\n                        string:    name,\n                        writeable: writeable,\n                        funct:     global_funct\n                    };\n                    global_funct[name] = 'var';\n\n// But if the variable is not in scope, and is not predefined, and if we are not\n// in the global scope, then we have an undefined variable error.\n\n                } else {\n                    if (!option.undef) {\n                        warn('used_before_a', token);\n                    }\n                    scope[name] = variable = {\n                        string: name,\n                        writeable: true,\n                        funct: funct\n                    };\n                    funct[name] = 'undef';\n                }\n\n            }\n            site = variable.funct;\n\n// The name is in scope and defined in the current function.\n\n            if (funct === site) {\n\n//      Change 'unused' to 'var', and reject labels.\n\n                switch (funct[name]) {\n                case 'becoming':\n                    warn('unexpected_a', token);\n                    funct[name] = 'var';\n                    break;\n                case 'unused':\n                    funct[name] = 'var';\n                    break;\n                case 'unparam':\n                    funct[name] = 'parameter';\n                    break;\n                case 'unction':\n                    funct[name] = 'function';\n                    break;\n                case 'label':\n                    warn('a_label', token, name);\n                    break;\n                }\n\n// If the name is already defined in the current\n// function, but not as outer, then there is a scope error.\n\n            } else {\n                switch (funct[name]) {\n                case 'closure':\n                case 'function':\n                case 'var':\n                case 'unused':\n                    warn('a_scope', token, name);\n                    break;\n                case 'label':\n                    warn('a_label', token, name);\n                    break;\n                case 'outer':\n                case 'global':\n                    break;\n                default:\n\n// If the name is defined in an outer function, make an outer entry, and if\n// it was unused, make it var.\n\n                    switch (site[name]) {\n                    case 'becoming':\n                    case 'closure':\n                    case 'function':\n                    case 'parameter':\n                    case 'unction':\n                    case 'unused':\n                    case 'var':\n                        site[name] = 'closure';\n                        funct[name] = site === global_funct\n                            ? 'global'\n                            : 'outer';\n                        break;\n                    case 'unparam':\n                        site[name] = 'parameter';\n                        funct[name] = 'outer';\n                        break;\n                    case 'undef':\n                        funct[name] = 'undef';\n                        break;\n                    case 'label':\n                        warn('a_label', token, name);\n                        break;\n                    }\n                }\n            }\n            return this;\n        },\n        led: function () {\n            stop('expected_operator_a');\n        }\n    };\n\n// Build the syntax table by declaring the syntactic elements.\n\n    type('(array)', 'array');\n    type('(color)', 'color');\n    type('(function)', 'function');\n    type('(number)', 'number', return_this);\n    type('(object)', 'object');\n    type('(string)', 'string', return_this);\n    type('(boolean)', 'boolean', return_this);\n    type('(range)', 'range');\n    type('(regexp)', 'regexp', return_this);\n\n    ultimate('(begin)');\n    ultimate('(end)');\n    ultimate('(error)');\n    postscript(symbol('</'));\n    symbol('<!');\n    symbol('<!--');\n    symbol('-->');\n    postscript(symbol('}'));\n    symbol(')');\n    symbol(']');\n    postscript(symbol('\"'));\n    postscript(symbol('\\''));\n    symbol(';');\n    symbol(':');\n    symbol(',');\n    symbol('#');\n    symbol('@');\n    symbol('*/');\n    postscript(reserve('case'));\n    reserve('catch');\n    postscript(reserve('default'));\n    reserve('else');\n    reserve('finally');\n\n    reservevar('arguments', function (x) {\n        if (strict_mode && funct === global_funct) {\n            warn('strict', x);\n        } else if (option.safe) {\n            warn('adsafe_a', x);\n        }\n        funct['(arguments)'] = true;\n    });\n    reservevar('eval', function (x) {\n        if (option.safe) {\n            warn('adsafe_a', x);\n        }\n    });\n    constant('false', 'boolean');\n    constant('Infinity', 'number');\n    constant('NaN', 'number');\n    constant('null', '');\n    reservevar('this', function (x) {\n        if (option.safe) {\n            warn('adsafe_a', x);\n        } else if (strict_mode && funct['(token)'] &&\n                (funct['(token)'].arity === 'statement' &&\n                funct['(name)'].charAt(0) > 'Z')) {\n            warn('strict', x);\n        }\n    });\n    constant('true', 'boolean');\n    constant('undefined', '');\n\n    infix('?', 30, function (left, that) {\n        step_in('?');\n        that.first = expected_condition(expected_relation(left));\n        that.second = expression(0);\n        spaces();\n        step_out();\n        var colon = next_token;\n        advance(':');\n        step_in(':');\n        spaces();\n        that.third = expression(10);\n        that.arity = 'ternary';\n        if (are_similar(that.second, that.third)) {\n            warn('weird_ternary', colon);\n        } else if (are_similar(that.first, that.second)) {\n            warn('use_or', that);\n        }\n        step_out();\n        return that;\n    });\n\n    infix('||', 40, function (left, that) {\n        function paren_check(that) {\n            if (that.id === '&&' && !that.paren) {\n                warn('and', that);\n            }\n            return that;\n        }\n\n        that.first = paren_check(expected_condition(expected_relation(left)));\n        that.second = paren_check(expected_relation(expression(40)));\n        if (are_similar(that.first, that.second)) {\n            warn('weird_condition', that);\n        }\n        return that;\n    });\n\n    infix('&&', 50, function (left, that) {\n        that.first = expected_condition(expected_relation(left));\n        that.second = expected_relation(expression(50));\n        if (are_similar(that.first, that.second)) {\n            warn('weird_condition', that);\n        }\n        return that;\n    });\n\n    prefix('void', function (that) {\n        that.first = expression(0);\n        if (option.es5 || strict_mode) {\n            warn('expected_a_b', that, 'undefined', 'void');\n        } else if (that.first.number !== 0) {\n            warn('expected_a_b', that.first, '0', artifact(that.first));\n        }\n        return that;\n    });\n\n    bitwise('|', 70);\n    bitwise('^', 80);\n    bitwise('&', 90);\n\n    relation('==', '===');\n    relation('===');\n    relation('!=', '!==');\n    relation('!==');\n    relation('<');\n    relation('>');\n    relation('<=');\n    relation('>=');\n\n    bitwise('<<', 120);\n    bitwise('>>', 120);\n    bitwise('>>>', 120);\n\n    infix('in', 120, function (left, that) {\n        warn('infix_in', that);\n        that.left = left;\n        that.right = expression(130);\n        return that;\n    });\n    infix('instanceof', 120);\n    infix('+', 130, function (left, that) {\n        if (left.id === '(number)') {\n            if (left.number === 0) {\n                warn('unexpected_a', left, '0');\n            }\n        } else if (left.id === '(string)') {\n            if (left.string === '') {\n                warn('expected_a_b', left, 'String', '\\'\\'');\n            }\n        }\n        var right = expression(130);\n        if (right.id === '(number)') {\n            if (right.number === 0) {\n                warn('unexpected_a', right, '0');\n            }\n        } else if (right.id === '(string)') {\n            if (right.string === '') {\n                warn('expected_a_b', right, 'String', '\\'\\'');\n            }\n        }\n        if (left.id === right.id) {\n            if (left.id === '(string)' || left.id === '(number)') {\n                if (left.id === '(string)') {\n                    left.string += right.string;\n                    if (jx.test(left.string)) {\n                        warn('url', left);\n                    }\n                } else {\n                    left.number += right.number;\n                }\n                left.thru = right.thru;\n                return left;\n            }\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('+');\n    prefix('+++', function () {\n        warn('confusing_a', token);\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('+++', 130, function (left) {\n        warn('confusing_a', token);\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('-', 130, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            warn('unexpected_a', left);\n        }\n        var right = expression(130);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            warn('unexpected_a', right);\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number -= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('-');\n    prefix('---', function () {\n        warn('confusing_a', token);\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('---', 130, function (left) {\n        warn('confusing_a', token);\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('*', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            warn('unexpected_a', left);\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            warn('unexpected_a', right);\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number *= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('/', 140, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            warn('unexpected_a', left);\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            warn('unexpected_a', right);\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number /= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('%', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            warn('unexpected_a', left);\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            warn('unexpected_a', right);\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number %= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n\n    suffix('++');\n    prefix('++');\n\n    suffix('--');\n    prefix('--');\n    prefix('delete', function (that) {\n        one_space();\n        var p = expression(0);\n        if (!p || (p.id !== '.' && p.id !== '[')) {\n            warn('deleted');\n        }\n        that.first = p;\n        return that;\n    });\n\n\n    prefix('~', function (that) {\n        no_space_only();\n        if (!option.bitwise) {\n            warn('unexpected_a', that);\n        }\n        that.first = expression(150);\n        return that;\n    });\n    function banger(that) {\n        no_space_only();\n        that.first = expected_condition(expression(150));\n        if (bang[that.first.id] === that || that.first.assign) {\n            warn('confusing_a', that);\n        }\n        return that;\n    }\n    prefix('!', banger);\n    prefix('!!', banger);\n    prefix('typeof');\n    prefix('new', function (that) {\n        one_space();\n        var c = expression(160), n, p, v;\n        that.first = c;\n        if (c.id !== 'function') {\n            if (c.identifier) {\n                switch (c.string) {\n                case 'Object':\n                    warn('use_object', token);\n                    break;\n                case 'Array':\n                    if (next_token.id === '(') {\n                        p = next_token;\n                        p.first = this;\n                        advance('(');\n                        if (next_token.id !== ')') {\n                            n = expression(0);\n                            p.second = [n];\n                            if (n.id !== '(number)' || next_token.id === ',') {\n                                warn('use_array', p);\n                            }\n                            while (next_token.id === ',') {\n                                advance(',');\n                                p.second.push(expression(0));\n                            }\n                        } else {\n                            warn('use_array', token);\n                        }\n                        advance(')', p);\n                        return p;\n                    }\n                    warn('use_array', token);\n                    break;\n                case 'Number':\n                case 'String':\n                case 'Boolean':\n                case 'Math':\n                case 'JSON':\n                    warn('not_a_constructor', c);\n                    break;\n                case 'Function':\n                    if (!option.evil) {\n                        warn('function_eval');\n                    }\n                    break;\n                case 'Date':\n                case 'RegExp':\n                case 'this':\n                    break;\n                default:\n                    if (c.id !== 'function') {\n                        v = c.string.charAt(0);\n                        if (!option.newcap && (v < 'A' || v > 'Z')) {\n                            warn('constructor_name_a', token);\n                        }\n                    }\n                }\n            } else {\n                if (c.id !== '.' && c.id !== '[' && c.id !== '(') {\n                    warn('bad_constructor', token);\n                }\n            }\n        } else {\n            warn('weird_new', that);\n        }\n        if (next_token.id !== '(') {\n            warn('missing_a', next_token, '()');\n        }\n        return that;\n    });\n\n    infix('(', 160, function (left, that) {\n        var e, p;\n        if (indent && indent.mode === 'expression') {\n            no_space(prev_token, token);\n        } else {\n            no_space_only(prev_token, token);\n        }\n        if (!left.immed && left.id === 'function') {\n            warn('wrap_immediate');\n        }\n        p = [];\n        if (left.identifier) {\n            if (left.string.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {\n                if (left.string !== 'Number' && left.string !== 'String' &&\n                        left.string !== 'Boolean' && left.string !== 'Date') {\n                    if (left.string === 'Math' || left.string === 'JSON') {\n                        warn('not_a_function', left);\n                    } else if (left.string === 'Object') {\n                        warn('use_object', token);\n                    } else if (left.string === 'Array' || !option.newcap) {\n                        warn('missing_a', left, 'new');\n                    }\n                }\n            }\n        } else if (left.id === '.') {\n            if (option.safe && left.first.string === 'Math' &&\n                    left.second === 'random') {\n                warn('adsafe_a', left);\n            } else if (left.second.string === 'split' &&\n                    left.first.id === '(string)') {\n                warn('use_array', left.second);\n            }\n        }\n        step_in();\n        if (next_token.id !== ')') {\n            no_space();\n            for (;;) {\n                edge();\n                e = expression(10);\n                if (left.string === 'Boolean' && (e.id === '!' || e.id === '~')) {\n                    warn('weird_condition', e);\n                }\n                p.push(e);\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', that);\n        if (typeof left === 'object') {\n            if (left.string === 'parseInt' && p.length === 1) {\n                warn('radix', left);\n            } else if (left.string === 'String' && p.length >= 1 && p[0].id === '(string)') {\n                warn('unexpected_a', left);\n            }\n            if (!option.evil) {\n                if (left.string === 'eval' || left.string === 'Function' ||\n                        left.string === 'execScript') {\n                    warn('evil', left);\n                } else if (p[0] && p[0].id === '(string)' &&\n                        (left.string === 'setTimeout' ||\n                        left.string === 'setInterval')) {\n                    warn('implied_evil', left);\n                }\n            }\n            if (!left.identifier && left.id !== '.' && left.id !== '[' &&\n                    left.id !== '(' && left.id !== '&&' && left.id !== '||' &&\n                    left.id !== '?') {\n                warn('bad_invocation', left);\n            }\n            if (left.id === '.') {\n                if (p.length > 0 &&\n                        left.first && left.first.first &&\n                        are_similar(p[0], left.first.first)) {\n                    if (left.second.string === 'call' ||\n                            (left.second.string === 'apply' && (p.length === 1 ||\n                            (p[1].arity === 'prefix' && p[1].id === '[')))) {\n                        warn('unexpected_a', left.second);\n                    }\n                }\n                if (left.second.string === 'toString') {\n                    if (left.first.id === '(string)' || left.first.id === '(number)') {\n                        warn('unexpected_a', left.second);\n                    }\n                }\n            }\n        }\n        that.first = left;\n        that.second = p;\n        return that;\n    }, true);\n\n    prefix('(', function (that) {\n        step_in('expression');\n        no_space();\n        edge();\n        if (next_token.id === 'function') {\n            next_token.immed = true;\n        }\n        var value = expression(0);\n        value.paren = true;\n        no_space();\n        step_out(')', that);\n        if (value.id === 'function') {\n            switch (next_token.id) {\n            case '(':\n                warn('move_invocation');\n                break;\n            case '.':\n            case '[':\n                warn('unexpected_a');\n                break;\n            default:\n                warn('bad_wrap', that);\n            }\n        } else if (!value.arity) {\n            warn('unexpected_a', that);\n        }\n        return value;\n    });\n\n    infix('.', 170, function (left, that) {\n        no_space(prev_token, token);\n        no_space();\n        var name = identifier();\n        if (typeof name === 'string') {\n            tally_property(name);\n        }\n        that.first = left;\n        that.second = token;\n        if (left && left.string === 'arguments' &&\n                (name === 'callee' || name === 'caller')) {\n            warn('avoid_a', left, 'arguments.' + name);\n        } else if (!option.evil && left && left.string === 'document' &&\n                (name === 'write' || name === 'writeln')) {\n            warn('write_is_wrong', left);\n        } else if (!option.stupid && syx.test(name)) {\n            warn('sync_a', token);\n        } else if (option.adsafe) {\n            if (!adsafe_top && left.string === 'ADSAFE') {\n                if (name === 'id' || name === 'lib') {\n                    warn('adsafe_a', that);\n                } else if (name === 'go') {\n                    if (xmode !== 'script') {\n                        warn('adsafe_a', that);\n                    } else if (adsafe_went || next_token.id !== '(' ||\n                            peek(0).id !== '(string)' ||\n                            peek(0).string !== adsafe_id ||\n                            peek(1).id !== ',') {\n                        stop('adsafe_a', that, 'go');\n                    }\n                    adsafe_went = true;\n                    adsafe_may = false;\n                }\n            }\n            adsafe_top = false;\n        }\n        if (!option.evil && (name === 'eval' || name === 'execScript')) {\n            warn('evil');\n        } else if (option.safe) {\n            for (;;) {\n                if (banned[name] === true) {\n                    warn('adsafe_a', token, name);\n                }\n                if (typeof predefined[left.string] !== 'boolean' ||    //// check for writeable\n                        next_token.id === '(') {\n                    break;\n                }\n                if (next_token.id !== '.') {\n                    warn('adsafe_a', that);\n                    break;\n                }\n                advance('.');\n                token.first = that;\n                token.second = name;\n                that = token;\n                name = identifier();\n                if (typeof name === 'string') {\n                    tally_property(name);\n                }\n            }\n        }\n        return that;\n    }, true);\n\n    infix('[', 170, function (left, that) {\n        var e, s;\n        no_space_only(prev_token, token);\n        no_space();\n        step_in();\n        edge();\n        e = expression(0);\n        switch (e.id) {\n        case '(number)':\n            if (e.id === '(number)' && left.id === 'arguments') {\n                warn('use_param', left);\n            }\n            break;\n        case '(string)':\n            if (option.safe && (banned[e.string] ||\n                    e.string.charAt(0) === '_' || e.string.slice(-1) === '_')) {\n                warn('adsafe_subscript_a', e);\n            } else if (!option.evil &&\n                    (e.string === 'eval' || e.string === 'execScript')) {\n                warn('evil', e);\n            } else if (!option.sub && ix.test(e.string)) {\n                s = syntax[e.string];\n                if (!s || !s.reserved) {\n                    warn('subscript', e);\n                }\n            }\n            tally_property(e.string);\n            break;\n        default:\n            if (option.safe) {\n                if ((e.id !== '+' || e.arity !== 'prefix') &&\n                        e.id !== '-' && e.id !== '*') {\n                    warn('adsafe_subscript_a', e);\n                }\n            }\n        }\n        step_out(']', that);\n        no_space(prev_token, token);\n        that.first = left;\n        that.second = e;\n        return that;\n    }, true);\n\n    prefix('[', function (that) {\n        that.first = [];\n        step_in('array');\n        while (next_token.id !== '(end)') {\n            while (next_token.id === ',') {\n                warn('unexpected_a', next_token);\n                advance(',');\n            }\n            if (next_token.id === ']') {\n                break;\n            }\n            indent.wrap = false;\n            edge();\n            that.first.push(expression(10));\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id === ']' && !option.es5) {\n                    warn('unexpected_a', token);\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        step_out(']', that);\n        return that;\n    }, 170);\n\n\n    function property_name() {\n        var id = optional_identifier();\n        if (!id) {\n            if (next_token.id === '(string)') {\n                id = next_token.string;\n                if (option.safe) {\n                    if (banned[id]) {\n                        warn('adsafe_a');\n                    } else if (id.charAt(0) === '_' ||\n                            id.charAt(id.length - 1) === '_') {\n                        warn('dangling_a');\n                    }\n                }\n                advance();\n            } else if (next_token.id === '(number)') {\n                id = next_token.number.toString();\n                advance();\n            }\n        }\n        return id;\n    }\n\n\n    function function_params() {\n        var id, paren = next_token, params = [];\n        advance('(');\n        step_in();\n        no_space();\n        if (next_token.id === ')') {\n            no_space();\n            step_out(')', paren);\n            return params;\n        }\n        for (;;) {\n            edge();\n            id = identifier();\n            params.push(token);\n            add_label(token, option.unparam ? 'parameter' : 'unparam');\n            if (next_token.id === ',') {\n                comma();\n            } else {\n                no_space();\n                step_out(')', paren);\n                return params;\n            }\n        }\n    }\n\n\n\n    function do_function(func, name) {\n        var old_funct      = funct,\n            old_option     = option,\n            old_scope      = scope;\n        funct = {\n            '(name)'     : name || '\\'' + (anonname || '').replace(nx, sanitize) + '\\'',\n            '(line)'     : next_token.line,\n            '(context)'  : old_funct,\n            '(breakage)' : 0,\n            '(loopage)'  : 0,\n            '(scope)'    : scope,\n            '(token)'    : func\n        };\n        option = Object.create(old_option);\n        scope = Object.create(old_scope);\n        functions.push(funct);\n        func.name = name;\n        if (name) {\n            add_label(func, 'function', name);\n        }\n        func.writeable = false;\n        func.first = funct['(params)'] = function_params();\n        one_space();\n        func.block = block(false);\n        if (funct['(arguments)']) {\n            func.first.forEach(function (value) {\n                if (value.assign) {\n                    warn('parameter_arguments_a', value, value.string);\n                }\n            });\n        }\n        funct      = old_funct;\n        option     = old_option;\n        scope      = old_scope;\n    }\n\n\n    assignop('=');\n    assignop('+=', '+');\n    assignop('-=', '-');\n    assignop('*=', '*');\n    assignop('/=', '/').nud = function () {\n        stop('slash_equal');\n    };\n    assignop('%=', '%');\n    assignop('&=', '&');\n    assignop('|=', '|');\n    assignop('^=', '^');\n    assignop('<<=', '<<');\n    assignop('>>=', '>>');\n    assignop('>>>=', '>>>');\n\n\n    prefix('{', function (that) {\n        var get, i, j, name, p, set, seen = {};\n        that.first = [];\n        step_in();\n        while (next_token.id !== '}') {\n            indent.wrap = false;\n\n// JSLint recognizes the ES5 extension for get/set in object literals,\n// but requires that they be used in pairs.\n\n            edge();\n            if (next_token.string === 'get' && peek().id !== ':') {\n                if (!option.es5) {\n                    warn('es5');\n                }\n                get = next_token;\n                advance('get');\n                one_space_only();\n                name = next_token;\n                i = property_name();\n                if (!i) {\n                    stop('missing_property');\n                }\n                get.string = '';\n                do_function(get);\n                if (funct['(loopage)']) {\n                    warn('function_loop', get);\n                }\n                p = get.first;\n                if (p && p.length) {\n                    warn('parameter_a_get_b', p[0], p[0].string, i);\n                }\n                comma();\n                set = next_token;\n                spaces();\n                edge();\n                advance('set');\n                set.string = '';\n                one_space_only();\n                j = property_name();\n                if (i !== j) {\n                    stop('expected_a_b', token, i, j || next_token.string);\n                }\n                do_function(set);\n                if (set.block.length === 0) {\n                    warn('missing_a', token, 'throw');\n                }\n                p = set.first;\n                if (!p || p.length !== 1) {\n                    stop('parameter_set_a', set, 'value');\n                } else if (p[0].string !== 'value') {\n                    stop('expected_a_b', p[0], 'value', p[0].string);\n                }\n                name.first = [get, set];\n            } else {\n                name = next_token;\n                i = property_name();\n                if (typeof i !== 'string') {\n                    stop('missing_property');\n                }\n                advance(':');\n                spaces();\n                name.first = expression(10);\n            }\n            that.first.push(name);\n            if (seen[i] === true) {\n                warn('duplicate_a', next_token, i);\n            }\n            seen[i] = true;\n            tally_property(i);\n            if (next_token.id !== ',') {\n                break;\n            }\n            for (;;) {\n                comma();\n                if (next_token.id !== ',') {\n                    break;\n                }\n                warn('unexpected_a', next_token);\n            }\n            if (next_token.id === '}' && !option.es5) {\n                warn('unexpected_a', token);\n            }\n        }\n        step_out('}', that);\n        return that;\n    });\n\n    stmt('{', function () {\n        warn('statement_block');\n        this.arity = 'statement';\n        this.block = statements();\n        this.disrupt = this.block.disrupt;\n        advance('}', this);\n        return this;\n    });\n\n    stmt('/*global', directive);\n    stmt('/*globals', directive);\n    stmt('/*jslint', directive);\n    stmt('/*member', directive);\n    stmt('/*members', directive);\n    stmt('/*property', directive);\n    stmt('/*properties', directive);\n\n    stmt('var', function () {\n\n// JavaScript does not have block scope. It only has function scope. So,\n// declaring a variable in a block can have unexpected consequences.\n\n// var.first will contain an array, the array containing name tokens\n// and assignment tokens.\n\n        var assign, id, name;\n\n        if (funct['(vars)'] && !option.vars) {\n            warn('combine_var');\n        } else if (funct !== global_funct) {\n            funct['(vars)'] = true;\n        }\n        this.arity = 'statement';\n        this.first = [];\n        step_in('var');\n        for (;;) {\n            name = next_token;\n            id = identifier(true);\n            add_label(name, 'becoming');\n\n            if (next_token.id === '=') {\n                assign = next_token;\n                assign.first = name;\n                spaces();\n                advance('=');\n                spaces();\n                if (next_token.id === 'undefined') {\n                    warn('unnecessary_initialize', token, id);\n                }\n                if (peek(0).id === '=' && next_token.identifier) {\n                    stop('var_a_not');\n                }\n                assign.second = expression(0);\n                assign.arity = 'infix';\n                this.first.push(assign);\n            } else {\n                this.first.push(name);\n            }\n            if (funct[id] === 'becoming') {\n                funct[id] = 'unused';\n            }\n            if (next_token.id !== ',') {\n                break;\n            }\n            comma();\n            indent.wrap = false;\n            if (var_mode && next_token.line === token.line &&\n                    this.first.length === 1) {\n                var_mode = null;\n                indent.open = false;\n                indent.at -= option.indent;\n            }\n            spaces();\n            edge();\n        }\n        var_mode = null;\n        step_out();\n        return this;\n    });\n\n    stmt('function', function () {\n        one_space();\n        if (in_block) {\n            warn('function_block', token);\n        }\n        var name = next_token, id = identifier(true);\n        add_label(name, 'unction');\n        no_space();\n        this.arity = 'statement';\n        do_function(this, id);\n        if (next_token.id === '(' && next_token.line === token.line) {\n            stop('function_statement');\n        }\n        return this;\n    });\n\n    prefix('function', function (that) {\n        if (!option.anon) {\n            one_space();\n        }\n        var id = optional_identifier(true);\n        if (id) {\n            no_space();\n        } else {\n            id = '';\n        }\n        do_function(that, id);\n        if (funct['(loopage)']) {\n            warn('function_loop');\n        }\n        switch (next_token.id) {\n        case ';':\n        case '(':\n        case ')':\n        case ',':\n        case ']':\n        case '}':\n        case ':':\n            break;\n        case '.':\n            if (peek().string !== 'bind' || peek(1).id !== '(') {\n                warn('unexpected_a');\n            }\n            break;\n        default:\n            stop('unexpected_a');\n        }\n        that.arity = 'function';\n        return that;\n    });\n\n    stmt('if', function () {\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block(true);\n        if (next_token.id === 'else') {\n            one_space();\n            advance('else');\n            one_space();\n            this['else'] = next_token.id === 'if' || next_token.id === 'switch'\n                ? statement(true)\n                : block(true);\n            if (this['else'].disrupt && this.block.disrupt) {\n                this.disrupt = true;\n            }\n        }\n        return this;\n    });\n\n    stmt('try', function () {\n\n// try.first    The catch variable\n// try.second   The catch clause\n// try.third    The finally clause\n// try.block    The try block\n\n        var exception_variable, old_scope, paren;\n        if (option.adsafe) {\n            warn('adsafe_a', this);\n        }\n        one_space();\n        this.arity = 'statement';\n        this.block = block(false);\n        if (next_token.id === 'catch') {\n            one_space();\n            advance('catch');\n            one_space();\n            paren = next_token;\n            advance('(');\n            step_in('control');\n            no_space();\n            edge();\n            old_scope = scope;\n            scope = Object.create(old_scope);\n            exception_variable = next_token.string;\n            this.first = exception_variable;\n            if (!next_token.identifier) {\n                warn('expected_identifier_a', next_token);\n            } else {\n                add_label(next_token, 'exception');\n            }\n            advance();\n            no_space();\n            step_out(')', paren);\n            one_space();\n            this.second = block(false);\n            scope = old_scope;\n        }\n        if (next_token.id === 'finally') {\n            one_space();\n            advance('finally');\n            one_space();\n            this.third = block(false);\n        } else if (!this.second) {\n            stop('expected_a_b', next_token, 'catch', artifact());\n        }\n        return this;\n    });\n\n    labeled_stmt('while', function () {\n        one_space();\n        var paren = next_token;\n        funct['(breakage)'] += 1;\n        funct['(loopage)'] += 1;\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_relation(expression(0));\n        if (this.first.id !== 'true') {\n            expected_condition(this.first, bundle.unexpected_a);\n        }\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block(true);\n        if (this.block.disrupt) {\n            warn('strange_loop', prev_token);\n        }\n        funct['(breakage)'] -= 1;\n        funct['(loopage)'] -= 1;\n        return this;\n    });\n\n    reserve('with');\n\n    labeled_stmt('switch', function () {\n\n// switch.first         the switch expression\n// switch.second        the array of cases. A case is 'case' or 'default' token:\n//    case.first        the array of case expressions\n//    case.second       the array of statements\n// If all of the arrays of statements are disrupt, then the switch is disrupt.\n\n        var cases = [],\n            old_in_block = in_block,\n            particular,\n            that = token,\n            the_case = next_token,\n            unbroken = true;\n\n        function find_duplicate_case(value) {\n            if (are_similar(particular, value)) {\n                warn('duplicate_a', value);\n            }\n        }\n\n        funct['(breakage)'] += 1;\n        one_space();\n        advance('(');\n        no_space();\n        step_in();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', the_case);\n        one_space();\n        advance('{');\n        step_in();\n        in_block = true;\n        this.second = [];\n        if (that.from !== next_token.from) {\n            warn('expected_a_at_b_c', next_token, next_token.string, that.from, next_token.from);\n        }\n        while (next_token.id === 'case') {\n            the_case = next_token;\n            cases.forEach(find_duplicate_case);\n            the_case.first = [];\n            the_case.arity = 'case';\n            spaces();\n            edge('case');\n            advance('case');\n            for (;;) {\n                one_space();\n                particular = expression(0);\n                cases.forEach(find_duplicate_case);\n                cases.push(particular);\n                the_case.first.push(particular);\n                if (particular.id === 'NaN') {\n                    warn('unexpected_a', particular);\n                }\n                no_space_only();\n                advance(':');\n                if (next_token.id !== 'case') {\n                    break;\n                }\n                spaces();\n                edge('case');\n                advance('case');\n            }\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                particular = the_case.second[the_case.second.length - 1];\n                if (particular.disrupt) {\n                    if (particular.id === 'break') {\n                        unbroken = false;\n                    }\n                } else {\n                    warn('missing_a_after_b', next_token, 'break', 'case');\n                }\n            } else {\n                warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.second.length === 0) {\n            warn('missing_a', next_token, 'case');\n        }\n        if (next_token.id === 'default') {\n            spaces();\n            the_case = next_token;\n            the_case.arity = 'case';\n            edge('case');\n            advance('default');\n            no_space_only();\n            advance(':');\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                particular = the_case.second[the_case.second.length - 1];\n                if (unbroken && particular.disrupt && particular.id !== 'break') {\n                    this.disrupt = true;\n                }\n            }\n            this.second.push(the_case);\n        }\n        funct['(breakage)'] -= 1;\n        spaces();\n        step_out('}', this);\n        in_block = old_in_block;\n        return this;\n    });\n\n    stmt('debugger', function () {\n        if (!option.debug) {\n            warn('unexpected_a', this);\n        }\n        this.arity = 'statement';\n        return this;\n    });\n\n    labeled_stmt('do', function () {\n        funct['(breakage)'] += 1;\n        funct['(loopage)'] += 1;\n        one_space();\n        this.arity = 'statement';\n        this.block = block(true);\n        if (this.block.disrupt) {\n            warn('strange_loop', prev_token);\n        }\n        one_space();\n        advance('while');\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in();\n        no_space();\n        edge();\n        this.first = expected_condition(expected_relation(expression(0)), bundle.unexpected_a);\n        no_space();\n        step_out(')', paren);\n        funct['(breakage)'] -= 1;\n        funct['(loopage)'] -= 1;\n        return this;\n    });\n\n    labeled_stmt('for', function () {\n\n        var blok, filter, ok = false, paren = next_token, value;\n        this.arity = 'statement';\n        funct['(breakage)'] += 1;\n        funct['(loopage)'] += 1;\n        advance('(');\n        if (next_token.id === ';') {\n            no_space();\n            advance(';');\n            no_space();\n            advance(';');\n            no_space();\n            advance(')');\n            blok = block(true);\n        } else {\n            step_in('control');\n            spaces(this, paren);\n            no_space();\n            if (next_token.id === 'var') {\n                stop('move_var');\n            }\n            edge();\n            if (peek(0).id === 'in') {\n                this.forin = true;\n                value = next_token;\n                switch (funct[value.string]) {\n                case 'unused':\n                    funct[value.string] = 'var';\n                    break;\n                case 'closure':\n                case 'var':\n                    break;\n                default:\n                    warn('bad_in_a', value);\n                }\n                advance();\n                advance('in');\n                this.first = value;\n                this.second = expression(20);\n                step_out(')', paren);\n                blok = block(true);\n                if (!option.forin) {\n                    if (blok.length === 1 && typeof blok[0] === 'object' &&\n                            blok[0].string === 'if' && !blok[0]['else']) {\n                        filter = blok[0].first;\n                        while (filter.id === '&&') {\n                            filter = filter.first;\n                        }\n                        switch (filter.id) {\n                        case '===':\n                        case '!==':\n                            ok = filter.first.id === '['\n                                ? filter.first.first.string === this.second.string &&\n                                    filter.first.second.string === this.first.string\n                                : filter.first.id === 'typeof' &&\n                                    filter.first.first.id === '[' &&\n                                    filter.first.first.first.string === this.second.string &&\n                                    filter.first.first.second.string === this.first.string;\n                            break;\n                        case '(':\n                            ok = filter.first.id === '.' && ((\n                                filter.first.first.string === this.second.string &&\n                                filter.first.second.string === 'hasOwnProperty' &&\n                                filter.second[0].string === this.first.string\n                            ) || (\n                                filter.first.first.string === 'ADSAFE' &&\n                                filter.first.second.string === 'has' &&\n                                filter.second[0].string === this.second.string &&\n                                filter.second[1].string === this.first.string\n                            ) || (\n                                filter.first.first.id === '.' &&\n                                filter.first.first.first.id === '.' &&\n                                filter.first.first.first.first.string === 'Object' &&\n                                filter.first.first.first.second.string === 'prototype' &&\n                                filter.first.first.second.string === 'hasOwnProperty' &&\n                                filter.first.second.string === 'call' &&\n                                filter.second[0].string === this.second.string &&\n                                filter.second[1].string === this.first.string\n                            ));\n                            break;\n                        }\n                    }\n                    if (!ok) {\n                        warn('for_if', this);\n                    }\n                }\n            } else {\n                edge();\n                this.first = [];\n                for (;;) {\n                    this.first.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                semicolon();\n                edge();\n                this.second = expected_relation(expression(0));\n                if (this.second.id !== 'true') {\n                    expected_condition(this.second, bundle.unexpected_a);\n                }\n                semicolon(token);\n                if (next_token.id === ';') {\n                    stop('expected_a_b', next_token, ')', ';');\n                }\n                this.third = [];\n                edge();\n                for (;;) {\n                    this.third.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                no_space();\n                step_out(')', paren);\n                one_space();\n                blok = block(true);\n            }\n        }\n        if (blok.disrupt) {\n            warn('strange_loop', prev_token);\n        }\n        this.block = blok;\n        funct['(breakage)'] -= 1;\n        funct['(loopage)'] -= 1;\n        return this;\n    });\n\n    disrupt_stmt('break', function () {\n        var label = next_token.string;\n        this.arity = 'statement';\n        if (funct['(breakage)'] === 0) {\n            warn('unexpected_a', this);\n        }\n        if (next_token.identifier && token.line === next_token.line) {\n            one_space_only();\n            if (funct[label] !== 'label') {\n                warn('not_a_label', next_token);\n            } else if (scope[label].funct !== funct) {\n                warn('not_a_scope', next_token);\n            }\n            this.first = next_token;\n            advance();\n        }\n        return this;\n    });\n\n    disrupt_stmt('continue', function () {\n        if (!option['continue']) {\n            warn('unexpected_a', this);\n        }\n        var label = next_token.string;\n        this.arity = 'statement';\n        if (funct['(breakage)'] === 0) {\n            warn('unexpected_a', this);\n        }\n        if (next_token.identifier && token.line === next_token.line) {\n            one_space_only();\n            if (funct[label] !== 'label') {\n                warn('not_a_label', next_token);\n            } else if (scope[label].funct !== funct) {\n                warn('not_a_scope', next_token);\n            }\n            this.first = next_token;\n            advance();\n        }\n        return this;\n    });\n\n    disrupt_stmt('return', function () {\n        if (funct === global_funct && xmode !== 'scriptstring') {\n            warn('unexpected_a', this);\n        }\n        this.arity = 'statement';\n        if (next_token.id !== ';' && next_token.line === token.line) {\n            one_space_only();\n            if (next_token.id === '/' || next_token.id === '(regexp)') {\n                warn('wrap_regexp');\n            }\n            this.first = expression(0);\n            if (this.first.assign) {\n                warn('unexpected_a', this.first);\n            }\n        }\n        if (peek(0).id === '}' && peek(1).id === 'else') {\n            warn('unexpected_else', this);\n        }\n        return this;\n    });\n\n    disrupt_stmt('throw', function () {\n        this.arity = 'statement';\n        one_space_only();\n        this.first = expression(20);\n        return this;\n    });\n\n\n//  Superfluous reserved words\n\n    reserve('class');\n    reserve('const');\n    reserve('enum');\n    reserve('export');\n    reserve('extends');\n    reserve('import');\n    reserve('super');\n\n// Harmony reserved words\n\n    reserve('implements');\n    reserve('interface');\n    reserve('let');\n    reserve('package');\n    reserve('private');\n    reserve('protected');\n    reserve('public');\n    reserve('static');\n    reserve('yield');\n\n\n// Parse JSON\n\n    function json_value() {\n\n        function json_object() {\n            var brace = next_token, object = {};\n            advance('{');\n            if (next_token.id !== '}') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        warn('unexpected_a', next_token);\n                        advance(',');\n                    }\n                    if (next_token.id !== '(string)') {\n                        warn('expected_string_a');\n                    }\n                    if (object[next_token.string] === true) {\n                        warn('duplicate_a');\n                    } else if (next_token.string === '__proto__') {\n                        warn('dangling_a');\n                    } else {\n                        object[next_token.string] = true;\n                    }\n                    advance();\n                    advance(':');\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === '}') {\n                        warn('unexpected_a', token);\n                        break;\n                    }\n                }\n            }\n            advance('}', brace);\n        }\n\n        function json_array() {\n            var bracket = next_token;\n            advance('[');\n            if (next_token.id !== ']') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        warn('unexpected_a', next_token);\n                        advance(',');\n                    }\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === ']') {\n                        warn('unexpected_a', token);\n                        break;\n                    }\n                }\n            }\n            advance(']', bracket);\n        }\n\n        switch (next_token.id) {\n        case '{':\n            json_object();\n            break;\n        case '[':\n            json_array();\n            break;\n        case 'true':\n        case 'false':\n        case 'null':\n        case '(number)':\n        case '(string)':\n            advance();\n            break;\n        case '-':\n            advance('-');\n            no_space_only();\n            advance('(number)');\n            break;\n        default:\n            stop('unexpected_a');\n        }\n    }\n\n\n// CSS parsing.\n\n    function css_name() {\n        if (next_token.identifier) {\n            advance();\n            return true;\n        }\n    }\n\n\n    function css_number() {\n        if (next_token.id === '-') {\n            advance('-');\n            no_space_only();\n        }\n        if (next_token.id === '(number)') {\n            advance('(number)');\n            return true;\n        }\n    }\n\n\n    function css_string() {\n        if (next_token.id === '(string)') {\n            advance();\n            return true;\n        }\n    }\n\n    function css_color() {\n        var i, number, paren, value;\n        if (next_token.identifier) {\n            value = next_token.string;\n            if (value === 'rgb' || value === 'rgba') {\n                advance();\n                paren = next_token;\n                advance('(');\n                for (i = 0; i < 3; i += 1) {\n                    if (i) {\n                        comma();\n                    }\n                    number = next_token.number;\n                    if (next_token.id !== '(number)' || number < 0) {\n                        warn('expected_positive_a', next_token);\n                        advance();\n                    } else {\n                        advance();\n                        if (next_token.id === '%') {\n                            advance('%');\n                            if (number > 100) {\n                                warn('expected_percent_a', token, number);\n                            }\n                        } else {\n                            if (number > 255) {\n                                warn('expected_small_a', token, number);\n                            }\n                        }\n                    }\n                }\n                if (value === 'rgba') {\n                    comma();\n                    number = next_token.number;\n                    if (next_token.id !== '(number)' || number < 0 || number > 1) {\n                        warn('expected_fraction_a', next_token);\n                    }\n                    advance();\n                    if (next_token.id === '%') {\n                        warn('unexpected_a');\n                        advance('%');\n                    }\n                }\n                advance(')', paren);\n                return true;\n            }\n            if (css_colorData[next_token.string] === true) {\n                advance();\n                return true;\n            }\n        } else if (next_token.id === '(color)') {\n            advance();\n            return true;\n        }\n        return false;\n    }\n\n\n    function css_length() {\n        if (next_token.id === '-') {\n            advance('-');\n            no_space_only();\n        }\n        if (next_token.id === '(number)') {\n            advance();\n            if (next_token.id !== '(string)' &&\n                    css_lengthData[next_token.string] === true) {\n                no_space_only();\n                advance();\n            } else if (+token.number !== 0) {\n                warn('expected_linear_a');\n            }\n            return true;\n        }\n        return false;\n    }\n\n\n    function css_line_height() {\n        if (next_token.id === '-') {\n            advance('-');\n            no_space_only();\n        }\n        if (next_token.id === '(number)') {\n            advance();\n            if (next_token.id !== '(string)' &&\n                    css_lengthData[next_token.string] === true) {\n                no_space_only();\n                advance();\n            }\n            return true;\n        }\n        return false;\n    }\n\n\n    function css_width() {\n        if (next_token.identifier) {\n            switch (next_token.string) {\n            case 'thin':\n            case 'medium':\n            case 'thick':\n                advance();\n                return true;\n            }\n        } else {\n            return css_length();\n        }\n    }\n\n\n    function css_margin() {\n        if (next_token.identifier) {\n            if (next_token.string === 'auto') {\n                advance();\n                return true;\n            }\n        } else {\n            return css_length();\n        }\n    }\n\n    function css_attr() {\n        if (next_token.identifier && next_token.string === 'attr') {\n            advance();\n            advance('(');\n            if (!next_token.identifier) {\n                warn('expected_name_a');\n            }\n            advance();\n            advance(')');\n            return true;\n        }\n        return false;\n    }\n\n\n    function css_comma_list() {\n        while (next_token.id !== ';') {\n            if (!css_name() && !css_string()) {\n                warn('expected_name_a');\n            }\n            if (next_token.id !== ',') {\n                return true;\n            }\n            comma();\n        }\n    }\n\n\n    function css_counter() {\n        if (next_token.identifier && next_token.string === 'counter') {\n            advance();\n            advance('(');\n            advance();\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id !== '(string)') {\n                    warn('expected_string_a');\n                }\n                advance();\n            }\n            advance(')');\n            return true;\n        }\n        if (next_token.identifier && next_token.string === 'counters') {\n            advance();\n            advance('(');\n            if (!next_token.identifier) {\n                warn('expected_name_a');\n            }\n            advance();\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id !== '(string)') {\n                    warn('expected_string_a');\n                }\n                advance();\n            }\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id !== '(string)') {\n                    warn('expected_string_a');\n                }\n                advance();\n            }\n            advance(')');\n            return true;\n        }\n        return false;\n    }\n\n\n    function css_radius() {\n        return css_length() && (next_token.id !== '(number)' || css_length());\n    }\n\n\n    function css_shadow() {\n        for (;;) {\n            if (next_token.string === 'inset') {\n                advance();\n            }\n            for (;;) {\n                if (!css_length()) {\n                    break;\n                }\n            }\n            css_color();\n            if (next_token.id !== ',') {\n                break;\n            }\n            advance(',');\n        }\n        return true;\n    }\n\n\n    function css_shape() {\n        var i;\n        if (next_token.identifier && next_token.string === 'rect') {\n            advance();\n            advance('(');\n            for (i = 0; i < 4; i += 1) {\n                if (!css_length()) {\n                    warn('expected_number_a');\n                    break;\n                }\n            }\n            advance(')');\n            return true;\n        }\n        return false;\n    }\n\n\n    function css_url() {\n        var c, url;\n        if (next_token.identifier && next_token.string === 'url') {\n            next_token = lex.range('(', ')');\n            url = next_token.string;\n            c = url.charAt(0);\n            if (c === '\"' || c === '\\'') {\n                if (url.slice(-1) !== c) {\n                    warn('bad_url_a');\n                } else {\n                    url = url.slice(1, -1);\n                    if (url.indexOf(c) >= 0) {\n                        warn('bad_url_a');\n                    }\n                }\n            }\n            if (!url) {\n                warn('missing_url');\n            }\n            if (ux.test(url)) {\n                stop('bad_url_a');\n            }\n            urls.push(url);\n            advance();\n            return true;\n        }\n        return false;\n    }\n\n\n    css_any = [css_url, function () {\n        for (;;) {\n            if (next_token.identifier) {\n                switch (next_token.string.toLowerCase()) {\n                case 'url':\n                    css_url();\n                    break;\n                case 'expression':\n                    warn('unexpected_a');\n                    advance();\n                    break;\n                default:\n                    advance();\n                }\n            } else {\n                if (next_token.id === ';' || next_token.id === '!'  ||\n                        next_token.id === '(end)' || next_token.id === '}') {\n                    return true;\n                }\n                advance();\n            }\n        }\n    }];\n\n\n    function font_face() {\n        advance_identifier('font-family');\n        advance(':');\n        if (!css_name() && !css_string()) {\n            stop('expected_name_a');\n        }\n        semicolon();\n        advance_identifier('src');\n        advance(':');\n        while (true) {\n            if (next_token.string === 'local') {\n                advance_identifier('local');\n                advance('(');\n                if (ux.test(next_token.string)) {\n                    stop('bad_url_a');\n                }\n\n                if (!css_name() && !css_string()) {\n                    stop('expected_name_a');\n                }\n                advance(')');\n            } else if (!css_url()) {\n                stop('expected_a_b', next_token, 'url', artifact());\n            }\n            if (next_token.id !== ',') {\n                break;\n            }\n            comma();\n        }\n        semicolon();\n    }\n\n\n    css_border_style = [\n        'none', 'dashed', 'dotted', 'double', 'groove',\n        'hidden', 'inset', 'outset', 'ridge', 'solid'\n    ];\n\n    css_break = [\n        'auto', 'always', 'avoid', 'left', 'right'\n    ];\n\n    css_media = {\n        'all': true,\n        'braille': true,\n        'embossed': true,\n        'handheld': true,\n        'print': true,\n        'projection': true,\n        'screen': true,\n        'speech': true,\n        'tty': true,\n        'tv': true\n    };\n\n    css_overflow = [\n        'auto', 'hidden', 'scroll', 'visible'\n    ];\n\n    css_attribute_data = {\n        background: [\n            true, 'background-attachment', 'background-color',\n            'background-image', 'background-position', 'background-repeat'\n        ],\n        'background-attachment': ['scroll', 'fixed'],\n        'background-color': ['transparent', css_color],\n        'background-image': ['none', css_url],\n        'background-position': [\n            2, [css_length, 'top', 'bottom', 'left', 'right', 'center']\n        ],\n        'background-repeat': [\n            'repeat', 'repeat-x', 'repeat-y', 'no-repeat'\n        ],\n        'border': [true, 'border-color', 'border-style', 'border-width'],\n        'border-bottom': [\n            true, 'border-bottom-color', 'border-bottom-style',\n            'border-bottom-width'\n        ],\n        'border-bottom-color': css_color,\n        'border-bottom-left-radius': css_radius,\n        'border-bottom-right-radius': css_radius,\n        'border-bottom-style': css_border_style,\n        'border-bottom-width': css_width,\n        'border-collapse': ['collapse', 'separate'],\n        'border-color': ['transparent', 4, css_color],\n        'border-left': [\n            true, 'border-left-color', 'border-left-style', 'border-left-width'\n        ],\n        'border-left-color': css_color,\n        'border-left-style': css_border_style,\n        'border-left-width': css_width,\n        'border-radius': function () {\n            function count(separator) {\n                var n = 1;\n                if (separator) {\n                    advance(separator);\n                }\n                if (!css_length()) {\n                    return false;\n                }\n                while (next_token.id === '(number)') {\n                    if (!css_length()) {\n                        return false;\n                    }\n                    n += 1;\n                }\n                if (n > 4) {\n                    warn('bad_style');\n                }\n                return true;\n            }\n\n            return count() && (next_token.id !== '/' || count('/'));\n        },\n        'border-right': [\n            true, 'border-right-color', 'border-right-style',\n            'border-right-width'\n        ],\n        'border-right-color': css_color,\n        'border-right-style': css_border_style,\n        'border-right-width': css_width,\n        'border-spacing': [2, css_length],\n        'border-style': [4, css_border_style],\n        'border-top': [\n            true, 'border-top-color', 'border-top-style', 'border-top-width'\n        ],\n        'border-top-color': css_color,\n        'border-top-left-radius': css_radius,\n        'border-top-right-radius': css_radius,\n        'border-top-style': css_border_style,\n        'border-top-width': css_width,\n        'border-width': [4, css_width],\n        bottom: [css_length, 'auto'],\n        'box-shadow': ['none', css_shadow],\n        'caption-side' : ['bottom', 'left', 'right', 'top'],\n        clear: ['both', 'left', 'none', 'right'],\n        clip: [css_shape, 'auto'],\n        color: css_color,\n        content: [\n            'open-quote', 'close-quote', 'no-open-quote', 'no-close-quote',\n            css_string, css_url, css_counter, css_attr\n        ],\n        'counter-increment': [\n            css_name, 'none'\n        ],\n        'counter-reset': [\n            css_name, 'none'\n        ],\n        cursor: [\n            css_url, 'auto', 'crosshair', 'default', 'e-resize', 'help', 'move',\n            'n-resize', 'ne-resize', 'nw-resize', 'pointer', 's-resize',\n            'se-resize', 'sw-resize', 'w-resize', 'text', 'wait'\n        ],\n        direction: ['ltr', 'rtl'],\n        display: [\n            'block', 'compact', 'inline', 'inline-block', 'inline-table',\n            'list-item', 'marker', 'none', 'run-in', 'table', 'table-caption',\n            'table-cell', 'table-column', 'table-column-group',\n            'table-footer-group', 'table-header-group', 'table-row',\n            'table-row-group'\n        ],\n        'empty-cells': ['show', 'hide'],\n        'float': ['left', 'none', 'right'],\n        font: [\n            'caption', 'icon', 'menu', 'message-box', 'small-caption',\n            'status-bar', true, 'font-size', 'font-style', 'font-weight',\n            'font-family'\n        ],\n        'font-family': css_comma_list,\n        'font-size': [\n            'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large',\n            'xx-large', 'larger', 'smaller', css_length\n        ],\n        'font-size-adjust': ['none', css_number],\n        'font-stretch': [\n            'normal', 'wider', 'narrower', 'ultra-condensed',\n            'extra-condensed', 'condensed', 'semi-condensed',\n            'semi-expanded', 'expanded', 'extra-expanded'\n        ],\n        'font-style': [\n            'normal', 'italic', 'oblique'\n        ],\n        'font-variant': [\n            'normal', 'small-caps'\n        ],\n        'font-weight': [\n            'normal', 'bold', 'bolder', 'lighter', css_number\n        ],\n        height: [css_length, 'auto'],\n        left: [css_length, 'auto'],\n        'letter-spacing': ['normal', css_length],\n        'line-height': ['normal', css_line_height],\n        'list-style': [\n            true, 'list-style-image', 'list-style-position', 'list-style-type'\n        ],\n        'list-style-image': ['none', css_url],\n        'list-style-position': ['inside', 'outside'],\n        'list-style-type': [\n            'circle', 'disc', 'square', 'decimal', 'decimal-leading-zero',\n            'lower-roman', 'upper-roman', 'lower-greek', 'lower-alpha',\n            'lower-latin', 'upper-alpha', 'upper-latin', 'hebrew', 'katakana',\n            'hiragana-iroha', 'katakana-oroha', 'none'\n        ],\n        margin: [4, css_margin],\n        'margin-bottom': css_margin,\n        'margin-left': css_margin,\n        'margin-right': css_margin,\n        'margin-top': css_margin,\n        'marker-offset': [css_length, 'auto'],\n        'max-height': [css_length, 'none'],\n        'max-width': [css_length, 'none'],\n        'min-height': css_length,\n        'min-width': css_length,\n        opacity: css_number,\n        outline: [true, 'outline-color', 'outline-style', 'outline-width'],\n        'outline-color': ['invert', css_color],\n        'outline-style': [\n            'dashed', 'dotted', 'double', 'groove', 'inset', 'none',\n            'outset', 'ridge', 'solid'\n        ],\n        'outline-width': css_width,\n        overflow: css_overflow,\n        'overflow-x': css_overflow,\n        'overflow-y': css_overflow,\n        padding: [4, css_length],\n        'padding-bottom': css_length,\n        'padding-left': css_length,\n        'padding-right': css_length,\n        'padding-top': css_length,\n        'page-break-after': css_break,\n        'page-break-before': css_break,\n        position: ['absolute', 'fixed', 'relative', 'static'],\n        quotes: [8, css_string],\n        right: [css_length, 'auto'],\n        'table-layout': ['auto', 'fixed'],\n        'text-align': ['center', 'justify', 'left', 'right'],\n        'text-decoration': [\n            'none', 'underline', 'overline', 'line-through', 'blink'\n        ],\n        'text-indent': css_length,\n        'text-shadow': ['none', 4, [css_color, css_length]],\n        'text-transform': ['capitalize', 'uppercase', 'lowercase', 'none'],\n        top: [css_length, 'auto'],\n        'unicode-bidi': ['normal', 'embed', 'bidi-override'],\n        'vertical-align': [\n            'baseline', 'bottom', 'sub', 'super', 'top', 'text-top', 'middle',\n            'text-bottom', css_length\n        ],\n        visibility: ['visible', 'hidden', 'collapse'],\n        'white-space': [\n            'normal', 'nowrap', 'pre', 'pre-line', 'pre-wrap', 'inherit'\n        ],\n        width: [css_length, 'auto'],\n        'word-spacing': ['normal', css_length],\n        'word-wrap': ['break-word', 'normal'],\n        'z-index': ['auto', css_number]\n    };\n\n    function style_attribute() {\n        var v;\n        while (next_token.id === '*' || next_token.id === '#' ||\n                next_token.string === '_') {\n            if (!option.css) {\n                warn('unexpected_a');\n            }\n            advance();\n        }\n        if (next_token.id === '-') {\n            if (!option.css) {\n                warn('unexpected_a');\n            }\n            advance('-');\n            if (!next_token.identifier) {\n                warn('expected_nonstandard_style_attribute');\n            }\n            advance();\n            return css_any;\n        }\n        if (!next_token.identifier) {\n            warn('expected_style_attribute');\n        } else {\n            if (Object.prototype.hasOwnProperty.call(css_attribute_data,\n                    next_token.string)) {\n                v = css_attribute_data[next_token.string];\n            } else {\n                v = css_any;\n                if (!option.css) {\n                    warn('unrecognized_style_attribute_a');\n                }\n            }\n        }\n        advance();\n        return v;\n    }\n\n\n    function style_value(v) {\n        var i = 0,\n            n,\n            once,\n            match,\n            round,\n            start = 0,\n            vi;\n        switch (typeof v) {\n        case 'function':\n            return v();\n        case 'string':\n            if (next_token.identifier && next_token.string === v) {\n                advance();\n                return true;\n            }\n            return false;\n        }\n        for (;;) {\n            if (i >= v.length) {\n                return false;\n            }\n            vi = v[i];\n            i += 1;\n            if (typeof vi === 'boolean') {\n                break;\n            } else if (typeof vi === 'number') {\n                n = vi;\n                vi = v[i];\n                i += 1;\n            } else {\n                n = 1;\n            }\n            match = false;\n            while (n > 0) {\n                if (style_value(vi)) {\n                    match = true;\n                    n -= 1;\n                } else {\n                    break;\n                }\n            }\n            if (match) {\n                return true;\n            }\n        }\n        start = i;\n        once = [];\n        for (;;) {\n            round = false;\n            for (i = start; i < v.length; i += 1) {\n                if (!once[i]) {\n                    if (style_value(css_attribute_data[v[i]])) {\n                        match = true;\n                        round = true;\n                        once[i] = true;\n                        break;\n                    }\n                }\n            }\n            if (!round) {\n                return match;\n            }\n        }\n    }\n\n    function style_child() {\n        if (next_token.id === '(number)') {\n            advance();\n            if (next_token.string === 'n' && next_token.identifier) {\n                no_space_only();\n                advance();\n                if (next_token.id === '+') {\n                    no_space_only();\n                    advance('+');\n                    no_space_only();\n                    advance('(number)');\n                }\n            }\n            return;\n        }\n        if (next_token.identifier &&\n                (next_token.string === 'odd' || next_token.string === 'even')) {\n            advance();\n            return;\n        }\n        warn('unexpected_a');\n    }\n\n    function substyle() {\n        var v;\n        for (;;) {\n            if (next_token.id === '}' || next_token.id === '(end)' ||\n                    (xquote && next_token.id === xquote)) {\n                return;\n            }\n            v = style_attribute();\n            advance(':');\n            if (next_token.identifier && next_token.string === 'inherit') {\n                advance();\n            } else {\n                if (!style_value(v)) {\n                    warn('unexpected_a');\n                    advance();\n                }\n            }\n            if (next_token.id === '!') {\n                advance('!');\n                no_space_only();\n                if (next_token.identifier && next_token.string === 'important') {\n                    advance();\n                } else {\n                    warn('expected_a_b',\n                        next_token, 'important', artifact());\n                }\n            }\n            if (next_token.id === '}' || next_token.id === xquote) {\n                warn('expected_a_b', next_token, ';', artifact());\n            } else {\n                semicolon();\n            }\n        }\n    }\n\n    function style_selector() {\n        if (next_token.identifier) {\n            if (!Object.prototype.hasOwnProperty.call(html_tag,\n                    next_token.string)) {\n                warn('expected_tagname_a');\n            }\n            advance();\n        } else {\n            switch (next_token.id) {\n            case '>':\n            case '+':\n                advance();\n                style_selector();\n                break;\n            case ':':\n                advance(':');\n                switch (next_token.string) {\n                case 'active':\n                case 'after':\n                case 'before':\n                case 'checked':\n                case 'disabled':\n                case 'empty':\n                case 'enabled':\n                case 'first-child':\n                case 'first-letter':\n                case 'first-line':\n                case 'first-of-type':\n                case 'focus':\n                case 'hover':\n                case 'last-child':\n                case 'last-of-type':\n                case 'link':\n                case 'only-of-type':\n                case 'root':\n                case 'target':\n                case 'visited':\n                    advance_identifier(next_token.string);\n                    break;\n                case 'lang':\n                    advance_identifier('lang');\n                    advance('(');\n                    if (!next_token.identifier) {\n                        warn('expected_lang_a');\n                    }\n                    advance(')');\n                    break;\n                case 'nth-child':\n                case 'nth-last-child':\n                case 'nth-last-of-type':\n                case 'nth-of-type':\n                    advance_identifier(next_token.string);\n                    advance('(');\n                    style_child();\n                    advance(')');\n                    break;\n                case 'not':\n                    advance_identifier('not');\n                    advance('(');\n                    if (next_token.id === ':' && peek(0).string === 'not') {\n                        warn('not');\n                    }\n                    style_selector();\n                    advance(')');\n                    break;\n                default:\n                    warn('expected_pseudo_a');\n                }\n                break;\n            case '#':\n                advance('#');\n                if (!next_token.identifier) {\n                    warn('expected_id_a');\n                }\n                advance();\n                break;\n            case '*':\n                advance('*');\n                break;\n            case '.':\n                advance('.');\n                if (!next_token.identifier) {\n                    warn('expected_class_a');\n                }\n                advance();\n                break;\n            case '[':\n                advance('[');\n                if (!next_token.identifier) {\n                    warn('expected_attribute_a');\n                }\n                advance();\n                if (next_token.id === '=' || next_token.string === '~=' ||\n                        next_token.string === '$=' ||\n                        next_token.string === '|=' ||\n                        next_token.id === '*=' ||\n                        next_token.id === '^=') {\n                    advance();\n                    if (next_token.id !== '(string)') {\n                        warn('expected_string_a');\n                    }\n                    advance();\n                }\n                advance(']');\n                break;\n            default:\n                stop('expected_selector_a');\n            }\n        }\n    }\n\n    function style_pattern() {\n        if (next_token.id === '{') {\n            warn('expected_style_pattern');\n        }\n        for (;;) {\n            style_selector();\n            if (next_token.id === '</' || next_token.id === '{' ||\n                    next_token.id === '}' || next_token.id === '(end)') {\n                return '';\n            }\n            if (next_token.id === ',') {\n                comma();\n            }\n        }\n    }\n\n    function style_list() {\n        while (next_token.id !== '}' && next_token.id !== '</' &&\n                next_token.id !== '(end)') {\n            style_pattern();\n            xmode = 'styleproperty';\n            if (next_token.id === ';') {\n                semicolon();\n            } else {\n                advance('{');\n                substyle();\n                xmode = 'style';\n                advance('}');\n            }\n        }\n    }\n\n    function styles() {\n        var i;\n        while (next_token.id === '@') {\n            i = peek();\n            advance('@');\n            switch (next_token.string) {\n            case 'import':\n                advance_identifier('import');\n                if (!css_url()) {\n                    warn('expected_a_b',\n                        next_token, 'url', artifact());\n                    advance();\n                }\n                semicolon();\n                break;\n            case 'media':\n                advance_identifier('media');\n                for (;;) {\n                    if (!next_token.identifier || css_media[next_token.string] !== true) {\n                        stop('expected_media_a');\n                    }\n                    advance();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                advance('{');\n                style_list();\n                advance('}');\n                break;\n            case 'font-face':\n                advance_identifier('font-face');\n                advance('{');\n                font_face();\n                advance('}');\n                break;\n            default:\n                stop('expected_at_a');\n            }\n        }\n        style_list();\n    }\n\n\n// Parse HTML\n\n    function do_begin(n) {\n        if (n !== 'html' && !option.fragment) {\n            if (n === 'div' && option.adsafe) {\n                stop('adsafe_fragment');\n            } else {\n                stop('expected_a_b', token, 'html', n);\n            }\n        }\n        if (option.adsafe) {\n            if (n === 'html') {\n                stop('adsafe_html', token);\n            }\n            if (option.fragment) {\n                if (n !== 'div') {\n                    stop('adsafe_div', token);\n                }\n            } else {\n                stop('adsafe_fragment', token);\n            }\n        }\n        option.browser = true;\n    }\n\n    function do_attribute(a, v) {\n        var u, x;\n        if (a === 'id') {\n            u = typeof v === 'string' ? v.toUpperCase() : '';\n            if (ids[u] === true) {\n                warn('duplicate_a', next_token, v);\n            }\n            if (!/^[A-Za-z][A-Za-z0-9._:\\-]*$/.test(v)) {\n                warn('bad_id_a', next_token, v);\n            } else if (option.adsafe) {\n                if (adsafe_id) {\n                    if (v.slice(0, adsafe_id.length) !== adsafe_id) {\n                        warn('adsafe_prefix_a', next_token, adsafe_id);\n                    } else if (!/^[A-Z]+_[A-Z]+$/.test(v)) {\n                        warn('adsafe_bad_id');\n                    }\n                } else {\n                    adsafe_id = v;\n                    if (!/^[A-Z]+_$/.test(v)) {\n                        warn('adsafe_bad_id');\n                    }\n                }\n            }\n            x = v.search(dx);\n            if (x >= 0) {\n                warn('unexpected_char_a_b', token, v.charAt(x), a);\n            }\n            ids[u] = true;\n        } else if (a === 'class' || a === 'type' || a === 'name') {\n            x = v.search(qx);\n            if (x >= 0) {\n                warn('unexpected_char_a_b', token, v.charAt(x), a);\n            }\n            ids[u] = true;\n        } else if (a === 'href' || a === 'background' ||\n                a === 'content' || a === 'data' ||\n                a.indexOf('src') >= 0 || a.indexOf('url') >= 0) {\n            if (option.safe && ux.test(v)) {\n                stop('bad_url_a', next_token, v);\n            }\n            urls.push(v);\n        } else if (a === 'for') {\n            if (option.adsafe) {\n                if (adsafe_id) {\n                    if (v.slice(0, adsafe_id.length) !== adsafe_id) {\n                        warn('adsafe_prefix_a', next_token, adsafe_id);\n                    } else if (!/^[A-Z]+_[A-Z]+$/.test(v)) {\n                        warn('adsafe_bad_id');\n                    }\n                } else {\n                    warn('adsafe_bad_id');\n                }\n            }\n        } else if (a === 'name') {\n            if (option.adsafe && v.indexOf('_') >= 0) {\n                warn('adsafe_name_a', next_token, v);\n            }\n        }\n    }\n\n    function do_tag(tag, name, attribute) {\n        var i, script, x;\n        src = false;\n        if (stack.length > 0) {\n            if (name === 'html') {\n                stop('unexpected_a', token, name);\n            }\n            x = tag.parent;\n            if (x) {\n                if (x.indexOf(' ' + stack[stack.length - 1].name + ' ') < 0) {\n                    stop('tag_a_in_b', token, name, x);\n                }\n            } else if (x !== false && !option.adsafe && !option.fragment) {\n                i = stack.length;\n                do {\n                    if (i <= 0) {\n                        stop('tag_a_in_b', token, name, 'body');\n                    }\n                    i -= 1;\n                } while (stack[i].name !== 'body');\n            }\n        }\n        switch (name) {\n        case 'div':\n            if (option.adsafe && stack.length === 1 && !adsafe_id) {\n                warn('adsafe_missing_id');\n            }\n            break;\n        case 'script':\n            xmode = 'script';\n            advance('>');\n            if (attribute.lang) {\n                warn('lang', token);\n            }\n            if (option.adsafe && stack.length !== 1) {\n                warn('adsafe_placement', token);\n            }\n            if (attribute.src) {\n                if (option.adsafe && (!adsafe_may || !approved[attribute.src])) {\n                    warn('adsafe_source', token);\n                }\n            } else {\n                step_in(next_token.from);\n                edge();\n                use_strict();\n                adsafe_top = true;\n                script = statements();\n\n// JSLint is also the static analyzer for ADsafe. See www.ADsafe.org.\n\n                if (option.adsafe) {\n                    if (adsafe_went) {\n                        stop('adsafe_script', token);\n                    }\n                    if (script.length !== 1 ||\n                            aint(script[0],             'id',     '(') ||\n                            aint(script[0].first,       'id',     '.') ||\n                            aint(script[0].first.first, 'string', 'ADSAFE') ||\n                            aint(script[0].second[0],   'string', adsafe_id)) {\n                        stop('adsafe_id_go');\n                    }\n                    switch (script[0].first.second.string) {\n                    case 'id':\n                        if (adsafe_may || adsafe_went ||\n                                script[0].second.length !== 1) {\n                            stop('adsafe_id', next_token);\n                        }\n                        adsafe_may = true;\n                        break;\n                    case 'go':\n                        if (adsafe_went) {\n                            stop('adsafe_go');\n                        }\n                        if (script[0].second.length !== 2 ||\n                                aint(script[0].second[1], 'id', 'function') ||\n                                !script[0].second[1].first ||\n                                aint(script[0].second[1].first[0], 'string', 'dom') ||\n                                script[0].second[1].first.length > 2 ||\n                                (script[0].second[1].first.length === 2 &&\n                                aint(script[0].second[1].first[1], 'string', 'lib'))) {\n                            stop('adsafe_go', next_token);\n                        }\n                        adsafe_went = true;\n                        break;\n                    default:\n                        stop('adsafe_id_go');\n                    }\n                }\n                indent = null;\n            }\n            xmode = 'html';\n            advance('</');\n            advance_identifier('script');\n            xmode = 'outer';\n            break;\n        case 'style':\n            xmode = 'style';\n            advance('>');\n            styles();\n            xmode = 'html';\n            advance('</');\n            advance_identifier('style');\n            break;\n        case 'input':\n            switch (attribute.type) {\n            case 'button':\n            case 'checkbox':\n            case 'color':\n            case 'date':\n            case 'datetime':\n            case 'datetime-local':\n            case 'month':\n            case 'number':\n            case 'radio':\n            case 'range':\n            case 'reset':\n            case 'submit':\n            case 'time':\n            case 'week':\n                break;\n            case 'email':\n            case 'file':\n            case 'hidden':\n            case 'image':\n            case 'password':\n            case 'search':\n            case 'tel':\n            case 'text':\n            case 'url':\n                if (option.adsafe && attribute.autocomplete !== 'off') {\n                    warn('adsafe_autocomplete');\n                }\n                break;\n            default:\n                warn('bad_type');\n            }\n            break;\n        case 'applet':\n        case 'body':\n        case 'embed':\n        case 'frame':\n        case 'frameset':\n        case 'head':\n        case 'iframe':\n        case 'noembed':\n        case 'noframes':\n        case 'object':\n        case 'param':\n            if (option.adsafe) {\n                warn('adsafe_tag', next_token, name);\n            }\n            break;\n        }\n    }\n\n\n    function closetag(name) {\n        return '</' + name + '>';\n    }\n\n    function html() {\n        var attribute, attributes, is_empty, name, old_white = option.white,\n            quote, tag_name, tag, value, wmode;\n        xmode = 'html';\n        xquote = '';\n        stack = null;\n        for (;;) {\n            switch (next_token.string) {\n            case '<':\n                xmode = 'html';\n                advance('<');\n                attributes = {};\n                tag_name = next_token;\n                name = tag_name.string;\n                advance_identifier(name);\n                tag_name.name = name;\n                if (!stack) {\n                    stack = [];\n                    do_begin(name);\n                }\n                tag = html_tag[name];\n                if (typeof tag !== 'object') {\n                    tag = {parent: false};\n                    warn('unrecognized_tag_a', tag_name, name === name.toLowerCase()\n                        ? name\n                        : name + ' (capitalization error)');\n                } else {\n                    is_empty = tag.empty;\n                }\n                tag_name.type = name;\n                for (;;) {\n                    if (next_token.id === '/') {\n                        advance('/');\n                        if (next_token.id !== '>') {\n                            warn('expected_a_b', next_token, '>', artifact());\n                        }\n                        break;\n                    }\n                    if (next_token.id && next_token.id.charAt(0) === '>') {\n                        break;\n                    }\n                    if (!next_token.identifier) {\n                        if (next_token.id === '(end)' || next_token.id === '(error)') {\n                            warn('expected_a_b', next_token, '>', artifact());\n                        }\n                        warn('bad_name_a');\n                    }\n                    option.white = false;\n                    spaces();\n                    attribute = next_token.string;\n                    option.white = old_white;\n                    advance();\n                    if (attribute !== attribute.toLowerCase()) {\n                        warn('attribute_case_a', token);\n                    }\n                    attribute = attribute.toLowerCase();\n                    xquote = '';\n                    if (Object.prototype.hasOwnProperty.call(attributes, attribute)) {\n                        warn('duplicate_a', token, attribute);\n                    }\n                    if (attribute.slice(0, 2) === 'on') {\n                        if (!option.on) {\n                            warn('html_handlers');\n                        }\n                        xmode = 'scriptstring';\n                        advance('=');\n                        quote = next_token.id;\n                        if (quote !== '\"' && quote !== '\\'') {\n                            stop('expected_a_b', next_token, '\"', artifact());\n                        }\n                        xquote = quote;\n                        wmode = option.white;\n                        option.white = true;\n                        advance(quote);\n                        use_strict();\n                        statements();\n                        option.white = wmode;\n                        if (next_token.id !== quote) {\n                            stop('expected_a_b', next_token, quote, artifact());\n                        }\n                        xmode = 'html';\n                        xquote = '';\n                        advance(quote);\n                        value = false;\n                    } else if (attribute === 'style') {\n                        xmode = 'scriptstring';\n                        advance('=');\n                        quote = next_token.id;\n                        if (quote !== '\"' && quote !== '\\'') {\n                            stop('expected_a_b', next_token, '\"', artifact());\n                        }\n                        xmode = 'styleproperty';\n                        xquote = quote;\n                        advance(quote);\n                        substyle();\n                        xmode = 'html';\n                        xquote = '';\n                        advance(quote);\n                        value = false;\n                    } else {\n                        if (next_token.id === '=') {\n                            advance('=');\n                            value = next_token.string;\n                            if (!next_token.identifier &&\n                                    next_token.id !== '\"' &&\n                                    next_token.id !== '\\'' &&\n                                    next_token.id !== '(string)' &&\n                                    next_token.id !== '(number)' &&\n                                    next_token.id !== '(color)') {\n                                warn('expected_attribute_value_a', token, attribute);\n                            }\n                            advance();\n                        } else {\n                            value = true;\n                        }\n                    }\n                    attributes[attribute] = value;\n                    do_attribute(attribute, value);\n                }\n                do_tag(tag, name, attributes);\n                if (!is_empty) {\n                    stack.push(tag_name);\n                }\n                xmode = 'outer';\n                advance('>');\n                break;\n            case '</':\n                xmode = 'html';\n                advance('</');\n                if (!next_token.identifier) {\n                    warn('bad_name_a');\n                }\n                name = next_token.string;\n                advance();\n                if (!stack) {\n                    stop('unexpected_a', next_token, closetag(name));\n                }\n                tag_name = stack.pop();\n                if (!tag_name) {\n                    stop('unexpected_a', next_token, closetag(name));\n                }\n                if (tag_name.name !== name) {\n                    stop('expected_a_b',\n                        next_token, closetag(tag_name.name), closetag(name));\n                }\n                if (next_token.id !== '>') {\n                    stop('expected_a_b', next_token, '>', artifact());\n                }\n                xmode = 'outer';\n                advance('>');\n                break;\n            case '<!':\n                if (option.safe) {\n                    warn('adsafe_a');\n                }\n                xmode = 'html';\n                for (;;) {\n                    advance();\n                    if (next_token.id === '>' || next_token.id === '(end)') {\n                        break;\n                    }\n                    if (next_token.string.indexOf('--') >= 0) {\n                        stop('unexpected_a', next_token, '--');\n                    }\n                    if (next_token.string.indexOf('<') >= 0) {\n                        stop('unexpected_a', next_token, '<');\n                    }\n                    if (next_token.string.indexOf('>') >= 0) {\n                        stop('unexpected_a', next_token, '>');\n                    }\n                }\n                xmode = 'outer';\n                advance('>');\n                break;\n            case '(end)':\n                if (stack.length !== 0) {\n                    warn('missing_a', next_token, '</' + stack.pop().string + '>');\n                }\n                return;\n            default:\n                if (next_token.id === '(end)') {\n                    stop('missing_a', next_token,\n                        '</' + stack[stack.length - 1].string + '>');\n                } else {\n                    advance();\n                }\n            }\n            if (stack && stack.length === 0 && (option.adsafe ||\n                    !option.fragment || next_token.id === '(end)')) {\n                break;\n            }\n        }\n        if (next_token.id !== '(end)') {\n            stop('unexpected_a');\n        }\n    }\n\n\n// The actual JSLINT function itself.\n\n    itself = function JSLint(the_source, the_option) {\n\n        var i, predef, tree;\n        JSLINT.errors = [];\n        JSLINT.tree = '';\n        JSLINT.properties = '';\n        begin = prev_token = token = next_token =\n            Object.create(syntax['(begin)']);\n        predefined = {};\n        add_to_predefined(standard);\n        property = {};\n        if (the_option) {\n            option = Object.create(the_option);\n            predef = option.predef;\n            if (predef) {\n                if (Array.isArray(predef)) {\n                    for (i = 0; i < predef.length; i += 1) {\n                        predefined[predef[i]] = true;\n                    }\n                } else if (typeof predef === 'object') {\n                    add_to_predefined(predef);\n                }\n            }\n            do_safe();\n        } else {\n            option = {};\n        }\n        option.indent = +option.indent || 4;\n        option.maxerr = +option.maxerr || 50;\n        adsafe_id = '';\n        adsafe_may = adsafe_top = adsafe_went = false;\n        approved = {};\n        if (option.approved) {\n            for (i = 0; i < option.approved.length; i += 1) {\n                approved[option.approved[i]] = option.approved[i];\n            }\n        } else {\n            approved.test = 'test';\n        }\n        tab = '';\n        for (i = 0; i < option.indent; i += 1) {\n            tab += ' ';\n        }\n        global_scope = scope = {};\n        global_funct = funct = {\n            '(scope)': scope,\n            '(breakage)': 0,\n            '(loopage)': 0\n        };\n        functions = [funct];\n\n        comments_off = false;\n        ids = {};\n        in_block = false;\n        indent = null;\n        json_mode = false;\n        lookahead = [];\n        node_js = false;\n        prereg = true;\n        src = false;\n        stack = null;\n        strict_mode = false;\n        urls = [];\n        var_mode = null;\n        warnings = 0;\n        xmode = '';\n        lex.init(the_source);\n\n        assume();\n\n        try {\n            advance();\n            if (next_token.id === '(number)') {\n                stop('unexpected_a');\n            } else if (next_token.string.charAt(0) === '<') {\n                html();\n                if (option.adsafe && !adsafe_went) {\n                    warn('adsafe_go', this);\n                }\n            } else {\n                switch (next_token.id) {\n                case '{':\n                case '[':\n                    json_mode = true;\n                    json_value();\n                    break;\n                case '@':\n                case '*':\n                case '#':\n                case '.':\n                case ':':\n                    xmode = 'style';\n                    advance();\n                    if (token.id !== '@' || !next_token.identifier ||\n                            next_token.string !== 'charset' || token.line !== 1 ||\n                            token.from !== 1) {\n                        stop('css');\n                    }\n                    advance();\n                    if (next_token.id !== '(string)' &&\n                            next_token.string !== 'UTF-8') {\n                        stop('css');\n                    }\n                    advance();\n                    semicolon();\n                    styles();\n                    break;\n\n                default:\n                    if (option.adsafe && option.fragment) {\n                        stop('expected_a_b',\n                            next_token, '<div>', artifact());\n                    }\n\n// If the first token is a semicolon, ignore it. This is sometimes used when\n// files are intended to be appended to files that may be sloppy. A sloppy\n// file may be depending on semicolon insertion on its last line.\n\n                    step_in(1);\n                    if (next_token.id === ';' && !node_js) {\n                        semicolon();\n                    }\n                    adsafe_top = true;\n                    tree = statements();\n                    begin.first = tree;\n                    itself.tree = begin;\n                    if (option.adsafe && (tree.length !== 1 ||\n                            aint(tree[0], 'id', '(') ||\n                            aint(tree[0].first, 'id', '.') ||\n                            aint(tree[0].first.first, 'string', 'ADSAFE') ||\n                            aint(tree[0].first.second, 'string', 'lib') ||\n                            tree[0].second.length !== 2 ||\n                            tree[0].second[0].id !== '(string)' ||\n                            aint(tree[0].second[1], 'id', 'function'))) {\n                        stop('adsafe_lib');\n                    }\n                    if (tree.disrupt) {\n                        warn('weird_program', prev_token);\n                    }\n                }\n            }\n            indent = null;\n            advance('(end)');\n            itself.property = property;\n        } catch (e) {\n            if (e) {        // ~~\n                JSLINT.errors.push({\n                    reason    : e.message,\n                    line      : e.line || next_token.line,\n                    character : e.character || next_token.from\n                }, null);\n            }\n        }\n        return JSLINT.errors.length === 0;\n    };\n\n\n// Data summary.\n\n    itself.data = function () {\n        var data = {functions: []},\n            function_data,\n            globals,\n            i,\n            j,\n            kind,\n            name,\n            the_function,\n            undef = [],\n            unused = [];\n        if (itself.errors.length) {\n            data.errors = itself.errors;\n        }\n\n        if (json_mode) {\n            data.json = true;\n        }\n\n        if (urls.length > 0) {\n            data.urls = urls;\n        }\n\n        globals = Object.keys(global_scope).filter(function (value) {\n            return value.charAt(0) !== '(' && typeof standard[value] !== 'boolean';\n        });\n        if (globals.length > 0) {\n            data.globals = globals;\n        }\n\n        for (i = 1; i < functions.length; i += 1) {\n            the_function = functions[i];\n            function_data = {};\n            for (j = 0; j < functionicity.length; j += 1) {\n                function_data[functionicity[j]] = [];\n            }\n            for (name in the_function) {\n                if (Object.prototype.hasOwnProperty.call(the_function, name)) {\n                    if (name.charAt(0) !== '(') {\n                        kind = the_function[name];\n                        if (kind === 'unction' || kind === 'unparam') {\n                            kind = 'unused';\n                        }\n                        if (Array.isArray(function_data[kind])) {\n                            function_data[kind].push(name);\n                            if (kind === 'unused') {\n                                unused.push({\n                                    name: name,\n                                    line: the_function['(line)'],\n                                    'function': the_function['(name)']\n                                });\n                            } else if (kind === 'undef') {\n                                undef.push({\n                                    name: name,\n                                    line: the_function['(line)'],\n                                    'function': the_function['(name)']\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            for (j = 0; j < functionicity.length; j += 1) {\n                if (function_data[functionicity[j]].length === 0) {\n                    delete function_data[functionicity[j]];\n                }\n            }\n            function_data.name = the_function['(name)'];\n            function_data.params = the_function['(params)'];\n            function_data.line = the_function['(line)'];\n            data.functions.push(function_data);\n        }\n\n        if (unused.length > 0) {\n            data.unused = unused;\n        }\n        if (undef.length > 0) {\n            data['undefined'] = undef;\n        }\n        return data;\n    };\n\n    itself.error_report = function (data) {\n        var evidence, i, output = [], snippets, warning;\n        if (data.errors) {\n            if (data.json) {\n                output.push('<cite>JSON: bad.</cite><br>');\n            }\n            for (i = 0; i < data.errors.length; i += 1) {\n                warning = data.errors[i];\n                if (warning) {\n                    evidence = warning.evidence || '';\n                    output.push('<cite>');\n                    if (isFinite(warning.line)) {\n                        output.push('<address>line ' +\n                            String(warning.line) +\n                            ' character ' + String(warning.character) +\n                            '</address>');\n                    }\n                    output.push(warning.reason.entityify() + '</cite>');\n                    if (evidence) {\n                        output.push('<pre>' + evidence.entityify() + '</pre>');\n                    }\n                }\n            }\n        }\n        if (data.unused || data['undefined']) {\n            output.push('<dl>');\n            if (data['undefined']) {\n                output.push('<dt>undefined</dt><dd>');\n                snippets = [];\n                for (i = 0; i < data['undefined'].length; i += 1) {\n                    snippets[i] = '<code>' + data['undefined'][i].name +\n                        '</code>&nbsp;<address>' +\n                        data['undefined'][i]['function']  + ' ' +\n                        String(data['undefined'][i].line) + '</address>';\n                }\n                output.push(snippets.join(', '));\n                output.push('</dd>');\n            }\n            if (data.unused) {\n                output.push('<dt>unused</dt><dd>');\n                snippets = [];\n                for (i = 0; i < data.unused.length; i += 1) {\n                    snippets[i] = '<code>' + data.unused[i].name + '</code>&nbsp;<address>' +\n                        data.unused[i]['function']  + ' ' +\n                        String(data.unused[i].line) + '</address>';\n                }\n                output.push(snippets.join(', '));\n                output.push('</dd>');\n            }\n            output.push('</dl>');\n        }\n        return output.join('');\n    };\n\n\n    itself.report = function (data) {\n        var dl, i, j, names, output = [], the_function;\n\n        function detail(h, value) {\n            var comma_needed, singularity;\n            if (Array.isArray(value)) {\n                output.push(\"<dt>\" + h + \"</dt><dd>\");\n                value.sort().forEach(function (item) {\n                    if (item !== singularity) {\n                        singularity = item;\n                        output.push((comma_needed ? ', ' : '') + singularity);\n                        comma_needed = true;\n                    }\n                });\n                output.push(\"</dd>\");\n            } else if (value) {\n                output.push(\"<dt>\" + h + \"</dt><dd>\", value, \"</dd>\");\n            }\n        }\n\n        output.push('<dl>');\n        if (data.urls) {\n            detail('url', data.urls);\n            dl = true;\n        }\n        if (data.globals) {\n            detail('global', data.globals);\n            dl = true;\n        } else if (xmode === 'style') {\n            output.push(\"<dt>CSS.</dt>\");\n        } else if (data.json) {\n            if (!data.errors) {\n                output.push(\"<dt>JSON: good.</dt>\");\n            }\n        } else {\n            output.push(\"<dt><i>No new global variables introduced.</i></dt>\");\n        }\n        if (dl) {\n            output.push(\"</dl>\");\n        } else {\n            output[0] = '';\n        }\n\n        if (data.functions) {\n            for (i = 0; i < data.functions.length; i += 1) {\n                the_function = data.functions[i];\n                names = [];\n                if (the_function.params) {\n                    for (j = 0; j < the_function.params.length; j += 1) {\n                        names[j] = the_function.params[j].string;\n                    }\n                }\n                output.push('<dl><address>line ' +\n                    String(the_function.line) + '</address>' +\n                    the_function.name.entityify() +\n                    '(' + names.join(', ') + ')');\n                detail('undefined', the_function['undefined']);\n                detail('unused', the_function.unused);\n                detail('closure', the_function.closure);\n                detail('variable', the_function['var']);\n                detail('exception', the_function.exception);\n                detail('outer', the_function.outer);\n                detail('global', the_function.global);\n                detail('label', the_function.label);\n                output.push('</dl>');\n            }\n        }\n        return output.join('');\n    };\n\n    itself.properties_report = function (property) {\n        if (!property) {\n            return '';\n        }\n        var i,\n            key,\n            keys = Object.keys(property).sort(),\n            length,\n            mem = '    ',\n            name,\n            not_first = false,\n            output = ['/*properties'];\n        for (i = 0; i < keys.length; i += 1) {\n            key = keys[i];\n            if (property[key] > 0) {\n                if (not_first) {\n                    mem += ', ';\n                }\n                name = ix.test(key)\n                    ? key\n                    : '\\'' + key.replace(nx, sanitize) + '\\'';\n                length += name.length + 2;\n                if (mem.length + name.length > 80) {\n                    output.push(mem);\n                    mem = '    ';\n                }\n                mem += name;\n                not_first = true;\n            }\n        }\n        output.push(mem, '*/\\n');\n        return output.join('\\n');\n    };\n\n    itself.jslint = itself;\n\n    itself.edition = '2013-02-03';\n\n    return itself;\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jslint-2013-08-13.js":"// jslint.js\n// 2013-08-13\n\n// Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// The Software shall be used for Good, not Evil.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// WARNING: JSLint will hurt your feelings.\n\n// JSLINT is a global function. It takes two parameters.\n\n//     var myResult = JSLINT(source, option);\n\n// The first parameter is either a string or an array of strings. If it is a\n// string, it will be split on '\\n' or '\\r'. If it is an array of strings, it\n// is assumed that each string represents one line. The source can be a\n// JavaScript text or a JSON text.\n\n// The second parameter is an optional object of options that control the\n// operation of JSLINT. Most of the options are booleans: They are all\n// optional and have a default value of false. One of the options, predef,\n// can be an array of names, which will be used to declare global variables,\n// or an object whose keys are used as global names, with a boolean value\n// that determines if they are assignable.\n\n// If it checks out, JSLINT returns true. Otherwise, it returns false.\n\n// If false, you can inspect JSLINT.errors to find out the problems.\n// JSLINT.errors is an array of objects containing these properties:\n\n//  {\n//      line      : The line (relative to 0) at which the lint was found\n//      character : The character (relative to 0) at which the lint was found\n//      reason    : The problem\n//      evidence  : The text line in which the problem occurred\n//      raw       : The raw message before the details were inserted\n//      a         : The first detail\n//      b         : The second detail\n//      c         : The third detail\n//      d         : The fourth detail\n//  }\n\n// If a stopping error was found, a null will be the last element of the\n// JSLINT.errors array. A stopping error means that JSLint was not confident\n// enough to continue. It does not necessarily mean that the error was\n// especially heinous.\n\n// You can request a data structure that contains JSLint's results.\n\n//     var myData = JSLINT.data();\n\n// It returns a structure with this form:\n\n//     {\n//         errors: [\n//             {\n//                 line: NUMBER,\n//                 character: NUMBER,\n//                 reason: STRING,\n//                 evidence: STRING\n//             }\n//         ],\n//         functions: [\n//             {\n//                 name: STRING,\n//                 line: NUMBER,\n//                 level: NUMBER,\n//                 parameter: [\n//                     STRING\n//                 ],\n//                 var: [\n//                     STRING\n//                 ],\n//                 exception: [\n//                     STRING\n//                 ],\n//                 closure: [\n//                     STRING\n//                 ],\n//                 outer: [\n//                     STRING\n//                 ],\n//                 global: [\n//                     STRING\n//                 ],\n//                 label: [\n//                     STRING\n//                 ]\n//             }\n//         ],\n//         global: [\n//             STRING\n//         ],\n//         member: {\n//             STRING: NUMBER\n//         },\n//         json: BOOLEAN\n//     }\n\n// You can request a Function Report, which shows all of the functions\n// and the parameters and vars that they use. This can be used to find\n// implied global variables and other problems. The report is in HTML and\n// can be inserted into an HTML <body>. It should be given the result of the\n// JSLINT.data function.\n\n//     var myReport = JSLINT.report(data);\n\n// You can request an HTML error report.\n\n//     var myErrorReport = JSLINT.error_report(data);\n\n// You can obtain an object containing all of the properties found in the\n// file. JSLINT.property contains an object containing a key for each\n// property used in the program, the value being the number of times that\n// property name was used in the file.\n\n// You can request a properties report, which produces a list of the program's\n// properties in the form of a /*properties*/ declaration.\n\n//      var myPropertyReport = JSLINT.properties_report(JSLINT.property);\n\n// You can obtain the parse tree that JSLint constructed while parsing. The\n// latest tree is kept in JSLINT.tree. A nice stringification can be produced\n// with\n\n//     JSON.stringify(JSLINT.tree, [\n//         'string',  'arity', 'name',  'first',\n//         'second', 'third', 'block', 'else'\n//     ], 4));\n\n// You can request a context coloring table. It contains information that can be\n// applied to the file that was analyzed. Context coloring colors functions\n// based on their nesting level, and variables on the color of the functions\n// in which they are defined.\n\n//      var myColorization = JSLINT.color(data);\n\n// It returns an array containing objects of this form:\n\n//      {\n//          from: COLUMN,\n//          thru: COLUMN,\n//          line: ROW,\n//          level: 0 or higher\n//      }\n\n// JSLint provides three inline directives. They look like slashstar comments,\n// and allow for setting options, declaring global variables, and establishing a\n// set of allowed property names.\n\n// These directives respect function scope.\n\n// The jslint directive is a special comment that can set one or more options.\n// For example:\n\n/*jslint\n    es5: true, evil: true, nomen: true, regexp: true, todo: true\n*/\n\n// The current option set is\n\n//     ass        true, if assignment expressions should be allowed\n//     bitwise    true, if bitwise operators should be allowed\n//     browser    true, if the standard browser globals should be predefined\n//     closure    true, if Google Closure idioms should be tolerated\n//     continue   true, if the continuation statement should be tolerated\n//     debug      true, if debugger statements should be allowed\n//     devel      true, if logging should be allowed (console, alert, etc.)\n//     eqeq       true, if == should be allowed\n//     es5        true, if ES5 syntax should be allowed\n//     evil       true, if eval should be allowed\n//     forin      true, if for in statements need not filter\n//     indent     the indentation factor\n//     maxerr     the maximum number of errors to allow\n//     maxlen     the maximum length of a source line\n//     newcap     true, if constructor names capitalization is ignored\n//     node       true, if Node.js globals should be predefined\n//     nomen      true, if names may have dangling _\n//     passfail   true, if the scan should stop on first error\n//     plusplus   true, if increment/decrement should be allowed\n//     properties true, if all property names must be declared with /*properties*/\n//     regexp     true, if the . should be allowed in regexp literals\n//     rhino      true, if the Rhino environment globals should be predefined\n//     unparam    true, if unused parameters should be tolerated\n//     sloppy     true, if the 'use strict'; pragma is optional\n//     stupid     true, if really stupid practices are tolerated\n//     sub        true, if all forms of subscript notation are tolerated\n//     todo       true, if TODO comments are tolerated\n//     vars       true, if multiple var statements per function should be allowed\n//     white      true, if sloppy whitespace is tolerated\n\n// The properties directive declares an exclusive list of property names.\n// Any properties named in the program that are not in the list will\n// produce a warning.\n\n// For example:\n\n/*properties\n    '\\b', '\\t', '\\n', '\\f', '\\r', '!', '!=', '!==', '\"', '%', '\\'', '(begin)',\n    '(error)', '*', '+', '-', '/', '<', '<=', '==', '===', '>', '>=', '\\\\', a,\n    a_label, a_scope, already_defined, and, arguments, arity, ass, assign,\n    assignment_expression, assignment_function_expression, at, avoid_a, b,\n    bad_assignment, bad_constructor, bad_in_a, bad_invocation, bad_new,\n    bad_number, bad_operand, bad_wrap, bitwise, block, browser, c, call, charAt,\n    charCodeAt, character, closure, code, color, combine_var, comments,\n    conditional_assignment, confusing_a, confusing_regexp, constructor_name_a,\n    continue, control_a, couch, create, d, dangling_a, data, dead, debug,\n    deleted, devel, disrupt, duplicate_a, edge, edition, else, empty_block,\n    empty_case, empty_class, entityify, eqeq, error_report, errors, es5,\n    evidence, evil, exception, exec, expected_a_at_b_c, expected_a_b,\n    expected_a_b_from_c_d, expected_id_a, expected_identifier_a,\n    expected_identifier_a_reserved, expected_number_a, expected_operator_a,\n    expected_positive_a, expected_small_a, expected_space_a_b,\n    expected_string_a, f, first, flag, floor, forEach, for_if, forin, from,\n    fromCharCode, fud, function, function_block, function_eval, function_loop,\n    function_statement, function_strict, functions, global, hasOwnProperty, id,\n    identifier, identifier_function, immed, implied_evil, indent, indexOf,\n    infix_in, init, insecure_a, isAlpha, isArray, isDigit, isNaN, join, jslint,\n    json, keys, kind, label, labeled, lbp, leading_decimal_a, led, left, length,\n    level, line, loopage, master, match, maxerr, maxlen, message, missing_a,\n    missing_a_after_b, missing_property, missing_space_a_b, missing_use_strict,\n    mode, move_invocation, move_var, n, name, name_function, nested_comment,\n    newcap, node, nomen, not, not_a_constructor, not_a_defined, not_a_function,\n    not_a_label, not_a_scope, not_greater, nud, number, octal_a, open, outer,\n    parameter, parameter_a_get_b, parameter_arguments_a, parameter_set_a,\n    params, paren, passfail, plusplus, postscript, predef, properties,\n    properties_report, property, prototype, push, quote, r, radix, raw,\n    read_only, reason, redefinition_a_b, regexp, relation, replace, report,\n    reserved, reserved_a, rhino, right, scanned_a_b, scope, search, second,\n    shift, slash_equal, slice, sloppy, sort, split, statement, statement_block,\n    stop, stopping, strange_loop, strict, string, stupid, sub, subscript,\n    substr, supplant, sync_a, t, tag_a_in_b, test, third, thru, toString, todo,\n    todo_comment, token, tokens, too_long, too_many, trailing_decimal_a, tree,\n    unclosed, unclosed_comment, unclosed_regexp, unescaped_a, unexpected_a,\n    unexpected_char_a, unexpected_comment, unexpected_label_a,\n    unexpected_property_a, unexpected_space_a_b, unexpected_typeof_a,\n    uninitialized_a, unnecessary_else, unnecessary_initialize, unnecessary_use,\n    unparam, unreachable_a_b, unsafe, unused_a, url, use_array, use_braces,\n    use_object, use_or, use_param, use_spaces, used, used_before_a, var,\n    var_a_not, var_loop, vars, varstatement, warn, warning, was,\n    weird_assignment, weird_condition, weird_new, weird_program, weird_relation,\n    weird_ternary, white, wrap, wrap_immediate, wrap_regexp, write_is_wrong,\n    writeable\n*/\n\n// The global directive is used to declare global variables that can\n// be accessed by the program. If a declaration is true, then the variable\n// is writeable. Otherwise, it is read-only.\n\n// We build the application inside a function so that we produce only a single\n// global variable. That function will be invoked immediately, and its return\n// value is the JSLINT function itself. That function is also an object that\n// can contain data and other functions.\n\nvar JSLINT = (function () {\n    'use strict';\n\n    function array_to_object(array, value) {\n\n// Make an object from an array of keys and a common value.\n\n        var i, length = array.length, object = Object.create(null);\n        for (i = 0; i < length; i += 1) {\n            object[array[i]] = value;\n        }\n        return object;\n    }\n\n\n    var allowed_option = {\n            ass       : true,\n            bitwise   : true,\n            browser   : true,\n            closure   : true,\n            continue  : true,\n            couch     : true,\n            debug     : true,\n            devel     : true,\n            eqeq      : true,\n            es5       : true,\n            evil      : true,\n            forin     : true,\n            indent    :   10,\n            maxerr    : 1000,\n            maxlen    :  256,\n            newcap    : true,\n            node      : true,\n            nomen     : true,\n            passfail  : true,\n            plusplus  : true,\n            properties: true,\n            regexp    : true,\n            rhino     : true,\n            unparam   : true,\n            sloppy    : true,\n            stupid    : true,\n            sub       : true,\n            todo      : true,\n            vars      : true,\n            white     : true\n        },\n        anonname,       // The guessed name for anonymous functions.\n\n// These are operators that should not be used with the ! operator.\n\n        bang = {\n            '<'  : true,\n            '<=' : true,\n            '==' : true,\n            '===': true,\n            '!==': true,\n            '!=' : true,\n            '>'  : true,\n            '>=' : true,\n            '+'  : true,\n            '-'  : true,\n            '*'  : true,\n            '/'  : true,\n            '%'  : true\n        },\n        begin,          // The root token\n        block_var,     // vars defined in the current block\n\n// browser contains a set of global names that are commonly provided by a\n// web browser environment.\n\n        browser = array_to_object([\n            'clearInterval', 'clearTimeout', 'document', 'event', 'FormData',\n            'frames', 'history', 'Image', 'localStorage', 'location', 'name',\n            'navigator', 'Option', 'parent', 'screen', 'sessionStorage',\n            'setInterval', 'setTimeout', 'Storage', 'window', 'XMLHttpRequest'\n        ], false),\n\n// bundle contains the text messages.\n\n        bundle = {\n            a_label: \"'{a}' is a statement label.\",\n            a_scope: \"'{a}' used out of scope.\",\n            already_defined: \"'{a}' is already defined.\",\n            and: \"The '&&' subexpression should be wrapped in parens.\",\n            assignment_expression: \"Unexpected assignment expression.\",\n            assignment_function_expression: \"Expected an assignment or \" +\n                \"function call and instead saw an expression.\",\n            avoid_a: \"Avoid '{a}'.\",\n            bad_assignment: \"Bad assignment.\",\n            bad_constructor: \"Bad constructor.\",\n            bad_in_a: \"Bad for in variable '{a}'.\",\n            bad_invocation: \"Bad invocation.\",\n            bad_new: \"Do not use 'new' for side effects.\",\n            bad_number: \"Bad number '{a}'.\",\n            bad_operand: \"Bad operand.\",\n            bad_wrap: \"Do not wrap function literals in parens unless they \" +\n                \"are to be immediately invoked.\",\n            combine_var: \"Combine this with the previous 'var' statement.\",\n            conditional_assignment: \"Expected a conditional expression and \" +\n                \"instead saw an assignment.\",\n            confusing_a: \"Confusing use of '{a}'.\",\n            confusing_regexp: \"Confusing regular expression.\",\n            constructor_name_a: \"A constructor name '{a}' should start with \" +\n                \"an uppercase letter.\",\n            control_a: \"Unexpected control character '{a}'.\",\n            dangling_a: \"Unexpected dangling '_' in '{a}'.\",\n            deleted: \"Only properties should be deleted.\",\n            duplicate_a: \"Duplicate '{a}'.\",\n            empty_block: \"Empty block.\",\n            empty_case: \"Empty case.\",\n            empty_class: \"Empty class.\",\n            es5: \"This is an ES5 feature.\",\n            evil: \"eval is evil.\",\n            expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n            expected_a_b_from_c_d: \"Expected '{a}' to match '{b}' from line \" +\n                \"{c} and instead saw '{d}'.\",\n            expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n            expected_id_a: \"Expected an id, and instead saw #{a}.\",\n            expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n            expected_identifier_a_reserved: \"Expected an identifier and \" +\n                \"instead saw '{a}' (a reserved word).\",\n            expected_number_a: \"Expected a number and instead saw '{a}'.\",\n            expected_operator_a: \"Expected an operator and instead saw '{a}'.\",\n            expected_positive_a: \"Expected a positive number and instead saw '{a}'\",\n            expected_small_a: \"Expected a small positive integer and instead saw '{a}'\",\n            expected_space_a_b: \"Expected exactly one space between '{a}' and '{b}'.\",\n            expected_string_a: \"Expected a string and instead saw '{a}'.\",\n            for_if: \"The body of a for in should be wrapped in an if \" +\n                \"statement to filter unwanted properties from the prototype.\",\n            function_block: \"Function statements should not be placed in blocks.\" +\n                \"Use a function expression or move the statement to the top of \" +\n                \"the outer function.\",\n            function_eval: \"The Function constructor is eval.\",\n            function_loop: \"Don't make functions within a loop.\",\n            function_statement: \"Function statements are not invocable. \" +\n                \"Wrap the whole function invocation in parens.\",\n            function_strict: \"Use the function form of 'use strict'.\",\n            identifier_function: \"Expected an identifier in an assignment \" +\n                \"and instead saw a function invocation.\",\n            implied_evil: \"Implied eval is evil. Pass a function instead of a string.\",\n            infix_in: \"Unexpected 'in'. Compare with undefined, or use the \" +\n                \"hasOwnProperty method instead.\",\n            insecure_a: \"Insecure '{a}'.\",\n            isNaN: \"Use the isNaN function to compare with NaN.\",\n            leading_decimal_a: \"A leading decimal point can be confused with a dot: '.{a}'.\",\n            missing_a: \"Missing '{a}'.\",\n            missing_a_after_b: \"Missing '{a}' after '{b}'.\",\n            missing_property: \"Missing property name.\",\n            missing_space_a_b: \"Missing space between '{a}' and '{b}'.\",\n            missing_use_strict: \"Missing 'use strict' statement.\",\n            move_invocation: \"Move the invocation into the parens that \" +\n                \"contain the function.\",\n            move_var: \"Move 'var' declarations to the top of the function.\",\n            name_function: \"Missing name in function statement.\",\n            nested_comment: \"Nested comment.\",\n            not: \"Nested not.\",\n            not_a_constructor: \"Do not use {a} as a constructor.\",\n            not_a_defined: \"'{a}' has not been fully defined yet.\",\n            not_a_function: \"'{a}' is not a function.\",\n            not_a_label: \"'{a}' is not a label.\",\n            not_a_scope: \"'{a}' is out of scope.\",\n            not_greater: \"'{a}' should not be greater than '{b}'.\",\n            octal_a: \"Don't use octal: '{a}'. Use '\\\\u....' instead.\",\n            parameter_arguments_a: \"Do not mutate parameter '{a}' when using 'arguments'.\",\n            parameter_a_get_b: \"Unexpected parameter '{a}' in get {b} function.\",\n            parameter_set_a: \"Expected parameter (value) in set {a} function.\",\n            radix: \"Missing radix parameter.\",\n            read_only: \"Read only.\",\n            redefinition_a_b: \"Redefinition of '{a}' from line {b}.\",\n            reserved_a: \"Reserved name '{a}'.\",\n            scanned_a_b: \"{a} ({b}% scanned).\",\n            slash_equal: \"A regular expression literal can be confused with '/='.\",\n            statement_block: \"Expected to see a statement and instead saw a block.\",\n            stopping: \"Stopping.\",\n            strange_loop: \"Strange loop.\",\n            strict: \"Strict violation.\",\n            subscript: \"['{a}'] is better written in dot notation.\",\n            sync_a: \"Unexpected sync method: '{a}'.\",\n            tag_a_in_b: \"A '<{a}>' must be within '<{b}>'.\",\n            todo_comment: \"Unexpected TODO comment.\",\n            too_long: \"Line too long.\",\n            too_many: \"Too many errors.\",\n            trailing_decimal_a: \"A trailing decimal point can be confused \" +\n                \"with a dot: '.{a}'.\",\n            unclosed: \"Unclosed string.\",\n            unclosed_comment: \"Unclosed comment.\",\n            unclosed_regexp: \"Unclosed regular expression.\",\n            unescaped_a: \"Unescaped '{a}'.\",\n            unexpected_a: \"Unexpected '{a}'.\",\n            unexpected_char_a: \"Unexpected character '{a}'.\",\n            unexpected_comment: \"Unexpected comment.\",\n            unexpected_label_a: \"Unexpected label '{a}'.\",\n            unexpected_property_a: \"Unexpected /*property*/ '{a}'.\",\n            unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n            unexpected_typeof_a: \"Unexpected 'typeof'. \" +\n                \"Use '===' to compare directly with {a}.\",\n            uninitialized_a: \"Uninitialized '{a}'.\",\n            unnecessary_else: \"Unnecessary 'else' after disruption.\",\n            unnecessary_initialize: \"It is not necessary to initialize '{a}' \" +\n                \"to 'undefined'.\",\n            unnecessary_use: \"Unnecessary 'use strict'.\",\n            unreachable_a_b: \"Unreachable '{a}' after '{b}'.\",\n            unsafe: \"Unsafe character.\",\n            unused_a: \"Unused '{a}'.\",\n            url: \"JavaScript URL.\",\n            use_array: \"Use the array literal notation [].\",\n            use_braces: \"Spaces are hard to count. Use {{a}}.\",\n            use_object: \"Use the object literal notation {} or Object.create(null).\",\n            use_or: \"Use the || operator.\",\n            use_param: \"Use a named parameter.\",\n            use_spaces: \"Use spaces, not tabs.\",\n            used_before_a: \"'{a}' was used before it was defined.\",\n            var_a_not: \"Variable {a} was not declared correctly.\",\n            var_loop: \"Don't declare variables in a loop.\",\n            weird_assignment: \"Weird assignment.\",\n            weird_condition: \"Weird condition.\",\n            weird_new: \"Weird construction. Delete 'new'.\",\n            weird_program: \"Weird program.\",\n            weird_relation: \"Weird relation.\",\n            weird_ternary: \"Weird ternary.\",\n            wrap_immediate: \"Wrap an immediate function invocation in \" +\n                \"parentheses to assist the reader in understanding that the \" +\n                \"expression is the result of a function, and not the \" +\n                \"function itself.\",\n            wrap_regexp: \"Wrap the /regexp/ literal in parens to \" +\n                \"disambiguate the slash operator.\",\n            write_is_wrong: \"document.write can be a form of eval.\"\n        },\n        closure = array_to_object([\n            'goog'\n        ], false),\n        comments,\n        comments_off,\n        couch = array_to_object([\n            'emit', 'getRow', 'isArray', 'log', 'provides', 'registerType',\n            'require', 'send', 'start', 'sum', 'toJSON'\n        ], false),\n\n        descapes = {\n            'b': '\\b',\n            't': '\\t',\n            'n': '\\n',\n            'f': '\\f',\n            'r': '\\r',\n            '\"': '\"',\n            '/': '/',\n            '\\\\': '\\\\',\n            '!': '!'\n        },\n\n        devel = array_to_object([\n            'alert', 'confirm', 'console', 'Debug', 'opera', 'prompt', 'WSH'\n        ], false),\n        directive,\n        escapes = {\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\\'': '\\\\\\'',\n            '\"' : '\\\\\"',\n            '/' : '\\\\/',\n            '\\\\': '\\\\\\\\'\n        },\n\n        funct,          // The current function\n\n        functions,      // All of the functions\n        global_funct,   // The global body\n        global_scope,   // The global scope\n        in_block,       // Where function statements are not allowed\n        indent,\n        itself,         // JSLINT itself\n        json_mode,\n        lex,            // the tokenizer\n        lines,\n        lookahead,\n        node = array_to_object([\n            'Buffer', 'clearImmediate', 'clearInterval', 'clearTimeout',\n            'console', 'exports', 'global', 'module', 'process', 'querystring',\n            'require', 'setImmediate', 'setInterval', 'setTimeout',\n            '__dirname', '__filename'\n        ], false),\n        node_js,\n        numbery = array_to_object(['indexOf', 'lastIndexOf', 'search'], true),\n        next_token,\n        option,\n        predefined,     // Global variables defined by option\n        prereg,\n        prev_token,\n        property,\n        protosymbol,\n        regexp_flag = array_to_object(['g', 'i', 'm'], true),\n        return_this = function return_this() {\n            return this;\n        },\n        rhino = array_to_object([\n            'defineClass', 'deserialize', 'gc', 'help', 'load', 'loadClass',\n            'print', 'quit', 'readFile', 'readUrl', 'runCommand', 'seal',\n            'serialize', 'spawn', 'sync', 'toint32', 'version'\n        ], false),\n\n        scope,      // An object containing an object for each variable in scope\n        semicolon_coda = array_to_object([';', '\"', '\\'', ')'], true),\n\n// standard contains the global names that are provided by the\n// ECMAScript standard.\n\n        standard = array_to_object([\n            'Array', 'Boolean', 'Date', 'decodeURI', 'decodeURIComponent',\n            'encodeURI', 'encodeURIComponent', 'Error', 'eval', 'EvalError',\n            'Function', 'isFinite', 'isNaN', 'JSON', 'Math', 'Number',\n            'Object', 'parseInt', 'parseFloat', 'RangeError', 'ReferenceError',\n            'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError'\n        ], false),\n\n        strict_mode,\n        syntax = Object.create(null),\n        token,\n        tokens,\n        var_mode,\n        warnings,\n\n// Regular expressions. Some of these are stupidly long.\n\n// carriage return, carriage return linefeed, or linefeed\n        crlfx = /\\r\\n?|\\n/,\n// unsafe characters that are silently deleted by one or more browsers\n        cx = /[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n// identifier\n        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,\n// javascript url\n        jx = /^(?:javascript|jscript|ecmascript|vbscript)\\s*:/i,\n// star slash\n        lx = /\\*\\/|\\/\\*/,\n// characters in strings that need escapement\n        nx = /[\\u0000-\\u001f'\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n// sync\n        syx = /Sync$/,\n// comment todo\n        tox = /^\\W*to\\s*do(?:\\W|$)/i,\n// token\n        tx = /^\\s*([(){}\\[\\]\\?.,:;'\"~#@`]|={1,3}|\\/(\\*(jslint|properties|property|members?|globals?)?|=|\\/)?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|[\\^%]=?|&[&=]?|\\|[|=]?|>{1,3}=?|<(?:[\\/=!]|\\!(\\[|--)?|<=?)?|\\!(\\!|==?)?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+(?:[xX][0-9a-fA-F]+|\\.[0-9]*)?(?:[eE][+\\-]?[0-9]+)?)/;\n\n\n    if (typeof String.prototype.entityify !== 'function') {\n        String.prototype.entityify = function () {\n            return this\n                .replace(/&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;');\n        };\n    }\n\n    if (typeof String.prototype.isAlpha !== 'function') {\n        String.prototype.isAlpha = function () {\n            return (this >= 'a' && this <= 'z\\uffff') ||\n                (this >= 'A' && this <= 'Z\\uffff');\n        };\n    }\n\n    if (typeof String.prototype.isDigit !== 'function') {\n        String.prototype.isDigit = function () {\n            return (this >= '0' && this <= '9');\n        };\n    }\n\n    if (typeof String.prototype.supplant !== 'function') {\n        String.prototype.supplant = function (o) {\n            return this.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n                var replacement = o[b];\n                return typeof replacement === 'string' ||\n                    typeof replacement === 'number' ? replacement : a;\n            });\n        };\n    }\n\n\n    function sanitize(a) {\n\n//  Escapify a troublesome character.\n\n        return escapes[a] ||\n            '\\\\u' + ('0000' + a.charCodeAt().toString(16)).slice(-4);\n    }\n\n\n    function add_to_predefined(group) {\n        Object.keys(group).forEach(function (name) {\n            predefined[name] = group[name];\n        });\n    }\n\n\n    function assume() {\n        if (option.browser) {\n            add_to_predefined(browser);\n            option.browser = false;\n        }\n        if (option.closure) {\n            add_to_predefined(closure);\n        }\n        if (option.couch) {\n            add_to_predefined(couch);\n            option.couch = false;\n            option.es5 = true;\n        }\n        if (option.devel) {\n            add_to_predefined(devel);\n            option.devel = false;\n        }\n        if (option.node) {\n            add_to_predefined(node);\n            option.node = false;\n            option.es5 = true;\n            node_js = true;\n        }\n        if (option.rhino) {\n            add_to_predefined(rhino);\n            option.rhino = false;\n        }\n    }\n\n\n// Produce an error warning.\n\n    function artifact(tok) {\n        if (!tok) {\n            tok = next_token;\n        }\n        return tok.id === '(number)' ? tok.number : tok.string;\n    }\n\n    function quit(message, line, character) {\n        throw {\n            name: 'JSLintError',\n            line: line,\n            character: character,\n            message: bundle.scanned_a_b.supplant({\n                a: bundle[message] || message,\n                b: Math.floor((line / lines.length) * 100)\n            })\n        };\n    }\n\n    function warn(code, line, character, a, b, c, d) {\n        var warning = {         // ~~\n            id: '(error)',\n            raw: bundle[code] || code,\n            code: code,\n            evidence: lines[line - 1] || '',\n            line: line,\n            character: character,\n            a: a || artifact(this),\n            b: b,\n            c: c,\n            d: d\n        };\n        warning.reason = warning.raw.supplant(warning);\n        itself.errors.push(warning);\n        if (option.passfail) {\n            quit('stopping', line, character);\n        }\n        warnings += 1;\n        if (warnings >= option.maxerr) {\n            quit('too_many', line, character);\n        }\n        return warning;\n    }\n\n    function stop(code, line, character, a, b, c, d) {\n        var warning = warn(code, line, character, a, b, c, d);\n        quit('stopping', warning.line, warning.character);\n    }\n\n    function expected_at(at) {\n        if (!option.white && next_token.from !== at) {\n            next_token.warn('expected_a_at_b_c', '', at, next_token.from);\n        }\n    }\n\n// lexical analysis and token construction\n\n    lex = (function lex() {\n        var character, c, from, length, line, pos, source_row;\n\n// Private lex methods\n\n        function next_line() {\n            var at;\n            character = 1;\n            source_row = lines[line];\n            line += 1;\n            if (source_row === undefined) {\n                return false;\n            }\n            at = source_row.search(/\\t/);\n            if (at >= 0) {\n                if (option.white) {\n                    source_row = source_row.replace(/\\t/g, ' ');\n                } else {\n                    warn('use_spaces', line, at + 1);\n                }\n            }\n            at = source_row.search(cx);\n            if (at >= 0) {\n                warn('unsafe', line, at);\n            }\n            if (option.maxlen && option.maxlen < source_row.length) {\n                warn('too_long', line, source_row.length);\n            }\n            return true;\n        }\n\n// Produce a token object.  The token inherits from a syntax symbol.\n\n        function it(type, value) {\n            var id, the_token;\n            if (type === '(string)') {\n                if (jx.test(value)) {\n                    warn('url', line, from);\n                }\n            }\n            the_token = Object.create(syntax[(\n                type === '(punctuator)' || (type === '(identifier)' &&\n                        Object.prototype.hasOwnProperty.call(syntax, value))\n                    ? value\n                    : type\n            )] || syntax['(error)']);\n            if (type === '(identifier)') {\n                the_token.identifier = true;\n                if (value === '__iterator__' || value === '__proto__') {\n                    stop('reserved_a', line, from, value);\n                } else if (!option.nomen &&\n                        (value.charAt(0) === '_' ||\n                        value.charAt(value.length - 1) === '_')) {\n                    warn('dangling_a', line, from, value);\n                }\n            }\n            if (type === '(number)') {\n                the_token.number = +value;\n            } else if (value !== undefined) {\n                the_token.string = String(value);\n            }\n            the_token.line = line;\n            the_token.from = from;\n            the_token.thru = character;\n            if (comments.length) {\n                the_token.comments = comments;\n                comments = [];\n            }\n            id = the_token.id;\n            prereg = id && (\n                ('(,=:[!&|?{};~+-*%^<>'.indexOf(id.charAt(id.length - 1)) >= 0) ||\n                id === 'return' || id === 'case'\n            );\n            return the_token;\n        }\n\n        function match(x) {\n            var exec = x.exec(source_row), first;\n            if (exec) {\n                length = exec[0].length;\n                first = exec[1];\n                c = first.charAt(0);\n                source_row = source_row.slice(length);\n                from = character + length - first.length;\n                character += length;\n                return first;\n            }\n            for (;;) {\n                if (!source_row) {\n                    if (!option.white) {\n                        warn('unexpected_char_a', line, character - 1, '(space)');\n                    }\n                    return;\n                }\n                c = source_row.charAt(0);\n                if (c !== ' ') {\n                    break;\n                }\n                source_row = source_row.slice(1);\n                character += 1;\n            }\n            stop('unexpected_char_a', line, character, c);\n\n        }\n\n        function string(x) {\n            var ch, at = 0, r = '', result;\n\n            function hex(n) {\n                var i = parseInt(source_row.substr(at + 1, n), 16);\n                at += n;\n                if (i >= 32 && i <= 126 &&\n                        i !== 34 && i !== 92 && i !== 39) {\n                    warn('unexpected_a', line, character, '\\\\');\n                }\n                character += n;\n                ch = String.fromCharCode(i);\n            }\n\n            if (json_mode && x !== '\"') {\n                warn('expected_a_b', line, character, '\"', x);\n            }\n\n            for (;;) {\n                while (at >= source_row.length) {\n                    at = 0;\n                    if (!next_line()) {\n                        stop('unclosed', line - 1, from);\n                    }\n                }\n                ch = source_row.charAt(at);\n                if (ch === x) {\n                    character += 1;\n                    source_row = source_row.slice(at + 1);\n                    result = it('(string)', r);\n                    result.quote = x;\n                    return result;\n                }\n                if (ch < ' ') {\n                    if (ch === '\\n' || ch === '\\r') {\n                        break;\n                    }\n                    warn('control_a', line, character + at,\n                        source_row.slice(0, at));\n                } else if (ch === '\\\\') {\n                    at += 1;\n                    character += 1;\n                    ch = source_row.charAt(at);\n                    switch (ch) {\n                    case '':\n                        if (!option.es5) {\n                            warn('es5', line, character);\n                        }\n                        next_line();\n                        at = -1;\n                        break;\n                    case '\\'':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\\\'');\n                        }\n                        break;\n                    case 'u':\n                        hex(4);\n                        break;\n                    case 'v':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\v');\n                        }\n                        ch = '\\v';\n                        break;\n                    case 'x':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\x');\n                        }\n                        hex(2);\n                        break;\n                    default:\n                        if (typeof descapes[ch] !== 'string') {\n                            warn(ch >= '0' && ch <= '7' ? 'octal_a' : 'unexpected_a',\n                                line, character, '\\\\' + ch);\n                        } else {\n                            ch = descapes[ch];\n                        }\n                    }\n                }\n                r += ch;\n                character += 1;\n                at += 1;\n            }\n        }\n\n        function number(snippet) {\n            var digit;\n            if (source_row.charAt(0).isAlpha()) {\n                warn('expected_space_a_b',\n                    line, character, c, source_row.charAt(0));\n            }\n            if (c === '0') {\n                digit = snippet.charAt(1);\n                if (digit.isDigit()) {\n                    if (token.id !== '.') {\n                        warn('unexpected_a', line, character, snippet);\n                    }\n                } else if (json_mode && (digit === 'x' || digit === 'X')) {\n                    warn('unexpected_a', line, character, '0x');\n                }\n            }\n            if (snippet.slice(snippet.length - 1) === '.') {\n                warn('trailing_decimal_a', line, character, snippet);\n            }\n            digit = +snippet;\n            if (!isFinite(digit)) {\n                warn('bad_number', line, character, snippet);\n            }\n            snippet = digit;\n            return it('(number)', snippet);\n        }\n\n        function comment(snippet, type) {\n            if (comments_off) {\n                warn('unexpected_comment', line, character);\n            } else if (!option.todo && tox.test(snippet)) {\n                warn('todo_comment', line, character);\n            }\n            comments.push({\n                id: type,\n                from: from,\n                thru: character,\n                line: line,\n                string: snippet\n            });\n        }\n\n        function regexp() {\n            var at = 0,\n                b,\n                bit,\n                depth = 0,\n                flag = '',\n                high,\n                letter,\n                low,\n                potential,\n                quote,\n                result;\n            for (;;) {\n                b = true;\n                c = source_row.charAt(at);\n                at += 1;\n                switch (c) {\n                case '':\n                    stop('unclosed_regexp', line, from);\n                    return;\n                case '/':\n                    if (depth > 0) {\n                        warn('unescaped_a', line, from + at, '/');\n                    }\n                    c = source_row.slice(0, at - 1);\n                    potential = Object.create(regexp_flag);\n                    for (;;) {\n                        letter = source_row.charAt(at);\n                        if (potential[letter] !== true) {\n                            break;\n                        }\n                        potential[letter] = false;\n                        at += 1;\n                        flag += letter;\n                    }\n                    if (source_row.charAt(at).isAlpha()) {\n                        stop('unexpected_a', line, from, source_row.charAt(at));\n                    }\n                    character += at;\n                    source_row = source_row.slice(at);\n                    quote = source_row.charAt(0);\n                    if (quote === '/' || quote === '*') {\n                        stop('confusing_regexp', line, from);\n                    }\n                    result = it('(regexp)', c);\n                    result.flag = flag;\n                    return result;\n                case '\\\\':\n                    c = source_row.charAt(at);\n                    if (c < ' ') {\n                        warn('control_a', line, from + at, String(c));\n                    } else if (c === '<') {\n                        warn('unexpected_a', line, from + at, '\\\\');\n                    }\n                    at += 1;\n                    break;\n                case '(':\n                    depth += 1;\n                    b = false;\n                    if (source_row.charAt(at) === '?') {\n                        at += 1;\n                        switch (source_row.charAt(at)) {\n                        case ':':\n                        case '=':\n                        case '!':\n                            at += 1;\n                            break;\n                        default:\n                            warn('expected_a_b', line, from + at,\n                                ':', source_row.charAt(at));\n                        }\n                    }\n                    break;\n                case '|':\n                    b = false;\n                    break;\n                case ')':\n                    if (depth === 0) {\n                        warn('unescaped_a', line, from + at, ')');\n                    } else {\n                        depth -= 1;\n                    }\n                    break;\n                case ' ':\n                    pos = 1;\n                    while (source_row.charAt(at) === ' ') {\n                        at += 1;\n                        pos += 1;\n                    }\n                    if (pos > 1) {\n                        warn('use_braces', line, from + at, pos);\n                    }\n                    break;\n                case '[':\n                    c = source_row.charAt(at);\n                    if (c === '^') {\n                        at += 1;\n                        if (!option.regexp) {\n                            warn('insecure_a', line, from + at, c);\n                        } else if (source_row.charAt(at) === ']') {\n                            stop('unescaped_a', line, from + at, '^');\n                        }\n                    }\n                    bit = false;\n                    if (c === ']') {\n                        warn('empty_class', line, from + at - 1);\n                        bit = true;\n                    }\nklass:              do {\n                        c = source_row.charAt(at);\n                        at += 1;\n                        switch (c) {\n                        case '[':\n                        case '^':\n                            warn('unescaped_a', line, from + at, c);\n                            bit = true;\n                            break;\n                        case '-':\n                            if (bit) {\n                                bit = false;\n                            } else {\n                                warn('unescaped_a', line, from + at, '-');\n                                bit = true;\n                            }\n                            break;\n                        case ']':\n                            if (!bit) {\n                                warn('unescaped_a', line, from + at - 1, '-');\n                            }\n                            break klass;\n                        case '\\\\':\n                            c = source_row.charAt(at);\n                            if (c < ' ') {\n                                warn('control_a', line, from + at, String(c));\n                            } else if (c === '<') {\n                                warn('unexpected_a', line, from + at, '\\\\');\n                            }\n                            at += 1;\n                            bit = true;\n                            break;\n                        case '/':\n                            warn('unescaped_a', line, from + at - 1, '/');\n                            bit = true;\n                            break;\n                        default:\n                            bit = true;\n                        }\n                    } while (c);\n                    break;\n                case '.':\n                    if (!option.regexp) {\n                        warn('insecure_a', line, from + at, c);\n                    }\n                    break;\n                case ']':\n                case '?':\n                case '{':\n                case '}':\n                case '+':\n                case '*':\n                    warn('unescaped_a', line, from + at, c);\n                    break;\n                }\n                if (b) {\n                    switch (source_row.charAt(at)) {\n                    case '?':\n                    case '+':\n                    case '*':\n                        at += 1;\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        break;\n                    case '{':\n                        at += 1;\n                        c = source_row.charAt(at);\n                        if (c < '0' || c > '9') {\n                            warn('expected_number_a', line,\n                                from + at, c);\n                        }\n                        at += 1;\n                        low = +c;\n                        for (;;) {\n                            c = source_row.charAt(at);\n                            if (c < '0' || c > '9') {\n                                break;\n                            }\n                            at += 1;\n                            low = +c + (low * 10);\n                        }\n                        high = low;\n                        if (c === ',') {\n                            at += 1;\n                            high = Infinity;\n                            c = source_row.charAt(at);\n                            if (c >= '0' && c <= '9') {\n                                at += 1;\n                                high = +c;\n                                for (;;) {\n                                    c = source_row.charAt(at);\n                                    if (c < '0' || c > '9') {\n                                        break;\n                                    }\n                                    at += 1;\n                                    high = +c + (high * 10);\n                                }\n                            }\n                        }\n                        if (source_row.charAt(at) !== '}') {\n                            warn('expected_a_b', line, from + at,\n                                '}', c);\n                        } else {\n                            at += 1;\n                        }\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        if (low > high) {\n                            warn('not_greater', line, from + at,\n                                low, high);\n                        }\n                        break;\n                    }\n                }\n            }\n            c = source_row.slice(0, at - 1);\n            character += at;\n            source_row = source_row.slice(at);\n            return it('(regexp)', c);\n        }\n\n// Public lex methods\n\n        return {\n            init: function (source) {\n                if (typeof source === 'string') {\n                    lines = source.split(crlfx);\n                } else {\n                    lines = source;\n                }\n                line = 0;\n                next_line();\n                from = 1;\n            },\n\n// token -- this is called by advance to get the next token.\n\n            token: function () {\n                var first, i, snippet;\n\n                for (;;) {\n                    while (!source_row) {\n                        if (!next_line()) {\n                            return it('(end)');\n                        }\n                    }\n                    snippet = match(tx);\n                    if (snippet) {\n\n//      identifier\n\n                        first = snippet.charAt(0);\n                        if (first.isAlpha() || first === '_' || first === '$') {\n                            return it('(identifier)', snippet);\n                        }\n\n//      number\n\n                        if (first.isDigit()) {\n                            return number(snippet);\n                        }\n                        switch (snippet) {\n\n//      string\n\n                        case '\"':\n                        case \"'\":\n                            return string(snippet);\n\n//      // comment\n\n                        case '//':\n                            comment(source_row, '//');\n                            source_row = '';\n                            break;\n\n//      /* comment\n\n                        case '/*':\n                            for (;;) {\n                                i = source_row.search(lx);\n                                if (i >= 0) {\n                                    break;\n                                }\n                                character = source_row.length;\n                                comment(source_row);\n                                from = 0;\n                                if (!next_line()) {\n                                    stop('unclosed_comment', line, character);\n                                }\n                            }\n                            comment(source_row.slice(0, i), '/*');\n                            character += i + 2;\n                            if (source_row.charAt(i) === '/') {\n                                stop('nested_comment', line, character);\n                            }\n                            source_row = source_row.slice(i + 2);\n                            break;\n\n                        case '':\n                            break;\n//      /\n                        case '/':\n                            if (token.id === '/=') {\n                                stop('slash_equal', line, from);\n                            }\n                            return prereg\n                                ? regexp()\n                                : it('(punctuator)', snippet);\n\n//      punctuator\n                        default:\n                            return it('(punctuator)', snippet);\n                        }\n                    }\n                }\n            }\n        };\n    }());\n\n    function define(kind, token) {\n\n// Define a name.\n\n        var name = token.string,\n            master = scope[name];       // The current definition of the name\n\n// vars are created with a deadzone, so that the expression that initializes\n// the var cannot access the var. Functions are not writeable.\n\n        token.dead = false;\n        token.init = false;\n        token.kind = kind;\n        token.master = master;\n        token.used = 0;\n        token.writeable = false;\n\n// Global variables are a little weird. They can be defined multiple times.\n// Some predefined global vars are (or should) not be writeable.\n\n        if (kind === 'var' && funct === global_funct) {\n            if (!master) {\n                if (predefined[name] === false) {\n                    token.writeable = false;\n                }\n                global_scope[name] = token;\n            }\n        } else {\n\n// It is an error if the name has already been defined in this scope, except\n// when reusing an exception variable name.\n\n            if (master) {\n                if (master.function === funct) {\n                    if (master.kind !== 'exception' || kind !== 'exception' ||\n                            !master.dead) {\n                        token.warn('already_defined', name);\n                    }\n                } else if (master.function !== global_funct) {\n                    if (kind === 'var') {\n                        token.warn('redefinition_a_b', name, master.line);\n                    }\n                }\n            }\n            scope[name] = token;\n            if (kind === 'var') {\n                block_var.push(name);\n            }\n        }\n    }\n\n    function peek(distance) {\n\n// Peek ahead to a future token. The distance is how far ahead to look. The\n// default is the next token.\n\n        var found, slot = 0;\n\n        distance = distance || 0;\n        while (slot <= distance) {\n            found = lookahead[slot];\n            if (!found) {\n                found = lookahead[slot] = lex.token();\n            }\n            slot += 1;\n        }\n        return found;\n    }\n\n\n    function advance(id, match) {\n\n// Produce the next token, also looking for programming errors.\n\n        if (indent) {\n\n// If indentation checking was requested, then inspect all of the line breakings.\n// The var statement is tricky because the names might be aligned or not. We\n// look at the first line break after the var to determine the programmer's\n// intention.\n\n            if (var_mode && next_token.line !== token.line) {\n                if ((var_mode !== indent || !next_token.edge) &&\n                        next_token.from === indent.at -\n                        (next_token.edge ? option.indent : 0)) {\n                    var dent = indent;\n                    for (;;) {\n                        dent.at -= option.indent;\n                        if (dent === var_mode) {\n                            break;\n                        }\n                        dent = dent.was;\n                    }\n                    dent.open = false;\n                }\n                var_mode = null;\n            }\n            if (next_token.id === '?' && indent.mode === ':' &&\n                    token.line !== next_token.line) {\n                indent.at -= option.indent;\n            }\n            if (indent.open) {\n\n// If the token is an edge.\n\n                if (next_token.edge) {\n                    if (next_token.edge === 'label') {\n                        expected_at(1);\n                    } else if (next_token.edge === 'case' || indent.mode === 'statement') {\n                        expected_at(indent.at - option.indent);\n                    } else if (indent.mode !== 'array' || next_token.line !== token.line) {\n                        expected_at(indent.at);\n                    }\n\n// If the token is not an edge, but is the first token on the line.\n\n                } else if (next_token.line !== token.line) {\n                    if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                    indent.wrap = true;\n                }\n            } else if (next_token.line !== token.line) {\n                if (next_token.edge) {\n                    expected_at(indent.at);\n                } else {\n                    indent.wrap = true;\n                    if (indent.mode === 'statement' || indent.mode === 'var') {\n                        expected_at(indent.at + option.indent);\n                    } else if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                }\n            }\n        }\n\n        switch (token.id) {\n        case '(number)':\n            if (next_token.id === '.') {\n                next_token.warn('trailing_decimal_a');\n            }\n            break;\n        case '-':\n            if (next_token.id === '-' || next_token.id === '--') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        case '+':\n            if (next_token.id === '+' || next_token.id === '++') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        }\n        if (token.id === '(string)' || token.identifier) {\n            anonname = token.string;\n        }\n\n        if (id && next_token.id !== id) {\n            if (match) {\n                next_token.warn('expected_a_b_from_c_d', id,\n                    match.id, match.line, artifact());\n            } else if (!next_token.identifier || next_token.string !== id) {\n                next_token.warn('expected_a_b', id, artifact());\n            }\n        }\n        prev_token = token;\n        token = next_token;\n        next_token = lookahead.shift() || lex.token();\n        next_token.function = funct;\n        tokens.push(next_token);\n    }\n\n\n    function do_globals() {\n        var name, writeable;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            writeable = false;\n            if (next_token.id === ':') {\n                advance(':');\n                switch (next_token.id) {\n                case 'true':\n                    writeable = predefined[name] !== false;\n                    advance('true');\n                    break;\n                case 'false':\n                    advance('false');\n                    break;\n                default:\n                    next_token.stop('unexpected_a');\n                }\n            }\n            predefined[name] = writeable;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    function do_jslint() {\n        var name, value;\n        while (next_token.id === '(string)' || next_token.identifier) {\n            name = next_token.string;\n            if (!allowed_option[name]) {\n                next_token.stop('unexpected_a');\n            }\n            advance();\n            if (next_token.id !== ':') {\n                next_token.stop('expected_a_b', ':', artifact());\n            }\n            advance(':');\n            if (typeof allowed_option[name] === 'number') {\n                value = next_token.number;\n                if (value > allowed_option[name] || value <= 0 ||\n                        Math.floor(value) !== value) {\n                    next_token.stop('expected_small_a');\n                }\n                option[name] = value;\n            } else {\n                if (next_token.id === 'true') {\n                    option[name] = true;\n                } else if (next_token.id === 'false') {\n                    option[name] = false;\n                } else {\n                    next_token.stop('unexpected_a');\n                }\n            }\n            advance();\n            if (next_token.id === ',') {\n                advance(',');\n            }\n        }\n        assume();\n    }\n\n\n    function do_properties() {\n        var name;\n        option.properties = true;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            if (next_token.id === ':') {\n                for (;;) {\n                    advance();\n                    if (next_token.id !== '(string)' && !next_token.identifier) {\n                        break;\n                    }\n                }\n            }\n            property[name] = 0;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    directive = function directive() {\n        var command = this.id,\n            old_comments_off = comments_off,\n            old_indent = indent;\n        comments_off = true;\n        indent = null;\n        if (next_token.line === token.line && next_token.from === token.thru) {\n            next_token.warn('missing_space_a_b', artifact(token), artifact());\n        }\n        if (lookahead.length > 0) {\n            this.warn('unexpected_a');\n        }\n        switch (command) {\n        case '/*properties':\n        case '/*property':\n        case '/*members':\n        case '/*member':\n            do_properties();\n            break;\n        case '/*jslint':\n            do_jslint();\n            break;\n        case '/*globals':\n        case '/*global':\n            do_globals();\n            break;\n        default:\n            this.stop('unexpected_a');\n        }\n        comments_off = old_comments_off;\n        advance('*/');\n        indent = old_indent;\n    };\n\n\n// Indentation intention\n\n    function edge(mode) {\n        next_token.edge = indent ? indent.open && (mode || 'edge') : '';\n    }\n\n\n    function step_in(mode) {\n        var open;\n        if (typeof mode === 'number') {\n            indent = {\n                at: +mode,\n                open: true,\n                was: indent\n            };\n        } else if (!indent) {\n            indent = {\n                at: 1,\n                mode: 'statement',\n                open: true\n            };\n        } else if (mode === 'statement') {\n            indent = {\n                at: indent.at,\n                open: true,\n                was: indent\n            };\n        } else {\n            open = mode === 'var' || next_token.line !== token.line;\n            indent = {\n                at: (open || mode === 'control'\n                    ? indent.at + option.indent\n                    : indent.at) + (indent.wrap ? option.indent : 0),\n                mode: mode,\n                open: open,\n                was: indent\n            };\n            if (mode === 'var' && open) {\n                var_mode = indent;\n            }\n        }\n    }\n\n    function step_out(id, symbol) {\n        if (id) {\n            if (indent && indent.open) {\n                indent.at -= option.indent;\n                edge();\n            }\n            advance(id, symbol);\n        }\n        if (indent) {\n            indent = indent.was;\n        }\n    }\n\n// Functions for conformance of whitespace.\n\n    function one_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && !option.white &&\n                (token.line !== right.line ||\n                token.thru + 1 !== right.from)) {\n            right.warn('expected_space_a_b', artifact(token), artifact(right));\n        }\n    }\n\n    function one_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru + 1 !== right.from))) {\n            right.warn('expected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if ((!option.white) &&\n                left.thru !== right.from && left.line === right.line) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru !== right.from))) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function spaces(left, right) {\n        if (!option.white) {\n            left = left || token;\n            right = right || next_token;\n            if (left.thru === right.from && left.line === right.line) {\n                right.warn('missing_space_a_b', artifact(left), artifact(right));\n            }\n        }\n    }\n\n    function comma() {\n        if (next_token.id !== ',') {\n            warn('expected_a_b', token.line, token.thru, ',', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(',');\n            spaces();\n        }\n    }\n\n\n    function semicolon() {\n        if (next_token.id !== ';') {\n            warn('expected_a_b', token.line, token.thru, ';', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(';');\n            if (semicolon_coda[next_token.id] !== true) {\n                spaces();\n            }\n        }\n    }\n\n    function use_strict() {\n        if (next_token.string === 'use strict') {\n            if (strict_mode) {\n                next_token.warn('unnecessary_use');\n            }\n            edge();\n            advance();\n            semicolon();\n            strict_mode = true;\n            return true;\n        }\n        return false;\n    }\n\n\n    function are_similar(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (Array.isArray(a)) {\n            if (Array.isArray(b) && a.length === b.length) {\n                var i;\n                for (i = 0; i < a.length; i += 1) {\n                    if (!are_similar(a[i], b[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n        if (Array.isArray(b)) {\n            return false;\n        }\n        if (a.id === '(number)' && b.id === '(number)') {\n            return a.number === b.number;\n        }\n        if (a.arity === b.arity && a.string === b.string) {\n            switch (a.arity) {\n            case undefined:\n                return a.string === b.string;\n            case 'prefix':\n            case 'suffix':\n                return a.id === b.id && are_similar(a.first, b.first) &&\n                    a.id !== '{' && a.id !== '[';\n            case 'infix':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second);\n            case 'ternary':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second) &&\n                    are_similar(a.third, b.third);\n            case 'function':\n            case 'regexp':\n                return false;\n            default:\n                return true;\n            }\n        }\n        if (a.id === '.' && b.id === '[' && b.arity === 'infix') {\n            return a.second.string === b.second.string && b.second.id === '(string)';\n        }\n        if (a.id === '[' && a.arity === 'infix' && b.id === '.') {\n            return a.second.string === b.second.string && a.second.id === '(string)';\n        }\n        return false;\n    }\n\n\n// This is the heart of JSLINT, the Pratt parser. In addition to parsing, it\n// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is\n// like .nud except that it is only used on the first token of a statement.\n// Having .fud makes it much easier to define statement-oriented languages like\n// JavaScript. I retained Pratt's nomenclature.\n\n// .nud     Null denotation\n// .fud     First null denotation\n// .led     Left denotation\n//  lbp     Left binding power\n//  rbp     Right binding power\n\n// They are elements of the parsing method called Top Down Operator Precedence.\n\n    function expression(rbp, initial) {\n\n// rbp is the right binding power.\n// initial indicates that this is the first expression of a statement.\n\n        var left;\n        if (next_token.id === '(end)') {\n            token.stop('unexpected_a', next_token.id);\n        }\n        advance();\n        if (initial) {\n            anonname = 'anonymous';\n        }\n        if (initial === true && token.fud) {\n            left = token.fud();\n        } else {\n            if (token.nud) {\n                left = token.nud();\n            } else {\n                if (next_token.id === '(number)' && token.id === '.') {\n                    token.warn('leading_decimal_a', artifact());\n                    advance();\n                    return token;\n                }\n                token.stop('expected_identifier_a', artifact(token));\n            }\n            while (rbp < next_token.lbp) {\n                advance();\n                left = token.led(left);\n            }\n        }\n        if (left && left.assign && !initial) {\n            if (!option.ass) {\n                left.warn('assignment_expression');\n            }\n            if (left.id !== '=' && left.first.master) {\n                left.first.master.used = true;\n            }\n        }\n        return left;\n    }\n\n    protosymbol = {\n        nud: function () {\n            this.stop('unexpected_a');\n        },\n        led: function () {\n            this.stop('expected_operator_a');\n        },\n        warn: function (code, a, b, c, d) {\n            if (!this.warning) {\n                this.warning = warn(code, this.line || 0, this.from || 0,\n                    a || artifact(this), b, c, d);\n            }\n        },\n        stop: function (code, a, b, c, d) {\n            this.warning = undefined;\n            this.warn(code, a, b, c, d);\n            return quit('stopping', this.line, this.character);\n        },\n        lbp: 0\n    };\n\n// Functional constructors for making the symbols that will be inherited by\n// tokens.\n\n    function symbol(s, bp) {\n        var x = syntax[s];\n        if (!x) {\n            x = Object.create(protosymbol);\n            x.id = x.string = s;\n            x.lbp = bp || 0;\n            syntax[s] = x;\n        }\n        return x;\n    }\n\n    function postscript(x) {\n        x.postscript = true;\n        return x;\n    }\n\n    function ultimate(s) {\n        var x = symbol(s, 0);\n        x.from = 1;\n        x.thru = 1;\n        x.line = 0;\n        x.edge = 'edge';\n        x.string = s;\n        return postscript(x);\n    }\n\n    function reserve_name(x) {\n        var c = x.id.charAt(0);\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            x.identifier = x.reserved = true;\n        }\n        return x;\n    }\n\n    function stmt(s, f) {\n        var x = symbol(s);\n        x.fud = f;\n        return reserve_name(x);\n    }\n\n    function disrupt_stmt(s, f) {\n        var x = stmt(s, f);\n        x.disrupt = true;\n    }\n\n    function labeled_stmt(s, f) {\n        var x = stmt(s, f);\n        x.labeled = true;\n    }\n\n    function prefix(s, f) {\n        var x = symbol(s, 150);\n        reserve_name(x);\n        x.nud = function () {\n            var that = this;\n            that.arity = 'prefix';\n            if (typeof f === 'function') {\n                that = f(that);\n                if (that.arity !== 'prefix') {\n                    return that;\n                }\n            } else {\n                if (s === 'typeof') {\n                    one_space();\n                } else {\n                    no_space_only();\n                }\n                that.first = expression(150);\n            }\n            switch (that.id) {\n            case '++':\n            case '--':\n                if (!option.plusplus) {\n                    that.warn('unexpected_a');\n                } else if ((!that.first.identifier || that.first.reserved) &&\n                        that.first.id !== '.' && that.first.id !== '[') {\n                    that.warn('bad_operand');\n                }\n                break;\n            default:\n                if (that.first.arity === 'prefix' ||\n                        that.first.arity === 'function') {\n                    that.warn('unexpected_a');\n                }\n            }\n            return that;\n        };\n        return x;\n    }\n\n\n    function type(s, t, nud) {\n        var x = symbol(s);\n        x.arity = t;\n        if (nud) {\n            x.nud = nud;\n        }\n        return x;\n    }\n\n\n    function reserve(s, f) {\n        var x = symbol(s);\n        x.identifier = x.reserved = true;\n        if (typeof f === 'function') {\n            x.nud = f;\n        }\n        return x;\n    }\n\n\n    function constant(name) {\n        var x = reserve(name);\n        x.string = name;\n        x.nud = return_this;\n        return x;\n    }\n\n\n    function reservevar(s, v) {\n        return reserve(s, function () {\n            if (typeof v === 'function') {\n                v(this);\n            }\n            return this;\n        });\n    }\n\n\n    function infix(s, p, f, w) {\n        var x = symbol(s, p);\n        reserve_name(x);\n        x.led = function (left) {\n            this.arity = 'infix';\n            if (!w) {\n                spaces(prev_token, token);\n                spaces();\n            }\n            if (!option.bitwise && this.bitwise) {\n                this.warn('unexpected_a');\n            }\n            if (typeof f === 'function') {\n                return f(left, this);\n            }\n            this.first = left;\n            this.second = expression(p);\n            return this;\n        };\n        return x;\n    }\n\n    function expected_relation(node, message) {\n        if (node.assign) {\n            node.warn(message || 'conditional_assignment');\n        }\n        return node;\n    }\n\n    function expected_condition(node, message) {\n        switch (node.id) {\n        case '[':\n        case '-':\n            if (node.arity !== 'infix') {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        case 'false':\n        case 'function':\n        case 'Infinity':\n        case 'NaN':\n        case 'null':\n        case 'true':\n        case 'undefined':\n        case 'void':\n        case '(number)':\n        case '(regexp)':\n        case '(string)':\n        case '{':\n        case '?':\n        case '~':\n            node.warn(message || 'weird_condition');\n            break;\n        case '(':\n            if (node.first.id === 'new' ||\n                    (node.first.string === 'Boolean') ||\n                    (node.first.id === '.' &&\n                        numbery[node.first.second.string] === true)) {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        }\n        return node;\n    }\n\n    function check_relation(node) {\n        switch (node.arity) {\n        case 'prefix':\n            switch (node.id) {\n            case '{':\n            case '[':\n                node.warn('unexpected_a');\n                break;\n            case '!':\n                node.warn('confusing_a');\n                break;\n            }\n            break;\n        case 'function':\n        case 'regexp':\n            node.warn('unexpected_a');\n            break;\n        default:\n            if (node.id  === 'NaN') {\n                node.warn('isNaN');\n            } else if (node.relation) {\n                node.warn('weird_relation');\n            }\n        }\n        return node;\n    }\n\n\n    function relation(s, eqeq) {\n        var x = infix(s, 100, function (left, that) {\n            check_relation(left);\n            if (eqeq && !option.eqeq) {\n                that.warn('expected_a_b', eqeq, that.id);\n            }\n            var right = expression(100);\n            if (are_similar(left, right) ||\n                    ((left.id === '(string)' || left.id === '(number)') &&\n                    (right.id === '(string)' || right.id === '(number)'))) {\n                that.warn('weird_relation');\n            } else if (left.id === 'typeof') {\n                if (right.id !== '(string)') {\n                    right.warn(\"expected_string_a\", artifact(right));\n                } else if (right.string === 'undefined' ||\n                        right.string === 'null') {\n                    left.warn(\"unexpected_typeof_a\", right.string);\n                }\n            } else if (right.id === 'typeof') {\n                if (left.id !== '(string)') {\n                    left.warn(\"expected_string_a\", artifact(left));\n                } else if (left.string === 'undefined' ||\n                        left.string === 'null') {\n                    right.warn(\"unexpected_typeof_a\", left.string);\n                }\n            }\n            that.first = left;\n            that.second = check_relation(right);\n            return that;\n        });\n        x.relation = true;\n        return x;\n    }\n\n    function lvalue(that, s) {\n        var master;\n        if (that.identifier) {\n            master = scope[that.string];\n            if (master) {\n                if (scope[that.string].writeable !== true) {\n                    that.warn('read_only');\n                }\n                master.used -= 1;\n                if (s === '=') {\n                    master.init = true;\n                }\n            }\n        } else if (that.id === '.' || that.id === '[') {\n            if (!that.first || that.first.string === 'arguments') {\n                that.warn('bad_assignment');\n            }\n        } else {\n            that.warn('bad_assignment');\n        }\n    }\n\n\n    function assignop(s, op) {\n        var x = infix(s, 20, function (left, that) {\n            var next;\n            that.first = left;\n            lvalue(left, s);\n            that.second = expression(20);\n            if (that.id === '=' && are_similar(that.first, that.second)) {\n                that.warn('weird_assignment');\n            }\n            next = that;\n            while (next_token.id === '=') {\n                lvalue(next.second, '=');\n                next_token.first = next.second;\n                next.second = next_token;\n                next = next_token;\n                advance('=');\n                next.second = expression(20);\n            }\n            return that;\n        });\n        x.assign = true;\n        if (op) {\n            if (syntax[op].bitwise) {\n                x.bitwise = true;\n            }\n        }\n        return x;\n    }\n\n\n    function bitwise(s, p) {\n        var x = infix(s, p, 'number');\n        x.bitwise = true;\n        return x;\n    }\n\n\n    function suffix(s) {\n        var x = symbol(s, 150);\n        x.led = function (left) {\n            no_space_only(prev_token, token);\n            if (!option.plusplus) {\n                this.warn('unexpected_a');\n            } else if ((!left.identifier || left.reserved) &&\n                    left.id !== '.' && left.id !== '[') {\n                this.warn('bad_operand');\n            }\n            this.first = left;\n            this.arity = 'suffix';\n            return this;\n        };\n        return x;\n    }\n\n\n    function optional_identifier(variable) {\n        if (next_token.identifier) {\n            advance();\n            if (token.reserved && (!option.es5 || variable)) {\n                token.warn('expected_identifier_a_reserved');\n            }\n            return token.string;\n        }\n    }\n\n\n    function identifier(variable) {\n        var i = optional_identifier(variable);\n        if (!i) {\n            next_token.stop(token.id === 'function' && next_token.id === '('\n                ? 'name_function'\n                : 'expected_identifier_a');\n        }\n        return i;\n    }\n\n\n    function statement() {\n\n        var label, preamble, the_statement;\n\n// We don't like the empty statement.\n\n        if (next_token.id === ';') {\n            next_token.warn('unexpected_a');\n            semicolon();\n            return;\n        }\n\n// Is this a labeled statement?\n\n        if (next_token.identifier && !next_token.reserved && peek().id === ':') {\n            edge('label');\n            label = next_token;\n            advance();\n            advance(':');\n            define('label', label);\n            if (next_token.labeled !== true || funct === global_funct) {\n                label.stop('unexpected_label_a');\n            } else if (jx.test(label.string + ':')) {\n                label.warn('url');\n            }\n            next_token.label = label;\n            label.init = true;\n        }\n\n// Parse the statement.\n\n        preamble = next_token;\n        if (token.id !== 'else') {\n            edge();\n        }\n        step_in('statement');\n        the_statement = expression(0, true);\n        if (the_statement) {\n\n// Look for the final semicolon.\n\n            if (the_statement.arity === 'statement') {\n                if (the_statement.id === 'switch' ||\n                        (the_statement.block && the_statement.id !== 'do')) {\n                    spaces();\n                } else {\n                    semicolon();\n                }\n            } else {\n\n// If this is an expression statement, determine if it is acceptable.\n// We do not like\n//      new Blah;\n// statements. If it is to be used at all, new should only be used to make\n// objects, not side effects. The expression statements we do like do\n// assignment or invocation or delete.\n\n                if (the_statement.id === '(') {\n                    if (the_statement.first.id === 'new') {\n                        next_token.warn('bad_new');\n                    }\n                } else if (the_statement.id === '++' ||\n                        the_statement.id === '--') {\n                    lvalue(the_statement.first);\n                } else if (!the_statement.assign &&\n                        the_statement.id !== 'delete') {\n                    if (!option.closure || !preamble.comments) {\n                        preamble.warn('assignment_function_expression');\n                    }\n                }\n                semicolon();\n            }\n        }\n        step_out();\n        if (label) {\n            label.dead = true;\n        }\n        return the_statement;\n    }\n\n\n    function statements() {\n        var array = [], disruptor, the_statement;\n\n// A disrupt statement may not be followed by any other statement.\n// If the last statement is disrupt, then the sequence is disrupt.\n\n        while (next_token.postscript !== true) {\n            if (next_token.id === ';') {\n                next_token.warn('unexpected_a');\n                semicolon();\n            } else {\n                if (next_token.string === 'use strict') {\n                    if ((!node_js) || funct !== global_funct || array.length > 0) {\n                        next_token.warn('function_strict');\n                    }\n                    use_strict();\n                }\n                if (disruptor) {\n                    next_token.warn('unreachable_a_b', next_token.string,\n                        disruptor.string);\n                    disruptor = null;\n                }\n                the_statement = statement();\n                if (the_statement) {\n                    array.push(the_statement);\n                    if (the_statement.disrupt) {\n                        disruptor = the_statement;\n                        array.disrupt = true;\n                    }\n                }\n            }\n        }\n        return array;\n    }\n\n\n    function block(kind) {\n\n// A block is a sequence of statements wrapped in braces.\n\n        var array,\n            curly = next_token,\n            old_block_var = block_var,\n            old_in_block = in_block,\n            old_strict_mode = strict_mode;\n\n        in_block = kind !== 'function' && kind !== 'try' && kind !== 'catch';\n        block_var = [];\n        if (curly.id === '{') {\n            spaces();\n            advance('{');\n            step_in();\n            if (kind === 'function' && !use_strict() && !old_strict_mode &&\n                    !option.sloppy && funct.level === 1) {\n                next_token.warn('missing_use_strict');\n            }\n            array = statements();\n            strict_mode = old_strict_mode;\n            step_out('}', curly);\n        } else if (in_block) {\n            curly.stop('expected_a_b', '{', artifact());\n        } else {\n            curly.warn('expected_a_b', '{', artifact());\n            array = [statement()];\n            array.disrupt = array[0].disrupt;\n        }\n        if (kind !== 'catch' && array.length === 0) {\n            curly.warn('empty_block');\n        }\n        block_var.forEach(function (name) {\n            scope[name].dead = true;\n        });\n        block_var = old_block_var;\n        in_block = old_in_block;\n        return array;\n    }\n\n\n    function tally_property(name) {\n        if (option.properties && typeof property[name] !== 'number') {\n            token.warn('unexpected_property_a', name);\n        }\n        if (property[name]) {\n            property[name] += 1;\n        } else {\n            property[name] = 1;\n        }\n    }\n\n\n// ECMAScript parser\n\n    (function () {\n        var x = symbol('(identifier)');\n        x.nud = function () {\n            var name = this.string,\n                master = scope[name],\n                writeable;\n\n// If the master is not in scope, then we may have an undeclared variable.\n// Check the predefined list. If it was predefined, create the global\n// variable.\n\n            if (!master) {\n                writeable = predefined[name];\n                if (typeof writeable === 'boolean') {\n                    global_scope[name] = master = {\n                        dead: false,\n                        function: global_funct,\n                        kind: 'var',\n                        string: name,\n                        writeable: writeable\n                    };\n\n// But if the variable is not in scope, and is not predefined, and if we are not\n// in the global scope, then we have an undefined variable error.\n\n                } else {\n                    token.warn('used_before_a');\n                }\n            } else {\n                this.master = master;\n            }\n\n// Annotate uses that cross scope boundaries.\n\n            if (master) {\n                if (master.kind === 'label') {\n                    this.warn('a_label');\n                } else {\n                    if (master.dead === true || master.dead === funct) {\n                        this.warn('a_scope');\n                    }\n                    master.used += 1;\n                    if (master.function !== funct) {\n                        if (master.function === global_funct) {\n                            funct.global.push(name);\n                        } else {\n                            master.function.closure.push(name);\n                            funct.outer.push(name);\n                        }\n                    }\n                }\n            }\n            return this;\n        };\n        x.identifier = true;\n    }());\n\n\n// Build the syntax table by declaring the syntactic elements.\n\n    type('(array)', 'array');\n    type('(function)', 'function');\n    type('(number)', 'number', return_this);\n    type('(object)', 'object');\n    type('(string)', 'string', return_this);\n    type('(boolean)', 'boolean', return_this);\n    type('(regexp)', 'regexp', return_this);\n\n    ultimate('(begin)');\n    ultimate('(end)');\n    ultimate('(error)');\n    postscript(symbol('}'));\n    symbol(')');\n    symbol(']');\n    postscript(symbol('\"'));\n    postscript(symbol('\\''));\n    symbol(';');\n    symbol(':');\n    symbol(',');\n    symbol('#');\n    symbol('@');\n    symbol('*/');\n    postscript(reserve('case'));\n    reserve('catch');\n    postscript(reserve('default'));\n    reserve('else');\n    reserve('finally');\n\n    reservevar('arguments', function (x) {\n        if (strict_mode && funct === global_funct) {\n            x.warn('strict');\n        }\n        funct.arguments = true;\n    });\n    reservevar('eval');\n    constant('false', 'boolean');\n    constant('Infinity', 'number');\n    constant('NaN', 'number');\n    constant('null', '');\n    reservevar('this', function (x) {\n        if (strict_mode && funct.statement && funct.name.charAt(0) > 'Z') {\n            x.warn('strict');\n        }\n    });\n    constant('true', 'boolean');\n    constant('undefined', '');\n\n    infix('?', 30, function (left, that) {\n        step_in('?');\n        that.first = expected_condition(expected_relation(left));\n        that.second = expression(0);\n        spaces();\n        step_out();\n        var colon = next_token;\n        advance(':');\n        step_in(':');\n        spaces();\n        that.third = expression(10);\n        that.arity = 'ternary';\n        if (are_similar(that.second, that.third)) {\n            colon.warn('weird_ternary');\n        } else if (are_similar(that.first, that.second)) {\n            that.warn('use_or');\n        }\n        step_out();\n        return that;\n    });\n\n    infix('||', 40, function (left, that) {\n        function paren_check(that) {\n            if (that.id === '&&' && !that.paren) {\n                that.warn('and');\n            }\n            return that;\n        }\n\n        that.first = paren_check(expected_condition(expected_relation(left)));\n        that.second = paren_check(expected_relation(expression(40)));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    infix('&&', 50, function (left, that) {\n        that.first = expected_condition(expected_relation(left));\n        that.second = expected_relation(expression(50));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    prefix('void', function (that) {\n        that.first = expression(0);\n        if (option.es5 || strict_mode) {\n            that.warn('expected_a_b', 'undefined', 'void');\n        } else if (that.first.number !== 0) {\n            that.first.warn('expected_a_b', '0', artifact(that.first));\n        }\n        return that;\n    });\n\n    bitwise('|', 70);\n    bitwise('^', 80);\n    bitwise('&', 90);\n\n    relation('==', '===');\n    relation('===');\n    relation('!=', '!==');\n    relation('!==');\n    relation('<');\n    relation('>');\n    relation('<=');\n    relation('>=');\n\n    bitwise('<<', 120);\n    bitwise('>>', 120);\n    bitwise('>>>', 120);\n\n    infix('in', 120, function (left, that) {\n        that.warn('infix_in');\n        that.left = left;\n        that.right = expression(130);\n        return that;\n    });\n    infix('instanceof', 120);\n    infix('+', 130, function (left, that) {\n        if (left.id === '(number)') {\n            if (left.number === 0) {\n                left.warn('unexpected_a', '0');\n            }\n        } else if (left.id === '(string)') {\n            if (left.string === '') {\n                left.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        var right = expression(130);\n        if (right.id === '(number)') {\n            if (right.number === 0) {\n                right.warn('unexpected_a', '0');\n            }\n        } else if (right.id === '(string)') {\n            if (right.string === '') {\n                right.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        if (left.id === right.id) {\n            if (left.id === '(string)' || left.id === '(number)') {\n                if (left.id === '(string)') {\n                    left.string += right.string;\n                    if (jx.test(left.string)) {\n                        left.warn('url');\n                    }\n                } else {\n                    left.number += right.number;\n                }\n                left.thru = right.thru;\n                return left;\n            }\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('+');\n    prefix('+++', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('+++', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('-', 130, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(130);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number -= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('-');\n    prefix('---', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('---', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('*', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number *= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('/', 140, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number /= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('%', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number %= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n\n    suffix('++');\n    prefix('++');\n\n    suffix('--');\n    prefix('--');\n    prefix('delete', function (that) {\n        one_space();\n        var p = expression(0);\n        if (!p || (p.id !== '.' && p.id !== '[')) {\n            next_token.warn('deleted');\n        }\n        that.first = p;\n        return that;\n    });\n\n\n    prefix('~', function (that) {\n        no_space_only();\n        if (!option.bitwise) {\n            that.warn('unexpected_a');\n        }\n        that.first = expression(150);\n        return that;\n    });\n    function banger(that) {\n        no_space_only();\n        that.first = expected_condition(expression(150));\n        if (bang[that.first.id] === that || that.first.assign) {\n            that.warn('confusing_a');\n        }\n        return that;\n    }\n    prefix('!', banger);\n    prefix('!!', banger);\n    prefix('typeof');\n    prefix('new', function (that) {\n        one_space();\n        var c = expression(160), n, p, v;\n        that.first = c;\n        if (c.id !== 'function') {\n            if (c.identifier) {\n                switch (c.string) {\n                case 'Object':\n                    token.warn('use_object');\n                    break;\n                case 'Array':\n                    if (next_token.id === '(') {\n                        p = next_token;\n                        p.first = this;\n                        advance('(');\n                        if (next_token.id !== ')') {\n                            n = expression(0);\n                            p.second = [n];\n                            if (n.id !== '(number)' || next_token.id === ',') {\n                                p.warn('use_array');\n                            }\n                            while (next_token.id === ',') {\n                                advance(',');\n                                p.second.push(expression(0));\n                            }\n                        } else {\n                            token.warn('use_array');\n                        }\n                        advance(')', p);\n                        return p;\n                    }\n                    token.warn('use_array');\n                    break;\n                case 'Number':\n                case 'String':\n                case 'Boolean':\n                case 'Math':\n                case 'JSON':\n                    c.warn('not_a_constructor');\n                    break;\n                case 'Function':\n                    if (!option.evil) {\n                        next_token.warn('function_eval');\n                    }\n                    break;\n                case 'Date':\n                case 'RegExp':\n                case 'this':\n                    break;\n                default:\n                    if (c.id !== 'function') {\n                        v = c.string.charAt(0);\n                        if (!option.newcap && (v < 'A' || v > 'Z')) {\n                            token.warn('constructor_name_a');\n                        }\n                    }\n                }\n            } else {\n                if (c.id !== '.' && c.id !== '[' && c.id !== '(') {\n                    token.warn('bad_constructor');\n                }\n            }\n        } else {\n            that.warn('weird_new');\n        }\n        if (next_token.id !== '(') {\n            next_token.warn('missing_a', '()');\n        }\n        return that;\n    });\n\n    infix('(', 160, function (left, that) {\n        var e, p;\n        if (indent && indent.mode === 'expression') {\n            no_space(prev_token, token);\n        } else {\n            no_space_only(prev_token, token);\n        }\n        if (!left.immed && left.id === 'function') {\n            next_token.warn('wrap_immediate');\n        }\n        p = [];\n        if (left.identifier) {\n            if (left.string.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {\n                if (left.string !== 'Number' && left.string !== 'String' &&\n                        left.string !== 'Boolean' && left.string !== 'Date') {\n                    if (left.string === 'Math') {\n                        left.warn('not_a_function');\n                    } else if (left.string === 'Object') {\n                        token.warn('use_object');\n                    } else if (left.string === 'Array' || !option.newcap) {\n                        left.warn('missing_a', 'new');\n                    }\n                }\n            } else if (left.string === 'JSON') {\n                left.warn('not_a_function');\n            }\n        } else if (left.id === '.') {\n            if (left.second.string === 'split' &&\n                    left.first.id === '(string)') {\n                left.second.warn('use_array');\n            }\n        }\n        step_in();\n        if (next_token.id !== ')') {\n            no_space();\n            for (;;) {\n                edge();\n                e = expression(10);\n                if (left.string === 'Boolean' && (e.id === '!' || e.id === '~')) {\n                    e.warn('weird_condition');\n                }\n                p.push(e);\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', that);\n        if (typeof left === 'object') {\n            if (left.string === 'parseInt' && p.length === 1) {\n                left.warn('radix');\n            } else if (left.string === 'String' && p.length >= 1 && p[0].id === '(string)') {\n                left.warn('unexpected_a');\n            }\n            if (!option.evil) {\n                if (left.string === 'eval' || left.string === 'Function' ||\n                        left.string === 'execScript') {\n                    left.warn('evil');\n                } else if (p[0] && p[0].id === '(string)' &&\n                        (left.string === 'setTimeout' ||\n                        left.string === 'setInterval')) {\n                    left.warn('implied_evil');\n                }\n            }\n            if (!left.identifier && left.id !== '.' && left.id !== '[' &&\n                    left.id !== '(' && left.id !== '&&' && left.id !== '||' &&\n                    left.id !== '?') {\n                left.warn('bad_invocation');\n            }\n            if (left.id === '.') {\n                if (p.length > 0 &&\n                        left.first && left.first.first &&\n                        are_similar(p[0], left.first.first)) {\n                    if (left.second.string === 'call' ||\n                            (left.second.string === 'apply' && (p.length === 1 ||\n                            (p[1].arity === 'prefix' && p[1].id === '[')))) {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n                if (left.second.string === 'toString') {\n                    if (left.first.id === '(string)' || left.first.id === '(number)') {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n            }\n        }\n        that.first = left;\n        that.second = p;\n        return that;\n    }, true);\n\n    prefix('(', function (that) {\n        step_in('expression');\n        no_space();\n        edge();\n        if (next_token.id === 'function') {\n            next_token.immed = true;\n        }\n        var value = expression(0);\n        value.paren = true;\n        no_space();\n        step_out(')', that);\n        if (value.id === 'function') {\n            switch (next_token.id) {\n            case '(':\n                next_token.warn('move_invocation');\n                break;\n            case '.':\n            case '[':\n                next_token.warn('unexpected_a');\n                break;\n            default:\n                that.warn('bad_wrap');\n            }\n        } else if (!value.arity) {\n            if (!option.closure || !that.comments) {\n                that.warn('unexpected_a');\n            }\n        }\n        return value;\n    });\n\n    infix('.', 170, function (left, that) {\n        no_space(prev_token, token);\n        no_space();\n        var name = identifier();\n        if (typeof name === 'string') {\n            tally_property(name);\n        }\n        that.first = left;\n        that.second = token;\n        if (left && left.string === 'arguments' &&\n                (name === 'callee' || name === 'caller')) {\n            left.warn('avoid_a', 'arguments.' + name);\n        } else if (!option.evil && left && left.string === 'document' &&\n                (name === 'write' || name === 'writeln')) {\n            left.warn('write_is_wrong');\n        } else if (!option.stupid && syx.test(name)) {\n            token.warn('sync_a');\n        }\n        if (!option.evil && (name === 'eval' || name === 'execScript')) {\n            next_token.warn('evil');\n        }\n        return that;\n    }, true);\n\n    infix('[', 170, function (left, that) {\n        var e, s;\n        no_space_only(prev_token, token);\n        no_space();\n        step_in();\n        edge();\n        e = expression(0);\n        switch (e.id) {\n        case '(number)':\n            if (e.id === '(number)' && left.id === 'arguments') {\n                left.warn('use_param');\n            }\n            break;\n        case '(string)':\n            if (!option.evil &&\n                    (e.string === 'eval' || e.string === 'execScript')) {\n                e.warn('evil');\n            } else if (!option.sub && ix.test(e.string)) {\n                s = syntax[e.string];\n                if (!s || !s.reserved) {\n                    e.warn('subscript');\n                }\n            }\n            tally_property(e.string);\n            break;\n        }\n        step_out(']', that);\n        no_space(prev_token, token);\n        that.first = left;\n        that.second = e;\n        return that;\n    }, true);\n\n    prefix('[', function (that) {\n        that.first = [];\n        step_in('array');\n        while (next_token.id !== '(end)') {\n            while (next_token.id === ',') {\n                next_token.warn('unexpected_a');\n                advance(',');\n            }\n            if (next_token.id === ']') {\n                break;\n            }\n            indent.wrap = false;\n            edge();\n            that.first.push(expression(10));\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id === ']' && !option.es5) {\n                    token.warn('unexpected_a');\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        step_out(']', that);\n        return that;\n    }, 170);\n\n\n    function property_name() {\n        var id = optional_identifier();\n        if (!id) {\n            if (next_token.id === '(string)') {\n                id = next_token.string;\n                advance();\n            } else if (next_token.id === '(number)') {\n                id = next_token.number.toString();\n                advance();\n            }\n        }\n        return id;\n    }\n\n\n\n    assignop('=');\n    assignop('+=', '+');\n    assignop('-=', '-');\n    assignop('*=', '*');\n    assignop('/=', '/').nud = function () {\n        next_token.stop('slash_equal');\n    };\n    assignop('%=', '%');\n    assignop('&=', '&');\n    assignop('|=', '|');\n    assignop('^=', '^');\n    assignop('<<=', '<<');\n    assignop('>>=', '>>');\n    assignop('>>>=', '>>>');\n\n    function function_parameters() {\n        var id, parameters = [], paren = next_token;\n        advance('(');\n        token.function = funct;\n        step_in();\n        no_space();\n        if (next_token.id !== ')') {\n            for (;;) {\n                edge();\n                id = identifier();\n                define('parameter', token);\n                parameters.push(id);\n                token.init = true;\n                token.writeable = true;\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', paren);\n        return parameters;\n    }\n\n    function do_function(func, name) {\n        var old_funct = funct,\n            old_option = option,\n            old_scope = scope;\n        scope = Object.create(old_scope);\n        funct = {\n            closure: [],\n            global: [],\n            level: old_funct.level + 1,\n            line: next_token.line,\n            loopage: 0,\n            name: name || '\\'' + (anonname || '').replace(nx, sanitize) + '\\'',\n            outer: [],\n            scope: scope\n        };\n        funct.parameter = function_parameters();\n        func.function = funct;\n        option = Object.create(old_option);\n        functions.push(funct);\n        if (name) {\n            func.name = name;\n            func.string = name;\n            define('function', func);\n            func.init = true;\n            func.used += 1;\n        }\n        func.writeable = false;\n        one_space();\n        func.block = block('function');\n        Object.keys(scope).forEach(function (name) {\n            var master = scope[name];\n            if (!master.used && master.kind !== 'exception' &&\n                    (master.kind !== 'parameter' || !option.unparam)) {\n                master.warn('unused_a');\n            } else if (!master.init) {\n                master.warn('uninitialized_a');\n            }\n        });\n        funct = old_funct;\n        option = old_option;\n        scope = old_scope;\n    }\n\n    prefix('{', function (that) {\n        var get, i, j, name, p, set, seen = Object.create(null);\n        that.first = [];\n        step_in();\n        while (next_token.id !== '}') {\n            indent.wrap = false;\n\n// JSLint recognizes the ES5 extension for get/set in object literals,\n// but requires that they be used in pairs.\n\n            edge();\n            if (next_token.string === 'get' && peek().id !== ':') {\n                if (!option.es5) {\n                    next_token.warn('es5');\n                }\n                get = next_token;\n                advance('get');\n                one_space_only();\n                name = next_token;\n                i = property_name();\n                if (!i) {\n                    next_token.stop('missing_property');\n                }\n                get.string = '';\n                do_function(get);\n                if (funct.loopage) {\n                    get.warn('function_loop');\n                }\n                if (get.function.parameter.length) {\n                    get.warn('parameter_a_get_b', get.function.parameter[0], i);\n                }\n                comma();\n                set = next_token;\n                spaces();\n                edge();\n                advance('set');\n                set.string = '';\n                one_space_only();\n                j = property_name();\n                if (i !== j) {\n                    token.stop('expected_a_b', i, j || next_token.string);\n                }\n                do_function(set);\n                if (set.block.length === 0) {\n                    token.warn('missing_a', 'throw');\n                }\n                if (set.function.parameter.length === 0) {\n                    set.stop('parameter_set_a', 'value');\n                } else if (set.function.parameter[0] !== 'value') {\n                    set.stop('expected_a_b', 'value',\n                        set.function.parameter[0]);\n                }\n                name.first = [get, set];\n            } else {\n                name = next_token;\n                i = property_name();\n                if (typeof i !== 'string') {\n                    next_token.stop('missing_property');\n                }\n                advance(':');\n                spaces();\n                name.first = expression(10);\n            }\n            that.first.push(name);\n            if (seen[i] === true) {\n                next_token.warn('duplicate_a', i);\n            }\n            seen[i] = true;\n            tally_property(i);\n            if (next_token.id !== ',') {\n                break;\n            }\n            for (;;) {\n                comma();\n                if (next_token.id !== ',') {\n                    break;\n                }\n                next_token.warn('unexpected_a');\n            }\n            if (next_token.id === '}' && !option.es5) {\n                token.warn('unexpected_a');\n            }\n        }\n        step_out('}', that);\n        return that;\n    });\n\n    stmt('{', function () {\n        next_token.warn('statement_block');\n        this.arity = 'statement';\n        this.block = statements();\n        this.disrupt = this.block.disrupt;\n        advance('}', this);\n        return this;\n    });\n\n    stmt('/*global', directive);\n    stmt('/*globals', directive);\n    stmt('/*jslint', directive);\n    stmt('/*member', directive);\n    stmt('/*members', directive);\n    stmt('/*property', directive);\n    stmt('/*properties', directive);\n\n    stmt('var', function () {\n\n// JavaScript does not have block scope. It only has function scope. So,\n// declaring a variable in a block can have unexpected consequences.\n\n// var.first will contain an array, the array containing name tokens\n// and assignment tokens.\n\n        var assign, id, name;\n\n        if (funct.loopage) {\n            next_token.warn('var_loop');\n        } else if (funct.varstatement && !option.vars) {\n            next_token.warn('combine_var');\n        }\n        if (funct !== global_funct) {\n            funct.varstatement = true;\n        }\n        this.arity = 'statement';\n        this.first = [];\n        step_in('var');\n        for (;;) {\n            name = next_token;\n            id = identifier(true);\n            define('var', name);\n            name.dead = funct;\n            if (next_token.id === '=') {\n                assign = next_token;\n                assign.first = name;\n                spaces();\n                advance('=');\n                spaces();\n                if (next_token.id === 'undefined') {\n                    token.warn('unnecessary_initialize', id);\n                }\n                if (peek(0).id === '=' && next_token.identifier) {\n                    next_token.stop('var_a_not');\n                }\n                assign.second = expression(0);\n                assign.arity = 'infix';\n                name.init = true;\n                this.first.push(assign);\n            } else {\n                this.first.push(name);\n            }\n            name.dead = false;\n            name.writeable = true;\n            if (next_token.id !== ',') {\n                break;\n            }\n            comma();\n            indent.wrap = false;\n            if (var_mode && next_token.line === token.line &&\n                    this.first.length === 1) {\n                var_mode = null;\n                indent.open = false;\n                indent.at -= option.indent;\n            }\n            spaces();\n            edge();\n        }\n        var_mode = null;\n        step_out();\n        return this;\n    });\n\n    stmt('function', function () {\n        one_space();\n        if (in_block) {\n            token.warn('function_block');\n        }\n        var name = next_token,\n            id = identifier(true);\n        define('var', name);\n        name.init = true;\n        name.statement = true;\n        no_space();\n        this.arity = 'statement';\n        do_function(this, id);\n        if (next_token.id === '(' && next_token.line === token.line) {\n            next_token.stop('function_statement');\n        }\n        return this;\n    });\n\n    prefix('function', function (that) {\n        var id = optional_identifier(true), name;\n        if (id) {\n            name = token;\n            no_space();\n        } else {\n            id = '';\n            one_space();\n        }\n        do_function(that, id);\n        if (name) {\n            name.function = that.function;\n        }\n        if (funct.loopage) {\n            that.warn('function_loop');\n        }\n        switch (next_token.id) {\n        case ';':\n        case '(':\n        case ')':\n        case ',':\n        case ']':\n        case '}':\n        case ':':\n            break;\n        case '.':\n            if (peek().string !== 'bind' || peek(1).id !== '(') {\n                next_token.warn('unexpected_a');\n            }\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n        that.arity = 'function';\n        return that;\n    });\n\n    stmt('if', function () {\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('if');\n        if (next_token.id === 'else') {\n            if (this.block.disrupt) {\n                next_token.warn('unnecessary_else');\n            }\n            one_space();\n            advance('else');\n            one_space();\n            this.else = next_token.id === 'if' || next_token.id === 'switch'\n                ? statement(true)\n                : block('else');\n            if (this.else.disrupt && this.block.disrupt) {\n                this.disrupt = true;\n            }\n        }\n        return this;\n    });\n\n    stmt('try', function () {\n\n// try.first    The catch variable\n// try.second   The catch clause\n// try.third    The finally clause\n// try.block    The try block\n\n        var exception_variable, paren;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('try');\n        if (next_token.id === 'catch') {\n            one_space();\n            advance('catch');\n            one_space();\n            paren = next_token;\n            advance('(');\n            step_in('control');\n            no_space();\n            edge();\n            exception_variable = next_token;\n            this.first = identifier();\n            define('exception', exception_variable);\n            exception_variable.init = true;\n            no_space();\n            step_out(')', paren);\n            one_space();\n            this.second = block('catch');\n            if (this.second.length) {\n                if (this.first === 'ignore') {\n                    exception_variable.warn('unexpected_a');\n                }\n            } else {\n                if (this.first !== 'ignore') {\n                    exception_variable.warn('expected_a_b', 'ignore',\n                        exception_variable.string);\n                }\n            }\n            exception_variable.dead = true;\n        }\n        if (next_token.id === 'finally') {\n            one_space();\n            advance('finally');\n            one_space();\n            this.third = block('finally');\n        } else if (!this.second) {\n            next_token.stop('expected_a_b', 'catch', artifact());\n        }\n        return this;\n    });\n\n    labeled_stmt('while', function () {\n        one_space();\n        var paren = next_token;\n        funct.loopage += 1;\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_relation(expression(0));\n        if (this.first.id !== 'true') {\n            expected_condition(this.first, 'unexpected_a');\n        }\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('while');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        funct.loopage -= 1;\n        return this;\n    });\n\n    reserve('with');\n\n    labeled_stmt('switch', function () {\n\n// switch.first         the switch expression\n// switch.second        the array of cases. A case is 'case' or 'default' token:\n//    case.first        the array of case expressions\n//    case.second       the array of statements\n// If all of the arrays of statements are disrupt, then the switch is disrupt.\n\n        var cases = [],\n            old_in_block = in_block,\n            particular,\n            that = token,\n            the_case = next_token,\n            unbroken = true;\n\n        function find_duplicate_case(value) {\n            if (are_similar(particular, value)) {\n                value.warn('duplicate_a');\n            }\n        }\n\n        one_space();\n        advance('(');\n        no_space();\n        step_in();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', the_case);\n        one_space();\n        advance('{');\n        step_in();\n        in_block = true;\n        this.second = [];\n        if (that.from !== next_token.from && !option.white) {\n            next_token.warn('expected_a_at_b_c', next_token.string, that.from, next_token.from);\n        }\n        while (next_token.id === 'case') {\n            the_case = next_token;\n            cases.forEach(find_duplicate_case);\n            the_case.first = [];\n            the_case.arity = 'case';\n            spaces();\n            edge('case');\n            advance('case');\n            for (;;) {\n                one_space();\n                particular = expression(0);\n                cases.forEach(find_duplicate_case);\n                cases.push(particular);\n                the_case.first.push(particular);\n                if (particular.id === 'NaN') {\n                    particular.warn('unexpected_a');\n                }\n                no_space_only();\n                advance(':');\n                if (next_token.id !== 'case') {\n                    break;\n                }\n                spaces();\n                edge('case');\n                advance('case');\n            }\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                particular = the_case.second[the_case.second.length - 1];\n                if (particular.disrupt) {\n                    if (particular.id === 'break') {\n                        unbroken = false;\n                    }\n                } else {\n                    next_token.warn('missing_a_after_b', 'break', 'case');\n                }\n            } else {\n                next_token.warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.second.length === 0) {\n            next_token.warn('missing_a', 'case');\n        }\n        if (next_token.id === 'default') {\n            spaces();\n            the_case = next_token;\n            the_case.arity = 'case';\n            edge('case');\n            advance('default');\n            no_space_only();\n            advance(':');\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                particular = the_case.second[the_case.second.length - 1];\n                if (unbroken && particular.disrupt && particular.id !== 'break') {\n                    this.disrupt = true;\n                }\n            }\n            this.second.push(the_case);\n        }\n        spaces();\n        step_out('}', this);\n        in_block = old_in_block;\n        return this;\n    });\n\n    stmt('debugger', function () {\n        if (!option.debug) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        return this;\n    });\n\n    labeled_stmt('do', function () {\n        funct.loopage += 1;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('do');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        one_space();\n        advance('while');\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in();\n        no_space();\n        edge();\n        this.first = expected_condition(expected_relation(expression(0)), 'unexpected_a');\n        no_space();\n        step_out(')', paren);\n        funct.loopage -= 1;\n        return this;\n    });\n\n    labeled_stmt('for', function () {\n\n        var blok, filter, master, ok = false, paren = next_token, value;\n        this.arity = 'statement';\n        funct.loopage += 1;\n        advance('(');\n        if (next_token.id === ';') {\n            no_space();\n            advance(';');\n            no_space();\n            advance(';');\n            no_space();\n            advance(')');\n            blok = block('for');\n        } else {\n            step_in('control');\n            spaces(this, paren);\n            no_space();\n            if (next_token.id === 'var') {\n                next_token.stop('move_var');\n            }\n            edge();\n            if (peek(0).id === 'in') {\n                this.forin = true;\n                value = expression(1000);\n                master = value.master;\n                if (master.kind !== 'var' || master.function !== funct ||\n                        !master.writeable || master.dead) {\n                    value.warn('bad_in_a');\n                }\n                master.init = true;\n                master.used -= 1;\n                this.first = value;\n                advance('in');\n                this.second = expression(20);\n                step_out(')', paren);\n                blok = block('for');\n                if (!option.forin) {\n                    if (blok.length === 1 && typeof blok[0] === 'object') {\n                        if (blok[0].id === 'if' && !blok[0].else) {\n                            filter = blok[0].first;\n                            while (filter.id === '&&') {\n                                filter = filter.first;\n                            }\n                            switch (filter.id) {\n                            case '===':\n                            case '!==':\n                                ok = filter.first.id === '['\n                                    ? are_similar(filter.first.first, this.second) &&\n                                        are_similar(filter.first.second, this.first)\n                                    : filter.first.id === 'typeof' &&\n                                        filter.first.first.id === '[' &&\n                                        are_similar(filter.first.first.first, this.second) &&\n                                        are_similar(filter.first.first.second, this.first);\n                                break;\n                            case '(':\n                                ok = filter.first.id === '.' && ((\n                                    are_similar(filter.first.first, this.second) &&\n                                    filter.first.second.string === 'hasOwnProperty' &&\n                                    are_similar(filter.second[0], this.first)\n                                ) || (\n                                    filter.first.first.id === '.' &&\n                                    filter.first.first.first.first &&\n                                    filter.first.first.first.first.string === 'Object' &&\n                                    filter.first.first.first.id === '.' &&\n                                    filter.first.first.first.second.string === 'prototype' &&\n                                    filter.first.first.second.string === 'hasOwnProperty' &&\n                                    filter.first.second.string === 'call' &&\n                                    are_similar(filter.second[0], this.second) &&\n                                    are_similar(filter.second[1], this.first)\n                                ));\n                                break;\n                            }\n                        } else if (blok[0].id === 'switch') {\n                            ok = blok[0].id === 'switch' &&\n                                blok[0].first.id === 'typeof' &&\n                                blok[0].first.first.id === '[' &&\n                                are_similar(blok[0].first.first.first, this.second) &&\n                                are_similar(blok[0].first.first.second, this.first);\n                        }\n                    }\n                    if (!ok) {\n                        this.warn('for_if');\n                    }\n                }\n            } else {\n                edge();\n                this.first = [];\n                for (;;) {\n                    this.first.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                semicolon();\n                edge();\n                this.second = expected_relation(expression(0));\n                if (this.second.id !== 'true') {\n                    expected_condition(this.second, 'unexpected_a');\n                }\n                semicolon(token);\n                if (next_token.id === ';') {\n                    next_token.stop('expected_a_b', ')', ';');\n                }\n                this.third = [];\n                edge();\n                for (;;) {\n                    this.third.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                no_space();\n                step_out(')', paren);\n                one_space();\n                blok = block('for');\n            }\n        }\n        if (blok.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        this.block = blok;\n        funct.loopage -= 1;\n        return this;\n    });\n\n    function optional_label(that) {\n        var label = next_token.string,\n            master;\n        that.arity = 'statement';\n        if (next_token.identifier && token.line === next_token.line) {\n            one_space_only();\n            master = scope[label];\n            if (!master || master.kind !== 'label') {\n                next_token.warn('not_a_label');\n            } else if (master.dead || master.function !== funct) {\n                next_token.warn('not_a_scope');\n            } else {\n                master.used += 1;\n            }\n            that.first = next_token;\n            advance();\n        }\n        return that;\n\n    }\n\n    disrupt_stmt('break', function () {\n        return optional_label(this);\n    });\n\n    disrupt_stmt('continue', function () {\n        if (!option.continue) {\n            this.warn('unexpected_a');\n        }\n        return optional_label(this);\n    });\n\n    disrupt_stmt('return', function () {\n        if (funct === global_funct) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        if (next_token.id !== ';' && next_token.line === token.line) {\n            if (option.closure) {\n                spaces();\n            } else {\n                one_space_only();\n            }\n            if (next_token.id === '/' || next_token.id === '(regexp)') {\n                next_token.warn('wrap_regexp');\n            }\n            this.first = expression(0);\n            if (this.first.assign) {\n                this.first.warn('unexpected_a');\n            }\n        }\n        return this;\n    });\n\n    disrupt_stmt('throw', function () {\n        this.arity = 'statement';\n        one_space_only();\n        this.first = expression(20);\n        return this;\n    });\n\n\n//  Superfluous reserved words\n\n    reserve('class');\n    reserve('const');\n    reserve('enum');\n    reserve('export');\n    reserve('extends');\n    reserve('import');\n    reserve('super');\n\n// Harmony reserved words\n\n    reserve('implements');\n    reserve('interface');\n    reserve('let');\n    reserve('package');\n    reserve('private');\n    reserve('protected');\n    reserve('public');\n    reserve('static');\n    reserve('yield');\n\n\n// Parse JSON\n\n    function json_value() {\n\n        function json_object() {\n            var brace = next_token, object = Object.create(null);\n            advance('{');\n            if (next_token.id !== '}') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    if (next_token.id !== '(string)') {\n                        next_token.warn('expected_string_a');\n                    }\n                    if (object[next_token.string] === true) {\n                        next_token.warn('duplicate_a');\n                    } else if (next_token.string === '__proto__') {\n                        next_token.warn('dangling_a');\n                    } else {\n                        object[next_token.string] = true;\n                    }\n                    advance();\n                    advance(':');\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === '}') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance('}', brace);\n        }\n\n        function json_array() {\n            var bracket = next_token;\n            advance('[');\n            if (next_token.id !== ']') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === ']') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance(']', bracket);\n        }\n\n        switch (next_token.id) {\n        case '{':\n            json_object();\n            break;\n        case '[':\n            json_array();\n            break;\n        case 'true':\n        case 'false':\n        case 'null':\n        case '(number)':\n        case '(string)':\n            advance();\n            break;\n        case '-':\n            advance('-');\n            no_space_only();\n            advance('(number)');\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n    }\n\n\n// The actual JSLINT function itself.\n\n    itself = function JSLint(the_source, the_option) {\n\n        var i, predef, tree;\n        itself.errors = [];\n        itself.tree = '';\n        itself.properties = '';\n        begin = prev_token = token = next_token =\n            Object.create(syntax['(begin)']);\n        tokens = [];\n        predefined = Object.create(null);\n        add_to_predefined(standard);\n        property = Object.create(null);\n        if (the_option) {\n            option = Object.create(the_option);\n            predef = option.predef;\n            if (predef) {\n                if (Array.isArray(predef)) {\n                    for (i = 0; i < predef.length; i += 1) {\n                        predefined[predef[i]] = true;\n                    }\n                } else if (typeof predef === 'object') {\n                    add_to_predefined(predef);\n                }\n            }\n        } else {\n            option = Object.create(null);\n        }\n        option.indent = +option.indent || 4;\n        option.maxerr = +option.maxerr || 50;\n        global_scope = scope = Object.create(null);\n        global_funct = funct = {\n            scope: scope,\n            loopage: 0,\n            level: 0\n        };\n        functions = [funct];\n        block_var = [];\n\n        comments = [];\n        comments_off = false;\n        in_block = false;\n        indent = null;\n        json_mode = false;\n        lookahead = [];\n        node_js = false;\n        prereg = true;\n        strict_mode = false;\n        var_mode = null;\n        warnings = 0;\n        lex.init(the_source);\n\n        assume();\n\n        try {\n            advance();\n            if (next_token.id === '(number)') {\n                next_token.stop('unexpected_a');\n            } else {\n                switch (next_token.id) {\n                case '{':\n                case '[':\n                    comments_off = true;\n                    json_mode = true;\n                    json_value();\n                    break;\n                default:\n\n// If the first token is a semicolon, ignore it. This is sometimes used when\n// files are intended to be appended to files that may be sloppy. A sloppy\n// file may be depending on semicolon insertion on its last line.\n\n                    step_in(1);\n                    if (next_token.id === ';' && !node_js) {\n                        semicolon();\n                    }\n                    tree = statements();\n                    begin.first = tree;\n                    itself.tree = begin;\n                    if (tree.disrupt) {\n                        prev_token.warn('weird_program');\n                    }\n                }\n            }\n            indent = null;\n            advance('(end)');\n            itself.property = property;\n        } catch (e) {\n            if (e) {        // ~~\n                itself.errors.push({\n                    reason    : e.message,\n                    line      : e.line || next_token.line,\n                    character : e.character || next_token.from\n                }, null);\n            }\n        }\n        return itself.errors.length === 0;\n    };\n\n    function unique(array) {\n        array = array.sort();\n        var i, length = 0, previous, value;\n        for (i = 0; i < array.length; i += 1) {\n            value = array[i];\n            if (value !== previous) {\n                array[length] = value;\n                previous = value;\n                length += 1;\n            }\n        }\n        array.length = length;\n        return array;\n    }\n\n// Data summary.\n\n    itself.data = function () {\n        var data = {functions: []},\n            function_data,\n            i,\n            the_function,\n            the_scope;\n        data.errors = itself.errors;\n        data.json = json_mode;\n        data.global = unique(Object.keys(global_scope));\n\n        function selects(name) {\n            var kind = the_scope[name].kind;\n            switch (kind) {\n            case 'var':\n            case 'exception':\n            case 'label':\n                function_data[kind].push(name);\n                break;\n            }\n        }\n\n        for (i = 1; i < functions.length; i += 1) {\n            the_function = functions[i];\n            function_data = {\n                name: the_function.name,\n                line: the_function.line,\n                level: the_function.level,\n                parameter: the_function.parameter,\n                var: [],\n                exception: [],\n                closure: unique(the_function.closure),\n                outer: unique(the_function.outer),\n                global: unique(the_function.global),\n                label: []\n            };\n            the_scope = the_function.scope;\n            Object.keys(the_scope).forEach(selects);\n            function_data.var.sort();\n            function_data.exception.sort();\n            function_data.label.sort();\n            data.functions.push(function_data);\n        }\n        data.tokens = tokens;\n        return data;\n    };\n\n    itself.error_report = function (data) {\n        var evidence, i, output = [], warning;\n        if (data.errors.length) {\n            if (data.json) {\n                output.push('<cite>JSON: bad.</cite><br>');\n            }\n            for (i = 0; i < data.errors.length; i += 1) {\n                warning = data.errors[i];\n                if (warning) {\n                    evidence = warning.evidence || '';\n                    output.push('<cite>');\n                    if (isFinite(warning.line)) {\n                        output.push('<address>line ' +\n                            String(warning.line) +\n                            ' character ' + String(warning.character) +\n                            '</address>');\n                    }\n                    output.push(warning.reason.entityify() + '</cite>');\n                    if (evidence) {\n                        output.push('<pre>' + evidence.entityify() + '</pre>');\n                    }\n                }\n            }\n        }\n        return output.join('');\n    };\n\n\n    itself.report = function (data) {\n        var dl, i, j, names, output = [], the_function;\n\n        function detail(h, array) {\n            var comma_needed = false;\n            if (array.length) {\n                output.push(\"<dt>\" + h + \"</dt><dd>\");\n                array.forEach(function (item) {\n                    output.push((comma_needed ? ', ' : '') + item);\n                    comma_needed = true;\n                });\n                output.push(\"</dd>\");\n            }\n        }\n\n        output.push('<dl class=level0>');\n        if (data.global.length) {\n            detail('global', data.global);\n            dl = true;\n        } else if (data.json) {\n            if (!data.errors.length) {\n                output.push(\"<dt>JSON: good.</dt>\");\n            }\n        } else {\n            output.push(\"<dt><i>No new global variables introduced.</i></dt>\");\n        }\n        if (dl) {\n            output.push(\"</dl>\");\n        } else {\n            output[0] = '';\n        }\n\n        if (data.functions) {\n            for (i = 0; i < data.functions.length; i += 1) {\n                the_function = data.functions[i];\n                names = [];\n                if (the_function.params) {\n                    for (j = 0; j < the_function.params.length; j += 1) {\n                        names[j] = the_function.params[j].string;\n                    }\n                }\n                output.push('<dl class=level' + the_function.level +\n                    '><address>line ' + String(the_function.line) +\n                    '</address>' + the_function.name.entityify());\n                detail('parameter', the_function.parameter);\n                detail('variable', the_function.var);\n                detail('exception', the_function.exception);\n                detail('closure', the_function.closure);\n                detail('outer', the_function.outer);\n                detail('global', the_function.global);\n                detail('label', the_function.label);\n                output.push('</dl>');\n            }\n        }\n        return output.join('');\n    };\n\n    itself.properties_report = function (property) {\n        if (!property) {\n            return '';\n        }\n        var i,\n            key,\n            keys = Object.keys(property).sort(),\n            mem = '    ',\n            name,\n            not_first = false,\n            output = ['/*properties'];\n        for (i = 0; i < keys.length; i += 1) {\n            key = keys[i];\n            if (property[key] > 0) {\n                if (not_first) {\n                    mem += ', ';\n                }\n                name = ix.test(key)\n                    ? key\n                    : '\\'' + key.replace(nx, sanitize) + '\\'';\n                if (mem.length + name.length >= 80) {\n                    output.push(mem);\n                    mem = '    ';\n                }\n                mem += name;\n                not_first = true;\n            }\n        }\n        output.push(mem, '*/\\n');\n        return output.join('\\n');\n    };\n\n    itself.color = function (data) {\n        var from,\n            i = 1,\n            level,\n            line,\n            result = [],\n            thru,\n            data_token = data.tokens[0];\n        while (data_token && data_token.id !== '(end)') {\n            from = data_token.from;\n            line = data_token.line;\n            thru = data_token.thru;\n            level = data_token.function.level;\n            do {\n                thru = data_token.thru;\n                data_token = data.tokens[i];\n                i += 1;\n            } while (data_token && data_token.line === line &&\n                    data_token.from - thru < 5 &&\n                    level === data_token.function.level);\n            result.push({\n                line: line,\n                level: level,\n                from: from,\n                thru: thru\n            });\n        }\n        return result;\n    };\n\n    itself.jslint = itself;\n\n    itself.edition = '2013-08-13';\n\n    return itself;\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jslint-2013-08-26.js":"// jslint.js\n// 2013-08-26\n\n// Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// The Software shall be used for Good, not Evil.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// WARNING: JSLint will hurt your feelings.\n\n// JSLINT is a global function. It takes two parameters.\n\n//     var myResult = JSLINT(source, option);\n\n// The first parameter is either a string or an array of strings. If it is a\n// string, it will be split on '\\n' or '\\r'. If it is an array of strings, it\n// is assumed that each string represents one line. The source can be a\n// JavaScript text or a JSON text.\n\n// The second parameter is an optional object of options that control the\n// operation of JSLINT. Most of the options are booleans: They are all\n// optional and have a default value of false. One of the options, predef,\n// can be an array of names, which will be used to declare global variables,\n// or an object whose keys are used as global names, with a boolean value\n// that determines if they are assignable.\n\n// If it checks out, JSLINT returns true. Otherwise, it returns false.\n\n// If false, you can inspect JSLINT.errors to find out the problems.\n// JSLINT.errors is an array of objects containing these properties:\n\n//  {\n//      line      : The line (relative to 0) at which the lint was found\n//      character : The character (relative to 0) at which the lint was found\n//      reason    : The problem\n//      evidence  : The text line in which the problem occurred\n//      raw       : The raw message before the details were inserted\n//      a         : The first detail\n//      b         : The second detail\n//      c         : The third detail\n//      d         : The fourth detail\n//  }\n\n// If a stopping error was found, a null will be the last element of the\n// JSLINT.errors array. A stopping error means that JSLint was not confident\n// enough to continue. It does not necessarily mean that the error was\n// especially heinous.\n\n// You can request a data structure that contains JSLint's results.\n\n//     var myData = JSLINT.data();\n\n// It returns a structure with this form:\n\n//     {\n//         errors: [\n//             {\n//                 line: NUMBER,\n//                 character: NUMBER,\n//                 reason: STRING,\n//                 evidence: STRING\n//             }\n//         ],\n//         functions: [\n//             {\n//                 name: STRING,\n//                 line: NUMBER,\n//                 level: NUMBER,\n//                 parameter: [\n//                     STRING\n//                 ],\n//                 var: [\n//                     STRING\n//                 ],\n//                 exception: [\n//                     STRING\n//                 ],\n//                 closure: [\n//                     STRING\n//                 ],\n//                 outer: [\n//                     STRING\n//                 ],\n//                 global: [\n//                     STRING\n//                 ],\n//                 label: [\n//                     STRING\n//                 ]\n//             }\n//         ],\n//         global: [\n//             STRING\n//         ],\n//         member: {\n//             STRING: NUMBER\n//         },\n//         json: BOOLEAN\n//     }\n\n// You can request a Function Report, which shows all of the functions\n// and the parameters and vars that they use. This can be used to find\n// implied global variables and other problems. The report is in HTML and\n// can be inserted into an HTML <body>. It should be given the result of the\n// JSLINT.data function.\n\n//     var myReport = JSLINT.report(data);\n\n// You can request an HTML error report.\n\n//     var myErrorReport = JSLINT.error_report(data);\n\n// You can obtain an object containing all of the properties found in the\n// file. JSLINT.property contains an object containing a key for each\n// property used in the program, the value being the number of times that\n// property name was used in the file.\n\n// You can request a properties report, which produces a list of the program's\n// properties in the form of a /*properties*/ declaration.\n\n//      var myPropertyReport = JSLINT.properties_report(JSLINT.property);\n\n// You can obtain the parse tree that JSLint constructed while parsing. The\n// latest tree is kept in JSLINT.tree. A nice stringification can be produced\n// with\n\n//     JSON.stringify(JSLINT.tree, [\n//         'string',  'arity', 'name',  'first',\n//         'second', 'third', 'block', 'else'\n//     ], 4));\n\n// You can request a context coloring table. It contains information that can be\n// applied to the file that was analyzed. Context coloring colors functions\n// based on their nesting level, and variables on the color of the functions\n// in which they are defined.\n\n//      var myColorization = JSLINT.color(data);\n\n// It returns an array containing objects of this form:\n\n//      {\n//          from: COLUMN,\n//          thru: COLUMN,\n//          line: ROW,\n//          level: 0 or higher\n//      }\n\n// JSLint provides three inline directives. They look like slashstar comments,\n// and allow for setting options, declaring global variables, and establishing a\n// set of allowed property names.\n\n// These directives respect function scope.\n\n// The jslint directive is a special comment that can set one or more options.\n// For example:\n\n/*jslint\n    es5: true, evil: true, nomen: true, regexp: true, todo: true\n*/\n\n// The current option set is\n\n//     ass        true, if assignment expressions should be allowed\n//     bitwise    true, if bitwise operators should be allowed\n//     browser    true, if the standard browser globals should be predefined\n//     closure    true, if Google Closure idioms should be tolerated\n//     continue   true, if the continuation statement should be tolerated\n//     debug      true, if debugger statements should be allowed\n//     devel      true, if logging should be allowed (console, alert, etc.)\n//     eqeq       true, if == should be allowed\n//     es5        true, if ES5 syntax should be allowed\n//     evil       true, if eval should be allowed\n//     forin      true, if for in statements need not filter\n//     indent     the indentation factor\n//     maxerr     the maximum number of errors to allow\n//     maxlen     the maximum length of a source line\n//     newcap     true, if constructor names capitalization is ignored\n//     node       true, if Node.js globals should be predefined\n//     nomen      true, if names may have dangling _\n//     passfail   true, if the scan should stop on first error\n//     plusplus   true, if increment/decrement should be allowed\n//     properties true, if all property names must be declared with /*properties*/\n//     regexp     true, if the . should be allowed in regexp literals\n//     rhino      true, if the Rhino environment globals should be predefined\n//     unparam    true, if unused parameters should be tolerated\n//     sloppy     true, if the 'use strict'; pragma is optional\n//     stupid     true, if really stupid practices are tolerated\n//     sub        true, if all forms of subscript notation are tolerated\n//     todo       true, if TODO comments are tolerated\n//     vars       true, if multiple var statements per function should be allowed\n//     white      true, if sloppy whitespace is tolerated\n\n// The properties directive declares an exclusive list of property names.\n// Any properties named in the program that are not in the list will\n// produce a warning.\n\n// For example:\n\n/*properties\n    '\\b', '\\t', '\\n', '\\f', '\\r', '!', '!=', '!==', '\"', '%', '\\'', '(begin)',\n    '(error)', '*', '+', '-', '/', '<', '<=', '==', '===', '>', '>=', '\\\\', a,\n    a_label, a_scope, already_defined, and, arguments, arity, ass, assign,\n    assignment_expression, assignment_function_expression, at, avoid_a, b,\n    bad_assignment, bad_constructor, bad_in_a, bad_invocation, bad_new,\n    bad_number, bad_operand, bad_wrap, bitwise, block, browser, c, call, charAt,\n    charCodeAt, character, closure, code, color, combine_var, comments,\n    conditional_assignment, confusing_a, confusing_regexp, constructor_name_a,\n    continue, control_a, couch, create, d, dangling_a, data, dead, debug,\n    deleted, devel, disrupt, duplicate_a, edge, edition, else, empty_block,\n    empty_case, empty_class, entityify, eqeq, error_report, errors, es5,\n    evidence, evil, exception, exec, expected_a_at_b_c, expected_a_b,\n    expected_a_b_from_c_d, expected_id_a, expected_identifier_a,\n    expected_identifier_a_reserved, expected_number_a, expected_operator_a,\n    expected_positive_a, expected_small_a, expected_space_a_b,\n    expected_string_a, f, first, flag, floor, forEach, for_if, forin, from,\n    fromCharCode, fud, function, function_block, function_eval, function_loop,\n    function_statement, function_strict, functions, global, hasOwnProperty, id,\n    identifier, identifier_function, immed, implied_evil, indent, indexOf,\n    infix_in, init, insecure_a, isAlpha, isArray, isDigit, isNaN, join, jslint,\n    json, keys, kind, label, labeled, lbp, leading_decimal_a, led, left, length,\n    level, line, loopage, master, match, maxerr, maxlen, message, missing_a,\n    missing_a_after_b, missing_property, missing_space_a_b, missing_use_strict,\n    mode, move_invocation, move_var, n, name, name_function, nested_comment,\n    newcap, node, nomen, not, not_a_constructor, not_a_defined, not_a_function,\n    not_a_label, not_a_scope, not_greater, nud, number, octal_a, open, outer,\n    parameter, parameter_a_get_b, parameter_arguments_a, parameter_set_a,\n    params, paren, passfail, plusplus, postscript, predef, properties,\n    properties_report, property, prototype, push, quote, r, radix, raw,\n    read_only, reason, redefinition_a_b, regexp, relation, replace, report,\n    reserved, reserved_a, rhino, right, scanned_a_b, scope, search, second,\n    shift, slash_equal, slice, sloppy, sort, split, statement, statement_block,\n    stop, stopping, strange_loop, strict, string, stupid, sub, subscript,\n    substr, supplant, sync_a, t, tag_a_in_b, test, third, thru, toString, todo,\n    todo_comment, token, tokens, too_long, too_many, trailing_decimal_a, tree,\n    unclosed, unclosed_comment, unclosed_regexp, unescaped_a, unexpected_a,\n    unexpected_char_a, unexpected_comment, unexpected_label_a,\n    unexpected_property_a, unexpected_space_a_b, unexpected_typeof_a,\n    uninitialized_a, unnecessary_else, unnecessary_initialize, unnecessary_use,\n    unparam, unreachable_a_b, unsafe, unused_a, url, use_array, use_braces,\n    use_object, use_or, use_param, use_spaces, used, used_before_a, var,\n    var_a_not, var_loop, vars, varstatement, warn, warning, was,\n    weird_assignment, weird_condition, weird_new, weird_program, weird_relation,\n    weird_ternary, white, wrap, wrap_immediate, wrap_regexp, write_is_wrong,\n    writeable\n*/\n\n// The global directive is used to declare global variables that can\n// be accessed by the program. If a declaration is true, then the variable\n// is writeable. Otherwise, it is read-only.\n\n// We build the application inside a function so that we produce only a single\n// global variable. That function will be invoked immediately, and its return\n// value is the JSLINT function itself. That function is also an object that\n// can contain data and other functions.\n\nvar JSLINT = (function () {\n    'use strict';\n\n    function array_to_object(array, value) {\n\n// Make an object from an array of keys and a common value.\n\n        var i, length = array.length, object = Object.create(null);\n        for (i = 0; i < length; i += 1) {\n            object[array[i]] = value;\n        }\n        return object;\n    }\n\n\n    var allowed_option = {\n            ass       : true,\n            bitwise   : true,\n            browser   : true,\n            closure   : true,\n            continue  : true,\n            couch     : true,\n            debug     : true,\n            devel     : true,\n            eqeq      : true,\n            es5       : true,\n            evil      : true,\n            forin     : true,\n            indent    :   10,\n            maxerr    : 1000,\n            maxlen    :  256,\n            newcap    : true,\n            node      : true,\n            nomen     : true,\n            passfail  : true,\n            plusplus  : true,\n            properties: true,\n            regexp    : true,\n            rhino     : true,\n            unparam   : true,\n            sloppy    : true,\n            stupid    : true,\n            sub       : true,\n            todo      : true,\n            vars      : true,\n            white     : true\n        },\n        anonname,       // The guessed name for anonymous functions.\n\n// These are operators that should not be used with the ! operator.\n\n        bang = {\n            '<'  : true,\n            '<=' : true,\n            '==' : true,\n            '===': true,\n            '!==': true,\n            '!=' : true,\n            '>'  : true,\n            '>=' : true,\n            '+'  : true,\n            '-'  : true,\n            '*'  : true,\n            '/'  : true,\n            '%'  : true\n        },\n        begin,          // The root token\n        block_var,     // vars defined in the current block\n\n// browser contains a set of global names that are commonly provided by a\n// web browser environment.\n\n        browser = array_to_object([\n            'clearInterval', 'clearTimeout', 'document', 'event', 'FormData',\n            'frames', 'history', 'Image', 'localStorage', 'location', 'name',\n            'navigator', 'Option', 'parent', 'screen', 'sessionStorage',\n            'setInterval', 'setTimeout', 'Storage', 'window', 'XMLHttpRequest'\n        ], false),\n\n// bundle contains the text messages.\n\n        bundle = {\n            a_label: \"'{a}' is a statement label.\",\n            a_scope: \"'{a}' used out of scope.\",\n            already_defined: \"'{a}' is already defined.\",\n            and: \"The '&&' subexpression should be wrapped in parens.\",\n            assignment_expression: \"Unexpected assignment expression.\",\n            assignment_function_expression: \"Expected an assignment or \" +\n                \"function call and instead saw an expression.\",\n            avoid_a: \"Avoid '{a}'.\",\n            bad_assignment: \"Bad assignment.\",\n            bad_constructor: \"Bad constructor.\",\n            bad_in_a: \"Bad for in variable '{a}'.\",\n            bad_invocation: \"Bad invocation.\",\n            bad_new: \"Do not use 'new' for side effects.\",\n            bad_number: \"Bad number '{a}'.\",\n            bad_operand: \"Bad operand.\",\n            bad_wrap: \"Do not wrap function literals in parens unless they \" +\n                \"are to be immediately invoked.\",\n            combine_var: \"Combine this with the previous 'var' statement.\",\n            conditional_assignment: \"Expected a conditional expression and \" +\n                \"instead saw an assignment.\",\n            confusing_a: \"Confusing use of '{a}'.\",\n            confusing_regexp: \"Confusing regular expression.\",\n            constructor_name_a: \"A constructor name '{a}' should start with \" +\n                \"an uppercase letter.\",\n            control_a: \"Unexpected control character '{a}'.\",\n            dangling_a: \"Unexpected dangling '_' in '{a}'.\",\n            deleted: \"Only properties should be deleted.\",\n            duplicate_a: \"Duplicate '{a}'.\",\n            empty_block: \"Empty block.\",\n            empty_case: \"Empty case.\",\n            empty_class: \"Empty class.\",\n            es5: \"This is an ES5 feature.\",\n            evil: \"eval is evil.\",\n            expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n            expected_a_b_from_c_d: \"Expected '{a}' to match '{b}' from line \" +\n                \"{c} and instead saw '{d}'.\",\n            expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n            expected_id_a: \"Expected an id, and instead saw #{a}.\",\n            expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n            expected_identifier_a_reserved: \"Expected an identifier and \" +\n                \"instead saw '{a}' (a reserved word).\",\n            expected_number_a: \"Expected a number and instead saw '{a}'.\",\n            expected_operator_a: \"Expected an operator and instead saw '{a}'.\",\n            expected_positive_a: \"Expected a positive number and instead saw '{a}'\",\n            expected_small_a: \"Expected a small positive integer and instead saw '{a}'\",\n            expected_space_a_b: \"Expected exactly one space between '{a}' and '{b}'.\",\n            expected_string_a: \"Expected a string and instead saw '{a}'.\",\n            for_if: \"The body of a for in should be wrapped in an if \" +\n                \"statement to filter unwanted properties from the prototype.\",\n            function_block: \"Function statements should not be placed in blocks.\" +\n                \"Use a function expression or move the statement to the top of \" +\n                \"the outer function.\",\n            function_eval: \"The Function constructor is eval.\",\n            function_loop: \"Don't make functions within a loop.\",\n            function_statement: \"Function statements are not invocable. \" +\n                \"Wrap the whole function invocation in parens.\",\n            function_strict: \"Use the function form of 'use strict'.\",\n            identifier_function: \"Expected an identifier in an assignment \" +\n                \"and instead saw a function invocation.\",\n            implied_evil: \"Implied eval is evil. Pass a function instead of a string.\",\n            infix_in: \"Unexpected 'in'. Compare with undefined, or use the \" +\n                \"hasOwnProperty method instead.\",\n            insecure_a: \"Insecure '{a}'.\",\n            isNaN: \"Use the isNaN function to compare with NaN.\",\n            leading_decimal_a: \"A leading decimal point can be confused with a dot: '.{a}'.\",\n            missing_a: \"Missing '{a}'.\",\n            missing_a_after_b: \"Missing '{a}' after '{b}'.\",\n            missing_property: \"Missing property name.\",\n            missing_space_a_b: \"Missing space between '{a}' and '{b}'.\",\n            missing_use_strict: \"Missing 'use strict' statement.\",\n            move_invocation: \"Move the invocation into the parens that \" +\n                \"contain the function.\",\n            move_var: \"Move 'var' declarations to the top of the function.\",\n            name_function: \"Missing name in function statement.\",\n            nested_comment: \"Nested comment.\",\n            not: \"Nested not.\",\n            not_a_constructor: \"Do not use {a} as a constructor.\",\n            not_a_defined: \"'{a}' has not been fully defined yet.\",\n            not_a_function: \"'{a}' is not a function.\",\n            not_a_label: \"'{a}' is not a label.\",\n            not_a_scope: \"'{a}' is out of scope.\",\n            not_greater: \"'{a}' should not be greater than '{b}'.\",\n            octal_a: \"Don't use octal: '{a}'. Use '\\\\u....' instead.\",\n            parameter_arguments_a: \"Do not mutate parameter '{a}' when using 'arguments'.\",\n            parameter_a_get_b: \"Unexpected parameter '{a}' in get {b} function.\",\n            parameter_set_a: \"Expected parameter (value) in set {a} function.\",\n            radix: \"Missing radix parameter.\",\n            read_only: \"Read only.\",\n            redefinition_a_b: \"Redefinition of '{a}' from line {b}.\",\n            reserved_a: \"Reserved name '{a}'.\",\n            scanned_a_b: \"{a} ({b}% scanned).\",\n            slash_equal: \"A regular expression literal can be confused with '/='.\",\n            statement_block: \"Expected to see a statement and instead saw a block.\",\n            stopping: \"Stopping.\",\n            strange_loop: \"Strange loop.\",\n            strict: \"Strict violation.\",\n            subscript: \"['{a}'] is better written in dot notation.\",\n            sync_a: \"Unexpected sync method: '{a}'.\",\n            tag_a_in_b: \"A '<{a}>' must be within '<{b}>'.\",\n            todo_comment: \"Unexpected TODO comment.\",\n            too_long: \"Line too long.\",\n            too_many: \"Too many errors.\",\n            trailing_decimal_a: \"A trailing decimal point can be confused \" +\n                \"with a dot: '.{a}'.\",\n            unclosed: \"Unclosed string.\",\n            unclosed_comment: \"Unclosed comment.\",\n            unclosed_regexp: \"Unclosed regular expression.\",\n            unescaped_a: \"Unescaped '{a}'.\",\n            unexpected_a: \"Unexpected '{a}'.\",\n            unexpected_char_a: \"Unexpected character '{a}'.\",\n            unexpected_comment: \"Unexpected comment.\",\n            unexpected_label_a: \"Unexpected label '{a}'.\",\n            unexpected_property_a: \"Unexpected /*property*/ '{a}'.\",\n            unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n            unexpected_typeof_a: \"Unexpected 'typeof'. \" +\n                \"Use '===' to compare directly with {a}.\",\n            uninitialized_a: \"Uninitialized '{a}'.\",\n            unnecessary_else: \"Unnecessary 'else' after disruption.\",\n            unnecessary_initialize: \"It is not necessary to initialize '{a}' \" +\n                \"to 'undefined'.\",\n            unnecessary_use: \"Unnecessary 'use strict'.\",\n            unreachable_a_b: \"Unreachable '{a}' after '{b}'.\",\n            unsafe: \"Unsafe character.\",\n            unused_a: \"Unused '{a}'.\",\n            url: \"JavaScript URL.\",\n            use_array: \"Use the array literal notation [].\",\n            use_braces: \"Spaces are hard to count. Use {{a}}.\",\n            use_object: \"Use the object literal notation {} or Object.create(null).\",\n            use_or: \"Use the || operator.\",\n            use_param: \"Use a named parameter.\",\n            use_spaces: \"Use spaces, not tabs.\",\n            used_before_a: \"'{a}' was used before it was defined.\",\n            var_a_not: \"Variable {a} was not declared correctly.\",\n            var_loop: \"Don't declare variables in a loop.\",\n            weird_assignment: \"Weird assignment.\",\n            weird_condition: \"Weird condition.\",\n            weird_new: \"Weird construction. Delete 'new'.\",\n            weird_program: \"Weird program.\",\n            weird_relation: \"Weird relation.\",\n            weird_ternary: \"Weird ternary.\",\n            wrap_immediate: \"Wrap an immediate function invocation in \" +\n                \"parentheses to assist the reader in understanding that the \" +\n                \"expression is the result of a function, and not the \" +\n                \"function itself.\",\n            wrap_regexp: \"Wrap the /regexp/ literal in parens to \" +\n                \"disambiguate the slash operator.\",\n            write_is_wrong: \"document.write can be a form of eval.\"\n        },\n        closure = array_to_object([\n            'goog'\n        ], false),\n        comments,\n        comments_off,\n        couch = array_to_object([\n            'emit', 'getRow', 'isArray', 'log', 'provides', 'registerType',\n            'require', 'send', 'start', 'sum', 'toJSON'\n        ], false),\n\n        descapes = {\n            'b': '\\b',\n            't': '\\t',\n            'n': '\\n',\n            'f': '\\f',\n            'r': '\\r',\n            '\"': '\"',\n            '/': '/',\n            '\\\\': '\\\\',\n            '!': '!'\n        },\n\n        devel = array_to_object([\n            'alert', 'confirm', 'console', 'Debug', 'opera', 'prompt', 'WSH'\n        ], false),\n        directive,\n        escapes = {\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\\'': '\\\\\\'',\n            '\"' : '\\\\\"',\n            '/' : '\\\\/',\n            '\\\\': '\\\\\\\\'\n        },\n\n        funct,          // The current function\n\n        functions,      // All of the functions\n        global_funct,   // The global body\n        global_scope,   // The global scope\n        in_block,       // Where function statements are not allowed\n        indent,\n        itself,         // JSLINT itself\n        json_mode,\n        lex,            // the tokenizer\n        lines,\n        lookahead,\n        node = array_to_object([\n            'Buffer', 'clearImmediate', 'clearInterval', 'clearTimeout',\n            'console', 'exports', 'global', 'module', 'process', 'querystring',\n            'require', 'setImmediate', 'setInterval', 'setTimeout',\n            '__dirname', '__filename'\n        ], false),\n        node_js,\n        numbery = array_to_object(['indexOf', 'lastIndexOf', 'search'], true),\n        next_token,\n        option,\n        predefined,     // Global variables defined by option\n        prereg,\n        prev_token,\n        property,\n        protosymbol,\n        regexp_flag = array_to_object(['g', 'i', 'm'], true),\n        return_this = function return_this() {\n            return this;\n        },\n        rhino = array_to_object([\n            'defineClass', 'deserialize', 'gc', 'help', 'load', 'loadClass',\n            'print', 'quit', 'readFile', 'readUrl', 'runCommand', 'seal',\n            'serialize', 'spawn', 'sync', 'toint32', 'version'\n        ], false),\n\n        scope,      // An object containing an object for each variable in scope\n        semicolon_coda = array_to_object([';', '\"', '\\'', ')'], true),\n\n// standard contains the global names that are provided by the\n// ECMAScript standard.\n\n        standard = array_to_object([\n            'Array', 'Boolean', 'Date', 'decodeURI', 'decodeURIComponent',\n            'encodeURI', 'encodeURIComponent', 'Error', 'eval', 'EvalError',\n            'Function', 'isFinite', 'isNaN', 'JSON', 'Math', 'Number',\n            'Object', 'parseInt', 'parseFloat', 'RangeError', 'ReferenceError',\n            'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError'\n        ], false),\n\n        strict_mode,\n        syntax = Object.create(null),\n        token,\n        tokens,\n        var_mode,\n        warnings,\n\n// Regular expressions. Some of these are stupidly long.\n\n// carriage return, carriage return linefeed, or linefeed\n        crlfx = /\\r\\n?|\\n/,\n// unsafe characters that are silently deleted by one or more browsers\n        cx = /[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n// identifier\n        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,\n// javascript url\n        jx = /^(?:javascript|jscript|ecmascript|vbscript)\\s*:/i,\n// star slash\n        lx = /\\*\\/|\\/\\*/,\n// characters in strings that need escapement\n        nx = /[\\u0000-\\u001f'\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n// sync\n        syx = /Sync$/,\n// comment todo\n        tox = /^\\W*to\\s*do(?:\\W|$)/i,\n// token\n        tx = /^\\s*([(){}\\[\\]\\?.,:;'\"~#@`]|={1,3}|\\/(\\*(jslint|properties|property|members?|globals?)?|=|\\/)?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|[\\^%]=?|&[&=]?|\\|[|=]?|>{1,3}=?|<(?:[\\/=!]|\\!(\\[|--)?|<=?)?|\\!(\\!|==?)?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+(?:[xX][0-9a-fA-F]+|\\.[0-9]*)?(?:[eE][+\\-]?[0-9]+)?)/;\n\n\n    if (typeof String.prototype.entityify !== 'function') {\n        String.prototype.entityify = function () {\n            return this\n                .replace(/&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;');\n        };\n    }\n\n    if (typeof String.prototype.isAlpha !== 'function') {\n        String.prototype.isAlpha = function () {\n            return (this >= 'a' && this <= 'z\\uffff') ||\n                (this >= 'A' && this <= 'Z\\uffff');\n        };\n    }\n\n    if (typeof String.prototype.isDigit !== 'function') {\n        String.prototype.isDigit = function () {\n            return (this >= '0' && this <= '9');\n        };\n    }\n\n    if (typeof String.prototype.supplant !== 'function') {\n        String.prototype.supplant = function (o) {\n            return this.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n                var replacement = o[b];\n                return typeof replacement === 'string' ||\n                    typeof replacement === 'number' ? replacement : a;\n            });\n        };\n    }\n\n\n    function sanitize(a) {\n\n//  Escapify a troublesome character.\n\n        return escapes[a] ||\n            '\\\\u' + ('0000' + a.charCodeAt().toString(16)).slice(-4);\n    }\n\n\n    function add_to_predefined(group) {\n        Object.keys(group).forEach(function (name) {\n            predefined[name] = group[name];\n        });\n    }\n\n\n    function assume() {\n        if (option.browser) {\n            add_to_predefined(browser);\n            option.browser = false;\n        }\n        if (option.closure) {\n            add_to_predefined(closure);\n        }\n        if (option.couch) {\n            add_to_predefined(couch);\n            option.couch = false;\n            option.es5 = true;\n        }\n        if (option.devel) {\n            add_to_predefined(devel);\n            option.devel = false;\n        }\n        if (option.node) {\n            add_to_predefined(node);\n            option.node = false;\n            option.es5 = true;\n            node_js = true;\n        }\n        if (option.rhino) {\n            add_to_predefined(rhino);\n            option.rhino = false;\n        }\n    }\n\n\n// Produce an error warning.\n\n    function artifact(tok) {\n        if (!tok) {\n            tok = next_token;\n        }\n        return tok.id === '(number)' ? tok.number : tok.string;\n    }\n\n    function quit(message, line, character) {\n        throw {\n            name: 'JSLintError',\n            line: line,\n            character: character,\n            message: bundle.scanned_a_b.supplant({\n                a: bundle[message] || message,\n                b: Math.floor((line / lines.length) * 100)\n            })\n        };\n    }\n\n    function warn(code, line, character, a, b, c, d) {\n        var warning = {         // ~~\n            id: '(error)',\n            raw: bundle[code] || code,\n            code: code,\n            evidence: lines[line - 1] || '',\n            line: line,\n            character: character,\n            a: a || artifact(this),\n            b: b,\n            c: c,\n            d: d\n        };\n        warning.reason = warning.raw.supplant(warning);\n        itself.errors.push(warning);\n        if (option.passfail) {\n            quit('stopping', line, character);\n        }\n        warnings += 1;\n        if (warnings >= option.maxerr) {\n            quit('too_many', line, character);\n        }\n        return warning;\n    }\n\n    function stop(code, line, character, a, b, c, d) {\n        var warning = warn(code, line, character, a, b, c, d);\n        quit('stopping', warning.line, warning.character);\n    }\n\n    function expected_at(at) {\n        if (!option.white && next_token.from !== at) {\n            next_token.warn('expected_a_at_b_c', '', at, next_token.from);\n        }\n    }\n\n// lexical analysis and token construction\n\n    lex = (function lex() {\n        var character, c, from, length, line, pos, source_row;\n\n// Private lex methods\n\n        function next_line() {\n            var at;\n            character = 1;\n            source_row = lines[line];\n            line += 1;\n            if (source_row === undefined) {\n                return false;\n            }\n            at = source_row.search(/\\t/);\n            if (at >= 0) {\n                if (option.white) {\n                    source_row = source_row.replace(/\\t/g, ' ');\n                } else {\n                    warn('use_spaces', line, at + 1);\n                }\n            }\n            at = source_row.search(cx);\n            if (at >= 0) {\n                warn('unsafe', line, at);\n            }\n            if (option.maxlen && option.maxlen < source_row.length) {\n                warn('too_long', line, source_row.length);\n            }\n            return true;\n        }\n\n// Produce a token object.  The token inherits from a syntax symbol.\n\n        function it(type, value) {\n            var id, the_token;\n            if (type === '(string)') {\n                if (jx.test(value)) {\n                    warn('url', line, from);\n                }\n            }\n            the_token = Object.create(syntax[(\n                type === '(punctuator)' || (type === '(identifier)' &&\n                        Object.prototype.hasOwnProperty.call(syntax, value))\n                    ? value\n                    : type\n            )] || syntax['(error)']);\n            if (type === '(identifier)') {\n                the_token.identifier = true;\n                if (value === '__iterator__' || value === '__proto__') {\n                    stop('reserved_a', line, from, value);\n                } else if (!option.nomen &&\n                        (value.charAt(0) === '_' ||\n                        value.charAt(value.length - 1) === '_')) {\n                    warn('dangling_a', line, from, value);\n                }\n            }\n            if (type === '(number)') {\n                the_token.number = +value;\n            } else if (value !== undefined) {\n                the_token.string = String(value);\n            }\n            the_token.line = line;\n            the_token.from = from;\n            the_token.thru = character;\n            if (comments.length) {\n                the_token.comments = comments;\n                comments = [];\n            }\n            id = the_token.id;\n            prereg = id && (\n                ('(,=:[!&|?{};~+-*%^<>'.indexOf(id.charAt(id.length - 1)) >= 0) ||\n                id === 'return' || id === 'case'\n            );\n            return the_token;\n        }\n\n        function match(x) {\n            var exec = x.exec(source_row), first;\n            if (exec) {\n                length = exec[0].length;\n                first = exec[1];\n                c = first.charAt(0);\n                source_row = source_row.slice(length);\n                from = character + length - first.length;\n                character += length;\n                return first;\n            }\n            for (;;) {\n                if (!source_row) {\n                    if (!option.white) {\n                        warn('unexpected_char_a', line, character - 1, '(space)');\n                    }\n                    return;\n                }\n                c = source_row.charAt(0);\n                if (c !== ' ') {\n                    break;\n                }\n                source_row = source_row.slice(1);\n                character += 1;\n            }\n            stop('unexpected_char_a', line, character, c);\n\n        }\n\n        function string(x) {\n            var ch, at = 0, r = '', result;\n\n            function hex(n) {\n                var i = parseInt(source_row.substr(at + 1, n), 16);\n                at += n;\n                if (i >= 32 && i <= 126 &&\n                        i !== 34 && i !== 92 && i !== 39) {\n                    warn('unexpected_a', line, character, '\\\\');\n                }\n                character += n;\n                ch = String.fromCharCode(i);\n            }\n\n            if (json_mode && x !== '\"') {\n                warn('expected_a_b', line, character, '\"', x);\n            }\n\n            for (;;) {\n                while (at >= source_row.length) {\n                    at = 0;\n                    if (!next_line()) {\n                        stop('unclosed', line - 1, from);\n                    }\n                }\n                ch = source_row.charAt(at);\n                if (ch === x) {\n                    character += 1;\n                    source_row = source_row.slice(at + 1);\n                    result = it('(string)', r);\n                    result.quote = x;\n                    return result;\n                }\n                if (ch < ' ') {\n                    if (ch === '\\n' || ch === '\\r') {\n                        break;\n                    }\n                    warn('control_a', line, character + at,\n                        source_row.slice(0, at));\n                } else if (ch === '\\\\') {\n                    at += 1;\n                    character += 1;\n                    ch = source_row.charAt(at);\n                    switch (ch) {\n                    case '':\n                        if (!option.es5) {\n                            warn('es5', line, character);\n                        }\n                        next_line();\n                        at = -1;\n                        break;\n                    case '\\'':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\\\'');\n                        }\n                        break;\n                    case 'u':\n                        hex(4);\n                        break;\n                    case 'v':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\v');\n                        }\n                        ch = '\\v';\n                        break;\n                    case 'x':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\x');\n                        }\n                        hex(2);\n                        break;\n                    default:\n                        if (typeof descapes[ch] !== 'string') {\n                            warn(ch >= '0' && ch <= '7' ? 'octal_a' : 'unexpected_a',\n                                line, character, '\\\\' + ch);\n                        } else {\n                            ch = descapes[ch];\n                        }\n                    }\n                }\n                r += ch;\n                character += 1;\n                at += 1;\n            }\n        }\n\n        function number(snippet) {\n            var digit;\n            if (source_row.charAt(0).isAlpha()) {\n                warn('expected_space_a_b',\n                    line, character, c, source_row.charAt(0));\n            }\n            if (c === '0') {\n                digit = snippet.charAt(1);\n                if (digit.isDigit()) {\n                    if (token.id !== '.') {\n                        warn('unexpected_a', line, character, snippet);\n                    }\n                } else if (json_mode && (digit === 'x' || digit === 'X')) {\n                    warn('unexpected_a', line, character, '0x');\n                }\n            }\n            if (snippet.slice(snippet.length - 1) === '.') {\n                warn('trailing_decimal_a', line, character, snippet);\n            }\n            digit = +snippet;\n            if (!isFinite(digit)) {\n                warn('bad_number', line, character, snippet);\n            }\n            snippet = digit;\n            return it('(number)', snippet);\n        }\n\n        function comment(snippet, type) {\n            if (comments_off) {\n                warn('unexpected_comment', line, character);\n            } else if (!option.todo && tox.test(snippet)) {\n                warn('todo_comment', line, character);\n            }\n            comments.push({\n                id: type,\n                from: from,\n                thru: character,\n                line: line,\n                string: snippet\n            });\n        }\n\n        function regexp() {\n            var at = 0,\n                b,\n                bit,\n                depth = 0,\n                flag = '',\n                high,\n                letter,\n                low,\n                potential,\n                quote,\n                result;\n            for (;;) {\n                b = true;\n                c = source_row.charAt(at);\n                at += 1;\n                switch (c) {\n                case '':\n                    stop('unclosed_regexp', line, from);\n                    return;\n                case '/':\n                    if (depth > 0) {\n                        warn('unescaped_a', line, from + at, '/');\n                    }\n                    c = source_row.slice(0, at - 1);\n                    potential = Object.create(regexp_flag);\n                    for (;;) {\n                        letter = source_row.charAt(at);\n                        if (potential[letter] !== true) {\n                            break;\n                        }\n                        potential[letter] = false;\n                        at += 1;\n                        flag += letter;\n                    }\n                    if (source_row.charAt(at).isAlpha()) {\n                        stop('unexpected_a', line, from, source_row.charAt(at));\n                    }\n                    character += at;\n                    source_row = source_row.slice(at);\n                    quote = source_row.charAt(0);\n                    if (quote === '/' || quote === '*') {\n                        stop('confusing_regexp', line, from);\n                    }\n                    result = it('(regexp)', c);\n                    result.flag = flag;\n                    return result;\n                case '\\\\':\n                    c = source_row.charAt(at);\n                    if (c < ' ') {\n                        warn('control_a', line, from + at, String(c));\n                    } else if (c === '<') {\n                        warn('unexpected_a', line, from + at, '\\\\');\n                    }\n                    at += 1;\n                    break;\n                case '(':\n                    depth += 1;\n                    b = false;\n                    if (source_row.charAt(at) === '?') {\n                        at += 1;\n                        switch (source_row.charAt(at)) {\n                        case ':':\n                        case '=':\n                        case '!':\n                            at += 1;\n                            break;\n                        default:\n                            warn('expected_a_b', line, from + at,\n                                ':', source_row.charAt(at));\n                        }\n                    }\n                    break;\n                case '|':\n                    b = false;\n                    break;\n                case ')':\n                    if (depth === 0) {\n                        warn('unescaped_a', line, from + at, ')');\n                    } else {\n                        depth -= 1;\n                    }\n                    break;\n                case ' ':\n                    pos = 1;\n                    while (source_row.charAt(at) === ' ') {\n                        at += 1;\n                        pos += 1;\n                    }\n                    if (pos > 1) {\n                        warn('use_braces', line, from + at, pos);\n                    }\n                    break;\n                case '[':\n                    c = source_row.charAt(at);\n                    if (c === '^') {\n                        at += 1;\n                        if (!option.regexp) {\n                            warn('insecure_a', line, from + at, c);\n                        } else if (source_row.charAt(at) === ']') {\n                            stop('unescaped_a', line, from + at, '^');\n                        }\n                    }\n                    bit = false;\n                    if (c === ']') {\n                        warn('empty_class', line, from + at - 1);\n                        bit = true;\n                    }\nklass:              do {\n                        c = source_row.charAt(at);\n                        at += 1;\n                        switch (c) {\n                        case '[':\n                        case '^':\n                            warn('unescaped_a', line, from + at, c);\n                            bit = true;\n                            break;\n                        case '-':\n                            if (bit) {\n                                bit = false;\n                            } else {\n                                warn('unescaped_a', line, from + at, '-');\n                                bit = true;\n                            }\n                            break;\n                        case ']':\n                            if (!bit) {\n                                warn('unescaped_a', line, from + at - 1, '-');\n                            }\n                            break klass;\n                        case '\\\\':\n                            c = source_row.charAt(at);\n                            if (c < ' ') {\n                                warn('control_a', line, from + at, String(c));\n                            } else if (c === '<') {\n                                warn('unexpected_a', line, from + at, '\\\\');\n                            }\n                            at += 1;\n                            bit = true;\n                            break;\n                        case '/':\n                            warn('unescaped_a', line, from + at - 1, '/');\n                            bit = true;\n                            break;\n                        default:\n                            bit = true;\n                        }\n                    } while (c);\n                    break;\n                case '.':\n                    if (!option.regexp) {\n                        warn('insecure_a', line, from + at, c);\n                    }\n                    break;\n                case ']':\n                case '?':\n                case '{':\n                case '}':\n                case '+':\n                case '*':\n                    warn('unescaped_a', line, from + at, c);\n                    break;\n                }\n                if (b) {\n                    switch (source_row.charAt(at)) {\n                    case '?':\n                    case '+':\n                    case '*':\n                        at += 1;\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        break;\n                    case '{':\n                        at += 1;\n                        c = source_row.charAt(at);\n                        if (c < '0' || c > '9') {\n                            warn('expected_number_a', line,\n                                from + at, c);\n                        }\n                        at += 1;\n                        low = +c;\n                        for (;;) {\n                            c = source_row.charAt(at);\n                            if (c < '0' || c > '9') {\n                                break;\n                            }\n                            at += 1;\n                            low = +c + (low * 10);\n                        }\n                        high = low;\n                        if (c === ',') {\n                            at += 1;\n                            high = Infinity;\n                            c = source_row.charAt(at);\n                            if (c >= '0' && c <= '9') {\n                                at += 1;\n                                high = +c;\n                                for (;;) {\n                                    c = source_row.charAt(at);\n                                    if (c < '0' || c > '9') {\n                                        break;\n                                    }\n                                    at += 1;\n                                    high = +c + (high * 10);\n                                }\n                            }\n                        }\n                        if (source_row.charAt(at) !== '}') {\n                            warn('expected_a_b', line, from + at,\n                                '}', c);\n                        } else {\n                            at += 1;\n                        }\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        if (low > high) {\n                            warn('not_greater', line, from + at,\n                                low, high);\n                        }\n                        break;\n                    }\n                }\n            }\n            c = source_row.slice(0, at - 1);\n            character += at;\n            source_row = source_row.slice(at);\n            return it('(regexp)', c);\n        }\n\n// Public lex methods\n\n        return {\n            init: function (source) {\n                if (typeof source === 'string') {\n                    lines = source.split(crlfx);\n                } else {\n                    lines = source;\n                }\n                line = 0;\n                next_line();\n                from = 1;\n            },\n\n// token -- this is called by advance to get the next token.\n\n            token: function () {\n                var first, i, snippet;\n\n                for (;;) {\n                    while (!source_row) {\n                        if (!next_line()) {\n                            return it('(end)');\n                        }\n                    }\n                    snippet = match(tx);\n                    if (snippet) {\n\n//      identifier\n\n                        first = snippet.charAt(0);\n                        if (first.isAlpha() || first === '_' || first === '$') {\n                            return it('(identifier)', snippet);\n                        }\n\n//      number\n\n                        if (first.isDigit()) {\n                            return number(snippet);\n                        }\n                        switch (snippet) {\n\n//      string\n\n                        case '\"':\n                        case \"'\":\n                            return string(snippet);\n\n//      // comment\n\n                        case '//':\n                            comment(source_row, '//');\n                            source_row = '';\n                            break;\n\n//      /* comment\n\n                        case '/*':\n                            for (;;) {\n                                i = source_row.search(lx);\n                                if (i >= 0) {\n                                    break;\n                                }\n                                character = source_row.length;\n                                comment(source_row);\n                                from = 0;\n                                if (!next_line()) {\n                                    stop('unclosed_comment', line, character);\n                                }\n                            }\n                            comment(source_row.slice(0, i), '/*');\n                            character += i + 2;\n                            if (source_row.charAt(i) === '/') {\n                                stop('nested_comment', line, character);\n                            }\n                            source_row = source_row.slice(i + 2);\n                            break;\n\n                        case '':\n                            break;\n//      /\n                        case '/':\n                            if (token.id === '/=') {\n                                stop('slash_equal', line, from);\n                            }\n                            return prereg\n                                ? regexp()\n                                : it('(punctuator)', snippet);\n\n//      punctuator\n                        default:\n                            return it('(punctuator)', snippet);\n                        }\n                    }\n                }\n            }\n        };\n    }());\n\n    function define(kind, token) {\n\n// Define a name.\n\n        var name = token.string,\n            master = scope[name];       // The current definition of the name\n\n// vars are created with a deadzone, so that the expression that initializes\n// the var cannot access the var. Functions are not writeable.\n\n        token.dead = false;\n        token.init = false;\n        token.kind = kind;\n        token.master = master;\n        token.used = 0;\n        token.writeable = false;\n\n// Global variables are a little weird. They can be defined multiple times.\n// Some predefined global vars are (or should) not be writeable.\n\n        if (kind === 'var' && funct === global_funct) {\n            if (!master) {\n                if (predefined[name] === false) {\n                    token.writeable = false;\n                }\n                global_scope[name] = token;\n            }\n        } else {\n\n// It is an error if the name has already been defined in this scope, except\n// when reusing an exception variable name.\n\n            if (master) {\n                if (master.function === funct) {\n                    if (master.kind !== 'exception' || kind !== 'exception' ||\n                            !master.dead) {\n                        token.warn('already_defined', name);\n                    }\n                } else if (master.function !== global_funct) {\n                    if (kind === 'var') {\n                        token.warn('redefinition_a_b', name, master.line);\n                    }\n                }\n            }\n            scope[name] = token;\n            if (kind === 'var') {\n                block_var.push(name);\n            }\n        }\n    }\n\n    function peek(distance) {\n\n// Peek ahead to a future token. The distance is how far ahead to look. The\n// default is the next token.\n\n        var found, slot = 0;\n\n        distance = distance || 0;\n        while (slot <= distance) {\n            found = lookahead[slot];\n            if (!found) {\n                found = lookahead[slot] = lex.token();\n            }\n            slot += 1;\n        }\n        return found;\n    }\n\n\n    function advance(id, match) {\n\n// Produce the next token, also looking for programming errors.\n\n        if (indent) {\n\n// If indentation checking was requested, then inspect all of the line breakings.\n// The var statement is tricky because the names might be aligned or not. We\n// look at the first line break after the var to determine the programmer's\n// intention.\n\n            if (var_mode && next_token.line !== token.line) {\n                if ((var_mode !== indent || !next_token.edge) &&\n                        next_token.from === indent.at -\n                        (next_token.edge ? option.indent : 0)) {\n                    var dent = indent;\n                    for (;;) {\n                        dent.at -= option.indent;\n                        if (dent === var_mode) {\n                            break;\n                        }\n                        dent = dent.was;\n                    }\n                    dent.open = false;\n                }\n                var_mode = null;\n            }\n            if (next_token.id === '?' && indent.mode === ':' &&\n                    token.line !== next_token.line) {\n                indent.at -= option.indent;\n            }\n            if (indent.open) {\n\n// If the token is an edge.\n\n                if (next_token.edge) {\n                    if (next_token.edge === 'label') {\n                        expected_at(1);\n                    } else if (next_token.edge === 'case' || indent.mode === 'statement') {\n                        expected_at(indent.at - option.indent);\n                    } else if (indent.mode !== 'array' || next_token.line !== token.line) {\n                        expected_at(indent.at);\n                    }\n\n// If the token is not an edge, but is the first token on the line.\n\n                } else if (next_token.line !== token.line) {\n                    if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                    indent.wrap = true;\n                }\n            } else if (next_token.line !== token.line) {\n                if (next_token.edge) {\n                    expected_at(indent.at);\n                } else {\n                    indent.wrap = true;\n                    if (indent.mode === 'statement' || indent.mode === 'var') {\n                        expected_at(indent.at + option.indent);\n                    } else if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                }\n            }\n        }\n\n        switch (token.id) {\n        case '(number)':\n            if (next_token.id === '.') {\n                next_token.warn('trailing_decimal_a');\n            }\n            break;\n        case '-':\n            if (next_token.id === '-' || next_token.id === '--') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        case '+':\n            if (next_token.id === '+' || next_token.id === '++') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        }\n        if (token.id === '(string)' || token.identifier) {\n            anonname = token.string;\n        }\n\n        if (id && next_token.id !== id) {\n            if (match) {\n                next_token.warn('expected_a_b_from_c_d', id,\n                    match.id, match.line, artifact());\n            } else if (!next_token.identifier || next_token.string !== id) {\n                next_token.warn('expected_a_b', id, artifact());\n            }\n        }\n        prev_token = token;\n        token = next_token;\n        next_token = lookahead.shift() || lex.token();\n        next_token.function = funct;\n        tokens.push(next_token);\n    }\n\n\n    function do_globals() {\n        var name, writeable;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            writeable = false;\n            if (next_token.id === ':') {\n                advance(':');\n                switch (next_token.id) {\n                case 'true':\n                    writeable = predefined[name] !== false;\n                    advance('true');\n                    break;\n                case 'false':\n                    advance('false');\n                    break;\n                default:\n                    next_token.stop('unexpected_a');\n                }\n            }\n            predefined[name] = writeable;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    function do_jslint() {\n        var name, value;\n        while (next_token.id === '(string)' || next_token.identifier) {\n            name = next_token.string;\n            if (!allowed_option[name]) {\n                next_token.stop('unexpected_a');\n            }\n            advance();\n            if (next_token.id !== ':') {\n                next_token.stop('expected_a_b', ':', artifact());\n            }\n            advance(':');\n            if (typeof allowed_option[name] === 'number') {\n                value = next_token.number;\n                if (value > allowed_option[name] || value <= 0 ||\n                        Math.floor(value) !== value) {\n                    next_token.stop('expected_small_a');\n                }\n                option[name] = value;\n            } else {\n                if (next_token.id === 'true') {\n                    option[name] = true;\n                } else if (next_token.id === 'false') {\n                    option[name] = false;\n                } else {\n                    next_token.stop('unexpected_a');\n                }\n            }\n            advance();\n            if (next_token.id === ',') {\n                advance(',');\n            }\n        }\n        assume();\n    }\n\n\n    function do_properties() {\n        var name;\n        option.properties = true;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            if (next_token.id === ':') {\n                for (;;) {\n                    advance();\n                    if (next_token.id !== '(string)' && !next_token.identifier) {\n                        break;\n                    }\n                }\n            }\n            property[name] = 0;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    directive = function directive() {\n        var command = this.id,\n            old_comments_off = comments_off,\n            old_indent = indent;\n        comments_off = true;\n        indent = null;\n        if (next_token.line === token.line && next_token.from === token.thru) {\n            next_token.warn('missing_space_a_b', artifact(token), artifact());\n        }\n        if (lookahead.length > 0) {\n            this.warn('unexpected_a');\n        }\n        switch (command) {\n        case '/*properties':\n        case '/*property':\n        case '/*members':\n        case '/*member':\n            do_properties();\n            break;\n        case '/*jslint':\n            do_jslint();\n            break;\n        case '/*globals':\n        case '/*global':\n            do_globals();\n            break;\n        default:\n            this.stop('unexpected_a');\n        }\n        comments_off = old_comments_off;\n        advance('*/');\n        indent = old_indent;\n    };\n\n\n// Indentation intention\n\n    function edge(mode) {\n        next_token.edge = indent ? indent.open && (mode || 'edge') : '';\n    }\n\n\n    function step_in(mode) {\n        var open;\n        if (typeof mode === 'number') {\n            indent = {\n                at: +mode,\n                open: true,\n                was: indent\n            };\n        } else if (!indent) {\n            indent = {\n                at: 1,\n                mode: 'statement',\n                open: true\n            };\n        } else if (mode === 'statement') {\n            indent = {\n                at: indent.at,\n                open: true,\n                was: indent\n            };\n        } else {\n            open = mode === 'var' || next_token.line !== token.line;\n            indent = {\n                at: (open || mode === 'control'\n                    ? indent.at + option.indent\n                    : indent.at) + (indent.wrap ? option.indent : 0),\n                mode: mode,\n                open: open,\n                was: indent\n            };\n            if (mode === 'var' && open) {\n                var_mode = indent;\n            }\n        }\n    }\n\n    function step_out(id, symbol) {\n        if (id) {\n            if (indent && indent.open) {\n                indent.at -= option.indent;\n                edge();\n            }\n            advance(id, symbol);\n        }\n        if (indent) {\n            indent = indent.was;\n        }\n    }\n\n// Functions for conformance of whitespace.\n\n    function one_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && !option.white &&\n                (token.line !== right.line ||\n                token.thru + 1 !== right.from)) {\n            right.warn('expected_space_a_b', artifact(token), artifact(right));\n        }\n    }\n\n    function one_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru + 1 !== right.from))) {\n            right.warn('expected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if ((!option.white) &&\n                left.thru !== right.from && left.line === right.line) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru !== right.from))) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function spaces(left, right) {\n        if (!option.white) {\n            left = left || token;\n            right = right || next_token;\n            if (left.thru === right.from && left.line === right.line) {\n                right.warn('missing_space_a_b', artifact(left), artifact(right));\n            }\n        }\n    }\n\n    function comma() {\n        if (next_token.id !== ',') {\n            warn('expected_a_b', token.line, token.thru, ',', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(',');\n            spaces();\n        }\n    }\n\n\n    function semicolon() {\n        if (next_token.id !== ';') {\n            warn('expected_a_b', token.line, token.thru, ';', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(';');\n            if (semicolon_coda[next_token.id] !== true) {\n                spaces();\n            }\n        }\n    }\n\n    function use_strict() {\n        if (next_token.string === 'use strict') {\n            if (strict_mode) {\n                next_token.warn('unnecessary_use');\n            }\n            edge();\n            advance();\n            semicolon();\n            strict_mode = true;\n            return true;\n        }\n        return false;\n    }\n\n\n    function are_similar(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (Array.isArray(a)) {\n            if (Array.isArray(b) && a.length === b.length) {\n                var i;\n                for (i = 0; i < a.length; i += 1) {\n                    if (!are_similar(a[i], b[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n        if (Array.isArray(b)) {\n            return false;\n        }\n        if (a.id === '(number)' && b.id === '(number)') {\n            return a.number === b.number;\n        }\n        if (a.arity === b.arity && a.string === b.string) {\n            switch (a.arity) {\n            case undefined:\n                return a.string === b.string;\n            case 'prefix':\n            case 'suffix':\n                return a.id === b.id && are_similar(a.first, b.first) &&\n                    a.id !== '{' && a.id !== '[';\n            case 'infix':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second);\n            case 'ternary':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second) &&\n                    are_similar(a.third, b.third);\n            case 'function':\n            case 'regexp':\n                return false;\n            default:\n                return true;\n            }\n        }\n        if (a.id === '.' && b.id === '[' && b.arity === 'infix') {\n            return a.second.string === b.second.string && b.second.id === '(string)';\n        }\n        if (a.id === '[' && a.arity === 'infix' && b.id === '.') {\n            return a.second.string === b.second.string && a.second.id === '(string)';\n        }\n        return false;\n    }\n\n\n// This is the heart of JSLINT, the Pratt parser. In addition to parsing, it\n// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is\n// like .nud except that it is only used on the first token of a statement.\n// Having .fud makes it much easier to define statement-oriented languages like\n// JavaScript. I retained Pratt's nomenclature.\n\n// .nud     Null denotation\n// .fud     First null denotation\n// .led     Left denotation\n//  lbp     Left binding power\n//  rbp     Right binding power\n\n// They are elements of the parsing method called Top Down Operator Precedence.\n\n    function expression(rbp, initial) {\n\n// rbp is the right binding power.\n// initial indicates that this is the first expression of a statement.\n\n        var left;\n        if (next_token.id === '(end)') {\n            token.stop('unexpected_a', next_token.id);\n        }\n        advance();\n        if (initial) {\n            anonname = 'anonymous';\n        }\n        if (initial === true && token.fud) {\n            left = token.fud();\n        } else {\n            if (token.nud) {\n                left = token.nud();\n            } else {\n                if (next_token.id === '(number)' && token.id === '.') {\n                    token.warn('leading_decimal_a', artifact());\n                    advance();\n                    return token;\n                }\n                token.stop('expected_identifier_a', artifact(token));\n            }\n            while (rbp < next_token.lbp) {\n                advance();\n                left = token.led(left);\n            }\n        }\n        if (left && left.assign && !initial) {\n            if (!option.ass) {\n                left.warn('assignment_expression');\n            }\n            if (left.id !== '=' && left.first.master) {\n                left.first.master.used = true;\n            }\n        }\n        return left;\n    }\n\n    protosymbol = {\n        nud: function () {\n            this.stop('unexpected_a');\n        },\n        led: function () {\n            this.stop('expected_operator_a');\n        },\n        warn: function (code, a, b, c, d) {\n            if (!this.warning) {\n                this.warning = warn(code, this.line || 0, this.from || 0,\n                    a || artifact(this), b, c, d);\n            }\n        },\n        stop: function (code, a, b, c, d) {\n            this.warning = undefined;\n            this.warn(code, a, b, c, d);\n            return quit('stopping', this.line, this.character);\n        },\n        lbp: 0\n    };\n\n// Functional constructors for making the symbols that will be inherited by\n// tokens.\n\n    function symbol(s, bp) {\n        var x = syntax[s];\n        if (!x) {\n            x = Object.create(protosymbol);\n            x.id = x.string = s;\n            x.lbp = bp || 0;\n            syntax[s] = x;\n        }\n        return x;\n    }\n\n    function postscript(x) {\n        x.postscript = true;\n        return x;\n    }\n\n    function ultimate(s) {\n        var x = symbol(s, 0);\n        x.from = 1;\n        x.thru = 1;\n        x.line = 0;\n        x.edge = 'edge';\n        x.string = s;\n        return postscript(x);\n    }\n\n    function reserve_name(x) {\n        var c = x.id.charAt(0);\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            x.identifier = x.reserved = true;\n        }\n        return x;\n    }\n\n    function stmt(s, f) {\n        var x = symbol(s);\n        x.fud = f;\n        return reserve_name(x);\n    }\n\n    function disrupt_stmt(s, f) {\n        var x = stmt(s, f);\n        x.disrupt = true;\n    }\n\n    function labeled_stmt(s, f) {\n        var x = stmt(s, f);\n        x.labeled = true;\n    }\n\n    function prefix(s, f) {\n        var x = symbol(s, 150);\n        reserve_name(x);\n        x.nud = function () {\n            var that = this;\n            that.arity = 'prefix';\n            if (typeof f === 'function') {\n                that = f(that);\n                if (that.arity !== 'prefix') {\n                    return that;\n                }\n            } else {\n                if (s === 'typeof') {\n                    one_space();\n                } else {\n                    no_space_only();\n                }\n                that.first = expression(150);\n            }\n            switch (that.id) {\n            case '++':\n            case '--':\n                if (!option.plusplus) {\n                    that.warn('unexpected_a');\n                } else if ((!that.first.identifier || that.first.reserved) &&\n                        that.first.id !== '.' && that.first.id !== '[') {\n                    that.warn('bad_operand');\n                }\n                break;\n            default:\n                if (that.first.arity === 'prefix' ||\n                        that.first.arity === 'function') {\n                    that.warn('unexpected_a');\n                }\n            }\n            return that;\n        };\n        return x;\n    }\n\n\n    function type(s, t, nud) {\n        var x = symbol(s);\n        x.arity = t;\n        if (nud) {\n            x.nud = nud;\n        }\n        return x;\n    }\n\n\n    function reserve(s, f) {\n        var x = symbol(s);\n        x.identifier = x.reserved = true;\n        if (typeof f === 'function') {\n            x.nud = f;\n        }\n        return x;\n    }\n\n\n    function constant(name) {\n        var x = reserve(name);\n        x.string = name;\n        x.nud = return_this;\n        return x;\n    }\n\n\n    function reservevar(s, v) {\n        return reserve(s, function () {\n            if (typeof v === 'function') {\n                v(this);\n            }\n            return this;\n        });\n    }\n\n\n    function infix(s, p, f, w) {\n        var x = symbol(s, p);\n        reserve_name(x);\n        x.led = function (left) {\n            this.arity = 'infix';\n            if (!w) {\n                spaces(prev_token, token);\n                spaces();\n            }\n            if (!option.bitwise && this.bitwise) {\n                this.warn('unexpected_a');\n            }\n            if (typeof f === 'function') {\n                return f(left, this);\n            }\n            this.first = left;\n            this.second = expression(p);\n            return this;\n        };\n        return x;\n    }\n\n    function expected_relation(node, message) {\n        if (node.assign) {\n            node.warn(message || 'conditional_assignment');\n        }\n        return node;\n    }\n\n    function expected_condition(node, message) {\n        switch (node.id) {\n        case '[':\n        case '-':\n            if (node.arity !== 'infix') {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        case 'false':\n        case 'function':\n        case 'Infinity':\n        case 'NaN':\n        case 'null':\n        case 'true':\n        case 'undefined':\n        case 'void':\n        case '(number)':\n        case '(regexp)':\n        case '(string)':\n        case '{':\n        case '?':\n        case '~':\n            node.warn(message || 'weird_condition');\n            break;\n        case '(':\n            if (node.first.id === 'new' ||\n                    (node.first.string === 'Boolean') ||\n                    (node.first.id === '.' &&\n                        numbery[node.first.second.string] === true)) {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        }\n        return node;\n    }\n\n    function check_relation(node) {\n        switch (node.arity) {\n        case 'prefix':\n            switch (node.id) {\n            case '{':\n            case '[':\n                node.warn('unexpected_a');\n                break;\n            case '!':\n                node.warn('confusing_a');\n                break;\n            }\n            break;\n        case 'function':\n        case 'regexp':\n            node.warn('unexpected_a');\n            break;\n        default:\n            if (node.id  === 'NaN') {\n                node.warn('isNaN');\n            } else if (node.relation) {\n                node.warn('weird_relation');\n            }\n        }\n        return node;\n    }\n\n\n    function relation(s, eqeq) {\n        var x = infix(s, 100, function (left, that) {\n            check_relation(left);\n            if (eqeq && !option.eqeq) {\n                that.warn('expected_a_b', eqeq, that.id);\n            }\n            var right = expression(100);\n            if (are_similar(left, right) ||\n                    ((left.id === '(string)' || left.id === '(number)') &&\n                    (right.id === '(string)' || right.id === '(number)'))) {\n                that.warn('weird_relation');\n            } else if (left.id === 'typeof') {\n                if (right.id !== '(string)') {\n                    right.warn(\"expected_string_a\", artifact(right));\n                } else if (right.string === 'undefined' ||\n                        right.string === 'null') {\n                    left.warn(\"unexpected_typeof_a\", right.string);\n                }\n            } else if (right.id === 'typeof') {\n                if (left.id !== '(string)') {\n                    left.warn(\"expected_string_a\", artifact(left));\n                } else if (left.string === 'undefined' ||\n                        left.string === 'null') {\n                    right.warn(\"unexpected_typeof_a\", left.string);\n                }\n            }\n            that.first = left;\n            that.second = check_relation(right);\n            return that;\n        });\n        x.relation = true;\n        return x;\n    }\n\n    function lvalue(that, s) {\n        var master;\n        if (that.identifier) {\n            master = scope[that.string];\n            if (master) {\n                if (scope[that.string].writeable !== true) {\n                    that.warn('read_only');\n                }\n                master.used -= 1;\n                if (s === '=') {\n                    master.init = true;\n                }\n            }\n        } else if (that.id === '.' || that.id === '[') {\n            if (!that.first || that.first.string === 'arguments') {\n                that.warn('bad_assignment');\n            }\n        } else {\n            that.warn('bad_assignment');\n        }\n    }\n\n\n    function assignop(s, op) {\n        var x = infix(s, 20, function (left, that) {\n            var next;\n            that.first = left;\n            lvalue(left, s);\n            that.second = expression(20);\n            if (that.id === '=' && are_similar(that.first, that.second)) {\n                that.warn('weird_assignment');\n            }\n            next = that;\n            while (next_token.id === '=') {\n                lvalue(next.second, '=');\n                next_token.first = next.second;\n                next.second = next_token;\n                next = next_token;\n                advance('=');\n                next.second = expression(20);\n            }\n            return that;\n        });\n        x.assign = true;\n        if (op) {\n            if (syntax[op].bitwise) {\n                x.bitwise = true;\n            }\n        }\n        return x;\n    }\n\n\n    function bitwise(s, p) {\n        var x = infix(s, p, 'number');\n        x.bitwise = true;\n        return x;\n    }\n\n\n    function suffix(s) {\n        var x = symbol(s, 150);\n        x.led = function (left) {\n            no_space_only(prev_token, token);\n            if (!option.plusplus) {\n                this.warn('unexpected_a');\n            } else if ((!left.identifier || left.reserved) &&\n                    left.id !== '.' && left.id !== '[') {\n                this.warn('bad_operand');\n            }\n            this.first = left;\n            this.arity = 'suffix';\n            return this;\n        };\n        return x;\n    }\n\n\n    function optional_identifier(variable) {\n        if (next_token.identifier) {\n            advance();\n            if (token.reserved && (!option.es5 || variable)) {\n                token.warn('expected_identifier_a_reserved');\n            }\n            return token.string;\n        }\n    }\n\n\n    function identifier(variable) {\n        var i = optional_identifier(variable);\n        if (!i) {\n            next_token.stop(token.id === 'function' && next_token.id === '('\n                ? 'name_function'\n                : 'expected_identifier_a');\n        }\n        return i;\n    }\n\n\n    function statement() {\n\n        var label, preamble, the_statement;\n\n// We don't like the empty statement.\n\n        if (next_token.id === ';') {\n            next_token.warn('unexpected_a');\n            semicolon();\n            return;\n        }\n\n// Is this a labeled statement?\n\n        if (next_token.identifier && !next_token.reserved && peek().id === ':') {\n            edge('label');\n            label = next_token;\n            advance();\n            advance(':');\n            define('label', label);\n            if (next_token.labeled !== true || funct === global_funct) {\n                label.stop('unexpected_label_a');\n            } else if (jx.test(label.string + ':')) {\n                label.warn('url');\n            }\n            next_token.label = label;\n            label.init = true;\n        }\n\n// Parse the statement.\n\n        preamble = next_token;\n        if (token.id !== 'else') {\n            edge();\n        }\n        step_in('statement');\n        the_statement = expression(0, true);\n        if (the_statement) {\n\n// Look for the final semicolon.\n\n            if (the_statement.arity === 'statement') {\n                if (the_statement.id === 'switch' ||\n                        (the_statement.block && the_statement.id !== 'do')) {\n                    spaces();\n                } else {\n                    semicolon();\n                }\n            } else {\n\n// If this is an expression statement, determine if it is acceptable.\n// We do not like\n//      new Blah;\n// statements. If it is to be used at all, new should only be used to make\n// objects, not side effects. The expression statements we do like do\n// assignment or invocation or delete.\n\n                if (the_statement.id === '(') {\n                    if (the_statement.first.id === 'new') {\n                        next_token.warn('bad_new');\n                    }\n                } else if (the_statement.id === '++' ||\n                        the_statement.id === '--') {\n                    lvalue(the_statement.first);\n                } else if (!the_statement.assign &&\n                        the_statement.id !== 'delete') {\n                    if (!option.closure || !preamble.comments) {\n                        preamble.warn('assignment_function_expression');\n                    }\n                }\n                semicolon();\n            }\n        }\n        step_out();\n        if (label) {\n            label.dead = true;\n        }\n        return the_statement;\n    }\n\n\n    function statements() {\n        var array = [], disruptor, the_statement;\n\n// A disrupt statement may not be followed by any other statement.\n// If the last statement is disrupt, then the sequence is disrupt.\n\n        while (next_token.postscript !== true) {\n            if (next_token.id === ';') {\n                next_token.warn('unexpected_a');\n                semicolon();\n            } else {\n                if (next_token.string === 'use strict') {\n                    if ((!node_js) || funct !== global_funct || array.length > 0) {\n                        next_token.warn('function_strict');\n                    }\n                    use_strict();\n                }\n                if (disruptor) {\n                    next_token.warn('unreachable_a_b', next_token.string,\n                        disruptor.string);\n                    disruptor = null;\n                }\n                the_statement = statement();\n                if (the_statement) {\n                    array.push(the_statement);\n                    if (the_statement.disrupt) {\n                        disruptor = the_statement;\n                        array.disrupt = true;\n                    }\n                }\n            }\n        }\n        return array;\n    }\n\n\n    function block(kind) {\n\n// A block is a sequence of statements wrapped in braces.\n\n        var array,\n            curly = next_token,\n            old_block_var = block_var,\n            old_in_block = in_block,\n            old_strict_mode = strict_mode;\n\n        in_block = kind !== 'function' && kind !== 'try' && kind !== 'catch';\n        block_var = [];\n        if (curly.id === '{') {\n            spaces();\n            advance('{');\n            step_in();\n            if (kind === 'function' && !use_strict() && !old_strict_mode &&\n                    !option.sloppy && funct.level === 1) {\n                next_token.warn('missing_use_strict');\n            }\n            array = statements();\n            strict_mode = old_strict_mode;\n            step_out('}', curly);\n        } else if (in_block) {\n            curly.stop('expected_a_b', '{', artifact());\n        } else {\n            curly.warn('expected_a_b', '{', artifact());\n            array = [statement()];\n            array.disrupt = array[0].disrupt;\n        }\n        if (kind !== 'catch' && array.length === 0) {\n            curly.warn('empty_block');\n        }\n        block_var.forEach(function (name) {\n            scope[name].dead = true;\n        });\n        block_var = old_block_var;\n        in_block = old_in_block;\n        return array;\n    }\n\n\n    function tally_property(name) {\n        if (option.properties && typeof property[name] !== 'number') {\n            token.warn('unexpected_property_a', name);\n        }\n        if (property[name]) {\n            property[name] += 1;\n        } else {\n            property[name] = 1;\n        }\n    }\n\n\n// ECMAScript parser\n\n    (function () {\n        var x = symbol('(identifier)');\n        x.nud = function () {\n            var name = this.string,\n                master = scope[name],\n                writeable;\n\n// If the master is not in scope, then we may have an undeclared variable.\n// Check the predefined list. If it was predefined, create the global\n// variable.\n\n            if (!master) {\n                writeable = predefined[name];\n                if (typeof writeable === 'boolean') {\n                    global_scope[name] = master = {\n                        dead: false,\n                        function: global_funct,\n                        kind: 'var',\n                        string: name,\n                        writeable: writeable\n                    };\n\n// But if the variable is not in scope, and is not predefined, and if we are not\n// in the global scope, then we have an undefined variable error.\n\n                } else {\n                    token.warn('used_before_a');\n                }\n            } else {\n                this.master = master;\n            }\n\n// Annotate uses that cross scope boundaries.\n\n            if (master) {\n                if (master.kind === 'label') {\n                    this.warn('a_label');\n                } else {\n                    if (master.dead === true || master.dead === funct) {\n                        this.warn('a_scope');\n                    }\n                    master.used += 1;\n                    if (master.function !== funct) {\n                        if (master.function === global_funct) {\n                            funct.global.push(name);\n                        } else {\n                            master.function.closure.push(name);\n                            funct.outer.push(name);\n                        }\n                    }\n                }\n            }\n            return this;\n        };\n        x.identifier = true;\n    }());\n\n\n// Build the syntax table by declaring the syntactic elements.\n\n    type('(array)', 'array');\n    type('(function)', 'function');\n    type('(number)', 'number', return_this);\n    type('(object)', 'object');\n    type('(string)', 'string', return_this);\n    type('(boolean)', 'boolean', return_this);\n    type('(regexp)', 'regexp', return_this);\n\n    ultimate('(begin)');\n    ultimate('(end)');\n    ultimate('(error)');\n    postscript(symbol('}'));\n    symbol(')');\n    symbol(']');\n    postscript(symbol('\"'));\n    postscript(symbol('\\''));\n    symbol(';');\n    symbol(':');\n    symbol(',');\n    symbol('#');\n    symbol('@');\n    symbol('*/');\n    postscript(reserve('case'));\n    reserve('catch');\n    postscript(reserve('default'));\n    reserve('else');\n    reserve('finally');\n\n    reservevar('arguments', function (x) {\n        if (strict_mode && funct === global_funct) {\n            x.warn('strict');\n        }\n        funct.arguments = true;\n    });\n    reservevar('eval');\n    constant('false', 'boolean');\n    constant('Infinity', 'number');\n    constant('NaN', 'number');\n    constant('null', '');\n    reservevar('this', function (x) {\n        if (strict_mode && funct.statement && funct.name.charAt(0) > 'Z') {\n            x.warn('strict');\n        }\n    });\n    constant('true', 'boolean');\n    constant('undefined', '');\n\n    infix('?', 30, function (left, that) {\n        step_in('?');\n        that.first = expected_condition(expected_relation(left));\n        that.second = expression(0);\n        spaces();\n        step_out();\n        var colon = next_token;\n        advance(':');\n        step_in(':');\n        spaces();\n        that.third = expression(10);\n        that.arity = 'ternary';\n        if (are_similar(that.second, that.third)) {\n            colon.warn('weird_ternary');\n        } else if (are_similar(that.first, that.second)) {\n            that.warn('use_or');\n        }\n        step_out();\n        return that;\n    });\n\n    infix('||', 40, function (left, that) {\n        function paren_check(that) {\n            if (that.id === '&&' && !that.paren) {\n                that.warn('and');\n            }\n            return that;\n        }\n\n        that.first = paren_check(expected_condition(expected_relation(left)));\n        that.second = paren_check(expected_relation(expression(40)));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    infix('&&', 50, function (left, that) {\n        that.first = expected_condition(expected_relation(left));\n        that.second = expected_relation(expression(50));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    prefix('void', function (that) {\n        that.first = expression(0);\n        if (option.es5 || strict_mode) {\n            that.warn('expected_a_b', 'undefined', 'void');\n        } else if (that.first.number !== 0) {\n            that.first.warn('expected_a_b', '0', artifact(that.first));\n        }\n        return that;\n    });\n\n    bitwise('|', 70);\n    bitwise('^', 80);\n    bitwise('&', 90);\n\n    relation('==', '===');\n    relation('===');\n    relation('!=', '!==');\n    relation('!==');\n    relation('<');\n    relation('>');\n    relation('<=');\n    relation('>=');\n\n    bitwise('<<', 120);\n    bitwise('>>', 120);\n    bitwise('>>>', 120);\n\n    infix('in', 120, function (left, that) {\n        that.warn('infix_in');\n        that.left = left;\n        that.right = expression(130);\n        return that;\n    });\n    infix('instanceof', 120);\n    infix('+', 130, function (left, that) {\n        if (left.id === '(number)') {\n            if (left.number === 0) {\n                left.warn('unexpected_a', '0');\n            }\n        } else if (left.id === '(string)') {\n            if (left.string === '') {\n                left.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        var right = expression(130);\n        if (right.id === '(number)') {\n            if (right.number === 0) {\n                right.warn('unexpected_a', '0');\n            }\n        } else if (right.id === '(string)') {\n            if (right.string === '') {\n                right.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        if (left.id === right.id) {\n            if (left.id === '(string)' || left.id === '(number)') {\n                if (left.id === '(string)') {\n                    left.string += right.string;\n                    if (jx.test(left.string)) {\n                        left.warn('url');\n                    }\n                } else {\n                    left.number += right.number;\n                }\n                left.thru = right.thru;\n                return left;\n            }\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('+');\n    prefix('+++', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('+++', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('-', 130, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(130);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number -= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('-');\n    prefix('---', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('---', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('*', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number *= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('/', 140, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number /= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('%', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number %= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n\n    suffix('++');\n    prefix('++');\n\n    suffix('--');\n    prefix('--');\n    prefix('delete', function (that) {\n        one_space();\n        var p = expression(0);\n        if (!p || (p.id !== '.' && p.id !== '[')) {\n            next_token.warn('deleted');\n        }\n        that.first = p;\n        return that;\n    });\n\n\n    prefix('~', function (that) {\n        no_space_only();\n        if (!option.bitwise) {\n            that.warn('unexpected_a');\n        }\n        that.first = expression(150);\n        return that;\n    });\n    function banger(that) {\n        no_space_only();\n        that.first = expected_condition(expression(150));\n        if (bang[that.first.id] === that || that.first.assign) {\n            that.warn('confusing_a');\n        }\n        return that;\n    }\n    prefix('!', banger);\n    prefix('!!', banger);\n    prefix('typeof');\n    prefix('new', function (that) {\n        one_space();\n        var c = expression(160), n, p, v;\n        that.first = c;\n        if (c.id !== 'function') {\n            if (c.identifier) {\n                switch (c.string) {\n                case 'Object':\n                    token.warn('use_object');\n                    break;\n                case 'Array':\n                    if (next_token.id === '(') {\n                        p = next_token;\n                        p.first = this;\n                        advance('(');\n                        if (next_token.id !== ')') {\n                            n = expression(0);\n                            p.second = [n];\n                            if (n.id !== '(number)' || next_token.id === ',') {\n                                p.warn('use_array');\n                            }\n                            while (next_token.id === ',') {\n                                advance(',');\n                                p.second.push(expression(0));\n                            }\n                        } else {\n                            token.warn('use_array');\n                        }\n                        advance(')', p);\n                        return p;\n                    }\n                    token.warn('use_array');\n                    break;\n                case 'Number':\n                case 'String':\n                case 'Boolean':\n                case 'Math':\n                case 'JSON':\n                    c.warn('not_a_constructor');\n                    break;\n                case 'Function':\n                    if (!option.evil) {\n                        next_token.warn('function_eval');\n                    }\n                    break;\n                case 'Date':\n                case 'RegExp':\n                case 'this':\n                    break;\n                default:\n                    if (c.id !== 'function') {\n                        v = c.string.charAt(0);\n                        if (!option.newcap && (v < 'A' || v > 'Z')) {\n                            token.warn('constructor_name_a');\n                        }\n                    }\n                }\n            } else {\n                if (c.id !== '.' && c.id !== '[' && c.id !== '(') {\n                    token.warn('bad_constructor');\n                }\n            }\n        } else {\n            that.warn('weird_new');\n        }\n        if (next_token.id !== '(') {\n            next_token.warn('missing_a', '()');\n        }\n        return that;\n    });\n\n    infix('(', 160, function (left, that) {\n        var e, p;\n        if (indent && indent.mode === 'expression') {\n            no_space(prev_token, token);\n        } else {\n            no_space_only(prev_token, token);\n        }\n        if (!left.immed && left.id === 'function') {\n            next_token.warn('wrap_immediate');\n        }\n        p = [];\n        if (left.identifier) {\n            if (left.string.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {\n                if (left.string !== 'Number' && left.string !== 'String' &&\n                        left.string !== 'Boolean' && left.string !== 'Date') {\n                    if (left.string === 'Math') {\n                        left.warn('not_a_function');\n                    } else if (left.string === 'Object') {\n                        token.warn('use_object');\n                    } else if (left.string === 'Array' || !option.newcap) {\n                        left.warn('missing_a', 'new');\n                    }\n                }\n            } else if (left.string === 'JSON') {\n                left.warn('not_a_function');\n            }\n        } else if (left.id === '.') {\n            if (left.second.string === 'split' &&\n                    left.first.id === '(string)') {\n                left.second.warn('use_array');\n            }\n        }\n        step_in();\n        if (next_token.id !== ')') {\n            no_space();\n            for (;;) {\n                edge();\n                e = expression(10);\n                if (left.string === 'Boolean' && (e.id === '!' || e.id === '~')) {\n                    e.warn('weird_condition');\n                }\n                p.push(e);\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', that);\n        if (typeof left === 'object') {\n            if (left.string === 'parseInt' && p.length === 1) {\n                left.warn('radix');\n            } else if (left.string === 'String' && p.length >= 1 && p[0].id === '(string)') {\n                left.warn('unexpected_a');\n            }\n            if (!option.evil) {\n                if (left.string === 'eval' || left.string === 'Function' ||\n                        left.string === 'execScript') {\n                    left.warn('evil');\n                } else if (p[0] && p[0].id === '(string)' &&\n                        (left.string === 'setTimeout' ||\n                        left.string === 'setInterval')) {\n                    left.warn('implied_evil');\n                }\n            }\n            if (!left.identifier && left.id !== '.' && left.id !== '[' &&\n                    left.id !== '(' && left.id !== '&&' && left.id !== '||' &&\n                    left.id !== '?') {\n                left.warn('bad_invocation');\n            }\n            if (left.id === '.') {\n                if (p.length > 0 &&\n                        left.first && left.first.first &&\n                        are_similar(p[0], left.first.first)) {\n                    if (left.second.string === 'call' ||\n                            (left.second.string === 'apply' && (p.length === 1 ||\n                            (p[1].arity === 'prefix' && p[1].id === '[')))) {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n                if (left.second.string === 'toString') {\n                    if (left.first.id === '(string)' || left.first.id === '(number)') {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n            }\n        }\n        that.first = left;\n        that.second = p;\n        return that;\n    }, true);\n\n    prefix('(', function (that) {\n        step_in('expression');\n        no_space();\n        edge();\n        if (next_token.id === 'function') {\n            next_token.immed = true;\n        }\n        var value = expression(0);\n        value.paren = true;\n        no_space();\n        step_out(')', that);\n        if (value.id === 'function') {\n            switch (next_token.id) {\n            case '(':\n                next_token.warn('move_invocation');\n                break;\n            case '.':\n            case '[':\n                next_token.warn('unexpected_a');\n                break;\n            default:\n                that.warn('bad_wrap');\n            }\n        } else if (!value.arity) {\n            if (!option.closure || !that.comments) {\n                that.warn('unexpected_a');\n            }\n        }\n        return value;\n    });\n\n    infix('.', 170, function (left, that) {\n        no_space(prev_token, token);\n        no_space();\n        var name = identifier();\n        if (typeof name === 'string') {\n            tally_property(name);\n        }\n        that.first = left;\n        that.second = token;\n        if (left && left.string === 'arguments' &&\n                (name === 'callee' || name === 'caller')) {\n            left.warn('avoid_a', 'arguments.' + name);\n        } else if (!option.evil && left && left.string === 'document' &&\n                (name === 'write' || name === 'writeln')) {\n            left.warn('write_is_wrong');\n        } else if (!option.stupid && syx.test(name)) {\n            token.warn('sync_a');\n        }\n        if (!option.evil && (name === 'eval' || name === 'execScript')) {\n            next_token.warn('evil');\n        }\n        return that;\n    }, true);\n\n    infix('[', 170, function (left, that) {\n        var e, s;\n        no_space_only(prev_token, token);\n        no_space();\n        step_in();\n        edge();\n        e = expression(0);\n        switch (e.id) {\n        case '(number)':\n            if (e.id === '(number)' && left.id === 'arguments') {\n                left.warn('use_param');\n            }\n            break;\n        case '(string)':\n            if (!option.evil &&\n                    (e.string === 'eval' || e.string === 'execScript')) {\n                e.warn('evil');\n            } else if (!option.sub && ix.test(e.string)) {\n                s = syntax[e.string];\n                if (!s || !s.reserved) {\n                    e.warn('subscript');\n                }\n            }\n            tally_property(e.string);\n            break;\n        }\n        step_out(']', that);\n        no_space(prev_token, token);\n        that.first = left;\n        that.second = e;\n        return that;\n    }, true);\n\n    prefix('[', function (that) {\n        that.first = [];\n        step_in('array');\n        while (next_token.id !== '(end)') {\n            while (next_token.id === ',') {\n                next_token.warn('unexpected_a');\n                advance(',');\n            }\n            if (next_token.id === ']') {\n                break;\n            }\n            indent.wrap = false;\n            edge();\n            that.first.push(expression(10));\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id === ']' && !option.es5) {\n                    token.warn('unexpected_a');\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        step_out(']', that);\n        return that;\n    }, 170);\n\n\n    function property_name() {\n        var id = optional_identifier();\n        if (!id) {\n            if (next_token.id === '(string)') {\n                id = next_token.string;\n                advance();\n            } else if (next_token.id === '(number)') {\n                id = next_token.number.toString();\n                advance();\n            }\n        }\n        return id;\n    }\n\n\n\n    assignop('=');\n    assignop('+=', '+');\n    assignop('-=', '-');\n    assignop('*=', '*');\n    assignop('/=', '/').nud = function () {\n        next_token.stop('slash_equal');\n    };\n    assignop('%=', '%');\n    assignop('&=', '&');\n    assignop('|=', '|');\n    assignop('^=', '^');\n    assignop('<<=', '<<');\n    assignop('>>=', '>>');\n    assignop('>>>=', '>>>');\n\n    function function_parameters() {\n        var id, parameters = [], paren = next_token;\n        advance('(');\n        token.function = funct;\n        step_in();\n        no_space();\n        if (next_token.id !== ')') {\n            for (;;) {\n                edge();\n                id = identifier();\n                define('parameter', token);\n                parameters.push(id);\n                token.init = true;\n                token.writeable = true;\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', paren);\n        return parameters;\n    }\n\n    function do_function(func, name) {\n        var old_funct = funct,\n            old_option = option,\n            old_scope = scope;\n        scope = Object.create(old_scope);\n        funct = {\n            closure: [],\n            global: [],\n            level: old_funct.level + 1,\n            line: next_token.line,\n            loopage: 0,\n            name: name || '\\'' + (anonname || '').replace(nx, sanitize) + '\\'',\n            outer: [],\n            scope: scope\n        };\n        funct.parameter = function_parameters();\n        func.function = funct;\n        option = Object.create(old_option);\n        functions.push(funct);\n        if (name) {\n            func.name = name;\n            func.string = name;\n            define('function', func);\n            func.init = true;\n            func.used += 1;\n        }\n        func.writeable = false;\n        one_space();\n        func.block = block('function');\n        Object.keys(scope).forEach(function (name) {\n            var master = scope[name];\n            if (!master.used && master.kind !== 'exception' &&\n                    (master.kind !== 'parameter' || !option.unparam)) {\n                master.warn('unused_a');\n            } else if (!master.init) {\n                master.warn('uninitialized_a');\n            }\n        });\n        funct = old_funct;\n        option = old_option;\n        scope = old_scope;\n    }\n\n    prefix('{', function (that) {\n        var get, i, j, name, set, seen = Object.create(null);\n        that.first = [];\n        step_in();\n        while (next_token.id !== '}') {\n            indent.wrap = false;\n\n// JSLint recognizes the ES5 extension for get/set in object literals,\n// but requires that they be used in pairs.\n\n            edge();\n            if (next_token.string === 'get' && peek().id !== ':') {\n                if (!option.es5) {\n                    next_token.warn('es5');\n                }\n                get = next_token;\n                advance('get');\n                one_space_only();\n                name = next_token;\n                i = property_name();\n                if (!i) {\n                    next_token.stop('missing_property');\n                }\n                get.string = '';\n                do_function(get);\n                if (funct.loopage) {\n                    get.warn('function_loop');\n                }\n                if (get.function.parameter.length) {\n                    get.warn('parameter_a_get_b', get.function.parameter[0], i);\n                }\n                comma();\n                set = next_token;\n                spaces();\n                edge();\n                advance('set');\n                set.string = '';\n                one_space_only();\n                j = property_name();\n                if (i !== j) {\n                    token.stop('expected_a_b', i, j || next_token.string);\n                }\n                do_function(set);\n                if (set.block.length === 0) {\n                    token.warn('missing_a', 'throw');\n                }\n                if (set.function.parameter.length === 0) {\n                    set.stop('parameter_set_a', 'value');\n                } else if (set.function.parameter[0] !== 'value') {\n                    set.stop('expected_a_b', 'value',\n                        set.function.parameter[0]);\n                }\n                name.first = [get, set];\n            } else {\n                name = next_token;\n                i = property_name();\n                if (typeof i !== 'string') {\n                    next_token.stop('missing_property');\n                }\n                advance(':');\n                spaces();\n                name.first = expression(10);\n            }\n            that.first.push(name);\n            if (seen[i] === true) {\n                next_token.warn('duplicate_a', i);\n            }\n            seen[i] = true;\n            tally_property(i);\n            if (next_token.id !== ',') {\n                break;\n            }\n            for (;;) {\n                comma();\n                if (next_token.id !== ',') {\n                    break;\n                }\n                next_token.warn('unexpected_a');\n            }\n            if (next_token.id === '}' && !option.es5) {\n                token.warn('unexpected_a');\n            }\n        }\n        step_out('}', that);\n        return that;\n    });\n\n    stmt('{', function () {\n        next_token.warn('statement_block');\n        this.arity = 'statement';\n        this.block = statements();\n        this.disrupt = this.block.disrupt;\n        advance('}', this);\n        return this;\n    });\n\n    stmt('/*global', directive);\n    stmt('/*globals', directive);\n    stmt('/*jslint', directive);\n    stmt('/*member', directive);\n    stmt('/*members', directive);\n    stmt('/*property', directive);\n    stmt('/*properties', directive);\n\n    stmt('var', function () {\n\n// JavaScript does not have block scope. It only has function scope. So,\n// declaring a variable in a block can have unexpected consequences.\n\n// var.first will contain an array, the array containing name tokens\n// and assignment tokens.\n\n        var assign, id, name;\n\n        if (funct.loopage) {\n            next_token.warn('var_loop');\n        } else if (funct.varstatement && !option.vars) {\n            next_token.warn('combine_var');\n        }\n        if (funct !== global_funct) {\n            funct.varstatement = true;\n        }\n        this.arity = 'statement';\n        this.first = [];\n        step_in('var');\n        for (;;) {\n            name = next_token;\n            id = identifier(true);\n            define('var', name);\n            name.dead = funct;\n            if (next_token.id === '=') {\n                assign = next_token;\n                assign.first = name;\n                spaces();\n                advance('=');\n                spaces();\n                if (next_token.id === 'undefined') {\n                    token.warn('unnecessary_initialize', id);\n                }\n                if (peek(0).id === '=' && next_token.identifier) {\n                    next_token.stop('var_a_not');\n                }\n                assign.second = expression(0);\n                assign.arity = 'infix';\n                name.init = true;\n                this.first.push(assign);\n            } else {\n                this.first.push(name);\n            }\n            name.dead = false;\n            name.writeable = true;\n            if (next_token.id !== ',') {\n                break;\n            }\n            comma();\n            indent.wrap = false;\n            if (var_mode && next_token.line === token.line &&\n                    this.first.length === 1) {\n                var_mode = null;\n                indent.open = false;\n                indent.at -= option.indent;\n            }\n            spaces();\n            edge();\n        }\n        var_mode = null;\n        step_out();\n        return this;\n    });\n\n    stmt('function', function () {\n        one_space();\n        if (in_block) {\n            token.warn('function_block');\n        }\n        var name = next_token,\n            id = identifier(true);\n        define('var', name);\n        name.init = true;\n        name.statement = true;\n        no_space();\n        this.arity = 'statement';\n        do_function(this, id);\n        if (next_token.id === '(' && next_token.line === token.line) {\n            next_token.stop('function_statement');\n        }\n        return this;\n    });\n\n    prefix('function', function (that) {\n        var id = optional_identifier(true), name;\n        if (id) {\n            name = token;\n            no_space();\n        } else {\n            id = '';\n            one_space();\n        }\n        do_function(that, id);\n        if (name) {\n            name.function = that.function;\n        }\n        if (funct.loopage) {\n            that.warn('function_loop');\n        }\n        switch (next_token.id) {\n        case ';':\n        case '(':\n        case ')':\n        case ',':\n        case ']':\n        case '}':\n        case ':':\n        case '(end)':\n            break;\n        case '.':\n            if (peek().string !== 'bind' || peek(1).id !== '(') {\n                next_token.warn('unexpected_a');\n            }\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n        that.arity = 'function';\n        return that;\n    });\n\n    stmt('if', function () {\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('if');\n        if (next_token.id === 'else') {\n            if (this.block.disrupt) {\n                next_token.warn('unnecessary_else');\n            }\n            one_space();\n            advance('else');\n            one_space();\n            this.else = next_token.id === 'if' || next_token.id === 'switch'\n                ? statement(true)\n                : block('else');\n            if (this.else.disrupt && this.block.disrupt) {\n                this.disrupt = true;\n            }\n        }\n        return this;\n    });\n\n    stmt('try', function () {\n\n// try.first    The catch variable\n// try.second   The catch clause\n// try.third    The finally clause\n// try.block    The try block\n\n        var exception_variable, paren;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('try');\n        if (next_token.id === 'catch') {\n            one_space();\n            advance('catch');\n            one_space();\n            paren = next_token;\n            advance('(');\n            step_in('control');\n            no_space();\n            edge();\n            exception_variable = next_token;\n            this.first = identifier();\n            define('exception', exception_variable);\n            exception_variable.init = true;\n            no_space();\n            step_out(')', paren);\n            one_space();\n            this.second = block('catch');\n            if (this.second.length) {\n                if (this.first === 'ignore') {\n                    exception_variable.warn('unexpected_a');\n                }\n            } else {\n                if (this.first !== 'ignore') {\n                    exception_variable.warn('expected_a_b', 'ignore',\n                        exception_variable.string);\n                }\n            }\n            exception_variable.dead = true;\n        }\n        if (next_token.id === 'finally') {\n            one_space();\n            advance('finally');\n            one_space();\n            this.third = block('finally');\n        } else if (!this.second) {\n            next_token.stop('expected_a_b', 'catch', artifact());\n        }\n        return this;\n    });\n\n    labeled_stmt('while', function () {\n        one_space();\n        var paren = next_token;\n        funct.loopage += 1;\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_relation(expression(0));\n        if (this.first.id !== 'true') {\n            expected_condition(this.first, 'unexpected_a');\n        }\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('while');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        funct.loopage -= 1;\n        return this;\n    });\n\n    reserve('with');\n\n    labeled_stmt('switch', function () {\n\n// switch.first         the switch expression\n// switch.second        the array of cases. A case is 'case' or 'default' token:\n//    case.first        the array of case expressions\n//    case.second       the array of statements\n// If all of the arrays of statements are disrupt, then the switch is disrupt.\n\n        var cases = [],\n            old_in_block = in_block,\n            particular,\n            that = token,\n            the_case = next_token,\n            unbroken = true;\n\n        function find_duplicate_case(value) {\n            if (are_similar(particular, value)) {\n                value.warn('duplicate_a');\n            }\n        }\n\n        one_space();\n        advance('(');\n        no_space();\n        step_in();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', the_case);\n        one_space();\n        advance('{');\n        step_in();\n        in_block = true;\n        this.second = [];\n        if (that.from !== next_token.from && !option.white) {\n            next_token.warn('expected_a_at_b_c', next_token.string, that.from, next_token.from);\n        }\n        while (next_token.id === 'case') {\n            the_case = next_token;\n            cases.forEach(find_duplicate_case);\n            the_case.first = [];\n            the_case.arity = 'case';\n            spaces();\n            edge('case');\n            advance('case');\n            for (;;) {\n                one_space();\n                particular = expression(0);\n                cases.forEach(find_duplicate_case);\n                cases.push(particular);\n                the_case.first.push(particular);\n                if (particular.id === 'NaN') {\n                    particular.warn('unexpected_a');\n                }\n                no_space_only();\n                advance(':');\n                if (next_token.id !== 'case') {\n                    break;\n                }\n                spaces();\n                edge('case');\n                advance('case');\n            }\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                particular = the_case.second[the_case.second.length - 1];\n                if (particular.disrupt) {\n                    if (particular.id === 'break') {\n                        unbroken = false;\n                    }\n                } else {\n                    next_token.warn('missing_a_after_b', 'break', 'case');\n                }\n            } else {\n                next_token.warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.second.length === 0) {\n            next_token.warn('missing_a', 'case');\n        }\n        if (next_token.id === 'default') {\n            spaces();\n            the_case = next_token;\n            the_case.arity = 'case';\n            edge('case');\n            advance('default');\n            no_space_only();\n            advance(':');\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                particular = the_case.second[the_case.second.length - 1];\n                if (unbroken && particular.disrupt && particular.id !== 'break') {\n                    this.disrupt = true;\n                }\n            }\n            this.second.push(the_case);\n        }\n        spaces();\n        step_out('}', this);\n        in_block = old_in_block;\n        return this;\n    });\n\n    stmt('debugger', function () {\n        if (!option.debug) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        return this;\n    });\n\n    labeled_stmt('do', function () {\n        funct.loopage += 1;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('do');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        one_space();\n        advance('while');\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in();\n        no_space();\n        edge();\n        this.first = expected_condition(expected_relation(expression(0)), 'unexpected_a');\n        no_space();\n        step_out(')', paren);\n        funct.loopage -= 1;\n        return this;\n    });\n\n    labeled_stmt('for', function () {\n\n        var blok, filter, master, ok = false, paren = next_token, value;\n        this.arity = 'statement';\n        funct.loopage += 1;\n        advance('(');\n        if (next_token.id === ';') {\n            no_space();\n            advance(';');\n            no_space();\n            advance(';');\n            no_space();\n            advance(')');\n            blok = block('for');\n        } else {\n            step_in('control');\n            spaces(this, paren);\n            no_space();\n            if (next_token.id === 'var') {\n                next_token.stop('move_var');\n            }\n            edge();\n            if (peek(0).id === 'in') {\n                this.forin = true;\n                value = expression(1000);\n                master = value.master;\n                if (master.kind !== 'var' || master.function !== funct ||\n                        !master.writeable || master.dead) {\n                    value.warn('bad_in_a');\n                }\n                master.init = true;\n                master.used -= 1;\n                this.first = value;\n                advance('in');\n                this.second = expression(20);\n                step_out(')', paren);\n                blok = block('for');\n                if (!option.forin) {\n                    if (blok.length === 1 && typeof blok[0] === 'object') {\n                        if (blok[0].id === 'if' && !blok[0].else) {\n                            filter = blok[0].first;\n                            while (filter.id === '&&') {\n                                filter = filter.first;\n                            }\n                            switch (filter.id) {\n                            case '===':\n                            case '!==':\n                                ok = filter.first.id === '['\n                                    ? are_similar(filter.first.first, this.second) &&\n                                        are_similar(filter.first.second, this.first)\n                                    : filter.first.id === 'typeof' &&\n                                        filter.first.first.id === '[' &&\n                                        are_similar(filter.first.first.first, this.second) &&\n                                        are_similar(filter.first.first.second, this.first);\n                                break;\n                            case '(':\n                                ok = filter.first.id === '.' && ((\n                                    are_similar(filter.first.first, this.second) &&\n                                    filter.first.second.string === 'hasOwnProperty' &&\n                                    are_similar(filter.second[0], this.first)\n                                ) || (\n                                    filter.first.first.id === '.' &&\n                                    filter.first.first.first.first &&\n                                    filter.first.first.first.first.string === 'Object' &&\n                                    filter.first.first.first.id === '.' &&\n                                    filter.first.first.first.second.string === 'prototype' &&\n                                    filter.first.first.second.string === 'hasOwnProperty' &&\n                                    filter.first.second.string === 'call' &&\n                                    are_similar(filter.second[0], this.second) &&\n                                    are_similar(filter.second[1], this.first)\n                                ));\n                                break;\n                            }\n                        } else if (blok[0].id === 'switch') {\n                            ok = blok[0].id === 'switch' &&\n                                blok[0].first.id === 'typeof' &&\n                                blok[0].first.first.id === '[' &&\n                                are_similar(blok[0].first.first.first, this.second) &&\n                                are_similar(blok[0].first.first.second, this.first);\n                        }\n                    }\n                    if (!ok) {\n                        this.warn('for_if');\n                    }\n                }\n            } else {\n                edge();\n                this.first = [];\n                for (;;) {\n                    this.first.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                semicolon();\n                edge();\n                this.second = expected_relation(expression(0));\n                if (this.second.id !== 'true') {\n                    expected_condition(this.second, 'unexpected_a');\n                }\n                semicolon(token);\n                if (next_token.id === ';') {\n                    next_token.stop('expected_a_b', ')', ';');\n                }\n                this.third = [];\n                edge();\n                for (;;) {\n                    this.third.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                no_space();\n                step_out(')', paren);\n                one_space();\n                blok = block('for');\n            }\n        }\n        if (blok.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        this.block = blok;\n        funct.loopage -= 1;\n        return this;\n    });\n\n    function optional_label(that) {\n        var label = next_token.string,\n            master;\n        that.arity = 'statement';\n        if (next_token.identifier && token.line === next_token.line) {\n            one_space_only();\n            master = scope[label];\n            if (!master || master.kind !== 'label') {\n                next_token.warn('not_a_label');\n            } else if (master.dead || master.function !== funct) {\n                next_token.warn('not_a_scope');\n            } else {\n                master.used += 1;\n            }\n            that.first = next_token;\n            advance();\n        }\n        return that;\n\n    }\n\n    disrupt_stmt('break', function () {\n        return optional_label(this);\n    });\n\n    disrupt_stmt('continue', function () {\n        if (!option.continue) {\n            this.warn('unexpected_a');\n        }\n        return optional_label(this);\n    });\n\n    disrupt_stmt('return', function () {\n        if (funct === global_funct) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        if (next_token.id !== ';' && next_token.line === token.line) {\n            if (option.closure) {\n                spaces();\n            } else {\n                one_space_only();\n            }\n            if (next_token.id === '/' || next_token.id === '(regexp)') {\n                next_token.warn('wrap_regexp');\n            }\n            this.first = expression(0);\n            if (this.first.assign) {\n                this.first.warn('unexpected_a');\n            }\n        }\n        return this;\n    });\n\n    disrupt_stmt('throw', function () {\n        this.arity = 'statement';\n        one_space_only();\n        this.first = expression(20);\n        return this;\n    });\n\n\n//  Superfluous reserved words\n\n    reserve('class');\n    reserve('const');\n    reserve('enum');\n    reserve('export');\n    reserve('extends');\n    reserve('import');\n    reserve('super');\n\n// Harmony reserved words\n\n    reserve('implements');\n    reserve('interface');\n    reserve('let');\n    reserve('package');\n    reserve('private');\n    reserve('protected');\n    reserve('public');\n    reserve('static');\n    reserve('yield');\n\n\n// Parse JSON\n\n    function json_value() {\n\n        function json_object() {\n            var brace = next_token, object = Object.create(null);\n            advance('{');\n            if (next_token.id !== '}') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    if (next_token.id !== '(string)') {\n                        next_token.warn('expected_string_a');\n                    }\n                    if (object[next_token.string] === true) {\n                        next_token.warn('duplicate_a');\n                    } else if (next_token.string === '__proto__') {\n                        next_token.warn('dangling_a');\n                    } else {\n                        object[next_token.string] = true;\n                    }\n                    advance();\n                    advance(':');\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === '}') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance('}', brace);\n        }\n\n        function json_array() {\n            var bracket = next_token;\n            advance('[');\n            if (next_token.id !== ']') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === ']') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance(']', bracket);\n        }\n\n        switch (next_token.id) {\n        case '{':\n            json_object();\n            break;\n        case '[':\n            json_array();\n            break;\n        case 'true':\n        case 'false':\n        case 'null':\n        case '(number)':\n        case '(string)':\n            advance();\n            break;\n        case '-':\n            advance('-');\n            no_space_only();\n            advance('(number)');\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n    }\n\n\n// The actual JSLINT function itself.\n\n    itself = function JSLint(the_source, the_option) {\n\n        var i, predef, tree;\n        itself.errors = [];\n        itself.tree = '';\n        itself.properties = '';\n        begin = prev_token = token = next_token =\n            Object.create(syntax['(begin)']);\n        tokens = [];\n        predefined = Object.create(null);\n        add_to_predefined(standard);\n        property = Object.create(null);\n        if (the_option) {\n            option = Object.create(the_option);\n            predef = option.predef;\n            if (predef) {\n                if (Array.isArray(predef)) {\n                    for (i = 0; i < predef.length; i += 1) {\n                        predefined[predef[i]] = true;\n                    }\n                } else if (typeof predef === 'object') {\n                    add_to_predefined(predef);\n                }\n            }\n        } else {\n            option = Object.create(null);\n        }\n        option.indent = +option.indent || 4;\n        option.maxerr = +option.maxerr || 50;\n        global_scope = scope = Object.create(null);\n        global_funct = funct = {\n            scope: scope,\n            loopage: 0,\n            level: 0\n        };\n        functions = [funct];\n        block_var = [];\n\n        comments = [];\n        comments_off = false;\n        in_block = false;\n        indent = null;\n        json_mode = false;\n        lookahead = [];\n        node_js = false;\n        prereg = true;\n        strict_mode = false;\n        var_mode = null;\n        warnings = 0;\n        lex.init(the_source);\n\n        assume();\n\n        try {\n            advance();\n            if (next_token.id === '(number)') {\n                next_token.stop('unexpected_a');\n            } else {\n                switch (next_token.id) {\n                case '{':\n                case '[':\n                    comments_off = true;\n                    json_mode = true;\n                    json_value();\n                    break;\n                default:\n\n// If the first token is a semicolon, ignore it. This is sometimes used when\n// files are intended to be appended to files that may be sloppy. A sloppy\n// file may be depending on semicolon insertion on its last line.\n\n                    step_in(1);\n                    if (next_token.id === ';' && !node_js) {\n                        semicolon();\n                    }\n                    tree = statements();\n                    begin.first = tree;\n                    itself.tree = begin;\n                    if (tree.disrupt) {\n                        prev_token.warn('weird_program');\n                    }\n                }\n            }\n            indent = null;\n            advance('(end)');\n            itself.property = property;\n        } catch (e) {\n            if (e) {        // ~~\n                itself.errors.push({\n                    reason    : e.message,\n                    line      : e.line || next_token.line,\n                    character : e.character || next_token.from\n                }, null);\n            }\n        }\n        return itself.errors.length === 0;\n    };\n\n    function unique(array) {\n        array = array.sort();\n        var i, length = 0, previous, value;\n        for (i = 0; i < array.length; i += 1) {\n            value = array[i];\n            if (value !== previous) {\n                array[length] = value;\n                previous = value;\n                length += 1;\n            }\n        }\n        array.length = length;\n        return array;\n    }\n\n// Data summary.\n\n    itself.data = function () {\n        var data = {functions: []},\n            function_data,\n            i,\n            the_function,\n            the_scope;\n        data.errors = itself.errors;\n        data.json = json_mode;\n        data.global = unique(Object.keys(global_scope));\n\n        function selects(name) {\n            var kind = the_scope[name].kind;\n            switch (kind) {\n            case 'var':\n            case 'exception':\n            case 'label':\n                function_data[kind].push(name);\n                break;\n            }\n        }\n\n        for (i = 1; i < functions.length; i += 1) {\n            the_function = functions[i];\n            function_data = {\n                name: the_function.name,\n                line: the_function.line,\n                level: the_function.level,\n                parameter: the_function.parameter,\n                var: [],\n                exception: [],\n                closure: unique(the_function.closure),\n                outer: unique(the_function.outer),\n                global: unique(the_function.global),\n                label: []\n            };\n            the_scope = the_function.scope;\n            Object.keys(the_scope).forEach(selects);\n            function_data.var.sort();\n            function_data.exception.sort();\n            function_data.label.sort();\n            data.functions.push(function_data);\n        }\n        data.tokens = tokens;\n        return data;\n    };\n\n    itself.error_report = function (data) {\n        var evidence, i, output = [], warning;\n        if (data.errors.length) {\n            if (data.json) {\n                output.push('<cite>JSON: bad.</cite><br>');\n            }\n            for (i = 0; i < data.errors.length; i += 1) {\n                warning = data.errors[i];\n                if (warning) {\n                    evidence = warning.evidence || '';\n                    output.push('<cite>');\n                    if (isFinite(warning.line)) {\n                        output.push('<address>line ' +\n                            String(warning.line) +\n                            ' character ' + String(warning.character) +\n                            '</address>');\n                    }\n                    output.push(warning.reason.entityify() + '</cite>');\n                    if (evidence) {\n                        output.push('<pre>' + evidence.entityify() + '</pre>');\n                    }\n                }\n            }\n        }\n        return output.join('');\n    };\n\n\n    itself.report = function (data) {\n        var dl, i, j, names, output = [], the_function;\n\n        function detail(h, array) {\n            var comma_needed = false;\n            if (array.length) {\n                output.push(\"<dt>\" + h + \"</dt><dd>\");\n                array.forEach(function (item) {\n                    output.push((comma_needed ? ', ' : '') + item);\n                    comma_needed = true;\n                });\n                output.push(\"</dd>\");\n            }\n        }\n\n        output.push('<dl class=level0>');\n        if (data.global.length) {\n            detail('global', data.global);\n            dl = true;\n        } else if (data.json) {\n            if (!data.errors.length) {\n                output.push(\"<dt>JSON: good.</dt>\");\n            }\n        } else {\n            output.push(\"<dt><i>No new global variables introduced.</i></dt>\");\n        }\n        if (dl) {\n            output.push(\"</dl>\");\n        } else {\n            output[0] = '';\n        }\n\n        if (data.functions) {\n            for (i = 0; i < data.functions.length; i += 1) {\n                the_function = data.functions[i];\n                names = [];\n                if (the_function.params) {\n                    for (j = 0; j < the_function.params.length; j += 1) {\n                        names[j] = the_function.params[j].string;\n                    }\n                }\n                output.push('<dl class=level' + the_function.level +\n                    '><address>line ' + String(the_function.line) +\n                    '</address>' + the_function.name.entityify());\n                detail('parameter', the_function.parameter);\n                detail('variable', the_function.var);\n                detail('exception', the_function.exception);\n                detail('closure', the_function.closure);\n                detail('outer', the_function.outer);\n                detail('global', the_function.global);\n                detail('label', the_function.label);\n                output.push('</dl>');\n            }\n        }\n        return output.join('');\n    };\n\n    itself.properties_report = function (property) {\n        if (!property) {\n            return '';\n        }\n        var i,\n            key,\n            keys = Object.keys(property).sort(),\n            mem = '    ',\n            name,\n            not_first = false,\n            output = ['/*properties'];\n        for (i = 0; i < keys.length; i += 1) {\n            key = keys[i];\n            if (property[key] > 0) {\n                if (not_first) {\n                    mem += ', ';\n                }\n                name = ix.test(key)\n                    ? key\n                    : '\\'' + key.replace(nx, sanitize) + '\\'';\n                if (mem.length + name.length >= 80) {\n                    output.push(mem);\n                    mem = '    ';\n                }\n                mem += name;\n                not_first = true;\n            }\n        }\n        output.push(mem, '*/\\n');\n        return output.join('\\n');\n    };\n\n    itself.color = function (data) {\n        var from,\n            i = 1,\n            level,\n            line,\n            result = [],\n            thru,\n            data_token = data.tokens[0];\n        while (data_token && data_token.id !== '(end)') {\n            from = data_token.from;\n            line = data_token.line;\n            thru = data_token.thru;\n            level = data_token.function.level;\n            do {\n                thru = data_token.thru;\n                data_token = data.tokens[i];\n                i += 1;\n            } while (data_token && data_token.line === line &&\n                    data_token.from - thru < 5 &&\n                    level === data_token.function.level);\n            result.push({\n                line: line,\n                level: level,\n                from: from,\n                thru: thru\n            });\n        }\n        return result;\n    };\n\n    itself.jslint = itself;\n\n    itself.edition = '2013-08-26';\n\n    return itself;\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jslint-2013-09-22.js":"// jslint.js\n// 2013-09-22\n\n// Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// The Software shall be used for Good, not Evil.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// WARNING: JSLint will hurt your feelings.\n\n// JSLINT is a global function. It takes two parameters.\n\n//     var myResult = JSLINT(source, option);\n\n// The first parameter is either a string or an array of strings. If it is a\n// string, it will be split on '\\n' or '\\r'. If it is an array of strings, it\n// is assumed that each string represents one line. The source can be a\n// JavaScript text or a JSON text.\n\n// The second parameter is an optional object of options that control the\n// operation of JSLINT. Most of the options are booleans: They are all\n// optional and have a default value of false. One of the options, predef,\n// can be an array of names, which will be used to declare global variables,\n// or an object whose keys are used as global names, with a boolean value\n// that determines if they are assignable.\n\n// If it checks out, JSLINT returns true. Otherwise, it returns false.\n\n// If false, you can inspect JSLINT.errors to find out the problems.\n// JSLINT.errors is an array of objects containing these properties:\n\n//  {\n//      line      : The line (relative to 0) at which the lint was found\n//      character : The character (relative to 0) at which the lint was found\n//      reason    : The problem\n//      evidence  : The text line in which the problem occurred\n//      raw       : The raw message before the details were inserted\n//      a         : The first detail\n//      b         : The second detail\n//      c         : The third detail\n//      d         : The fourth detail\n//  }\n\n// If a stopping error was found, a null will be the last element of the\n// JSLINT.errors array. A stopping error means that JSLint was not confident\n// enough to continue. It does not necessarily mean that the error was\n// especially heinous.\n\n// You can request a data structure that contains JSLint's results.\n\n//     var myData = JSLINT.data();\n\n// It returns a structure with this form:\n\n//     {\n//         errors: [\n//             {\n//                 line: NUMBER,\n//                 character: NUMBER,\n//                 reason: STRING,\n//                 evidence: STRING\n//             }\n//         ],\n//         functions: [\n//             {\n//                 name: STRING,\n//                 line: NUMBER,\n//                 level: NUMBER,\n//                 parameter: [\n//                     STRING\n//                 ],\n//                 var: [\n//                     STRING\n//                 ],\n//                 exception: [\n//                     STRING\n//                 ],\n//                 closure: [\n//                     STRING\n//                 ],\n//                 outer: [\n//                     STRING\n//                 ],\n//                 global: [\n//                     STRING\n//                 ],\n//                 label: [\n//                     STRING\n//                 ]\n//             }\n//         ],\n//         global: [\n//             STRING\n//         ],\n//         member: {\n//             STRING: NUMBER\n//         },\n//         json: BOOLEAN\n//     }\n\n// You can request a Function Report, which shows all of the functions\n// and the parameters and vars that they use. This can be used to find\n// implied global variables and other problems. The report is in HTML and\n// can be inserted into an HTML <body>. It should be given the result of the\n// JSLINT.data function.\n\n//     var myReport = JSLINT.report(data);\n\n// You can request an HTML error report.\n\n//     var myErrorReport = JSLINT.error_report(data);\n\n// You can obtain an object containing all of the properties found in the\n// file. JSLINT.property contains an object containing a key for each\n// property used in the program, the value being the number of times that\n// property name was used in the file.\n\n// You can request a properties report, which produces a list of the program's\n// properties in the form of a /*properties*/ declaration.\n\n//      var myPropertyReport = JSLINT.properties_report(JSLINT.property);\n\n// You can obtain the parse tree that JSLint constructed while parsing. The\n// latest tree is kept in JSLINT.tree. A nice stringification can be produced\n// with\n\n//     JSON.stringify(JSLINT.tree, [\n//         'string',  'arity', 'name',  'first',\n//         'second', 'third', 'block', 'else'\n//     ], 4));\n\n// You can request a context coloring table. It contains information that can be\n// applied to the file that was analyzed. Context coloring colors functions\n// based on their nesting level, and variables on the color of the functions\n// in which they are defined.\n\n//      var myColorization = JSLINT.color(data);\n\n// It returns an array containing objects of this form:\n\n//      {\n//          from: COLUMN,\n//          thru: COLUMN,\n//          line: ROW,\n//          level: 0 or higher\n//      }\n\n// JSLint provides three inline directives. They look like slashstar comments,\n// and allow for setting options, declaring global variables, and establishing a\n// set of allowed property names.\n\n// These directives respect function scope.\n\n// The jslint directive is a special comment that can set one or more options.\n// For example:\n\n/*jslint\n    evil: true, nomen: true, regexp: true, todo: true\n*/\n\n// The current option set is\n\n//     ass        true, if assignment expressions should be allowed\n//     bitwise    true, if bitwise operators should be allowed\n//     browser    true, if the standard browser globals should be predefined\n//     closure    true, if Google Closure idioms should be tolerated\n//     continue   true, if the continuation statement should be tolerated\n//     debug      true, if debugger statements should be allowed\n//     devel      true, if logging should be allowed (console, alert, etc.)\n//     eqeq       true, if == should be allowed\n//     evil       true, if eval should be allowed\n//     forin      true, if for in statements need not filter\n//     indent     the indentation factor\n//     maxerr     the maximum number of errors to allow\n//     maxlen     the maximum length of a source line\n//     newcap     true, if constructor names capitalization is ignored\n//     node       true, if Node.js globals should be predefined\n//     nomen      true, if names may have dangling _\n//     passfail   true, if the scan should stop on first error\n//     plusplus   true, if increment/decrement should be allowed\n//     properties true, if all property names must be declared with /*properties*/\n//     regexp     true, if the . should be allowed in regexp literals\n//     rhino      true, if the Rhino environment globals should be predefined\n//     unparam    true, if unused parameters should be tolerated\n//     sloppy     true, if the 'use strict'; pragma is optional\n//     stupid     true, if really stupid practices are tolerated\n//     sub        true, if all forms of subscript notation are tolerated\n//     todo       true, if TODO comments are tolerated\n//     vars       true, if multiple var statements per function should be allowed\n//     white      true, if sloppy whitespace is tolerated\n\n// The properties directive declares an exclusive list of property names.\n// Any properties named in the program that are not in the list will\n// produce a warning.\n\n// For example:\n\n/*properties\n    '\\b', '\\t', '\\n', '\\f', '\\r', '!', '!=', '!==', '\"', '%', '\\'', '(begin)',\n    '(error)', '*', '+', '-', '/', '<', '<=', '==', '===', '>', '>=', '\\\\', a,\n    a_label, a_scope, already_defined, and, arguments, arity, ass, assign,\n    assignment_expression, assignment_function_expression, at, avoid_a, b,\n    bad_assignment, bad_constructor, bad_in_a, bad_invocation, bad_new,\n    bad_number, bad_operand, bad_wrap, bitwise, block, browser, c, call, charAt,\n    charCodeAt, character, closure, code, color, combine_var, comments,\n    conditional_assignment, confusing_a, confusing_regexp, constructor_name_a,\n    continue, control_a, couch, create, d, dangling_a, data, dead, debug,\n    deleted, devel, disrupt, duplicate_a, edge, edition, else, empty_block,\n    empty_case, empty_class, entityify, eqeq, error_report, errors,\n    evidence, evil, exception, exec, expected_a_at_b_c, expected_a_b,\n    expected_a_b_from_c_d, expected_id_a, expected_identifier_a,\n    expected_identifier_a_reserved, expected_number_a, expected_operator_a,\n    expected_positive_a, expected_small_a, expected_space_a_b,\n    expected_string_a, f, first, flag, floor, forEach, for_if, forin, from,\n    fromCharCode, fud, function, function_block, function_eval, function_loop,\n    function_statement, function_strict, functions, global, hasOwnProperty, id,\n    identifier, identifier_function, immed, implied_evil, indent, indexOf,\n    infix_in, init, insecure_a, isAlpha, isArray, isDigit, isNaN, join, jslint,\n    json, keys, kind, label, labeled, lbp, leading_decimal_a, led, left, length,\n    level, line, loopage, master, match, maxerr, maxlen, message, missing_a,\n    missing_a_after_b, missing_property, missing_space_a_b, missing_use_strict,\n    mode, move_invocation, move_var, n, name, name_function, nested_comment,\n    newcap, node, nomen, not, not_a_constructor, not_a_defined, not_a_function,\n    not_a_label, not_a_scope, not_greater, nud, number, octal_a, open, outer,\n    parameter, parameter_a_get_b, parameter_arguments_a, parameter_set_a,\n    params, paren, passfail, plusplus, postscript, predef, properties,\n    properties_report, property, prototype, push, quote, r, radix, raw,\n    read_only, reason, redefinition_a_b, regexp, relation, replace, report,\n    reserved, reserved_a, rhino, right, scanned_a_b, scope, search, second,\n    shift, slash_equal, slice, sloppy, sort, split, statement, statement_block,\n    stop, stopping, strange_loop, strict, string, stupid, sub, subscript,\n    substr, supplant, sync_a, t, tag_a_in_b, test, third, thru, toString, todo,\n    todo_comment, token, tokens, too_long, too_many, trailing_decimal_a, tree,\n    unclosed, unclosed_comment, unclosed_regexp, unescaped_a, unexpected_a,\n    unexpected_char_a, unexpected_comment, unexpected_label_a,\n    unexpected_property_a, unexpected_space_a_b, unexpected_typeof_a,\n    uninitialized_a, unnecessary_else, unnecessary_initialize, unnecessary_use,\n    unparam, unreachable_a_b, unsafe, unused_a, url, use_array, use_braces,\n    use_object, use_or, use_param, use_spaces, used, used_before_a, var,\n    var_a_not, var_loop, vars, varstatement, warn, warning, was,\n    weird_assignment, weird_condition, weird_new, weird_program, weird_relation,\n    weird_ternary, white, wrap, wrap_immediate, wrap_regexp, write_is_wrong,\n    writeable\n*/\n\n// The global directive is used to declare global variables that can\n// be accessed by the program. If a declaration is true, then the variable\n// is writeable. Otherwise, it is read-only.\n\n// We build the application inside a function so that we produce only a single\n// global variable. That function will be invoked immediately, and its return\n// value is the JSLINT function itself. That function is also an object that\n// can contain data and other functions.\n\nvar JSLINT = (function () {\n    'use strict';\n\n    function array_to_object(array, value) {\n\n// Make an object from an array of keys and a common value.\n\n        var i, length = array.length, object = Object.create(null);\n        for (i = 0; i < length; i += 1) {\n            object[array[i]] = value;\n        }\n        return object;\n    }\n\n\n    var allowed_option = {\n            ass       : true,\n            bitwise   : true,\n            browser   : true,\n            closure   : true,\n            continue  : true,\n            couch     : true,\n            debug     : true,\n            devel     : true,\n            eqeq      : true,\n            evil      : true,\n            forin     : true,\n            indent    :   10,\n            maxerr    : 1000,\n            maxlen    :  256,\n            newcap    : true,\n            node      : true,\n            nomen     : true,\n            passfail  : true,\n            plusplus  : true,\n            properties: true,\n            regexp    : true,\n            rhino     : true,\n            unparam   : true,\n            sloppy    : true,\n            stupid    : true,\n            sub       : true,\n            todo      : true,\n            vars      : true,\n            white     : true\n        },\n        anonname,       // The guessed name for anonymous functions.\n\n// These are operators that should not be used with the ! operator.\n\n        bang = {\n            '<'  : true,\n            '<=' : true,\n            '==' : true,\n            '===': true,\n            '!==': true,\n            '!=' : true,\n            '>'  : true,\n            '>=' : true,\n            '+'  : true,\n            '-'  : true,\n            '*'  : true,\n            '/'  : true,\n            '%'  : true\n        },\n        begin,          // The root token\n        block_var,     // vars defined in the current block\n\n// browser contains a set of global names that are commonly provided by a\n// web browser environment.\n\n        browser = array_to_object([\n            'clearInterval', 'clearTimeout', 'document', 'event', 'FormData',\n            'frames', 'history', 'Image', 'localStorage', 'location', 'name',\n            'navigator', 'Option', 'parent', 'screen', 'sessionStorage',\n            'setInterval', 'setTimeout', 'Storage', 'window', 'XMLHttpRequest'\n        ], false),\n\n// bundle contains the text messages.\n\n        bundle = {\n            a_label: \"'{a}' is a statement label.\",\n            a_scope: \"'{a}' used out of scope.\",\n            already_defined: \"'{a}' is already defined.\",\n            and: \"The '&&' subexpression should be wrapped in parens.\",\n            assignment_expression: \"Unexpected assignment expression.\",\n            assignment_function_expression: \"Expected an assignment or \" +\n                \"function call and instead saw an expression.\",\n            avoid_a: \"Avoid '{a}'.\",\n            bad_assignment: \"Bad assignment.\",\n            bad_constructor: \"Bad constructor.\",\n            bad_in_a: \"Bad for in variable '{a}'.\",\n            bad_invocation: \"Bad invocation.\",\n            bad_new: \"Do not use 'new' for side effects.\",\n            bad_number: \"Bad number '{a}'.\",\n            bad_operand: \"Bad operand.\",\n            bad_wrap: \"Do not wrap function literals in parens unless they \" +\n                \"are to be immediately invoked.\",\n            combine_var: \"Combine this with the previous 'var' statement.\",\n            conditional_assignment: \"Expected a conditional expression and \" +\n                \"instead saw an assignment.\",\n            confusing_a: \"Confusing use of '{a}'.\",\n            confusing_regexp: \"Confusing regular expression.\",\n            constructor_name_a: \"A constructor name '{a}' should start with \" +\n                \"an uppercase letter.\",\n            control_a: \"Unexpected control character '{a}'.\",\n            dangling_a: \"Unexpected dangling '_' in '{a}'.\",\n            deleted: \"Only properties should be deleted.\",\n            duplicate_a: \"Duplicate '{a}'.\",\n            empty_block: \"Empty block.\",\n            empty_case: \"Empty case.\",\n            empty_class: \"Empty class.\",\n            evil: \"eval is evil.\",\n            expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n            expected_a_b_from_c_d: \"Expected '{a}' to match '{b}' from line \" +\n                \"{c} and instead saw '{d}'.\",\n            expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n            expected_id_a: \"Expected an id, and instead saw #{a}.\",\n            expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n            expected_identifier_a_reserved: \"Expected an identifier and \" +\n                \"instead saw '{a}' (a reserved word).\",\n            expected_number_a: \"Expected a number and instead saw '{a}'.\",\n            expected_operator_a: \"Expected an operator and instead saw '{a}'.\",\n            expected_positive_a: \"Expected a positive number and instead saw '{a}'\",\n            expected_small_a: \"Expected a small positive integer and instead saw '{a}'\",\n            expected_space_a_b: \"Expected exactly one space between '{a}' and '{b}'.\",\n            expected_string_a: \"Expected a string and instead saw '{a}'.\",\n            for_if: \"The body of a for in should be wrapped in an if \" +\n                \"statement to filter unwanted properties from the prototype.\",\n            function_block: \"Function statements should not be placed in blocks.\" +\n                \"Use a function expression or move the statement to the top of \" +\n                \"the outer function.\",\n            function_eval: \"The Function constructor is eval.\",\n            function_loop: \"Don't make functions within a loop.\",\n            function_statement: \"Function statements are not invocable. \" +\n                \"Wrap the whole function invocation in parens.\",\n            function_strict: \"Use the function form of 'use strict'.\",\n            identifier_function: \"Expected an identifier in an assignment \" +\n                \"and instead saw a function invocation.\",\n            implied_evil: \"Implied eval is evil. Pass a function instead of a string.\",\n            infix_in: \"Unexpected 'in'. Compare with undefined, or use the \" +\n                \"hasOwnProperty method instead.\",\n            insecure_a: \"Insecure '{a}'.\",\n            isNaN: \"Use the isNaN function to compare with NaN.\",\n            leading_decimal_a: \"A leading decimal point can be confused with a dot: '.{a}'.\",\n            missing_a: \"Missing '{a}'.\",\n            missing_a_after_b: \"Missing '{a}' after '{b}'.\",\n            missing_property: \"Missing property name.\",\n            missing_space_a_b: \"Missing space between '{a}' and '{b}'.\",\n            missing_use_strict: \"Missing 'use strict' statement.\",\n            move_invocation: \"Move the invocation into the parens that \" +\n                \"contain the function.\",\n            move_var: \"Move 'var' declarations to the top of the function.\",\n            name_function: \"Missing name in function statement.\",\n            nested_comment: \"Nested comment.\",\n            not: \"Nested not.\",\n            not_a_constructor: \"Do not use {a} as a constructor.\",\n            not_a_defined: \"'{a}' has not been fully defined yet.\",\n            not_a_function: \"'{a}' is not a function.\",\n            not_a_label: \"'{a}' is not a label.\",\n            not_a_scope: \"'{a}' is out of scope.\",\n            not_greater: \"'{a}' should not be greater than '{b}'.\",\n            octal_a: \"Don't use octal: '{a}'. Use '\\\\u....' instead.\",\n            parameter_arguments_a: \"Do not mutate parameter '{a}' when using 'arguments'.\",\n            parameter_a_get_b: \"Unexpected parameter '{a}' in get {b} function.\",\n            parameter_set_a: \"Expected parameter (value) in set {a} function.\",\n            radix: \"Missing radix parameter.\",\n            read_only: \"Read only.\",\n            redefinition_a_b: \"Redefinition of '{a}' from line {b}.\",\n            reserved_a: \"Reserved name '{a}'.\",\n            scanned_a_b: \"{a} ({b}% scanned).\",\n            slash_equal: \"A regular expression literal can be confused with '/='.\",\n            statement_block: \"Expected to see a statement and instead saw a block.\",\n            stopping: \"Stopping.\",\n            strange_loop: \"Strange loop.\",\n            strict: \"Strict violation.\",\n            subscript: \"['{a}'] is better written in dot notation.\",\n            sync_a: \"Unexpected sync method: '{a}'.\",\n            tag_a_in_b: \"A '<{a}>' must be within '<{b}>'.\",\n            todo_comment: \"Unexpected TODO comment.\",\n            too_long: \"Line too long.\",\n            too_many: \"Too many errors.\",\n            trailing_decimal_a: \"A trailing decimal point can be confused \" +\n                \"with a dot: '.{a}'.\",\n            unclosed: \"Unclosed string.\",\n            unclosed_comment: \"Unclosed comment.\",\n            unclosed_regexp: \"Unclosed regular expression.\",\n            unescaped_a: \"Unescaped '{a}'.\",\n            unexpected_a: \"Unexpected '{a}'.\",\n            unexpected_char_a: \"Unexpected character '{a}'.\",\n            unexpected_comment: \"Unexpected comment.\",\n            unexpected_label_a: \"Unexpected label '{a}'.\",\n            unexpected_property_a: \"Unexpected /*property*/ '{a}'.\",\n            unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n            unexpected_typeof_a: \"Unexpected 'typeof'. \" +\n                \"Use '===' to compare directly with {a}.\",\n            uninitialized_a: \"Uninitialized '{a}'.\",\n            unnecessary_else: \"Unnecessary 'else' after disruption.\",\n            unnecessary_initialize: \"It is not necessary to initialize '{a}' \" +\n                \"to 'undefined'.\",\n            unnecessary_use: \"Unnecessary 'use strict'.\",\n            unreachable_a_b: \"Unreachable '{a}' after '{b}'.\",\n            unsafe: \"Unsafe character.\",\n            unused_a: \"Unused '{a}'.\",\n            url: \"JavaScript URL.\",\n            use_array: \"Use the array literal notation [].\",\n            use_braces: \"Spaces are hard to count. Use {{a}}.\",\n            use_object: \"Use the object literal notation {} or Object.create(null).\",\n            use_or: \"Use the || operator.\",\n            use_param: \"Use a named parameter.\",\n            use_spaces: \"Use spaces, not tabs.\",\n            used_before_a: \"'{a}' was used before it was defined.\",\n            var_a_not: \"Variable {a} was not declared correctly.\",\n            var_loop: \"Don't declare variables in a loop.\",\n            weird_assignment: \"Weird assignment.\",\n            weird_condition: \"Weird condition.\",\n            weird_new: \"Weird construction. Delete 'new'.\",\n            weird_program: \"Weird program.\",\n            weird_relation: \"Weird relation.\",\n            weird_ternary: \"Weird ternary.\",\n            wrap_immediate: \"Wrap an immediate function invocation in \" +\n                \"parentheses to assist the reader in understanding that the \" +\n                \"expression is the result of a function, and not the \" +\n                \"function itself.\",\n            wrap_regexp: \"Wrap the /regexp/ literal in parens to \" +\n                \"disambiguate the slash operator.\",\n            write_is_wrong: \"document.write can be a form of eval.\"\n        },\n        closure = array_to_object([\n            'goog'\n        ], false),\n        comments,\n        comments_off,\n        couch = array_to_object([\n            'emit', 'getRow', 'isArray', 'log', 'provides', 'registerType',\n            'require', 'send', 'start', 'sum', 'toJSON'\n        ], false),\n\n        descapes = {\n            'b': '\\b',\n            't': '\\t',\n            'n': '\\n',\n            'f': '\\f',\n            'r': '\\r',\n            '\"': '\"',\n            '/': '/',\n            '\\\\': '\\\\',\n            '!': '!'\n        },\n\n        devel = array_to_object([\n            'alert', 'confirm', 'console', 'Debug', 'opera', 'prompt', 'WSH'\n        ], false),\n        directive,\n        escapes = {\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\\'': '\\\\\\'',\n            '\"' : '\\\\\"',\n            '/' : '\\\\/',\n            '\\\\': '\\\\\\\\'\n        },\n\n        funct,          // The current function\n\n        functions,      // All of the functions\n        global_funct,   // The global body\n        global_scope,   // The global scope\n        in_block,       // Where function statements are not allowed\n        indent,\n        itself,         // JSLINT itself\n        json_mode,\n        lex,            // the tokenizer\n        lines,\n        lookahead,\n        node = array_to_object([\n            'Buffer', 'clearImmediate', 'clearInterval', 'clearTimeout',\n            'console', 'exports', 'global', 'module', 'process', 'querystring',\n            'require', 'setImmediate', 'setInterval', 'setTimeout',\n            '__dirname', '__filename'\n        ], false),\n        node_js,\n        numbery = array_to_object(['indexOf', 'lastIndexOf', 'search'], true),\n        next_token,\n        option,\n        predefined,     // Global variables defined by option\n        prereg,\n        prev_token,\n        property,\n        protosymbol,\n        regexp_flag = array_to_object(['g', 'i', 'm'], true),\n        return_this = function return_this() {\n            return this;\n        },\n        rhino = array_to_object([\n            'defineClass', 'deserialize', 'gc', 'help', 'load', 'loadClass',\n            'print', 'quit', 'readFile', 'readUrl', 'runCommand', 'seal',\n            'serialize', 'spawn', 'sync', 'toint32', 'version'\n        ], false),\n\n        scope,      // An object containing an object for each variable in scope\n        semicolon_coda = array_to_object([';', '\"', '\\'', ')'], true),\n\n// standard contains the global names that are provided by the\n// ECMAScript standard.\n\n        standard = array_to_object([\n            'Array', 'Boolean', 'Date', 'decodeURI', 'decodeURIComponent',\n            'encodeURI', 'encodeURIComponent', 'Error', 'eval', 'EvalError',\n            'Function', 'isFinite', 'isNaN', 'JSON', 'Map', 'Math', 'Number',\n            'Object', 'parseInt', 'parseFloat', 'Promise', 'Proxy',\n            'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set',\n            'String', 'Symbol', 'SyntaxError', 'System', 'TypeError',\n            'URIError', 'WeakMap', 'WeakSet'\n        ], false),\n\n        strict_mode,\n        syntax = Object.create(null),\n        token,\n        tokens,\n        var_mode,\n        warnings,\n\n// Regular expressions. Some of these are stupidly long.\n\n// carriage return, carriage return linefeed, or linefeed\n        crlfx = /\\r\\n?|\\n/,\n// unsafe characters that are silently deleted by one or more browsers\n        cx = /[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n// identifier\n        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,\n// javascript url\n        jx = /^(?:javascript|jscript|ecmascript|vbscript)\\s*:/i,\n// star slash\n        lx = /\\*\\/|\\/\\*/,\n// characters in strings that need escapement\n        nx = /[\\u0000-\\u001f'\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n// sync\n        syx = /Sync$/,\n// comment todo\n        tox = /^\\W*to\\s*do(?:\\W|$)/i,\n// token\n        tx = /^\\s*([(){}\\[\\]\\?.,:;'\"~#@`]|={1,3}|\\/(\\*(jslint|properties|property|members?|globals?)?|=|\\/)?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|[\\^%]=?|&[&=]?|\\|[|=]?|>{1,3}=?|<(?:[\\/=!]|\\!(\\[|--)?|<=?)?|\\!(\\!|==?)?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+(?:[xX][0-9a-fA-F]+|\\.[0-9]*)?(?:[eE][+\\-]?[0-9]+)?)/;\n\n\n    if (typeof String.prototype.entityify !== 'function') {\n        String.prototype.entityify = function () {\n            return this\n                .replace(/&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;');\n        };\n    }\n\n    if (typeof String.prototype.isAlpha !== 'function') {\n        String.prototype.isAlpha = function () {\n            return (this >= 'a' && this <= 'z\\uffff') ||\n                (this >= 'A' && this <= 'Z\\uffff');\n        };\n    }\n\n    if (typeof String.prototype.isDigit !== 'function') {\n        String.prototype.isDigit = function () {\n            return (this >= '0' && this <= '9');\n        };\n    }\n\n    if (typeof String.prototype.supplant !== 'function') {\n        String.prototype.supplant = function (o) {\n            return this.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n                var replacement = o[b];\n                return typeof replacement === 'string' ||\n                    typeof replacement === 'number' ? replacement : a;\n            });\n        };\n    }\n\n\n    function sanitize(a) {\n\n//  Escapify a troublesome character.\n\n        return escapes[a] ||\n            '\\\\u' + ('0000' + a.charCodeAt().toString(16)).slice(-4);\n    }\n\n\n    function add_to_predefined(group) {\n        Object.keys(group).forEach(function (name) {\n            predefined[name] = group[name];\n        });\n    }\n\n\n    function assume() {\n        if (option.browser) {\n            add_to_predefined(browser);\n            option.browser = false;\n        }\n        if (option.closure) {\n            add_to_predefined(closure);\n        }\n        if (option.couch) {\n            add_to_predefined(couch);\n            option.couch = false;\n        }\n        if (option.devel) {\n            add_to_predefined(devel);\n            option.devel = false;\n        }\n        if (option.node) {\n            add_to_predefined(node);\n            option.node = false;\n            node_js = true;\n        }\n        if (option.rhino) {\n            add_to_predefined(rhino);\n            option.rhino = false;\n        }\n    }\n\n\n// Produce an error warning.\n\n    function artifact(tok) {\n        if (!tok) {\n            tok = next_token;\n        }\n        return tok.id === '(number)' ? tok.number : tok.string;\n    }\n\n    function quit(message, line, character) {\n        throw {\n            name: 'JSLintError',\n            line: line,\n            character: character,\n            message: bundle.scanned_a_b.supplant({\n                a: bundle[message] || message,\n                b: Math.floor((line / lines.length) * 100)\n            })\n        };\n    }\n\n    function warn(code, line, character, a, b, c, d) {\n        var warning = {         // ~~\n            id: '(error)',\n            raw: bundle[code] || code,\n            code: code,\n            evidence: lines[line - 1] || '',\n            line: line,\n            character: character,\n            a: a || artifact(this),\n            b: b,\n            c: c,\n            d: d\n        };\n        warning.reason = warning.raw.supplant(warning);\n        itself.errors.push(warning);\n        if (option.passfail) {\n            quit('stopping', line, character);\n        }\n        warnings += 1;\n        if (warnings >= option.maxerr) {\n            quit('too_many', line, character);\n        }\n        return warning;\n    }\n\n    function stop(code, line, character, a, b, c, d) {\n        var warning = warn(code, line, character, a, b, c, d);\n        quit('stopping', warning.line, warning.character);\n    }\n\n    function expected_at(at) {\n        if (!option.white && next_token.from !== at) {\n            next_token.warn('expected_a_at_b_c', '', at, next_token.from);\n        }\n    }\n\n// lexical analysis and token construction\n\n    lex = (function lex() {\n        var character, c, from, length, line, pos, source_row;\n\n// Private lex methods\n\n        function next_line() {\n            var at;\n            character = 1;\n            source_row = lines[line];\n            line += 1;\n            if (source_row === undefined) {\n                return false;\n            }\n            at = source_row.search(/\\t/);\n            if (at >= 0) {\n                if (option.white) {\n                    source_row = source_row.replace(/\\t/g, ' ');\n                } else {\n                    warn('use_spaces', line, at + 1);\n                }\n            }\n            at = source_row.search(cx);\n            if (at >= 0) {\n                warn('unsafe', line, at);\n            }\n            if (option.maxlen && option.maxlen < source_row.length) {\n                warn('too_long', line, source_row.length);\n            }\n            return true;\n        }\n\n// Produce a token object.  The token inherits from a syntax symbol.\n\n        function it(type, value) {\n            var id, the_token;\n            if (type === '(string)') {\n                if (jx.test(value)) {\n                    warn('url', line, from);\n                }\n            }\n            the_token = Object.create(syntax[(\n                type === '(punctuator)' || (type === '(identifier)' &&\n                        Object.prototype.hasOwnProperty.call(syntax, value))\n                    ? value\n                    : type\n            )] || syntax['(error)']);\n            if (type === '(identifier)') {\n                the_token.identifier = true;\n                if (value === '__iterator__' || value === '__proto__') {\n                    stop('reserved_a', line, from, value);\n                } else if (!option.nomen &&\n                        (value.charAt(0) === '_' ||\n                        value.charAt(value.length - 1) === '_')) {\n                    warn('dangling_a', line, from, value);\n                }\n            }\n            if (type === '(number)') {\n                the_token.number = +value;\n            } else if (value !== undefined) {\n                the_token.string = String(value);\n            }\n            the_token.line = line;\n            the_token.from = from;\n            the_token.thru = character;\n            if (comments.length) {\n                the_token.comments = comments;\n                comments = [];\n            }\n            id = the_token.id;\n            prereg = id && (\n                ('(,=:[!&|?{};~+-*%^<>'.indexOf(id.charAt(id.length - 1)) >= 0) ||\n                id === 'return' || id === 'case'\n            );\n            return the_token;\n        }\n\n        function match(x) {\n            var exec = x.exec(source_row), first;\n            if (exec) {\n                length = exec[0].length;\n                first = exec[1];\n                c = first.charAt(0);\n                source_row = source_row.slice(length);\n                from = character + length - first.length;\n                character += length;\n                return first;\n            }\n            for (;;) {\n                if (!source_row) {\n                    if (!option.white) {\n                        warn('unexpected_char_a', line, character - 1, '(space)');\n                    }\n                    return;\n                }\n                c = source_row.charAt(0);\n                if (c !== ' ') {\n                    break;\n                }\n                source_row = source_row.slice(1);\n                character += 1;\n            }\n            stop('unexpected_char_a', line, character, c);\n\n        }\n\n        function string(x) {\n            var ch, at = 0, r = '', result;\n\n            function hex(n) {\n                var i = parseInt(source_row.substr(at + 1, n), 16);\n                at += n;\n                if (i >= 32 && i <= 126 &&\n                        i !== 34 && i !== 92 && i !== 39) {\n                    warn('unexpected_a', line, character, '\\\\');\n                }\n                character += n;\n                ch = String.fromCharCode(i);\n            }\n\n            if (json_mode && x !== '\"') {\n                warn('expected_a_b', line, character, '\"', x);\n            }\n\n            for (;;) {\n                while (at >= source_row.length) {\n                    at = 0;\n                    if (!next_line()) {\n                        stop('unclosed', line - 1, from);\n                    }\n                }\n                ch = source_row.charAt(at);\n                if (ch === x) {\n                    character += 1;\n                    source_row = source_row.slice(at + 1);\n                    result = it('(string)', r);\n                    result.quote = x;\n                    return result;\n                }\n                if (ch < ' ') {\n                    if (ch === '\\n' || ch === '\\r') {\n                        break;\n                    }\n                    warn('control_a', line, character + at,\n                        source_row.slice(0, at));\n                } else if (ch === '\\\\') {\n                    at += 1;\n                    character += 1;\n                    ch = source_row.charAt(at);\n                    switch (ch) {\n                    case '':\n                        warn('unexpected_a', line, character, '\\\\');\n                        next_line();\n                        at = -1;\n                        break;\n                    case '\\'':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\\\'');\n                        }\n                        break;\n                    case 'u':\n                        hex(4);\n                        break;\n                    case 'v':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\v');\n                        }\n                        ch = '\\v';\n                        break;\n                    case 'x':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\x');\n                        }\n                        hex(2);\n                        break;\n                    default:\n                        if (typeof descapes[ch] !== 'string') {\n                            warn(ch >= '0' && ch <= '7' ? 'octal_a' : 'unexpected_a',\n                                line, character, '\\\\' + ch);\n                        } else {\n                            ch = descapes[ch];\n                        }\n                    }\n                }\n                r += ch;\n                character += 1;\n                at += 1;\n            }\n        }\n\n        function number(snippet) {\n            var digit;\n            if (source_row.charAt(0).isAlpha()) {\n                warn('expected_space_a_b',\n                    line, character, c, source_row.charAt(0));\n            }\n            if (c === '0') {\n                digit = snippet.charAt(1);\n                if (digit.isDigit()) {\n                    if (token.id !== '.') {\n                        warn('unexpected_a', line, character, snippet);\n                    }\n                } else if (json_mode && (digit === 'x' || digit === 'X')) {\n                    warn('unexpected_a', line, character, '0x');\n                }\n            }\n            if (snippet.slice(snippet.length - 1) === '.') {\n                warn('trailing_decimal_a', line, character, snippet);\n            }\n            digit = +snippet;\n            if (!isFinite(digit)) {\n                warn('bad_number', line, character, snippet);\n            }\n            snippet = digit;\n            return it('(number)', snippet);\n        }\n\n        function comment(snippet, type) {\n            if (comments_off) {\n                warn('unexpected_comment', line, character);\n            } else if (!option.todo && tox.test(snippet)) {\n                warn('todo_comment', line, character);\n            }\n            comments.push({\n                id: type,\n                from: from,\n                thru: character,\n                line: line,\n                string: snippet\n            });\n        }\n\n        function regexp() {\n            var at = 0,\n                b,\n                bit,\n                depth = 0,\n                flag = '',\n                high,\n                letter,\n                low,\n                potential,\n                quote,\n                result;\n            for (;;) {\n                b = true;\n                c = source_row.charAt(at);\n                at += 1;\n                switch (c) {\n                case '':\n                    stop('unclosed_regexp', line, from);\n                    return;\n                case '/':\n                    if (depth > 0) {\n                        warn('unescaped_a', line, from + at, '/');\n                    }\n                    c = source_row.slice(0, at - 1);\n                    potential = Object.create(regexp_flag);\n                    for (;;) {\n                        letter = source_row.charAt(at);\n                        if (potential[letter] !== true) {\n                            break;\n                        }\n                        potential[letter] = false;\n                        at += 1;\n                        flag += letter;\n                    }\n                    if (source_row.charAt(at).isAlpha()) {\n                        stop('unexpected_a', line, from, source_row.charAt(at));\n                    }\n                    character += at;\n                    source_row = source_row.slice(at);\n                    quote = source_row.charAt(0);\n                    if (quote === '/' || quote === '*') {\n                        stop('confusing_regexp', line, from);\n                    }\n                    result = it('(regexp)', c);\n                    result.flag = flag;\n                    return result;\n                case '\\\\':\n                    c = source_row.charAt(at);\n                    if (c < ' ') {\n                        warn('control_a', line, from + at, String(c));\n                    } else if (c === '<') {\n                        warn('unexpected_a', line, from + at, '\\\\');\n                    }\n                    at += 1;\n                    break;\n                case '(':\n                    depth += 1;\n                    b = false;\n                    if (source_row.charAt(at) === '?') {\n                        at += 1;\n                        switch (source_row.charAt(at)) {\n                        case ':':\n                        case '=':\n                        case '!':\n                            at += 1;\n                            break;\n                        default:\n                            warn('expected_a_b', line, from + at,\n                                ':', source_row.charAt(at));\n                        }\n                    }\n                    break;\n                case '|':\n                    b = false;\n                    break;\n                case ')':\n                    if (depth === 0) {\n                        warn('unescaped_a', line, from + at, ')');\n                    } else {\n                        depth -= 1;\n                    }\n                    break;\n                case ' ':\n                    pos = 1;\n                    while (source_row.charAt(at) === ' ') {\n                        at += 1;\n                        pos += 1;\n                    }\n                    if (pos > 1) {\n                        warn('use_braces', line, from + at, pos);\n                    }\n                    break;\n                case '[':\n                    c = source_row.charAt(at);\n                    if (c === '^') {\n                        at += 1;\n                        if (!option.regexp) {\n                            warn('insecure_a', line, from + at, c);\n                        } else if (source_row.charAt(at) === ']') {\n                            stop('unescaped_a', line, from + at, '^');\n                        }\n                    }\n                    bit = false;\n                    if (c === ']') {\n                        warn('empty_class', line, from + at - 1);\n                        bit = true;\n                    }\nklass:              do {\n                        c = source_row.charAt(at);\n                        at += 1;\n                        switch (c) {\n                        case '[':\n                        case '^':\n                            warn('unescaped_a', line, from + at, c);\n                            bit = true;\n                            break;\n                        case '-':\n                            if (bit) {\n                                bit = false;\n                            } else {\n                                warn('unescaped_a', line, from + at, '-');\n                                bit = true;\n                            }\n                            break;\n                        case ']':\n                            if (!bit) {\n                                warn('unescaped_a', line, from + at - 1, '-');\n                            }\n                            break klass;\n                        case '\\\\':\n                            c = source_row.charAt(at);\n                            if (c < ' ') {\n                                warn('control_a', line, from + at, String(c));\n                            } else if (c === '<') {\n                                warn('unexpected_a', line, from + at, '\\\\');\n                            }\n                            at += 1;\n                            bit = true;\n                            break;\n                        case '/':\n                            warn('unescaped_a', line, from + at - 1, '/');\n                            bit = true;\n                            break;\n                        default:\n                            bit = true;\n                        }\n                    } while (c);\n                    break;\n                case '.':\n                    if (!option.regexp) {\n                        warn('insecure_a', line, from + at, c);\n                    }\n                    break;\n                case ']':\n                case '?':\n                case '{':\n                case '}':\n                case '+':\n                case '*':\n                    warn('unescaped_a', line, from + at, c);\n                    break;\n                }\n                if (b) {\n                    switch (source_row.charAt(at)) {\n                    case '?':\n                    case '+':\n                    case '*':\n                        at += 1;\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        break;\n                    case '{':\n                        at += 1;\n                        c = source_row.charAt(at);\n                        if (c < '0' || c > '9') {\n                            warn('expected_number_a', line,\n                                from + at, c);\n                        }\n                        at += 1;\n                        low = +c;\n                        for (;;) {\n                            c = source_row.charAt(at);\n                            if (c < '0' || c > '9') {\n                                break;\n                            }\n                            at += 1;\n                            low = +c + (low * 10);\n                        }\n                        high = low;\n                        if (c === ',') {\n                            at += 1;\n                            high = Infinity;\n                            c = source_row.charAt(at);\n                            if (c >= '0' && c <= '9') {\n                                at += 1;\n                                high = +c;\n                                for (;;) {\n                                    c = source_row.charAt(at);\n                                    if (c < '0' || c > '9') {\n                                        break;\n                                    }\n                                    at += 1;\n                                    high = +c + (high * 10);\n                                }\n                            }\n                        }\n                        if (source_row.charAt(at) !== '}') {\n                            warn('expected_a_b', line, from + at,\n                                '}', c);\n                        } else {\n                            at += 1;\n                        }\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        if (low > high) {\n                            warn('not_greater', line, from + at,\n                                low, high);\n                        }\n                        break;\n                    }\n                }\n            }\n            c = source_row.slice(0, at - 1);\n            character += at;\n            source_row = source_row.slice(at);\n            return it('(regexp)', c);\n        }\n\n// Public lex methods\n\n        return {\n            init: function (source) {\n                if (typeof source === 'string') {\n                    lines = source.split(crlfx);\n                } else {\n                    lines = source;\n                }\n                line = 0;\n                next_line();\n                from = 1;\n            },\n\n// token -- this is called by advance to get the next token.\n\n            token: function () {\n                var first, i, snippet;\n\n                for (;;) {\n                    while (!source_row) {\n                        if (!next_line()) {\n                            return it('(end)');\n                        }\n                    }\n                    snippet = match(tx);\n                    if (snippet) {\n\n//      identifier\n\n                        first = snippet.charAt(0);\n                        if (first.isAlpha() || first === '_' || first === '$') {\n                            return it('(identifier)', snippet);\n                        }\n\n//      number\n\n                        if (first.isDigit()) {\n                            return number(snippet);\n                        }\n                        switch (snippet) {\n\n//      string\n\n                        case '\"':\n                        case \"'\":\n                            return string(snippet);\n\n//      // comment\n\n                        case '//':\n                            comment(source_row, '//');\n                            source_row = '';\n                            break;\n\n//      /* comment\n\n                        case '/*':\n                            for (;;) {\n                                i = source_row.search(lx);\n                                if (i >= 0) {\n                                    break;\n                                }\n                                character = source_row.length;\n                                comment(source_row);\n                                from = 0;\n                                if (!next_line()) {\n                                    stop('unclosed_comment', line, character);\n                                }\n                            }\n                            comment(source_row.slice(0, i), '/*');\n                            character += i + 2;\n                            if (source_row.charAt(i) === '/') {\n                                stop('nested_comment', line, character);\n                            }\n                            source_row = source_row.slice(i + 2);\n                            break;\n\n                        case '':\n                            break;\n//      /\n                        case '/':\n                            if (token.id === '/=') {\n                                stop('slash_equal', line, from);\n                            }\n                            return prereg\n                                ? regexp()\n                                : it('(punctuator)', snippet);\n\n//      punctuator\n                        default:\n                            return it('(punctuator)', snippet);\n                        }\n                    }\n                }\n            }\n        };\n    }());\n\n    function define(kind, token) {\n\n// Define a name.\n\n        var name = token.string,\n            master = scope[name];       // The current definition of the name\n\n// vars are created with a deadzone, so that the expression that initializes\n// the var cannot access the var. Functions are not writeable.\n\n        token.dead = false;\n        token.init = false;\n        token.kind = kind;\n        token.master = master;\n        token.used = 0;\n        token.writeable = true;\n\n// Global variables are a little weird. They can be defined multiple times.\n// Some predefined global vars are (or should) not be writeable.\n\n        if (kind === 'var' && funct === global_funct) {\n            if (!master) {\n                if (predefined[name] === false) {\n                    token.writeable = false;\n                }\n                global_scope[name] = token;\n            }\n        } else {\n\n// It is an error if the name has already been defined in this scope, except\n// when reusing an exception variable name.\n\n            if (master) {\n                if (master.function === funct) {\n                    if (master.kind !== 'exception' || kind !== 'exception' ||\n                            !master.dead) {\n                        token.warn('already_defined', name);\n                    }\n                } else if (master.function !== global_funct) {\n                    if (kind === 'var') {\n                        token.warn('redefinition_a_b', name, master.line);\n                    }\n                }\n            }\n            scope[name] = token;\n            if (kind === 'var') {\n                block_var.push(name);\n            }\n        }\n    }\n\n    function peek(distance) {\n\n// Peek ahead to a future token. The distance is how far ahead to look. The\n// default is the next token.\n\n        var found, slot = 0;\n\n        distance = distance || 0;\n        while (slot <= distance) {\n            found = lookahead[slot];\n            if (!found) {\n                found = lookahead[slot] = lex.token();\n            }\n            slot += 1;\n        }\n        return found;\n    }\n\n\n    function advance(id, match) {\n\n// Produce the next token, also looking for programming errors.\n\n        if (indent) {\n\n// If indentation checking was requested, then inspect all of the line breakings.\n// The var statement is tricky because the names might be aligned or not. We\n// look at the first line break after the var to determine the programmer's\n// intention.\n\n            if (var_mode && next_token.line !== token.line) {\n                if ((var_mode !== indent || !next_token.edge) &&\n                        next_token.from === indent.at -\n                        (next_token.edge ? option.indent : 0)) {\n                    var dent = indent;\n                    for (;;) {\n                        dent.at -= option.indent;\n                        if (dent === var_mode) {\n                            break;\n                        }\n                        dent = dent.was;\n                    }\n                    dent.open = false;\n                }\n                var_mode = null;\n            }\n            if (next_token.id === '?' && indent.mode === ':' &&\n                    token.line !== next_token.line) {\n                indent.at -= option.indent;\n            }\n            if (indent.open) {\n\n// If the token is an edge.\n\n                if (next_token.edge) {\n                    if (next_token.edge === 'label') {\n                        expected_at(1);\n                    } else if (next_token.edge === 'case' || indent.mode === 'statement') {\n                        expected_at(indent.at - option.indent);\n                    } else if (indent.mode !== 'array' || next_token.line !== token.line) {\n                        expected_at(indent.at);\n                    }\n\n// If the token is not an edge, but is the first token on the line.\n\n                } else if (next_token.line !== token.line) {\n                    if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                    indent.wrap = true;\n                }\n            } else if (next_token.line !== token.line) {\n                if (next_token.edge) {\n                    expected_at(indent.at);\n                } else {\n                    indent.wrap = true;\n                    if (indent.mode === 'statement' || indent.mode === 'var') {\n                        expected_at(indent.at + option.indent);\n                    } else if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                }\n            }\n        }\n\n        switch (token.id) {\n        case '(number)':\n            if (next_token.id === '.') {\n                next_token.warn('trailing_decimal_a');\n            }\n            break;\n        case '-':\n            if (next_token.id === '-' || next_token.id === '--') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        case '+':\n            if (next_token.id === '+' || next_token.id === '++') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        }\n        if (token.id === '(string)' || token.identifier) {\n            anonname = token.string;\n        }\n\n        if (id && next_token.id !== id) {\n            if (match) {\n                next_token.warn('expected_a_b_from_c_d', id,\n                    match.id, match.line, artifact());\n            } else if (!next_token.identifier || next_token.string !== id) {\n                next_token.warn('expected_a_b', id, artifact());\n            }\n        }\n        prev_token = token;\n        token = next_token;\n        next_token = lookahead.shift() || lex.token();\n        next_token.function = funct;\n        tokens.push(next_token);\n    }\n\n\n    function do_globals() {\n        var name, writeable;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            writeable = false;\n            if (next_token.id === ':') {\n                advance(':');\n                switch (next_token.id) {\n                case 'true':\n                    writeable = predefined[name] !== false;\n                    advance('true');\n                    break;\n                case 'false':\n                    advance('false');\n                    break;\n                default:\n                    next_token.stop('unexpected_a');\n                }\n            }\n            predefined[name] = writeable;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    function do_jslint() {\n        var name, value;\n        while (next_token.id === '(string)' || next_token.identifier) {\n            name = next_token.string;\n            if (!allowed_option[name]) {\n                next_token.stop('unexpected_a');\n            }\n            advance();\n            if (next_token.id !== ':') {\n                next_token.stop('expected_a_b', ':', artifact());\n            }\n            advance(':');\n            if (typeof allowed_option[name] === 'number') {\n                value = next_token.number;\n                if (value > allowed_option[name] || value <= 0 ||\n                        Math.floor(value) !== value) {\n                    next_token.stop('expected_small_a');\n                }\n                option[name] = value;\n            } else {\n                if (next_token.id === 'true') {\n                    option[name] = true;\n                } else if (next_token.id === 'false') {\n                    option[name] = false;\n                } else {\n                    next_token.stop('unexpected_a');\n                }\n            }\n            advance();\n            if (next_token.id === ',') {\n                advance(',');\n            }\n        }\n        assume();\n    }\n\n\n    function do_properties() {\n        var name;\n        option.properties = true;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            if (next_token.id === ':') {\n                for (;;) {\n                    advance();\n                    if (next_token.id !== '(string)' && !next_token.identifier) {\n                        break;\n                    }\n                }\n            }\n            property[name] = 0;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    directive = function directive() {\n        var command = this.id,\n            old_comments_off = comments_off,\n            old_indent = indent;\n        comments_off = true;\n        indent = null;\n        if (next_token.line === token.line && next_token.from === token.thru) {\n            next_token.warn('missing_space_a_b', artifact(token), artifact());\n        }\n        if (lookahead.length > 0) {\n            this.warn('unexpected_a');\n        }\n        switch (command) {\n        case '/*properties':\n        case '/*property':\n        case '/*members':\n        case '/*member':\n            do_properties();\n            break;\n        case '/*jslint':\n            do_jslint();\n            break;\n        case '/*globals':\n        case '/*global':\n            do_globals();\n            break;\n        default:\n            this.stop('unexpected_a');\n        }\n        comments_off = old_comments_off;\n        advance('*/');\n        indent = old_indent;\n    };\n\n\n// Indentation intention\n\n    function edge(mode) {\n        next_token.edge = indent ? indent.open && (mode || 'edge') : '';\n    }\n\n\n    function step_in(mode) {\n        var open;\n        if (typeof mode === 'number') {\n            indent = {\n                at: +mode,\n                open: true,\n                was: indent\n            };\n        } else if (!indent) {\n            indent = {\n                at: 1,\n                mode: 'statement',\n                open: true\n            };\n        } else if (mode === 'statement') {\n            indent = {\n                at: indent.at,\n                open: true,\n                was: indent\n            };\n        } else {\n            open = mode === 'var' || next_token.line !== token.line;\n            indent = {\n                at: (open || mode === 'control'\n                    ? indent.at + option.indent\n                    : indent.at) + (indent.wrap ? option.indent : 0),\n                mode: mode,\n                open: open,\n                was: indent\n            };\n            if (mode === 'var' && open) {\n                var_mode = indent;\n            }\n        }\n    }\n\n    function step_out(id, symbol) {\n        if (id) {\n            if (indent && indent.open) {\n                indent.at -= option.indent;\n                edge();\n            }\n            advance(id, symbol);\n        }\n        if (indent) {\n            indent = indent.was;\n        }\n    }\n\n// Functions for conformance of whitespace.\n\n    function one_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && !option.white &&\n                (token.line !== right.line ||\n                token.thru + 1 !== right.from)) {\n            right.warn('expected_space_a_b', artifact(token), artifact(right));\n        }\n    }\n\n    function one_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru + 1 !== right.from))) {\n            right.warn('expected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if ((!option.white) &&\n                left.thru !== right.from && left.line === right.line) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru !== right.from))) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function spaces(left, right) {\n        if (!option.white) {\n            left = left || token;\n            right = right || next_token;\n            if (left.thru === right.from && left.line === right.line) {\n                right.warn('missing_space_a_b', artifact(left), artifact(right));\n            }\n        }\n    }\n\n    function comma() {\n        if (next_token.id !== ',') {\n            warn('expected_a_b', token.line, token.thru, ',', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(',');\n            spaces();\n        }\n    }\n\n\n    function semicolon() {\n        if (next_token.id !== ';') {\n            warn('expected_a_b', token.line, token.thru, ';', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(';');\n            if (semicolon_coda[next_token.id] !== true) {\n                spaces();\n            }\n        }\n    }\n\n    function use_strict() {\n        if (next_token.string === 'use strict') {\n            if (strict_mode) {\n                next_token.warn('unnecessary_use');\n            }\n            edge();\n            advance();\n            semicolon();\n            strict_mode = true;\n            return true;\n        }\n        return false;\n    }\n\n\n    function are_similar(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (Array.isArray(a)) {\n            if (Array.isArray(b) && a.length === b.length) {\n                var i;\n                for (i = 0; i < a.length; i += 1) {\n                    if (!are_similar(a[i], b[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n        if (Array.isArray(b)) {\n            return false;\n        }\n        if (a.id === '(number)' && b.id === '(number)') {\n            return a.number === b.number;\n        }\n        if (a.arity === b.arity && a.string === b.string) {\n            switch (a.arity) {\n            case undefined:\n                return a.string === b.string;\n            case 'prefix':\n            case 'suffix':\n                return a.id === b.id && are_similar(a.first, b.first) &&\n                    a.id !== '{' && a.id !== '[';\n            case 'infix':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second);\n            case 'ternary':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second) &&\n                    are_similar(a.third, b.third);\n            case 'function':\n            case 'regexp':\n                return false;\n            default:\n                return true;\n            }\n        }\n        if (a.id === '.' && b.id === '[' && b.arity === 'infix') {\n            return a.second.string === b.second.string && b.second.id === '(string)';\n        }\n        if (a.id === '[' && a.arity === 'infix' && b.id === '.') {\n            return a.second.string === b.second.string && a.second.id === '(string)';\n        }\n        return false;\n    }\n\n\n// This is the heart of JSLINT, the Pratt parser. In addition to parsing, it\n// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is\n// like .nud except that it is only used on the first token of a statement.\n// Having .fud makes it much easier to define statement-oriented languages like\n// JavaScript. I retained Pratt's nomenclature.\n\n// .nud     Null denotation\n// .fud     First null denotation\n// .led     Left denotation\n//  lbp     Left binding power\n//  rbp     Right binding power\n\n// They are elements of the parsing method called Top Down Operator Precedence.\n\n    function expression(rbp, initial) {\n\n// rbp is the right binding power.\n// initial indicates that this is the first expression of a statement.\n\n        var left;\n        if (next_token.id === '(end)') {\n            token.stop('unexpected_a', next_token.id);\n        }\n        advance();\n        if (initial) {\n            anonname = 'anonymous';\n        }\n        if (initial === true && token.fud) {\n            left = token.fud();\n        } else {\n            if (token.nud) {\n                left = token.nud();\n            } else {\n                if (next_token.id === '(number)' && token.id === '.') {\n                    token.warn('leading_decimal_a', artifact());\n                    advance();\n                    return token;\n                }\n                token.stop('expected_identifier_a', artifact(token));\n            }\n            while (rbp < next_token.lbp) {\n                advance();\n                left = token.led(left);\n            }\n        }\n        if (left && left.assign && !initial) {\n            if (!option.ass) {\n                left.warn('assignment_expression');\n            }\n            if (left.id !== '=' && left.first.master) {\n                left.first.master.used = true;\n            }\n        }\n        return left;\n    }\n\n    protosymbol = {\n        nud: function () {\n            this.stop('unexpected_a');\n        },\n        led: function () {\n            this.stop('expected_operator_a');\n        },\n        warn: function (code, a, b, c, d) {\n            if (!this.warning) {\n                this.warning = warn(code, this.line || 0, this.from || 0,\n                    a || artifact(this), b, c, d);\n            }\n        },\n        stop: function (code, a, b, c, d) {\n            this.warning = undefined;\n            this.warn(code, a, b, c, d);\n            return quit('stopping', this.line, this.character);\n        },\n        lbp: 0\n    };\n\n// Functional constructors for making the symbols that will be inherited by\n// tokens.\n\n    function symbol(s, bp) {\n        var x = syntax[s];\n        if (!x) {\n            x = Object.create(protosymbol);\n            x.id = x.string = s;\n            x.lbp = bp || 0;\n            syntax[s] = x;\n        }\n        return x;\n    }\n\n    function postscript(x) {\n        x.postscript = true;\n        return x;\n    }\n\n    function ultimate(s) {\n        var x = symbol(s, 0);\n        x.from = 1;\n        x.thru = 1;\n        x.line = 0;\n        x.edge = 'edge';\n        x.string = s;\n        return postscript(x);\n    }\n\n    function reserve_name(x) {\n        var c = x.id.charAt(0);\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            x.identifier = x.reserved = true;\n        }\n        return x;\n    }\n\n    function stmt(s, f) {\n        var x = symbol(s);\n        x.fud = f;\n        return reserve_name(x);\n    }\n\n    function disrupt_stmt(s, f) {\n        var x = stmt(s, f);\n        x.disrupt = true;\n    }\n\n    function labeled_stmt(s, f) {\n        var x = stmt(s, f);\n        x.labeled = true;\n    }\n\n    function prefix(s, f) {\n        var x = symbol(s, 150);\n        reserve_name(x);\n        x.nud = function () {\n            var that = this;\n            that.arity = 'prefix';\n            if (typeof f === 'function') {\n                that = f(that);\n                if (that.arity !== 'prefix') {\n                    return that;\n                }\n            } else {\n                if (s === 'typeof') {\n                    one_space();\n                } else {\n                    no_space_only();\n                }\n                that.first = expression(150);\n            }\n            switch (that.id) {\n            case '++':\n            case '--':\n                if (!option.plusplus) {\n                    that.warn('unexpected_a');\n                } else if ((!that.first.identifier || that.first.reserved) &&\n                        that.first.id !== '.' && that.first.id !== '[') {\n                    that.warn('bad_operand');\n                }\n                break;\n            default:\n                if (that.first.arity === 'prefix' ||\n                        that.first.arity === 'function') {\n                    that.warn('unexpected_a');\n                }\n            }\n            return that;\n        };\n        return x;\n    }\n\n\n    function type(s, t, nud) {\n        var x = symbol(s);\n        x.arity = t;\n        if (nud) {\n            x.nud = nud;\n        }\n        return x;\n    }\n\n\n    function reserve(s, f) {\n        var x = symbol(s);\n        x.identifier = x.reserved = true;\n        if (typeof f === 'function') {\n            x.nud = f;\n        }\n        return x;\n    }\n\n\n    function constant(name) {\n        var x = reserve(name);\n        x.string = name;\n        x.nud = return_this;\n        return x;\n    }\n\n\n    function reservevar(s, v) {\n        return reserve(s, function () {\n            if (typeof v === 'function') {\n                v(this);\n            }\n            return this;\n        });\n    }\n\n\n    function infix(s, p, f, w) {\n        var x = symbol(s, p);\n        reserve_name(x);\n        x.led = function (left) {\n            this.arity = 'infix';\n            if (!w) {\n                spaces(prev_token, token);\n                spaces();\n            }\n            if (!option.bitwise && this.bitwise) {\n                this.warn('unexpected_a');\n            }\n            if (typeof f === 'function') {\n                return f(left, this);\n            }\n            this.first = left;\n            this.second = expression(p);\n            return this;\n        };\n        return x;\n    }\n\n    function expected_relation(node, message) {\n        if (node.assign) {\n            node.warn(message || 'conditional_assignment');\n        }\n        return node;\n    }\n\n    function expected_condition(node, message) {\n        switch (node.id) {\n        case '[':\n        case '-':\n            if (node.arity !== 'infix') {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        case 'false':\n        case 'function':\n        case 'Infinity':\n        case 'NaN':\n        case 'null':\n        case 'true':\n        case 'undefined':\n        case 'void':\n        case '(number)':\n        case '(regexp)':\n        case '(string)':\n        case '{':\n        case '?':\n        case '~':\n            node.warn(message || 'weird_condition');\n            break;\n        case '(':\n            if (node.first.id === 'new' ||\n                    (node.first.string === 'Boolean') ||\n                    (node.first.id === '.' &&\n                        numbery[node.first.second.string] === true)) {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        }\n        return node;\n    }\n\n    function check_relation(node) {\n        switch (node.arity) {\n        case 'prefix':\n            switch (node.id) {\n            case '{':\n            case '[':\n                node.warn('unexpected_a');\n                break;\n            case '!':\n                node.warn('confusing_a');\n                break;\n            }\n            break;\n        case 'function':\n        case 'regexp':\n            node.warn('unexpected_a');\n            break;\n        default:\n            if (node.id  === 'NaN') {\n                node.warn('isNaN');\n            } else if (node.relation) {\n                node.warn('weird_relation');\n            }\n        }\n        return node;\n    }\n\n\n    function relation(s, eqeq) {\n        var x = infix(s, 100, function (left, that) {\n            check_relation(left);\n            if (eqeq && !option.eqeq) {\n                that.warn('expected_a_b', eqeq, that.id);\n            }\n            var right = expression(100);\n            if (are_similar(left, right) ||\n                    ((left.id === '(string)' || left.id === '(number)') &&\n                    (right.id === '(string)' || right.id === '(number)'))) {\n                that.warn('weird_relation');\n            } else if (left.id === 'typeof') {\n                if (right.id !== '(string)') {\n                    right.warn(\"expected_string_a\", artifact(right));\n                } else if (right.string === 'undefined' ||\n                        right.string === 'null') {\n                    left.warn(\"unexpected_typeof_a\", right.string);\n                }\n            } else if (right.id === 'typeof') {\n                if (left.id !== '(string)') {\n                    left.warn(\"expected_string_a\", artifact(left));\n                } else if (left.string === 'undefined' ||\n                        left.string === 'null') {\n                    right.warn(\"unexpected_typeof_a\", left.string);\n                }\n            }\n            that.first = left;\n            that.second = check_relation(right);\n            return that;\n        });\n        x.relation = true;\n        return x;\n    }\n\n    function lvalue(that, s) {\n        var master;\n        if (that.identifier) {\n            master = scope[that.string];\n            if (master) {\n                if (scope[that.string].writeable !== true) {\n                    that.warn('read_only');\n                }\n                master.used -= 1;\n                if (s === '=') {\n                    master.init = true;\n                }\n            }\n        } else if (that.id === '.' || that.id === '[') {\n            if (!that.first || that.first.string === 'arguments') {\n                that.warn('bad_assignment');\n            }\n        } else {\n            that.warn('bad_assignment');\n        }\n    }\n\n\n    function assignop(s, op) {\n        var x = infix(s, 20, function (left, that) {\n            var next;\n            that.first = left;\n            lvalue(left, s);\n            that.second = expression(20);\n            if (that.id === '=' && are_similar(that.first, that.second)) {\n                that.warn('weird_assignment');\n            }\n            next = that;\n            while (next_token.id === '=') {\n                lvalue(next.second, '=');\n                next_token.first = next.second;\n                next.second = next_token;\n                next = next_token;\n                advance('=');\n                next.second = expression(20);\n            }\n            return that;\n        });\n        x.assign = true;\n        if (op) {\n            if (syntax[op].bitwise) {\n                x.bitwise = true;\n            }\n        }\n        return x;\n    }\n\n\n    function bitwise(s, p) {\n        var x = infix(s, p, 'number');\n        x.bitwise = true;\n        return x;\n    }\n\n\n    function suffix(s) {\n        var x = symbol(s, 150);\n        x.led = function (left) {\n            no_space_only(prev_token, token);\n            if (!option.plusplus) {\n                this.warn('unexpected_a');\n            } else if ((!left.identifier || left.reserved) &&\n                    left.id !== '.' && left.id !== '[') {\n                this.warn('bad_operand');\n            }\n            this.first = left;\n            this.arity = 'suffix';\n            return this;\n        };\n        return x;\n    }\n\n\n    function optional_identifier(variable) {\n        if (next_token.identifier) {\n            advance();\n            if (token.reserved && variable) {\n                token.warn('expected_identifier_a_reserved');\n            }\n            return token.string;\n        }\n    }\n\n\n    function identifier(variable) {\n        var i = optional_identifier(variable);\n        if (!i) {\n            next_token.stop(token.id === 'function' && next_token.id === '('\n                ? 'name_function'\n                : 'expected_identifier_a');\n        }\n        return i;\n    }\n\n\n    function statement() {\n\n        var label, preamble, the_statement;\n\n// We don't like the empty statement.\n\n        if (next_token.id === ';') {\n            next_token.warn('unexpected_a');\n            semicolon();\n            return;\n        }\n\n// Is this a labeled statement?\n\n        if (next_token.identifier && !next_token.reserved && peek().id === ':') {\n            edge('label');\n            label = next_token;\n            advance();\n            advance(':');\n            define('label', label);\n            if (next_token.labeled !== true || funct === global_funct) {\n                label.stop('unexpected_label_a');\n            } else if (jx.test(label.string + ':')) {\n                label.warn('url');\n            }\n            next_token.label = label;\n            label.init = true;\n        }\n\n// Parse the statement.\n\n        preamble = next_token;\n        if (token.id !== 'else') {\n            edge();\n        }\n        step_in('statement');\n        the_statement = expression(0, true);\n        if (the_statement) {\n\n// Look for the final semicolon.\n\n            if (the_statement.arity === 'statement') {\n                if (the_statement.id === 'switch' ||\n                        (the_statement.block && the_statement.id !== 'do')) {\n                    spaces();\n                } else {\n                    semicolon();\n                }\n            } else {\n\n// If this is an expression statement, determine if it is acceptable.\n// We do not like\n//      new Blah;\n// statements. If it is to be used at all, new should only be used to make\n// objects, not side effects. The expression statements we do like do\n// assignment or invocation or delete.\n\n                if (the_statement.id === '(') {\n                    if (the_statement.first.id === 'new') {\n                        next_token.warn('bad_new');\n                    }\n                } else if (the_statement.id === '++' ||\n                        the_statement.id === '--') {\n                    lvalue(the_statement.first);\n                } else if (!the_statement.assign &&\n                        the_statement.id !== 'delete') {\n                    if (!option.closure || !preamble.comments) {\n                        preamble.warn('assignment_function_expression');\n                    }\n                }\n                semicolon();\n            }\n        }\n        step_out();\n        if (label) {\n            label.dead = true;\n        }\n        return the_statement;\n    }\n\n\n    function statements() {\n        var array = [], disruptor, the_statement;\n\n// A disrupt statement may not be followed by any other statement.\n// If the last statement is disrupt, then the sequence is disrupt.\n\n        while (next_token.postscript !== true) {\n            if (next_token.id === ';') {\n                next_token.warn('unexpected_a');\n                semicolon();\n            } else {\n                if (next_token.string === 'use strict') {\n                    if ((!node_js) || funct !== global_funct || array.length > 0) {\n                        next_token.warn('function_strict');\n                    }\n                    use_strict();\n                }\n                if (disruptor) {\n                    next_token.warn('unreachable_a_b', next_token.string,\n                        disruptor.string);\n                    disruptor = null;\n                }\n                the_statement = statement();\n                if (the_statement) {\n                    array.push(the_statement);\n                    if (the_statement.disrupt) {\n                        disruptor = the_statement;\n                        array.disrupt = true;\n                    }\n                }\n            }\n        }\n        return array;\n    }\n\n\n    function block(kind) {\n\n// A block is a sequence of statements wrapped in braces.\n\n        var array,\n            curly = next_token,\n            old_block_var = block_var,\n            old_in_block = in_block,\n            old_strict_mode = strict_mode;\n\n        in_block = kind !== 'function' && kind !== 'try' && kind !== 'catch';\n        block_var = [];\n        if (curly.id === '{') {\n            spaces();\n            advance('{');\n            step_in();\n            if (kind === 'function' && !use_strict() && !old_strict_mode &&\n                    !option.sloppy && funct.level === 1) {\n                next_token.warn('missing_use_strict');\n            }\n            array = statements();\n            strict_mode = old_strict_mode;\n            step_out('}', curly);\n        } else if (in_block) {\n            curly.stop('expected_a_b', '{', artifact());\n        } else {\n            curly.warn('expected_a_b', '{', artifact());\n            array = [statement()];\n            array.disrupt = array[0].disrupt;\n        }\n        if (kind !== 'catch' && array.length === 0) {\n            curly.warn('empty_block');\n        }\n        block_var.forEach(function (name) {\n            scope[name].dead = true;\n        });\n        block_var = old_block_var;\n        in_block = old_in_block;\n        return array;\n    }\n\n\n    function tally_property(name) {\n        if (option.properties && typeof property[name] !== 'number') {\n            token.warn('unexpected_property_a', name);\n        }\n        if (property[name]) {\n            property[name] += 1;\n        } else {\n            property[name] = 1;\n        }\n    }\n\n\n// ECMAScript parser\n\n    (function () {\n        var x = symbol('(identifier)');\n        x.nud = function () {\n            var name = this.string,\n                master = scope[name],\n                writeable;\n\n// If the master is not in scope, then we may have an undeclared variable.\n// Check the predefined list. If it was predefined, create the global\n// variable.\n\n            if (!master) {\n                writeable = predefined[name];\n                if (typeof writeable === 'boolean') {\n                    global_scope[name] = master = {\n                        dead: false,\n                        function: global_funct,\n                        kind: 'var',\n                        string: name,\n                        writeable: writeable\n                    };\n\n// But if the variable is not in scope, and is not predefined, and if we are not\n// in the global scope, then we have an undefined variable error.\n\n                } else {\n                    token.warn('used_before_a');\n                }\n            } else {\n                this.master = master;\n            }\n\n// Annotate uses that cross scope boundaries.\n\n            if (master) {\n                if (master.kind === 'label') {\n                    this.warn('a_label');\n                } else {\n                    if (master.dead === true || master.dead === funct) {\n                        this.warn('a_scope');\n                    }\n                    master.used += 1;\n                    if (master.function !== funct) {\n                        if (master.function === global_funct) {\n                            funct.global.push(name);\n                        } else {\n                            master.function.closure.push(name);\n                            funct.outer.push(name);\n                        }\n                    }\n                }\n            }\n            return this;\n        };\n        x.identifier = true;\n    }());\n\n\n// Build the syntax table by declaring the syntactic elements.\n\n    type('(array)', 'array');\n    type('(function)', 'function');\n    type('(number)', 'number', return_this);\n    type('(object)', 'object');\n    type('(string)', 'string', return_this);\n    type('(boolean)', 'boolean', return_this);\n    type('(regexp)', 'regexp', return_this);\n\n    ultimate('(begin)');\n    ultimate('(end)');\n    ultimate('(error)');\n    postscript(symbol('}'));\n    symbol(')');\n    symbol(']');\n    postscript(symbol('\"'));\n    postscript(symbol('\\''));\n    symbol(';');\n    symbol(':');\n    symbol(',');\n    symbol('#');\n    symbol('@');\n    symbol('*/');\n    postscript(reserve('case'));\n    reserve('catch');\n    postscript(reserve('default'));\n    reserve('else');\n    reserve('finally');\n\n    reservevar('arguments', function (x) {\n        if (strict_mode && funct === global_funct) {\n            x.warn('strict');\n        }\n        funct.arguments = true;\n    });\n    reservevar('eval');\n    constant('false', 'boolean');\n    constant('Infinity', 'number');\n    constant('NaN', 'number');\n    constant('null', '');\n    reservevar('this', function (x) {\n        if (strict_mode && funct.statement && funct.name.charAt(0) > 'Z') {\n            x.warn('strict');\n        }\n    });\n    constant('true', 'boolean');\n    constant('undefined', '');\n\n    infix('?', 30, function (left, that) {\n        step_in('?');\n        that.first = expected_condition(expected_relation(left));\n        that.second = expression(0);\n        spaces();\n        step_out();\n        var colon = next_token;\n        advance(':');\n        step_in(':');\n        spaces();\n        that.third = expression(10);\n        that.arity = 'ternary';\n        if (are_similar(that.second, that.third)) {\n            colon.warn('weird_ternary');\n        } else if (are_similar(that.first, that.second)) {\n            that.warn('use_or');\n        }\n        step_out();\n        return that;\n    });\n\n    infix('||', 40, function (left, that) {\n        function paren_check(that) {\n            if (that.id === '&&' && !that.paren) {\n                that.warn('and');\n            }\n            return that;\n        }\n\n        that.first = paren_check(expected_condition(expected_relation(left)));\n        that.second = paren_check(expected_relation(expression(40)));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    infix('&&', 50, function (left, that) {\n        that.first = expected_condition(expected_relation(left));\n        that.second = expected_relation(expression(50));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    prefix('void', function (that) {\n        that.first = expression(0);\n        that.warn('expected_a_b', 'undefined', 'void');\n        return that;\n    });\n\n    bitwise('|', 70);\n    bitwise('^', 80);\n    bitwise('&', 90);\n\n    relation('==', '===');\n    relation('===');\n    relation('!=', '!==');\n    relation('!==');\n    relation('<');\n    relation('>');\n    relation('<=');\n    relation('>=');\n\n    bitwise('<<', 120);\n    bitwise('>>', 120);\n    bitwise('>>>', 120);\n\n    infix('in', 120, function (left, that) {\n        that.warn('infix_in');\n        that.left = left;\n        that.right = expression(130);\n        return that;\n    });\n    infix('instanceof', 120);\n    infix('+', 130, function (left, that) {\n        if (left.id === '(number)') {\n            if (left.number === 0) {\n                left.warn('unexpected_a', '0');\n            }\n        } else if (left.id === '(string)') {\n            if (left.string === '') {\n                left.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        var right = expression(130);\n        if (right.id === '(number)') {\n            if (right.number === 0) {\n                right.warn('unexpected_a', '0');\n            }\n        } else if (right.id === '(string)') {\n            if (right.string === '') {\n                right.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        if (left.id === right.id) {\n            if (left.id === '(string)' || left.id === '(number)') {\n                if (left.id === '(string)') {\n                    left.string += right.string;\n                    if (jx.test(left.string)) {\n                        left.warn('url');\n                    }\n                } else {\n                    left.number += right.number;\n                }\n                left.thru = right.thru;\n                return left;\n            }\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('+');\n    prefix('+++', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('+++', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('-', 130, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(130);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number -= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('-');\n    prefix('---', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('---', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('*', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number *= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('/', 140, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number /= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('%', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number %= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n\n    suffix('++');\n    prefix('++');\n\n    suffix('--');\n    prefix('--');\n    prefix('delete', function (that) {\n        one_space();\n        var p = expression(0);\n        if (!p || (p.id !== '.' && p.id !== '[')) {\n            next_token.warn('deleted');\n        }\n        that.first = p;\n        return that;\n    });\n\n\n    prefix('~', function (that) {\n        no_space_only();\n        if (!option.bitwise) {\n            that.warn('unexpected_a');\n        }\n        that.first = expression(150);\n        return that;\n    });\n    function banger(that) {\n        no_space_only();\n        that.first = expected_condition(expression(150));\n        if (bang[that.first.id] === that || that.first.assign) {\n            that.warn('confusing_a');\n        }\n        return that;\n    }\n    prefix('!', banger);\n    prefix('!!', banger);\n    prefix('typeof');\n    prefix('new', function (that) {\n        one_space();\n        var c = expression(160), n, p, v;\n        that.first = c;\n        if (c.id !== 'function') {\n            if (c.identifier) {\n                switch (c.string) {\n                case 'Object':\n                    token.warn('use_object');\n                    break;\n                case 'Array':\n                    if (next_token.id === '(') {\n                        p = next_token;\n                        p.first = this;\n                        advance('(');\n                        if (next_token.id !== ')') {\n                            n = expression(0);\n                            p.second = [n];\n                            if (n.id !== '(number)' || next_token.id === ',') {\n                                p.warn('use_array');\n                            }\n                            while (next_token.id === ',') {\n                                advance(',');\n                                p.second.push(expression(0));\n                            }\n                        } else {\n                            token.warn('use_array');\n                        }\n                        advance(')', p);\n                        return p;\n                    }\n                    token.warn('use_array');\n                    break;\n                case 'Number':\n                case 'String':\n                case 'Boolean':\n                case 'Math':\n                case 'JSON':\n                    c.warn('not_a_constructor');\n                    break;\n                case 'Function':\n                    if (!option.evil) {\n                        next_token.warn('function_eval');\n                    }\n                    break;\n                case 'Date':\n                case 'RegExp':\n                case 'this':\n                    break;\n                default:\n                    if (c.id !== 'function') {\n                        v = c.string.charAt(0);\n                        if (!option.newcap && (v < 'A' || v > 'Z')) {\n                            token.warn('constructor_name_a');\n                        }\n                    }\n                }\n            } else {\n                if (c.id !== '.' && c.id !== '[' && c.id !== '(') {\n                    token.warn('bad_constructor');\n                }\n            }\n        } else {\n            that.warn('weird_new');\n        }\n        if (next_token.id !== '(') {\n            next_token.warn('missing_a', '()');\n        }\n        return that;\n    });\n\n    infix('(', 160, function (left, that) {\n        var e, p;\n        if (indent && indent.mode === 'expression') {\n            no_space(prev_token, token);\n        } else {\n            no_space_only(prev_token, token);\n        }\n        if (!left.immed && left.id === 'function') {\n            next_token.warn('wrap_immediate');\n        }\n        p = [];\n        if (left.identifier) {\n            if (left.string.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {\n                if (left.string !== 'Number' && left.string !== 'String' &&\n                        left.string !== 'Boolean' && left.string !== 'Date') {\n                    if (left.string === 'Math') {\n                        left.warn('not_a_function');\n                    } else if (left.string === 'Object') {\n                        token.warn('use_object');\n                    } else if (left.string === 'Array' || !option.newcap) {\n                        left.warn('missing_a', 'new');\n                    }\n                }\n            } else if (left.string === 'JSON') {\n                left.warn('not_a_function');\n            }\n        } else if (left.id === '.') {\n            if (left.second.string === 'split' &&\n                    left.first.id === '(string)') {\n                left.second.warn('use_array');\n            }\n        }\n        step_in();\n        if (next_token.id !== ')') {\n            no_space();\n            for (;;) {\n                edge();\n                e = expression(10);\n                if (left.string === 'Boolean' && (e.id === '!' || e.id === '~')) {\n                    e.warn('weird_condition');\n                }\n                p.push(e);\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', that);\n        if (typeof left === 'object') {\n            if (left.string === 'parseInt' && p.length === 1) {\n                left.warn('radix');\n            } else if (left.string === 'String' && p.length >= 1 && p[0].id === '(string)') {\n                left.warn('unexpected_a');\n            }\n            if (!option.evil) {\n                if (left.string === 'eval' || left.string === 'Function' ||\n                        left.string === 'execScript') {\n                    left.warn('evil');\n                } else if (p[0] && p[0].id === '(string)' &&\n                        (left.string === 'setTimeout' ||\n                        left.string === 'setInterval')) {\n                    left.warn('implied_evil');\n                }\n            }\n            if (!left.identifier && left.id !== '.' && left.id !== '[' &&\n                    left.id !== '(' && left.id !== '&&' && left.id !== '||' &&\n                    left.id !== '?') {\n                left.warn('bad_invocation');\n            }\n            if (left.id === '.') {\n                if (p.length > 0 &&\n                        left.first && left.first.first &&\n                        are_similar(p[0], left.first.first)) {\n                    if (left.second.string === 'call' ||\n                            (left.second.string === 'apply' && (p.length === 1 ||\n                            (p[1].arity === 'prefix' && p[1].id === '[')))) {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n                if (left.second.string === 'toString') {\n                    if (left.first.id === '(string)' || left.first.id === '(number)') {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n            }\n        }\n        that.first = left;\n        that.second = p;\n        return that;\n    }, true);\n\n    prefix('(', function (that) {\n        step_in('expression');\n        no_space();\n        edge();\n        if (next_token.id === 'function') {\n            next_token.immed = true;\n        }\n        var value = expression(0);\n        value.paren = true;\n        no_space();\n        step_out(')', that);\n        if (value.id === 'function') {\n            switch (next_token.id) {\n            case '(':\n                next_token.warn('move_invocation');\n                break;\n            case '.':\n            case '[':\n                next_token.warn('unexpected_a');\n                break;\n            default:\n                that.warn('bad_wrap');\n            }\n        } else if (!value.arity) {\n            if (!option.closure || !that.comments) {\n                that.warn('unexpected_a');\n            }\n        }\n        return value;\n    });\n\n    infix('.', 170, function (left, that) {\n        no_space(prev_token, token);\n        no_space();\n        var name = identifier();\n        if (typeof name === 'string') {\n            tally_property(name);\n        }\n        that.first = left;\n        that.second = token;\n        if (left && left.string === 'arguments' &&\n                (name === 'callee' || name === 'caller')) {\n            left.warn('avoid_a', 'arguments.' + name);\n        } else if (!option.evil && left && left.string === 'document' &&\n                (name === 'write' || name === 'writeln')) {\n            left.warn('write_is_wrong');\n        } else if (!option.stupid && syx.test(name)) {\n            token.warn('sync_a');\n        }\n        if (!option.evil && (name === 'eval' || name === 'execScript')) {\n            next_token.warn('evil');\n        }\n        return that;\n    }, true);\n\n    infix('[', 170, function (left, that) {\n        var e, s;\n        no_space_only(prev_token, token);\n        no_space();\n        step_in();\n        edge();\n        e = expression(0);\n        switch (e.id) {\n        case '(number)':\n            if (e.id === '(number)' && left.id === 'arguments') {\n                left.warn('use_param');\n            }\n            break;\n        case '(string)':\n            if (!option.evil &&\n                    (e.string === 'eval' || e.string === 'execScript')) {\n                e.warn('evil');\n            } else if (!option.sub && ix.test(e.string)) {\n                s = syntax[e.string];\n                if (!s || !s.reserved) {\n                    e.warn('subscript');\n                }\n            }\n            tally_property(e.string);\n            break;\n        }\n        step_out(']', that);\n        no_space(prev_token, token);\n        that.first = left;\n        that.second = e;\n        return that;\n    }, true);\n\n    prefix('[', function (that) {\n        that.first = [];\n        step_in('array');\n        while (next_token.id !== '(end)') {\n            while (next_token.id === ',') {\n                next_token.warn('unexpected_a');\n                advance(',');\n            }\n            if (next_token.id === ']') {\n                break;\n            }\n            indent.wrap = false;\n            edge();\n            that.first.push(expression(10));\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id === ']') {\n                    token.warn('unexpected_a');\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        step_out(']', that);\n        return that;\n    }, 170);\n\n\n    function property_name() {\n        var id = optional_identifier();\n        if (!id) {\n            if (next_token.id === '(string)') {\n                id = next_token.string;\n                advance();\n            } else if (next_token.id === '(number)') {\n                id = next_token.number.toString();\n                advance();\n            }\n        }\n        return id;\n    }\n\n\n\n    assignop('=');\n    assignop('+=', '+');\n    assignop('-=', '-');\n    assignop('*=', '*');\n    assignop('/=', '/').nud = function () {\n        next_token.stop('slash_equal');\n    };\n    assignop('%=', '%');\n    assignop('&=', '&');\n    assignop('|=', '|');\n    assignop('^=', '^');\n    assignop('<<=', '<<');\n    assignop('>>=', '>>');\n    assignop('>>>=', '>>>');\n\n    function function_parameters() {\n        var id, parameters = [], paren = next_token;\n        advance('(');\n        token.function = funct;\n        step_in();\n        no_space();\n        if (next_token.id !== ')') {\n            for (;;) {\n                edge();\n                id = identifier();\n                define('parameter', token);\n                parameters.push(id);\n                token.init = true;\n                token.writeable = true;\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', paren);\n        return parameters;\n    }\n\n    function do_function(func, name) {\n        var old_funct = funct,\n            old_option = option,\n            old_scope = scope;\n        scope = Object.create(old_scope);\n        funct = {\n            closure: [],\n            global: [],\n            level: old_funct.level + 1,\n            line: next_token.line,\n            loopage: 0,\n            name: name || '\\'' + (anonname || '').replace(nx, sanitize) + '\\'',\n            outer: [],\n            scope: scope\n        };\n        funct.parameter = function_parameters();\n        func.function = funct;\n        option = Object.create(old_option);\n        functions.push(funct);\n        if (name) {\n            func.name = name;\n            func.string = name;\n            define('function', func);\n            func.init = true;\n            func.used += 1;\n        }\n        func.writeable = false;\n        one_space();\n        func.block = block('function');\n        Object.keys(scope).forEach(function (name) {\n            var master = scope[name];\n            if (!master.used && master.kind !== 'exception' &&\n                    (master.kind !== 'parameter' || !option.unparam)) {\n                master.warn('unused_a');\n            } else if (!master.init) {\n                master.warn('uninitialized_a');\n            }\n        });\n        funct = old_funct;\n        option = old_option;\n        scope = old_scope;\n    }\n\n    prefix('{', function (that) {\n        var get, i, j, name, set, seen = Object.create(null);\n        that.first = [];\n        step_in();\n        while (next_token.id !== '}') {\n            indent.wrap = false;\n\n// JSLint recognizes the ES5 extension for get/set in object literals,\n// but requires that they be used in pairs.\n\n            edge();\n            if (next_token.string === 'get' && peek().id !== ':') {\n                get = next_token;\n                advance('get');\n                one_space_only();\n                name = next_token;\n                i = property_name();\n                if (!i) {\n                    next_token.stop('missing_property');\n                }\n                get.string = '';\n                do_function(get);\n                if (funct.loopage) {\n                    get.warn('function_loop');\n                }\n                if (get.function.parameter.length) {\n                    get.warn('parameter_a_get_b', get.function.parameter[0], i);\n                }\n                comma();\n                set = next_token;\n                spaces();\n                edge();\n                advance('set');\n                set.string = '';\n                one_space_only();\n                j = property_name();\n                if (i !== j) {\n                    token.stop('expected_a_b', i, j || next_token.string);\n                }\n                do_function(set);\n                if (set.block.length === 0) {\n                    token.warn('missing_a', 'throw');\n                }\n                if (set.function.parameter.length === 0) {\n                    set.stop('parameter_set_a', 'value');\n                } else if (set.function.parameter[0] !== 'value') {\n                    set.stop('expected_a_b', 'value',\n                        set.function.parameter[0]);\n                }\n                name.first = [get, set];\n            } else {\n                name = next_token;\n                i = property_name();\n                if (typeof i !== 'string') {\n                    next_token.stop('missing_property');\n                }\n                advance(':');\n                spaces();\n                name.first = expression(10);\n            }\n            that.first.push(name);\n            if (seen[i] === true) {\n                next_token.warn('duplicate_a', i);\n            }\n            seen[i] = true;\n            tally_property(i);\n            if (next_token.id !== ',') {\n                break;\n            }\n            for (;;) {\n                comma();\n                if (next_token.id !== ',') {\n                    break;\n                }\n                next_token.warn('unexpected_a');\n            }\n            if (next_token.id === '}') {\n                token.warn('unexpected_a');\n            }\n        }\n        step_out('}', that);\n        return that;\n    });\n\n    stmt('{', function () {\n        next_token.warn('statement_block');\n        this.arity = 'statement';\n        this.block = statements();\n        this.disrupt = this.block.disrupt;\n        advance('}', this);\n        return this;\n    });\n\n    stmt('/*global', directive);\n    stmt('/*globals', directive);\n    stmt('/*jslint', directive);\n    stmt('/*member', directive);\n    stmt('/*members', directive);\n    stmt('/*property', directive);\n    stmt('/*properties', directive);\n\n    stmt('var', function () {\n\n// JavaScript does not have block scope. It only has function scope. So,\n// declaring a variable in a block can have unexpected consequences.\n\n// var.first will contain an array, the array containing name tokens\n// and assignment tokens.\n\n        var assign, id, name;\n\n        if (funct.loopage) {\n            next_token.warn('var_loop');\n        } else if (funct.varstatement && !option.vars) {\n            next_token.warn('combine_var');\n        }\n        if (funct !== global_funct) {\n            funct.varstatement = true;\n        }\n        this.arity = 'statement';\n        this.first = [];\n        step_in('var');\n        for (;;) {\n            name = next_token;\n            id = identifier(true);\n            define('var', name);\n            name.dead = funct;\n            if (next_token.id === '=') {\n                if (funct === global_funct && !name.writeable) {\n                    name.warn('read_only');\n                }\n                assign = next_token;\n                assign.first = name;\n                spaces();\n                advance('=');\n                spaces();\n                if (next_token.id === 'undefined') {\n                    token.warn('unnecessary_initialize', id);\n                }\n                if (peek(0).id === '=' && next_token.identifier) {\n                    next_token.stop('var_a_not');\n                }\n                assign.second = expression(0);\n                assign.arity = 'infix';\n                name.init = true;\n                this.first.push(assign);\n            } else {\n                this.first.push(name);\n            }\n            name.dead = false;\n            name.writeable = true;\n            if (next_token.id !== ',') {\n                break;\n            }\n            comma();\n            indent.wrap = false;\n            if (var_mode && next_token.line === token.line &&\n                    this.first.length === 1) {\n                var_mode = null;\n                indent.open = false;\n                indent.at -= option.indent;\n            }\n            spaces();\n            edge();\n        }\n        var_mode = null;\n        step_out();\n        return this;\n    });\n\n    stmt('function', function () {\n        one_space();\n        if (in_block) {\n            token.warn('function_block');\n        }\n        var name = next_token,\n            id = identifier(true);\n        define('var', name);\n        if (!name.writeable) {\n            name.warn('read_only');\n        }\n        name.init = true;\n        name.statement = true;\n        no_space();\n        this.arity = 'statement';\n        do_function(this, id);\n        if (next_token.id === '(' && next_token.line === token.line) {\n            next_token.stop('function_statement');\n        }\n        return this;\n    });\n\n    prefix('function', function (that) {\n        var id = optional_identifier(true), name;\n        if (id) {\n            name = token;\n            no_space();\n        } else {\n            id = '';\n            one_space();\n        }\n        do_function(that, id);\n        if (name) {\n            name.function = that.function;\n        }\n        if (funct.loopage) {\n            that.warn('function_loop');\n        }\n        switch (next_token.id) {\n        case ';':\n        case '(':\n        case ')':\n        case ',':\n        case ']':\n        case '}':\n        case ':':\n        case '(end)':\n            break;\n        case '.':\n            if (peek().string !== 'bind' || peek(1).id !== '(') {\n                next_token.warn('unexpected_a');\n            }\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n        that.arity = 'function';\n        return that;\n    });\n\n    stmt('if', function () {\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('if');\n        if (next_token.id === 'else') {\n            if (this.block.disrupt) {\n                next_token.warn('unnecessary_else');\n            }\n            one_space();\n            advance('else');\n            one_space();\n            this.else = next_token.id === 'if' || next_token.id === 'switch'\n                ? statement(true)\n                : block('else');\n            if (this.else.disrupt && this.block.disrupt) {\n                this.disrupt = true;\n            }\n        }\n        return this;\n    });\n\n    stmt('try', function () {\n\n// try.first    The catch variable\n// try.second   The catch clause\n// try.third    The finally clause\n// try.block    The try block\n\n        var exception_variable, paren;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('try');\n        if (next_token.id === 'catch') {\n            one_space();\n            advance('catch');\n            one_space();\n            paren = next_token;\n            advance('(');\n            step_in('control');\n            no_space();\n            edge();\n            exception_variable = next_token;\n            this.first = identifier();\n            define('exception', exception_variable);\n            exception_variable.init = true;\n            no_space();\n            step_out(')', paren);\n            one_space();\n            this.second = block('catch');\n            if (this.second.length) {\n                if (this.first === 'ignore') {\n                    exception_variable.warn('unexpected_a');\n                }\n            } else {\n                if (this.first !== 'ignore') {\n                    exception_variable.warn('expected_a_b', 'ignore',\n                        exception_variable.string);\n                }\n            }\n            exception_variable.dead = true;\n        }\n        if (next_token.id === 'finally') {\n            one_space();\n            advance('finally');\n            one_space();\n            this.third = block('finally');\n        } else if (!this.second) {\n            next_token.stop('expected_a_b', 'catch', artifact());\n        }\n        return this;\n    });\n\n    labeled_stmt('while', function () {\n        one_space();\n        var paren = next_token;\n        funct.loopage += 1;\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_relation(expression(0));\n        if (this.first.id !== 'true') {\n            expected_condition(this.first, 'unexpected_a');\n        }\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('while');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        funct.loopage -= 1;\n        return this;\n    });\n\n    reserve('with');\n\n    labeled_stmt('switch', function () {\n\n// switch.first         the switch expression\n// switch.second        the array of cases. A case is 'case' or 'default' token:\n//    case.first        the array of case expressions\n//    case.second       the array of statements\n// If all of the arrays of statements are disrupt, then the switch is disrupt.\n\n        var cases = [],\n            old_in_block = in_block,\n            particular,\n            that = token,\n            the_case = next_token,\n            unbroken = true;\n\n        function find_duplicate_case(value) {\n            if (are_similar(particular, value)) {\n                value.warn('duplicate_a');\n            }\n        }\n\n        one_space();\n        advance('(');\n        no_space();\n        step_in();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', the_case);\n        one_space();\n        advance('{');\n        step_in();\n        in_block = true;\n        this.second = [];\n        if (that.from !== next_token.from && !option.white) {\n            next_token.warn('expected_a_at_b_c', next_token.string, that.from, next_token.from);\n        }\n        while (next_token.id === 'case') {\n            the_case = next_token;\n            cases.forEach(find_duplicate_case);\n            the_case.first = [];\n            the_case.arity = 'case';\n            spaces();\n            edge('case');\n            advance('case');\n            for (;;) {\n                one_space();\n                particular = expression(0);\n                cases.forEach(find_duplicate_case);\n                cases.push(particular);\n                the_case.first.push(particular);\n                if (particular.id === 'NaN') {\n                    particular.warn('unexpected_a');\n                }\n                no_space_only();\n                advance(':');\n                if (next_token.id !== 'case') {\n                    break;\n                }\n                spaces();\n                edge('case');\n                advance('case');\n            }\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                particular = the_case.second[the_case.second.length - 1];\n                if (particular.disrupt) {\n                    if (particular.id === 'break') {\n                        unbroken = false;\n                    }\n                } else {\n                    next_token.warn('missing_a_after_b', 'break', 'case');\n                }\n            } else {\n                next_token.warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.second.length === 0) {\n            next_token.warn('missing_a', 'case');\n        }\n        if (next_token.id === 'default') {\n            spaces();\n            the_case = next_token;\n            the_case.arity = 'case';\n            edge('case');\n            advance('default');\n            no_space_only();\n            advance(':');\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                particular = the_case.second[the_case.second.length - 1];\n                if (unbroken && particular.disrupt && particular.id !== 'break') {\n                    this.disrupt = true;\n                }\n            }\n            this.second.push(the_case);\n        }\n        spaces();\n        step_out('}', this);\n        in_block = old_in_block;\n        return this;\n    });\n\n    stmt('debugger', function () {\n        if (!option.debug) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        return this;\n    });\n\n    labeled_stmt('do', function () {\n        funct.loopage += 1;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('do');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        one_space();\n        advance('while');\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in();\n        no_space();\n        edge();\n        this.first = expected_condition(expected_relation(expression(0)), 'unexpected_a');\n        no_space();\n        step_out(')', paren);\n        funct.loopage -= 1;\n        return this;\n    });\n\n    labeled_stmt('for', function () {\n\n        var blok, filter, master, ok = false, paren = next_token, value;\n        this.arity = 'statement';\n        funct.loopage += 1;\n        advance('(');\n        if (next_token.id === ';') {\n            no_space();\n            advance(';');\n            no_space();\n            advance(';');\n            no_space();\n            advance(')');\n            blok = block('for');\n        } else {\n            step_in('control');\n            spaces(this, paren);\n            no_space();\n            if (next_token.id === 'var') {\n                next_token.stop('move_var');\n            }\n            edge();\n            if (peek(0).id === 'in') {\n                this.forin = true;\n                value = expression(1000);\n                master = value.master;\n                if (master.kind !== 'var' || master.function !== funct ||\n                        !master.writeable || master.dead) {\n                    value.warn('bad_in_a');\n                }\n                master.init = true;\n                master.used -= 1;\n                this.first = value;\n                advance('in');\n                this.second = expression(20);\n                step_out(')', paren);\n                blok = block('for');\n                if (!option.forin) {\n                    if (blok.length === 1 && typeof blok[0] === 'object') {\n                        if (blok[0].id === 'if' && !blok[0].else) {\n                            filter = blok[0].first;\n                            while (filter.id === '&&') {\n                                filter = filter.first;\n                            }\n                            switch (filter.id) {\n                            case '===':\n                            case '!==':\n                                ok = filter.first.id === '['\n                                    ? are_similar(filter.first.first, this.second) &&\n                                        are_similar(filter.first.second, this.first)\n                                    : filter.first.id === 'typeof' &&\n                                        filter.first.first.id === '[' &&\n                                        are_similar(filter.first.first.first, this.second) &&\n                                        are_similar(filter.first.first.second, this.first);\n                                break;\n                            case '(':\n                                ok = filter.first.id === '.' && ((\n                                    are_similar(filter.first.first, this.second) &&\n                                    filter.first.second.string === 'hasOwnProperty' &&\n                                    are_similar(filter.second[0], this.first)\n                                ) || (\n                                    filter.first.first.id === '.' &&\n                                    filter.first.first.first.first &&\n                                    filter.first.first.first.first.string === 'Object' &&\n                                    filter.first.first.first.id === '.' &&\n                                    filter.first.first.first.second.string === 'prototype' &&\n                                    filter.first.first.second.string === 'hasOwnProperty' &&\n                                    filter.first.second.string === 'call' &&\n                                    are_similar(filter.second[0], this.second) &&\n                                    are_similar(filter.second[1], this.first)\n                                ));\n                                break;\n                            }\n                        } else if (blok[0].id === 'switch') {\n                            ok = blok[0].id === 'switch' &&\n                                blok[0].first.id === 'typeof' &&\n                                blok[0].first.first.id === '[' &&\n                                are_similar(blok[0].first.first.first, this.second) &&\n                                are_similar(blok[0].first.first.second, this.first);\n                        }\n                    }\n                    if (!ok) {\n                        this.warn('for_if');\n                    }\n                }\n            } else {\n                edge();\n                this.first = [];\n                for (;;) {\n                    this.first.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                semicolon();\n                edge();\n                this.second = expected_relation(expression(0));\n                if (this.second.id !== 'true') {\n                    expected_condition(this.second, 'unexpected_a');\n                }\n                semicolon(token);\n                if (next_token.id === ';') {\n                    next_token.stop('expected_a_b', ')', ';');\n                }\n                this.third = [];\n                edge();\n                for (;;) {\n                    this.third.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                no_space();\n                step_out(')', paren);\n                one_space();\n                blok = block('for');\n            }\n        }\n        if (blok.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        this.block = blok;\n        funct.loopage -= 1;\n        return this;\n    });\n\n    function optional_label(that) {\n        var label = next_token.string,\n            master;\n        that.arity = 'statement';\n        if (next_token.identifier && token.line === next_token.line) {\n            one_space_only();\n            master = scope[label];\n            if (!master || master.kind !== 'label') {\n                next_token.warn('not_a_label');\n            } else if (master.dead || master.function !== funct) {\n                next_token.warn('not_a_scope');\n            } else {\n                master.used += 1;\n            }\n            that.first = next_token;\n            advance();\n        }\n        return that;\n\n    }\n\n    disrupt_stmt('break', function () {\n        return optional_label(this);\n    });\n\n    disrupt_stmt('continue', function () {\n        if (!option.continue) {\n            this.warn('unexpected_a');\n        }\n        return optional_label(this);\n    });\n\n    disrupt_stmt('return', function () {\n        if (funct === global_funct) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        if (next_token.id !== ';' && next_token.line === token.line) {\n            if (option.closure) {\n                spaces();\n            } else {\n                one_space_only();\n            }\n            if (next_token.id === '/' || next_token.id === '(regexp)') {\n                next_token.warn('wrap_regexp');\n            }\n            this.first = expression(0);\n            if (this.first.assign) {\n                this.first.warn('unexpected_a');\n            }\n        }\n        return this;\n    });\n\n    disrupt_stmt('throw', function () {\n        this.arity = 'statement';\n        one_space_only();\n        this.first = expression(20);\n        return this;\n    });\n\n\n//  Superfluous reserved words\n\n    reserve('class');\n    reserve('const');\n    reserve('enum');\n    reserve('export');\n    reserve('extends');\n    reserve('import');\n    reserve('super');\n\n// Harmony reserved words\n\n    reserve('implements');\n    reserve('interface');\n    reserve('let');\n    reserve('package');\n    reserve('private');\n    reserve('protected');\n    reserve('public');\n    reserve('static');\n    reserve('yield');\n\n\n// Parse JSON\n\n    function json_value() {\n\n        function json_object() {\n            var brace = next_token, object = Object.create(null);\n            advance('{');\n            if (next_token.id !== '}') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    if (next_token.id !== '(string)') {\n                        next_token.warn('expected_string_a');\n                    }\n                    if (object[next_token.string] === true) {\n                        next_token.warn('duplicate_a');\n                    } else if (next_token.string === '__proto__') {\n                        next_token.warn('dangling_a');\n                    } else {\n                        object[next_token.string] = true;\n                    }\n                    advance();\n                    advance(':');\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === '}') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance('}', brace);\n        }\n\n        function json_array() {\n            var bracket = next_token;\n            advance('[');\n            if (next_token.id !== ']') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === ']') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance(']', bracket);\n        }\n\n        switch (next_token.id) {\n        case '{':\n            json_object();\n            break;\n        case '[':\n            json_array();\n            break;\n        case 'true':\n        case 'false':\n        case 'null':\n        case '(number)':\n        case '(string)':\n            advance();\n            break;\n        case '-':\n            advance('-');\n            no_space_only();\n            advance('(number)');\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n    }\n\n\n// The actual JSLINT function itself.\n\n    itself = function JSLint(the_source, the_option) {\n\n        var i, predef, tree;\n        itself.errors = [];\n        itself.tree = '';\n        itself.properties = '';\n        begin = prev_token = token = next_token =\n            Object.create(syntax['(begin)']);\n        tokens = [];\n        predefined = Object.create(null);\n        add_to_predefined(standard);\n        property = Object.create(null);\n        if (the_option) {\n            option = Object.create(the_option);\n            predef = option.predef;\n            if (predef) {\n                if (Array.isArray(predef)) {\n                    for (i = 0; i < predef.length; i += 1) {\n                        predefined[predef[i]] = true;\n                    }\n                } else if (typeof predef === 'object') {\n                    add_to_predefined(predef);\n                }\n            }\n        } else {\n            option = Object.create(null);\n        }\n        option.indent = +option.indent || 4;\n        option.maxerr = +option.maxerr || 50;\n        global_scope = scope = Object.create(null);\n        global_funct = funct = {\n            scope: scope,\n            loopage: 0,\n            level: 0\n        };\n        functions = [funct];\n        block_var = [];\n\n        comments = [];\n        comments_off = false;\n        in_block = false;\n        indent = null;\n        json_mode = false;\n        lookahead = [];\n        node_js = false;\n        prereg = true;\n        strict_mode = false;\n        var_mode = null;\n        warnings = 0;\n        lex.init(the_source);\n\n        assume();\n\n        try {\n            advance();\n            if (next_token.id === '(number)') {\n                next_token.stop('unexpected_a');\n            } else {\n                switch (next_token.id) {\n                case '{':\n                case '[':\n                    comments_off = true;\n                    json_mode = true;\n                    json_value();\n                    break;\n                default:\n\n// If the first token is a semicolon, ignore it. This is sometimes used when\n// files are intended to be appended to files that may be sloppy. A sloppy\n// file may be depending on semicolon insertion on its last line.\n\n                    step_in(1);\n                    if (next_token.id === ';' && !node_js) {\n                        semicolon();\n                    }\n                    tree = statements();\n                    begin.first = tree;\n                    itself.tree = begin;\n                    if (tree.disrupt) {\n                        prev_token.warn('weird_program');\n                    }\n                }\n            }\n            indent = null;\n            advance('(end)');\n            itself.property = property;\n        } catch (e) {\n            if (e) {        // ~~\n                itself.errors.push({\n                    reason    : e.message,\n                    line      : e.line || next_token.line,\n                    character : e.character || next_token.from\n                }, null);\n            }\n        }\n        return itself.errors.length === 0;\n    };\n\n    function unique(array) {\n        array = array.sort();\n        var i, length = 0, previous, value;\n        for (i = 0; i < array.length; i += 1) {\n            value = array[i];\n            if (value !== previous) {\n                array[length] = value;\n                previous = value;\n                length += 1;\n            }\n        }\n        array.length = length;\n        return array;\n    }\n\n// Data summary.\n\n    itself.data = function () {\n        var data = {functions: []},\n            function_data,\n            i,\n            the_function,\n            the_scope;\n        data.errors = itself.errors;\n        data.json = json_mode;\n        data.global = unique(Object.keys(global_scope));\n\n        function selects(name) {\n            var kind = the_scope[name].kind;\n            switch (kind) {\n            case 'var':\n            case 'exception':\n            case 'label':\n                function_data[kind].push(name);\n                break;\n            }\n        }\n\n        for (i = 1; i < functions.length; i += 1) {\n            the_function = functions[i];\n            function_data = {\n                name: the_function.name,\n                line: the_function.line,\n                level: the_function.level,\n                parameter: the_function.parameter,\n                var: [],\n                exception: [],\n                closure: unique(the_function.closure),\n                outer: unique(the_function.outer),\n                global: unique(the_function.global),\n                label: []\n            };\n            the_scope = the_function.scope;\n            Object.keys(the_scope).forEach(selects);\n            function_data.var.sort();\n            function_data.exception.sort();\n            function_data.label.sort();\n            data.functions.push(function_data);\n        }\n        data.tokens = tokens;\n        return data;\n    };\n\n    itself.error_report = function (data) {\n        var evidence, i, output = [], warning;\n        if (data.errors.length) {\n            if (data.json) {\n                output.push('<cite>JSON: bad.</cite><br>');\n            }\n            for (i = 0; i < data.errors.length; i += 1) {\n                warning = data.errors[i];\n                if (warning) {\n                    evidence = warning.evidence || '';\n                    output.push('<cite>');\n                    if (isFinite(warning.line)) {\n                        output.push('<address>line ' +\n                            String(warning.line) +\n                            ' character ' + String(warning.character) +\n                            '</address>');\n                    }\n                    output.push(warning.reason.entityify() + '</cite>');\n                    if (evidence) {\n                        output.push('<pre>' + evidence.entityify() + '</pre>');\n                    }\n                }\n            }\n        }\n        return output.join('');\n    };\n\n\n    itself.report = function (data) {\n        var dl, i, j, names, output = [], the_function;\n\n        function detail(h, array) {\n            var comma_needed = false;\n            if (array.length) {\n                output.push(\"<dt>\" + h + \"</dt><dd>\");\n                array.forEach(function (item) {\n                    output.push((comma_needed ? ', ' : '') + item);\n                    comma_needed = true;\n                });\n                output.push(\"</dd>\");\n            }\n        }\n\n        output.push('<dl class=level0>');\n        if (data.global.length) {\n            detail('global', data.global);\n            dl = true;\n        } else if (data.json) {\n            if (!data.errors.length) {\n                output.push(\"<dt>JSON: good.</dt>\");\n            }\n        } else {\n            output.push(\"<dt><i>No new global variables introduced.</i></dt>\");\n        }\n        if (dl) {\n            output.push(\"</dl>\");\n        } else {\n            output[0] = '';\n        }\n\n        if (data.functions) {\n            for (i = 0; i < data.functions.length; i += 1) {\n                the_function = data.functions[i];\n                names = [];\n                if (the_function.params) {\n                    for (j = 0; j < the_function.params.length; j += 1) {\n                        names[j] = the_function.params[j].string;\n                    }\n                }\n                output.push('<dl class=level' + the_function.level +\n                    '><address>line ' + String(the_function.line) +\n                    '</address>' + the_function.name.entityify());\n                detail('parameter', the_function.parameter);\n                detail('variable', the_function.var);\n                detail('exception', the_function.exception);\n                detail('closure', the_function.closure);\n                detail('outer', the_function.outer);\n                detail('global', the_function.global);\n                detail('label', the_function.label);\n                output.push('</dl>');\n            }\n        }\n        return output.join('');\n    };\n\n    itself.properties_report = function (property) {\n        if (!property) {\n            return '';\n        }\n        var i,\n            key,\n            keys = Object.keys(property).sort(),\n            mem = '    ',\n            name,\n            not_first = false,\n            output = ['/*properties'];\n        for (i = 0; i < keys.length; i += 1) {\n            key = keys[i];\n            if (property[key] > 0) {\n                if (not_first) {\n                    mem += ', ';\n                }\n                name = ix.test(key)\n                    ? key\n                    : '\\'' + key.replace(nx, sanitize) + '\\'';\n                if (mem.length + name.length >= 80) {\n                    output.push(mem);\n                    mem = '    ';\n                }\n                mem += name;\n                not_first = true;\n            }\n        }\n        output.push(mem, '*/\\n');\n        return output.join('\\n');\n    };\n\n    itself.color = function (data) {\n        var from,\n            i = 1,\n            level,\n            line,\n            result = [],\n            thru,\n            data_token = data.tokens[0];\n        while (data_token && data_token.id !== '(end)') {\n            from = data_token.from;\n            line = data_token.line;\n            thru = data_token.thru;\n            level = data_token.function.level;\n            do {\n                thru = data_token.thru;\n                data_token = data.tokens[i];\n                i += 1;\n            } while (data_token && data_token.line === line &&\n                    data_token.from - thru < 5 &&\n                    level === data_token.function.level);\n            result.push({\n                line: line,\n                level: level,\n                from: from,\n                thru: thru\n            });\n        }\n        return result;\n    };\n\n    itself.jslint = itself;\n\n    itself.edition = '2013-09-22';\n\n    return itself;\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jslint-2013-11-23.js":"// jslint.js\n// 2013-11-23\n\n// Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// The Software shall be used for Good, not Evil.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// WARNING: JSLint will hurt your feelings.\n\n// JSLINT is a global function. It takes two parameters.\n\n//     var myResult = JSLINT(source, option);\n\n// The first parameter is either a string or an array of strings. If it is a\n// string, it will be split on '\\n' or '\\r'. If it is an array of strings, it\n// is assumed that each string represents one line. The source can be a\n// JavaScript text or a JSON text.\n\n// The second parameter is an optional object of options that control the\n// operation of JSLINT. Most of the options are booleans: They are all\n// optional and have a default value of false. One of the options, predef,\n// can be an array of names, which will be used to declare global variables,\n// or an object whose keys are used as global names, with a boolean value\n// that determines if they are assignable.\n\n// If it checks out, JSLINT returns true. Otherwise, it returns false.\n\n// If false, you can inspect JSLINT.errors to find out the problems.\n// JSLINT.errors is an array of objects containing these properties:\n\n//  {\n//      line      : The line (relative to 0) at which the lint was found\n//      character : The character (relative to 0) at which the lint was found\n//      reason    : The problem\n//      evidence  : The text line in which the problem occurred\n//      raw       : The raw message before the details were inserted\n//      a         : The first detail\n//      b         : The second detail\n//      c         : The third detail\n//      d         : The fourth detail\n//  }\n\n// If a stopping error was found, a null will be the last element of the\n// JSLINT.errors array. A stopping error means that JSLint was not confident\n// enough to continue. It does not necessarily mean that the error was\n// especially heinous.\n\n// You can request a data structure that contains JSLint's results.\n\n//     var myData = JSLINT.data();\n\n// It returns a structure with this form:\n\n//     {\n//         errors: [\n//             {\n//                 line: NUMBER,\n//                 character: NUMBER,\n//                 reason: STRING,\n//                 evidence: STRING\n//             }\n//         ],\n//         functions: [\n//             {\n//                 name: STRING,\n//                 line: NUMBER,\n//                 level: NUMBER,\n//                 parameter: [\n//                     STRING\n//                 ],\n//                 var: [\n//                     STRING\n//                 ],\n//                 exception: [\n//                     STRING\n//                 ],\n//                 closure: [\n//                     STRING\n//                 ],\n//                 outer: [\n//                     STRING\n//                 ],\n//                 global: [\n//                     STRING\n//                 ],\n//                 label: [\n//                     STRING\n//                 ]\n//             }\n//         ],\n//         global: [\n//             STRING\n//         ],\n//         member: {\n//             STRING: NUMBER\n//         },\n//         json: BOOLEAN\n//     }\n\n// You can request a Function Report, which shows all of the functions\n// and the parameters and vars that they use. This can be used to find\n// implied global variables and other problems. The report is in HTML and\n// can be inserted into an HTML <body>. It should be given the result of the\n// JSLINT.data function.\n\n//     var myReport = JSLINT.report(data);\n\n// You can request an HTML error report.\n\n//     var myErrorReport = JSLINT.error_report(data);\n\n// You can obtain an object containing all of the properties found in the\n// file. JSLINT.property contains an object containing a key for each\n// property used in the program, the value being the number of times that\n// property name was used in the file.\n\n// You can request a properties report, which produces a list of the program's\n// properties in the form of a /*properties*/ declaration.\n\n//      var myPropertyReport = JSLINT.properties_report(JSLINT.property);\n\n// You can obtain the parse tree that JSLint constructed while parsing. The\n// latest tree is kept in JSLINT.tree. A nice stringification can be produced\n// with\n\n//     JSON.stringify(JSLINT.tree, [\n//         'string',  'arity', 'name',  'first',\n//         'second', 'third', 'block', 'else'\n//     ], 4));\n\n// You can request a context coloring table. It contains information that can be\n// applied to the file that was analyzed. Context coloring colors functions\n// based on their nesting level, and variables on the color of the functions\n// in which they are defined.\n\n//      var myColorization = JSLINT.color(data);\n\n// It returns an array containing objects of this form:\n\n//      {\n//          from: COLUMN,\n//          thru: COLUMN,\n//          line: ROW,\n//          level: 0 or higher\n//      }\n\n// JSLint provides three inline directives. They look like slashstar comments,\n// and allow for setting options, declaring global variables, and establishing a\n// set of allowed property names.\n\n// These directives respect function scope.\n\n// The jslint directive is a special comment that can set one or more options.\n// For example:\n\n/*jslint\n    evil: true, nomen: true, regexp: true, todo: true\n*/\n\n// The current option set is\n\n//     ass        true, if assignment expressions should be allowed\n//     bitwise    true, if bitwise operators should be allowed\n//     browser    true, if the standard browser globals should be predefined\n//     closure    true, if Google Closure idioms should be tolerated\n//     continue   true, if the continuation statement should be tolerated\n//     debug      true, if debugger statements should be allowed\n//     devel      true, if logging should be allowed (console, alert, etc.)\n//     eqeq       true, if == should be allowed\n//     evil       true, if eval should be allowed\n//     forin      true, if for in statements need not filter\n//     indent     the indentation factor\n//     maxerr     the maximum number of errors to allow\n//     maxlen     the maximum length of a source line\n//     newcap     true, if constructor names capitalization is ignored\n//     node       true, if Node.js globals should be predefined\n//     nomen      true, if names may have dangling _\n//     passfail   true, if the scan should stop on first error\n//     plusplus   true, if increment/decrement should be allowed\n//     properties true, if all property names must be declared with /*properties*/\n//     regexp     true, if the . should be allowed in regexp literals\n//     rhino      true, if the Rhino environment globals should be predefined\n//     unparam    true, if unused parameters should be tolerated\n//     sloppy     true, if the 'use strict'; pragma is optional\n//     stupid     true, if really stupid practices are tolerated\n//     sub        true, if all forms of subscript notation are tolerated\n//     todo       true, if TODO comments are tolerated\n//     vars       true, if multiple var statements per function should be allowed\n//     white      true, if sloppy whitespace is tolerated\n\n// The properties directive declares an exclusive list of property names.\n// Any properties named in the program that are not in the list will\n// produce a warning.\n\n// For example:\n\n/*properties\n    '\\b', '\\t', '\\n', '\\f', '\\r', '!', '!=', '!==', '\"', '%', '\\'', '(begin)',\n    '(error)', '*', '+', '-', '/', '<', '<=', '==', '===', '>', '>=', '\\\\', a,\n    a_label, a_scope, already_defined, and, apply, arguments, arity, ass,\n    assign, assignment_expression, assignment_function_expression, at, avoid_a,\n    b, bad_assignment, bad_constructor, bad_in_a, bad_invocation, bad_new,\n    bad_number, bad_operand, bad_wrap, bitwise, block, break, breakage, browser,\n    c, call, charAt, charCodeAt, character, closure, code, color, combine_var,\n    comments, conditional_assignment, confusing_a, confusing_regexp,\n    constructor_name_a, continue, control_a, couch, create, d, dangling_a, data,\n    dead, debug, deleted, devel, disrupt, duplicate_a, edge, edition, elif,\n    else, empty_block, empty_case, empty_class, entityify, eqeq, error_report,\n    errors, evidence, evil, exception, exec, expected_a_at_b_c, expected_a_b,\n    expected_a_b_from_c_d, expected_id_a, expected_identifier_a,\n    expected_identifier_a_reserved, expected_number_a, expected_operator_a,\n    expected_positive_a, expected_small_a, expected_space_a_b,\n    expected_string_a, f, first, flag, floor, forEach, for_if, forin, from,\n    fromCharCode, fud, function, function_block, function_eval, function_loop,\n    function_statement, function_strict, functions, global, hasOwnProperty, id,\n    identifier, identifier_function, immed, implied_evil, indent, indexOf,\n    infix_in, init, insecure_a, isAlpha, isArray, isDigit, isNaN, join, jslint,\n    json, keys, kind, label, labeled, lbp, leading_decimal_a, led, left, length,\n    level, line, loopage, master, match, maxerr, maxlen, message, missing_a,\n    missing_a_after_b, missing_property, missing_space_a_b, missing_use_strict,\n    mode, move_invocation, move_var, n, name, name_function, nested_comment,\n    newcap, node, nomen, not, not_a_constructor, not_a_defined, not_a_function,\n    not_a_label, not_a_scope, not_greater, nud, number, octal_a, open, outer,\n    parameter, parameter_a_get_b, parameter_arguments_a, parameter_set_a,\n    params, paren, passfail, plusplus, pop, postscript, predef, properties,\n    properties_report, property, prototype, push, quote, r, radix, raw,\n    read_only, reason, redefinition_a_b, regexp, relation, replace, report,\n    reserved, reserved_a, rhino, right, scanned_a_b, scope, search, second,\n    shift, slash_equal, slice, sloppy, sort, split, statement, statement_block,\n    stop, stopping, strange_loop, strict, string, stupid, sub, subscript,\n    substr, supplant, sync_a, t, tag_a_in_b, test, third, thru, toString, todo,\n    todo_comment, token, tokens, too_long, too_many, trailing_decimal_a, tree,\n    unclosed, unclosed_comment, unclosed_regexp, unescaped_a, unexpected_a,\n    unexpected_char_a, unexpected_comment, unexpected_label_a,\n    unexpected_property_a, unexpected_space_a_b, unexpected_typeof_a,\n    uninitialized_a, unnecessary_else, unnecessary_initialize, unnecessary_use,\n    unparam, unreachable_a_b, unsafe, unused_a, url, use_array, use_braces,\n    use_nested_if, use_object, use_or, use_param, use_spaces, used,\n    used_before_a, var, var_a_not, var_loop, vars, varstatement, warn, warning,\n    was, weird_assignment, weird_condition, weird_new, weird_program,\n    weird_relation, weird_ternary, white, wrap, wrap_immediate, wrap_regexp,\n    write_is_wrong, writeable\n*/\n\n// The global directive is used to declare global variables that can\n// be accessed by the program. If a declaration is true, then the variable\n// is writeable. Otherwise, it is read-only.\n\n// We build the application inside a function so that we produce only a single\n// global variable. That function will be invoked immediately, and its return\n// value is the JSLINT function itself. That function is also an object that\n// can contain data and other functions.\n\nvar JSLINT = (function () {\n    'use strict';\n\n    function array_to_object(array, value) {\n\n// Make an object from an array of keys and a common value.\n\n        var i, length = array.length, object = Object.create(null);\n        for (i = 0; i < length; i += 1) {\n            object[array[i]] = value;\n        }\n        return object;\n    }\n\n\n    var allowed_option = {\n            ass       : true,\n            bitwise   : true,\n            browser   : true,\n            closure   : true,\n            continue  : true,\n            couch     : true,\n            debug     : true,\n            devel     : true,\n            eqeq      : true,\n            evil      : true,\n            forin     : true,\n            indent    :   10,\n            maxerr    : 1000,\n            maxlen    :  256,\n            newcap    : true,\n            node      : true,\n            nomen     : true,\n            passfail  : true,\n            plusplus  : true,\n            properties: true,\n            regexp    : true,\n            rhino     : true,\n            unparam   : true,\n            sloppy    : true,\n            stupid    : true,\n            sub       : true,\n            todo      : true,\n            vars      : true,\n            white     : true\n        },\n        anonname,       // The guessed name for anonymous functions.\n\n// These are operators that should not be used with the ! operator.\n\n        bang = {\n            '<'  : true,\n            '<=' : true,\n            '==' : true,\n            '===': true,\n            '!==': true,\n            '!=' : true,\n            '>'  : true,\n            '>=' : true,\n            '+'  : true,\n            '-'  : true,\n            '*'  : true,\n            '/'  : true,\n            '%'  : true\n        },\n        begin,          // The root token\n        block_var,     // vars defined in the current block\n\n// browser contains a set of global names that are commonly provided by a\n// web browser environment.\n\n        browser = array_to_object([\n            'clearInterval', 'clearTimeout', 'document', 'event', 'FormData',\n            'frames', 'history', 'Image', 'localStorage', 'location', 'name',\n            'navigator', 'Option', 'parent', 'screen', 'sessionStorage',\n            'setInterval', 'setTimeout', 'Storage', 'window', 'XMLHttpRequest'\n        ], false),\n\n// bundle contains the text messages.\n\n        bundle = {\n            a_label: \"'{a}' is a statement label.\",\n            a_scope: \"'{a}' used out of scope.\",\n            already_defined: \"'{a}' is already defined.\",\n            and: \"The '&&' subexpression should be wrapped in parens.\",\n            assignment_expression: \"Unexpected assignment expression.\",\n            assignment_function_expression: \"Expected an assignment or \" +\n                \"function call and instead saw an expression.\",\n            avoid_a: \"Avoid '{a}'.\",\n            bad_assignment: \"Bad assignment.\",\n            bad_constructor: \"Bad constructor.\",\n            bad_in_a: \"Bad for in variable '{a}'.\",\n            bad_invocation: \"Bad invocation.\",\n            bad_new: \"Do not use 'new' for side effects.\",\n            bad_number: \"Bad number '{a}'.\",\n            bad_operand: \"Bad operand.\",\n            bad_wrap: \"Do not wrap function literals in parens unless they \" +\n                \"are to be immediately invoked.\",\n            combine_var: \"Combine this with the previous 'var' statement.\",\n            conditional_assignment: \"Expected a conditional expression and \" +\n                \"instead saw an assignment.\",\n            confusing_a: \"Confusing use of '{a}'.\",\n            confusing_regexp: \"Confusing regular expression.\",\n            constructor_name_a: \"A constructor name '{a}' should start with \" +\n                \"an uppercase letter.\",\n            control_a: \"Unexpected control character '{a}'.\",\n            dangling_a: \"Unexpected dangling '_' in '{a}'.\",\n            deleted: \"Only properties should be deleted.\",\n            duplicate_a: \"Duplicate '{a}'.\",\n            empty_block: \"Empty block.\",\n            empty_case: \"Empty case.\",\n            empty_class: \"Empty class.\",\n            evil: \"eval is evil.\",\n            expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n            expected_a_b_from_c_d: \"Expected '{a}' to match '{b}' from line \" +\n                \"{c} and instead saw '{d}'.\",\n            expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n            expected_id_a: \"Expected an id, and instead saw #{a}.\",\n            expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n            expected_identifier_a_reserved: \"Expected an identifier and \" +\n                \"instead saw '{a}' (a reserved word).\",\n            expected_number_a: \"Expected a number and instead saw '{a}'.\",\n            expected_operator_a: \"Expected an operator and instead saw '{a}'.\",\n            expected_positive_a: \"Expected a positive number and instead saw '{a}'\",\n            expected_small_a: \"Expected a small positive integer and instead saw '{a}'\",\n            expected_space_a_b: \"Expected exactly one space between '{a}' and '{b}'.\",\n            expected_string_a: \"Expected a string and instead saw '{a}'.\",\n            for_if: \"The body of a for in should be wrapped in an if \" +\n                \"statement to filter unwanted properties from the prototype.\",\n            function_block: \"Function statements should not be placed in blocks.\" +\n                \"Use a function expression or move the statement to the top of \" +\n                \"the outer function.\",\n            function_eval: \"The Function constructor is eval.\",\n            function_loop: \"Don't make functions within a loop.\",\n            function_statement: \"Function statements are not invocable. \" +\n                \"Wrap the whole function invocation in parens.\",\n            function_strict: \"Use the function form of 'use strict'.\",\n            identifier_function: \"Expected an identifier in an assignment \" +\n                \"and instead saw a function invocation.\",\n            implied_evil: \"Implied eval is evil. Pass a function instead of a string.\",\n            infix_in: \"Unexpected 'in'. Compare with undefined, or use the \" +\n                \"hasOwnProperty method instead.\",\n            insecure_a: \"Insecure '{a}'.\",\n            isNaN: \"Use the isNaN function to compare with NaN.\",\n            leading_decimal_a: \"A leading decimal point can be confused with a dot: '.{a}'.\",\n            missing_a: \"Missing '{a}'.\",\n            missing_a_after_b: \"Missing '{a}' after '{b}'.\",\n            missing_property: \"Missing property name.\",\n            missing_space_a_b: \"Missing space between '{a}' and '{b}'.\",\n            missing_use_strict: \"Missing 'use strict' statement.\",\n            move_invocation: \"Move the invocation into the parens that \" +\n                \"contain the function.\",\n            move_var: \"Move 'var' declarations to the top of the function.\",\n            name_function: \"Missing name in function statement.\",\n            nested_comment: \"Nested comment.\",\n            not: \"Nested not.\",\n            not_a_constructor: \"Do not use {a} as a constructor.\",\n            not_a_defined: \"'{a}' has not been fully defined yet.\",\n            not_a_function: \"'{a}' is not a function.\",\n            not_a_label: \"'{a}' is not a label.\",\n            not_a_scope: \"'{a}' is out of scope.\",\n            not_greater: \"'{a}' should not be greater than '{b}'.\",\n            octal_a: \"Don't use octal: '{a}'. Use '\\\\u....' instead.\",\n            parameter_arguments_a: \"Do not mutate parameter '{a}' when using 'arguments'.\",\n            parameter_a_get_b: \"Unexpected parameter '{a}' in get {b} function.\",\n            parameter_set_a: \"Expected parameter (value) in set {a} function.\",\n            radix: \"Missing radix parameter.\",\n            read_only: \"Read only.\",\n            redefinition_a_b: \"Redefinition of '{a}' from line {b}.\",\n            reserved_a: \"Reserved name '{a}'.\",\n            scanned_a_b: \"{a} ({b}% scanned).\",\n            slash_equal: \"A regular expression literal can be confused with '/='.\",\n            statement_block: \"Expected to see a statement and instead saw a block.\",\n            stopping: \"Stopping.\",\n            strange_loop: \"Strange loop.\",\n            strict: \"Strict violation.\",\n            subscript: \"['{a}'] is better written in dot notation.\",\n            sync_a: \"Unexpected sync method: '{a}'.\",\n            tag_a_in_b: \"A '<{a}>' must be within '<{b}>'.\",\n            todo_comment: \"Unexpected TODO comment.\",\n            too_long: \"Line too long.\",\n            too_many: \"Too many errors.\",\n            trailing_decimal_a: \"A trailing decimal point can be confused \" +\n                \"with a dot: '.{a}'.\",\n            unclosed: \"Unclosed string.\",\n            unclosed_comment: \"Unclosed comment.\",\n            unclosed_regexp: \"Unclosed regular expression.\",\n            unescaped_a: \"Unescaped '{a}'.\",\n            unexpected_a: \"Unexpected '{a}'.\",\n            unexpected_char_a: \"Unexpected character '{a}'.\",\n            unexpected_comment: \"Unexpected comment.\",\n            unexpected_label_a: \"Unexpected label '{a}'.\",\n            unexpected_property_a: \"Unexpected /*property*/ '{a}'.\",\n            unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n            unexpected_typeof_a: \"Unexpected 'typeof'. \" +\n                \"Use '===' to compare directly with {a}.\",\n            uninitialized_a: \"Uninitialized '{a}'.\",\n            unnecessary_else: \"Unnecessary 'else' after disruption.\",\n            unnecessary_initialize: \"It is not necessary to initialize '{a}' \" +\n                \"to 'undefined'.\",\n            unnecessary_use: \"Unnecessary 'use strict'.\",\n            unreachable_a_b: \"Unreachable '{a}' after '{b}'.\",\n            unsafe: \"Unsafe character.\",\n            unused_a: \"Unused '{a}'.\",\n            url: \"JavaScript URL.\",\n            use_array: \"Use the array literal notation [].\",\n            use_braces: \"Spaces are hard to count. Use {{a}}.\",\n            use_nested_if: \"Expected 'else { if' and instead saw 'else if'.\",\n            use_object: \"Use the object literal notation {} or Object.create(null).\",\n            use_or: \"Use the || operator.\",\n            use_param: \"Use a named parameter.\",\n            use_spaces: \"Use spaces, not tabs.\",\n            used_before_a: \"'{a}' was used before it was defined.\",\n            var_a_not: \"Variable {a} was not declared correctly.\",\n            var_loop: \"Don't declare variables in a loop.\",\n            weird_assignment: \"Weird assignment.\",\n            weird_condition: \"Weird condition.\",\n            weird_new: \"Weird construction. Delete 'new'.\",\n            weird_program: \"Weird program.\",\n            weird_relation: \"Weird relation.\",\n            weird_ternary: \"Weird ternary.\",\n            wrap_immediate: \"Wrap an immediate function invocation in \" +\n                \"parentheses to assist the reader in understanding that the \" +\n                \"expression is the result of a function, and not the \" +\n                \"function itself.\",\n            wrap_regexp: \"Wrap the /regexp/ literal in parens to \" +\n                \"disambiguate the slash operator.\",\n            write_is_wrong: \"document.write can be a form of eval.\"\n        },\n        closure = array_to_object([\n            'goog'\n        ], false),\n        comments,\n        comments_off,\n        couch = array_to_object([\n            'emit', 'getRow', 'isArray', 'log', 'provides', 'registerType',\n            'require', 'send', 'start', 'sum', 'toJSON'\n        ], false),\n\n        descapes = {\n            'b': '\\b',\n            't': '\\t',\n            'n': '\\n',\n            'f': '\\f',\n            'r': '\\r',\n            '\"': '\"',\n            '/': '/',\n            '\\\\': '\\\\',\n            '!': '!'\n        },\n\n        devel = array_to_object([\n            'alert', 'confirm', 'console', 'Debug', 'opera', 'prompt', 'WSH'\n        ], false),\n        directive,\n        escapes = {\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\\'': '\\\\\\'',\n            '\"' : '\\\\\"',\n            '/' : '\\\\/',\n            '\\\\': '\\\\\\\\'\n        },\n\n        funct,          // The current function\n\n        functions,      // All of the functions\n        global_funct,   // The global body\n        global_scope,   // The global scope\n        in_block,       // Where function statements are not allowed\n        indent,\n        itself,         // JSLINT itself\n        json_mode,\n        lex,            // the tokenizer\n        lines,\n        lookahead,\n        node = array_to_object([\n            'Buffer', 'clearImmediate', 'clearInterval', 'clearTimeout',\n            'console', 'exports', 'global', 'module', 'process', 'querystring',\n            'require', 'setImmediate', 'setInterval', 'setTimeout',\n            '__dirname', '__filename'\n        ], false),\n        node_js,\n        numbery = array_to_object(['indexOf', 'lastIndexOf', 'search'], true),\n        next_token,\n        option,\n        predefined,     // Global variables defined by option\n        prereg,\n        prev_token,\n        property,\n        protosymbol,\n        regexp_flag = array_to_object(['g', 'i', 'm'], true),\n        return_this = function return_this() {\n            return this;\n        },\n        rhino = array_to_object([\n            'defineClass', 'deserialize', 'gc', 'help', 'load', 'loadClass',\n            'print', 'quit', 'readFile', 'readUrl', 'runCommand', 'seal',\n            'serialize', 'spawn', 'sync', 'toint32', 'version'\n        ], false),\n\n        scope,      // An object containing an object for each variable in scope\n        semicolon_coda = array_to_object([';', '\"', '\\'', ')'], true),\n\n// standard contains the global names that are provided by the\n// ECMAScript standard.\n\n        standard = array_to_object([\n            'Array', 'Boolean', 'Date', 'decodeURI', 'decodeURIComponent',\n            'encodeURI', 'encodeURIComponent', 'Error', 'eval', 'EvalError',\n            'Function', 'isFinite', 'isNaN', 'JSON', 'Map', 'Math', 'Number',\n            'Object', 'parseInt', 'parseFloat', 'Promise', 'Proxy',\n            'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set',\n            'String', 'Symbol', 'SyntaxError', 'System', 'TypeError',\n            'URIError', 'WeakMap', 'WeakSet'\n        ], false),\n\n        strict_mode,\n        syntax = Object.create(null),\n        token,\n        tokens,\n        var_mode,\n        warnings,\n\n// Regular expressions. Some of these are stupidly long.\n\n// carriage return, carriage return linefeed, or linefeed\n        crlfx = /\\r\\n?|\\n/,\n// unsafe characters that are silently deleted by one or more browsers\n        cx = /[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n// identifier\n        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,\n// javascript url\n        jx = /^(?:javascript|jscript|ecmascript|vbscript)\\s*:/i,\n// star slash\n        lx = /\\*\\/|\\/\\*/,\n// characters in strings that need escapement\n        nx = /[\\u0000-\\u001f'\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n// sync\n        syx = /Sync$/,\n// comment todo\n        tox = /^\\W*to\\s*do(?:\\W|$)/i,\n// token\n        tx = /^\\s*([(){}\\[\\]\\?.,:;'\"~#@`]|={1,3}|\\/(\\*(jslint|properties|property|members?|globals?)?|=|\\/)?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|[\\^%]=?|&[&=]?|\\|[|=]?|>{1,3}=?|<(?:[\\/=!]|\\!(\\[|--)?|<=?)?|\\!(\\!|==?)?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+(?:[xX][0-9a-fA-F]+|\\.[0-9]*)?(?:[eE][+\\-]?[0-9]+)?)/;\n\n\n    if (typeof String.prototype.entityify !== 'function') {\n        String.prototype.entityify = function () {\n            return this\n                .replace(/&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;');\n        };\n    }\n\n    if (typeof String.prototype.isAlpha !== 'function') {\n        String.prototype.isAlpha = function () {\n            return (this >= 'a' && this <= 'z\\uffff') ||\n                (this >= 'A' && this <= 'Z\\uffff');\n        };\n    }\n\n    if (typeof String.prototype.isDigit !== 'function') {\n        String.prototype.isDigit = function () {\n            return (this >= '0' && this <= '9');\n        };\n    }\n\n    if (typeof String.prototype.supplant !== 'function') {\n        String.prototype.supplant = function (o) {\n            return this.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n                var replacement = o[b];\n                return typeof replacement === 'string' ||\n                    typeof replacement === 'number' ? replacement : a;\n            });\n        };\n    }\n\n\n    function sanitize(a) {\n\n//  Escapify a troublesome character.\n\n        return escapes[a] ||\n            '\\\\u' + ('0000' + a.charCodeAt().toString(16)).slice(-4);\n    }\n\n\n    function add_to_predefined(group) {\n        Object.keys(group).forEach(function (name) {\n            predefined[name] = group[name];\n        });\n    }\n\n\n    function assume() {\n        if (option.browser) {\n            add_to_predefined(browser);\n            option.browser = false;\n        }\n        if (option.closure) {\n            add_to_predefined(closure);\n        }\n        if (option.couch) {\n            add_to_predefined(couch);\n            option.couch = false;\n        }\n        if (option.devel) {\n            add_to_predefined(devel);\n            option.devel = false;\n        }\n        if (option.node) {\n            add_to_predefined(node);\n            option.node = false;\n            node_js = true;\n        }\n        if (option.rhino) {\n            add_to_predefined(rhino);\n            option.rhino = false;\n        }\n    }\n\n\n// Produce an error warning.\n\n    function artifact(tok) {\n        if (!tok) {\n            tok = next_token;\n        }\n        return tok.id === '(number)' ? tok.number : tok.string;\n    }\n\n    function quit(message, line, character) {\n        throw {\n            name: 'JSLintError',\n            line: line,\n            character: character,\n            message: bundle.scanned_a_b.supplant({\n                a: bundle[message] || message,\n                b: Math.floor((line / lines.length) * 100)\n            })\n        };\n    }\n\n    function warn(code, line, character, a, b, c, d) {\n        var warning = {         // ~~\n            id: '(error)',\n            raw: bundle[code] || code,\n            code: code,\n            evidence: lines[line - 1] || '',\n            line: line,\n            character: character,\n            a: a || artifact(this),\n            b: b,\n            c: c,\n            d: d\n        };\n        warning.reason = warning.raw.supplant(warning);\n        itself.errors.push(warning);\n        if (option.passfail) {\n            quit('stopping', line, character);\n        }\n        warnings += 1;\n        if (warnings >= option.maxerr) {\n            quit('too_many', line, character);\n        }\n        return warning;\n    }\n\n    function stop(code, line, character, a, b, c, d) {\n        var warning = warn(code, line, character, a, b, c, d);\n        quit('stopping', warning.line, warning.character);\n    }\n\n    function expected_at(at) {\n        if (!option.white && next_token.from !== at) {\n            next_token.warn('expected_a_at_b_c', '', at, next_token.from);\n        }\n    }\n\n// lexical analysis and token construction\n\n    lex = (function lex() {\n        var character, c, from, length, line, pos, source_row;\n\n// Private lex methods\n\n        function next_line() {\n            var at;\n            character = 1;\n            source_row = lines[line];\n            line += 1;\n            if (source_row === undefined) {\n                return false;\n            }\n            at = source_row.search(/\\t/);\n            if (at >= 0) {\n                if (option.white) {\n                    source_row = source_row.replace(/\\t/g, ' ');\n                } else {\n                    warn('use_spaces', line, at + 1);\n                }\n            }\n            at = source_row.search(cx);\n            if (at >= 0) {\n                warn('unsafe', line, at);\n            }\n            if (option.maxlen && option.maxlen < source_row.length) {\n                warn('too_long', line, source_row.length);\n            }\n            return true;\n        }\n\n// Produce a token object.  The token inherits from a syntax symbol.\n\n        function it(type, value) {\n            var id, the_token;\n            if (type === '(string)') {\n                if (jx.test(value)) {\n                    warn('url', line, from);\n                }\n            }\n            the_token = Object.create(syntax[(\n                type === '(punctuator)' || (type === '(identifier)' &&\n                        Object.prototype.hasOwnProperty.call(syntax, value))\n                    ? value\n                    : type\n            )] || syntax['(error)']);\n            if (type === '(identifier)') {\n                the_token.identifier = true;\n                if (value === '__iterator__' || value === '__proto__') {\n                    stop('reserved_a', line, from, value);\n                } else if (!option.nomen &&\n                        (value.charAt(0) === '_' ||\n                        value.charAt(value.length - 1) === '_')) {\n                    warn('dangling_a', line, from, value);\n                }\n            }\n            if (type === '(number)') {\n                the_token.number = +value;\n            } else if (value !== undefined) {\n                the_token.string = String(value);\n            }\n            the_token.line = line;\n            the_token.from = from;\n            the_token.thru = character;\n            if (comments.length) {\n                the_token.comments = comments;\n                comments = [];\n            }\n            id = the_token.id;\n            prereg = id && (\n                ('(,=:[!&|?{};~+-*%^<>'.indexOf(id.charAt(id.length - 1)) >= 0) ||\n                id === 'return' || id === 'case'\n            );\n            return the_token;\n        }\n\n        function match(x) {\n            var exec = x.exec(source_row), first;\n            if (exec) {\n                length = exec[0].length;\n                first = exec[1];\n                c = first.charAt(0);\n                source_row = source_row.slice(length);\n                from = character + length - first.length;\n                character += length;\n                return first;\n            }\n            for (;;) {\n                if (!source_row) {\n                    if (!option.white) {\n                        warn('unexpected_char_a', line, character - 1, '(space)');\n                    }\n                    return;\n                }\n                c = source_row.charAt(0);\n                if (c !== ' ') {\n                    break;\n                }\n                source_row = source_row.slice(1);\n                character += 1;\n            }\n            stop('unexpected_char_a', line, character, c);\n\n        }\n\n        function string(x) {\n            var ch, at = 0, r = '', result;\n\n            function hex(n) {\n                var i = parseInt(source_row.substr(at + 1, n), 16);\n                at += n;\n                if (i >= 32 && i <= 126 &&\n                        i !== 34 && i !== 92 && i !== 39) {\n                    warn('unexpected_a', line, character, '\\\\');\n                }\n                character += n;\n                ch = String.fromCharCode(i);\n            }\n\n            if (json_mode && x !== '\"') {\n                warn('expected_a_b', line, character, '\"', x);\n            }\n\n            for (;;) {\n                while (at >= source_row.length) {\n                    at = 0;\n                    if (!next_line()) {\n                        stop('unclosed', line - 1, from);\n                    }\n                }\n                ch = source_row.charAt(at);\n                if (ch === x) {\n                    character += 1;\n                    source_row = source_row.slice(at + 1);\n                    result = it('(string)', r);\n                    result.quote = x;\n                    return result;\n                }\n                if (ch < ' ') {\n                    if (ch === '\\n' || ch === '\\r') {\n                        break;\n                    }\n                    warn('control_a', line, character + at,\n                        source_row.slice(0, at));\n                } else if (ch === '\\\\') {\n                    at += 1;\n                    character += 1;\n                    ch = source_row.charAt(at);\n                    switch (ch) {\n                    case '':\n                        warn('unexpected_a', line, character, '\\\\');\n                        next_line();\n                        at = -1;\n                        break;\n                    case '\\'':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\\\'');\n                        }\n                        break;\n                    case 'u':\n                        hex(4);\n                        break;\n                    case 'v':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\v');\n                        }\n                        ch = '\\v';\n                        break;\n                    case 'x':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\x');\n                        }\n                        hex(2);\n                        break;\n                    default:\n                        if (typeof descapes[ch] !== 'string') {\n                            warn(ch >= '0' && ch <= '7' ? 'octal_a' : 'unexpected_a',\n                                line, character, '\\\\' + ch);\n                        } else {\n                            ch = descapes[ch];\n                        }\n                    }\n                }\n                r += ch;\n                character += 1;\n                at += 1;\n            }\n        }\n\n        function number(snippet) {\n            var digit;\n            if (source_row.charAt(0).isAlpha()) {\n                warn('expected_space_a_b',\n                    line, character, c, source_row.charAt(0));\n            }\n            if (c === '0') {\n                digit = snippet.charAt(1);\n                if (digit.isDigit()) {\n                    if (token.id !== '.') {\n                        warn('unexpected_a', line, character, snippet);\n                    }\n                } else if (json_mode && (digit === 'x' || digit === 'X')) {\n                    warn('unexpected_a', line, character, '0x');\n                }\n            }\n            if (snippet.slice(snippet.length - 1) === '.') {\n                warn('trailing_decimal_a', line, character, snippet);\n            }\n            digit = +snippet;\n            if (!isFinite(digit)) {\n                warn('bad_number', line, character, snippet);\n            }\n            snippet = digit;\n            return it('(number)', snippet);\n        }\n\n        function comment(snippet, type) {\n            if (comments_off) {\n                warn('unexpected_comment', line, character);\n            } else if (!option.todo && tox.test(snippet)) {\n                warn('todo_comment', line, character);\n            }\n            comments.push({\n                id: type,\n                from: from,\n                thru: character,\n                line: line,\n                string: snippet\n            });\n        }\n\n        function regexp() {\n            var at = 0,\n                b,\n                bit,\n                depth = 0,\n                flag = '',\n                high,\n                letter,\n                low,\n                potential,\n                quote,\n                result;\n            for (;;) {\n                b = true;\n                c = source_row.charAt(at);\n                at += 1;\n                switch (c) {\n                case '':\n                    stop('unclosed_regexp', line, from);\n                    return;\n                case '/':\n                    if (depth > 0) {\n                        warn('unescaped_a', line, from + at, '/');\n                    }\n                    c = source_row.slice(0, at - 1);\n                    potential = Object.create(regexp_flag);\n                    for (;;) {\n                        letter = source_row.charAt(at);\n                        if (potential[letter] !== true) {\n                            break;\n                        }\n                        potential[letter] = false;\n                        at += 1;\n                        flag += letter;\n                    }\n                    if (source_row.charAt(at).isAlpha()) {\n                        stop('unexpected_a', line, from, source_row.charAt(at));\n                    }\n                    character += at;\n                    source_row = source_row.slice(at);\n                    quote = source_row.charAt(0);\n                    if (quote === '/' || quote === '*') {\n                        stop('confusing_regexp', line, from);\n                    }\n                    result = it('(regexp)', c);\n                    result.flag = flag;\n                    return result;\n                case '\\\\':\n                    c = source_row.charAt(at);\n                    if (c < ' ') {\n                        warn('control_a', line, from + at, String(c));\n                    } else if (c === '<') {\n                        warn('unexpected_a', line, from + at, '\\\\');\n                    }\n                    at += 1;\n                    break;\n                case '(':\n                    depth += 1;\n                    b = false;\n                    if (source_row.charAt(at) === '?') {\n                        at += 1;\n                        switch (source_row.charAt(at)) {\n                        case ':':\n                        case '=':\n                        case '!':\n                            at += 1;\n                            break;\n                        default:\n                            warn('expected_a_b', line, from + at,\n                                ':', source_row.charAt(at));\n                        }\n                    }\n                    break;\n                case '|':\n                    b = false;\n                    break;\n                case ')':\n                    if (depth === 0) {\n                        warn('unescaped_a', line, from + at, ')');\n                    } else {\n                        depth -= 1;\n                    }\n                    break;\n                case ' ':\n                    pos = 1;\n                    while (source_row.charAt(at) === ' ') {\n                        at += 1;\n                        pos += 1;\n                    }\n                    if (pos > 1) {\n                        warn('use_braces', line, from + at, pos);\n                    }\n                    break;\n                case '[':\n                    c = source_row.charAt(at);\n                    if (c === '^') {\n                        at += 1;\n                        if (!option.regexp) {\n                            warn('insecure_a', line, from + at, c);\n                        } else if (source_row.charAt(at) === ']') {\n                            stop('unescaped_a', line, from + at, '^');\n                        }\n                    }\n                    bit = false;\n                    if (c === ']') {\n                        warn('empty_class', line, from + at - 1);\n                        bit = true;\n                    }\nklass:              do {\n                        c = source_row.charAt(at);\n                        at += 1;\n                        switch (c) {\n                        case '[':\n                        case '^':\n                            warn('unescaped_a', line, from + at, c);\n                            bit = true;\n                            break;\n                        case '-':\n                            if (bit) {\n                                bit = false;\n                            } else {\n                                warn('unescaped_a', line, from + at, '-');\n                                bit = true;\n                            }\n                            break;\n                        case ']':\n                            if (!bit) {\n                                warn('unescaped_a', line, from + at - 1, '-');\n                            }\n                            break klass;\n                        case '\\\\':\n                            c = source_row.charAt(at);\n                            if (c < ' ') {\n                                warn('control_a', line, from + at, String(c));\n                            } else if (c === '<') {\n                                warn('unexpected_a', line, from + at, '\\\\');\n                            }\n                            at += 1;\n                            bit = true;\n                            break;\n                        case '/':\n                            warn('unescaped_a', line, from + at - 1, '/');\n                            bit = true;\n                            break;\n                        default:\n                            bit = true;\n                        }\n                    } while (c);\n                    break;\n                case '.':\n                    if (!option.regexp) {\n                        warn('insecure_a', line, from + at, c);\n                    }\n                    break;\n                case ']':\n                case '?':\n                case '{':\n                case '}':\n                case '+':\n                case '*':\n                    warn('unescaped_a', line, from + at, c);\n                    break;\n                }\n                if (b) {\n                    switch (source_row.charAt(at)) {\n                    case '?':\n                    case '+':\n                    case '*':\n                        at += 1;\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        break;\n                    case '{':\n                        at += 1;\n                        c = source_row.charAt(at);\n                        if (c < '0' || c > '9') {\n                            warn('expected_number_a', line,\n                                from + at, c);\n                        }\n                        at += 1;\n                        low = +c;\n                        for (;;) {\n                            c = source_row.charAt(at);\n                            if (c < '0' || c > '9') {\n                                break;\n                            }\n                            at += 1;\n                            low = +c + (low * 10);\n                        }\n                        high = low;\n                        if (c === ',') {\n                            at += 1;\n                            high = Infinity;\n                            c = source_row.charAt(at);\n                            if (c >= '0' && c <= '9') {\n                                at += 1;\n                                high = +c;\n                                for (;;) {\n                                    c = source_row.charAt(at);\n                                    if (c < '0' || c > '9') {\n                                        break;\n                                    }\n                                    at += 1;\n                                    high = +c + (high * 10);\n                                }\n                            }\n                        }\n                        if (source_row.charAt(at) !== '}') {\n                            warn('expected_a_b', line, from + at,\n                                '}', c);\n                        } else {\n                            at += 1;\n                        }\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        if (low > high) {\n                            warn('not_greater', line, from + at,\n                                low, high);\n                        }\n                        break;\n                    }\n                }\n            }\n            c = source_row.slice(0, at - 1);\n            character += at;\n            source_row = source_row.slice(at);\n            return it('(regexp)', c);\n        }\n\n// Public lex methods\n\n        return {\n            init: function (source) {\n                if (typeof source === 'string') {\n                    lines = source.split(crlfx);\n                } else {\n                    lines = source;\n                }\n                line = 0;\n                next_line();\n                from = 1;\n            },\n\n// token -- this is called by advance to get the next token.\n\n            token: function () {\n                var first, i, snippet;\n\n                for (;;) {\n                    while (!source_row) {\n                        if (!next_line()) {\n                            return it('(end)');\n                        }\n                    }\n                    snippet = match(tx);\n                    if (snippet) {\n\n//      identifier\n\n                        first = snippet.charAt(0);\n                        if (first.isAlpha() || first === '_' || first === '$') {\n                            return it('(identifier)', snippet);\n                        }\n\n//      number\n\n                        if (first.isDigit()) {\n                            return number(snippet);\n                        }\n                        switch (snippet) {\n\n//      string\n\n                        case '\"':\n                        case \"'\":\n                            return string(snippet);\n\n//      // comment\n\n                        case '//':\n                            comment(source_row, '//');\n                            source_row = '';\n                            break;\n\n//      /* comment\n\n                        case '/*':\n                            for (;;) {\n                                i = source_row.search(lx);\n                                if (i >= 0) {\n                                    break;\n                                }\n                                character = source_row.length;\n                                comment(source_row);\n                                from = 0;\n                                if (!next_line()) {\n                                    stop('unclosed_comment', line, character);\n                                }\n                            }\n                            comment(source_row.slice(0, i), '/*');\n                            character += i + 2;\n                            if (source_row.charAt(i) === '/') {\n                                stop('nested_comment', line, character);\n                            }\n                            source_row = source_row.slice(i + 2);\n                            break;\n\n                        case '':\n                            break;\n//      /\n                        case '/':\n                            if (token.id === '/=') {\n                                stop('slash_equal', line, from);\n                            }\n                            return prereg\n                                ? regexp()\n                                : it('(punctuator)', snippet);\n\n//      punctuator\n                        default:\n                            return it('(punctuator)', snippet);\n                        }\n                    }\n                }\n            }\n        };\n    }());\n\n    function define(kind, token) {\n\n// Define a name.\n\n        var name = token.string,\n            master = scope[name];       // The current definition of the name\n\n// vars are created with a deadzone, so that the expression that initializes\n// the var cannot access the var. Functions are not writeable.\n\n        token.dead = false;\n        token.init = false;\n        token.kind = kind;\n        token.master = master;\n        token.used = 0;\n        token.writeable = true;\n\n// Global variables are a little weird. They can be defined multiple times.\n// Some predefined global vars are (or should) not be writeable.\n\n        if (kind === 'var' && funct === global_funct) {\n            if (!master) {\n                if (predefined[name] === false) {\n                    token.writeable = false;\n                }\n                global_scope[name] = token;\n            }\n        } else {\n\n// It is an error if the name has already been defined in this scope, except\n// when reusing an exception variable name.\n\n            if (master) {\n                if (master.function === funct) {\n                    if (master.kind !== 'exception' || kind !== 'exception' ||\n                            !master.dead) {\n                        token.warn('already_defined', name);\n                    }\n                } else if (master.function !== global_funct) {\n                    if (kind === 'var') {\n                        token.warn('redefinition_a_b', name, master.line);\n                    }\n                }\n            }\n            scope[name] = token;\n            if (kind === 'var') {\n                block_var.push(name);\n            }\n        }\n    }\n\n    function peek(distance) {\n\n// Peek ahead to a future token. The distance is how far ahead to look. The\n// default is the next token.\n\n        var found, slot = 0;\n\n        distance = distance || 0;\n        while (slot <= distance) {\n            found = lookahead[slot];\n            if (!found) {\n                found = lookahead[slot] = lex.token();\n            }\n            slot += 1;\n        }\n        return found;\n    }\n\n\n    function advance(id, match) {\n\n// Produce the next token, also looking for programming errors.\n\n        if (indent) {\n\n// If indentation checking was requested, then inspect all of the line breakings.\n// The var statement is tricky because the names might be aligned or not. We\n// look at the first line break after the var to determine the programmer's\n// intention.\n\n            if (var_mode && next_token.line !== token.line) {\n                if ((var_mode !== indent || !next_token.edge) &&\n                        next_token.from === indent.at -\n                        (next_token.edge ? option.indent : 0)) {\n                    var dent = indent;\n                    for (;;) {\n                        dent.at -= option.indent;\n                        if (dent === var_mode) {\n                            break;\n                        }\n                        dent = dent.was;\n                    }\n                    dent.open = false;\n                }\n                var_mode = null;\n            }\n            if (next_token.id === '?' && indent.mode === ':' &&\n                    token.line !== next_token.line) {\n                indent.at -= option.indent;\n            }\n            if (indent.open) {\n\n// If the token is an edge.\n\n                if (next_token.edge) {\n                    if (next_token.edge === 'label') {\n                        expected_at(1);\n                    } else if (next_token.edge === 'case' || indent.mode === 'statement') {\n                        expected_at(indent.at - option.indent);\n                    } else if (indent.mode !== 'array' || next_token.line !== token.line) {\n                        expected_at(indent.at);\n                    }\n\n// If the token is not an edge, but is the first token on the line.\n\n                } else if (next_token.line !== token.line) {\n                    if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                    indent.wrap = true;\n                }\n            } else if (next_token.line !== token.line) {\n                if (next_token.edge) {\n                    expected_at(indent.at);\n                } else {\n                    indent.wrap = true;\n                    if (indent.mode === 'statement' || indent.mode === 'var') {\n                        expected_at(indent.at + option.indent);\n                    } else if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                }\n            }\n        }\n\n        switch (token.id) {\n        case '(number)':\n            if (next_token.id === '.') {\n                next_token.warn('trailing_decimal_a');\n            }\n            break;\n        case '-':\n            if (next_token.id === '-' || next_token.id === '--') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        case '+':\n            if (next_token.id === '+' || next_token.id === '++') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        }\n        if (token.id === '(string)' || token.identifier) {\n            anonname = token.string;\n        }\n\n        if (id && next_token.id !== id) {\n            if (match) {\n                next_token.warn('expected_a_b_from_c_d', id,\n                    match.id, match.line, artifact());\n            } else if (!next_token.identifier || next_token.string !== id) {\n                next_token.warn('expected_a_b', id, artifact());\n            }\n        }\n        prev_token = token;\n        token = next_token;\n        next_token = lookahead.shift() || lex.token();\n        next_token.function = funct;\n        tokens.push(next_token);\n    }\n\n\n    function do_globals() {\n        var name, writeable;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            writeable = false;\n            if (next_token.id === ':') {\n                advance(':');\n                switch (next_token.id) {\n                case 'true':\n                    writeable = predefined[name] !== false;\n                    advance('true');\n                    break;\n                case 'false':\n                    advance('false');\n                    break;\n                default:\n                    next_token.stop('unexpected_a');\n                }\n            }\n            predefined[name] = writeable;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    function do_jslint() {\n        var name, value;\n        while (next_token.id === '(string)' || next_token.identifier) {\n            name = next_token.string;\n            if (!allowed_option[name]) {\n                next_token.stop('unexpected_a');\n            }\n            advance();\n            if (next_token.id !== ':') {\n                next_token.stop('expected_a_b', ':', artifact());\n            }\n            advance(':');\n            if (typeof allowed_option[name] === 'number') {\n                value = next_token.number;\n                if (value > allowed_option[name] || value <= 0 ||\n                        Math.floor(value) !== value) {\n                    next_token.stop('expected_small_a');\n                }\n                option[name] = value;\n            } else {\n                if (next_token.id === 'true') {\n                    option[name] = true;\n                } else if (next_token.id === 'false') {\n                    option[name] = false;\n                } else {\n                    next_token.stop('unexpected_a');\n                }\n            }\n            advance();\n            if (next_token.id === ',') {\n                advance(',');\n            }\n        }\n        assume();\n    }\n\n\n    function do_properties() {\n        var name;\n        option.properties = true;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            if (next_token.id === ':') {\n                for (;;) {\n                    advance();\n                    if (next_token.id !== '(string)' && !next_token.identifier) {\n                        break;\n                    }\n                }\n            }\n            property[name] = 0;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    directive = function directive() {\n        var command = this.id,\n            old_comments_off = comments_off,\n            old_indent = indent;\n        comments_off = true;\n        indent = null;\n        if (next_token.line === token.line && next_token.from === token.thru) {\n            next_token.warn('missing_space_a_b', artifact(token), artifact());\n        }\n        if (lookahead.length > 0) {\n            this.warn('unexpected_a');\n        }\n        switch (command) {\n        case '/*properties':\n        case '/*property':\n        case '/*members':\n        case '/*member':\n            do_properties();\n            break;\n        case '/*jslint':\n            do_jslint();\n            break;\n        case '/*globals':\n        case '/*global':\n            do_globals();\n            break;\n        default:\n            this.stop('unexpected_a');\n        }\n        comments_off = old_comments_off;\n        advance('*/');\n        indent = old_indent;\n    };\n\n\n// Indentation intention\n\n    function edge(mode) {\n        next_token.edge = indent ? indent.open && (mode || 'edge') : '';\n    }\n\n\n    function step_in(mode) {\n        var open;\n        if (typeof mode === 'number') {\n            indent = {\n                at: +mode,\n                open: true,\n                was: indent\n            };\n        } else if (!indent) {\n            indent = {\n                at: 1,\n                mode: 'statement',\n                open: true\n            };\n        } else if (mode === 'statement') {\n            indent = {\n                at: indent.at,\n                open: true,\n                was: indent\n            };\n        } else {\n            open = mode === 'var' || next_token.line !== token.line;\n            indent = {\n                at: (open || mode === 'control'\n                    ? indent.at + option.indent\n                    : indent.at) + (indent.wrap ? option.indent : 0),\n                mode: mode,\n                open: open,\n                was: indent\n            };\n            if (mode === 'var' && open) {\n                var_mode = indent;\n            }\n        }\n    }\n\n    function step_out(id, symbol) {\n        if (id) {\n            if (indent && indent.open) {\n                indent.at -= option.indent;\n                edge();\n            }\n            advance(id, symbol);\n        }\n        if (indent) {\n            indent = indent.was;\n        }\n    }\n\n// Functions for conformance of whitespace.\n\n    function one_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && !option.white &&\n                (token.line !== right.line ||\n                token.thru + 1 !== right.from)) {\n            right.warn('expected_space_a_b', artifact(token), artifact(right));\n        }\n    }\n\n    function one_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru + 1 !== right.from))) {\n            right.warn('expected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if ((!option.white) &&\n                left.thru !== right.from && left.line === right.line) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru !== right.from))) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function spaces(left, right) {\n        if (!option.white) {\n            left = left || token;\n            right = right || next_token;\n            if (left.thru === right.from && left.line === right.line) {\n                right.warn('missing_space_a_b', artifact(left), artifact(right));\n            }\n        }\n    }\n\n    function comma() {\n        if (next_token.id !== ',') {\n            warn('expected_a_b', token.line, token.thru, ',', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(',');\n            spaces();\n        }\n    }\n\n\n    function semicolon() {\n        if (next_token.id !== ';') {\n            warn('expected_a_b', token.line, token.thru, ';', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(';');\n            if (semicolon_coda[next_token.id] !== true) {\n                spaces();\n            }\n        }\n    }\n\n    function use_strict() {\n        if (next_token.string === 'use strict') {\n            if (strict_mode) {\n                next_token.warn('unnecessary_use');\n            }\n            edge();\n            advance();\n            semicolon();\n            strict_mode = true;\n            return true;\n        }\n        return false;\n    }\n\n\n    function are_similar(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (Array.isArray(a)) {\n            if (Array.isArray(b) && a.length === b.length) {\n                var i;\n                for (i = 0; i < a.length; i += 1) {\n                    if (!are_similar(a[i], b[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n        if (Array.isArray(b)) {\n            return false;\n        }\n        if (a.id === '(number)' && b.id === '(number)') {\n            return a.number === b.number;\n        }\n        if (a.arity === b.arity && a.string === b.string) {\n            switch (a.arity) {\n            case undefined:\n                return a.string === b.string;\n            case 'prefix':\n            case 'suffix':\n                return a.id === b.id && are_similar(a.first, b.first) &&\n                    a.id !== '{' && a.id !== '[';\n            case 'infix':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second);\n            case 'ternary':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second) &&\n                    are_similar(a.third, b.third);\n            case 'function':\n            case 'regexp':\n                return false;\n            default:\n                return true;\n            }\n        }\n        if (a.id === '.' && b.id === '[' && b.arity === 'infix') {\n            return a.second.string === b.second.string && b.second.id === '(string)';\n        }\n        if (a.id === '[' && a.arity === 'infix' && b.id === '.') {\n            return a.second.string === b.second.string && a.second.id === '(string)';\n        }\n        return false;\n    }\n\n\n// This is the heart of JSLINT, the Pratt parser. In addition to parsing, it\n// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is\n// like .nud except that it is only used on the first token of a statement.\n// Having .fud makes it much easier to define statement-oriented languages like\n// JavaScript. I retained Pratt's nomenclature.\n\n// .nud     Null denotation\n// .fud     First null denotation\n// .led     Left denotation\n//  lbp     Left binding power\n//  rbp     Right binding power\n\n// They are elements of the parsing method called Top Down Operator Precedence.\n\n    function expression(rbp, initial) {\n\n// rbp is the right binding power.\n// initial indicates that this is the first expression of a statement.\n\n        var left;\n        if (next_token.id === '(end)') {\n            token.stop('unexpected_a', next_token.id);\n        }\n        advance();\n        if (initial) {\n            anonname = 'anonymous';\n        }\n        if (initial === true && token.fud) {\n            left = token.fud();\n        } else {\n            if (token.nud) {\n                left = token.nud();\n            } else {\n                if (next_token.id === '(number)' && token.id === '.') {\n                    token.warn('leading_decimal_a', artifact());\n                    advance();\n                    return token;\n                }\n                token.stop('expected_identifier_a', artifact(token));\n            }\n            while (rbp < next_token.lbp) {\n                advance();\n                left = token.led(left);\n            }\n        }\n        if (left && left.assign && !initial) {\n            if (!option.ass) {\n                left.warn('assignment_expression');\n            }\n            if (left.id !== '=' && left.first.master) {\n                left.first.master.used = true;\n            }\n        }\n        return left;\n    }\n\n    protosymbol = {\n        nud: function () {\n            this.stop('unexpected_a');\n        },\n        led: function () {\n            this.stop('expected_operator_a');\n        },\n        warn: function (code, a, b, c, d) {\n            if (!this.warning) {\n                this.warning = warn(code, this.line || 0, this.from || 0,\n                    a || artifact(this), b, c, d);\n            }\n        },\n        stop: function (code, a, b, c, d) {\n            this.warning = undefined;\n            this.warn(code, a, b, c, d);\n            return quit('stopping', this.line, this.character);\n        },\n        lbp: 0\n    };\n\n// Functional constructors for making the symbols that will be inherited by\n// tokens.\n\n    function symbol(s, bp) {\n        var x = syntax[s];\n        if (!x) {\n            x = Object.create(protosymbol);\n            x.id = x.string = s;\n            x.lbp = bp || 0;\n            syntax[s] = x;\n        }\n        return x;\n    }\n\n    function postscript(x) {\n        x.postscript = true;\n        return x;\n    }\n\n    function ultimate(s) {\n        var x = symbol(s, 0);\n        x.from = 1;\n        x.thru = 1;\n        x.line = 0;\n        x.edge = 'edge';\n        x.string = s;\n        return postscript(x);\n    }\n\n    function reserve_name(x) {\n        var c = x.id.charAt(0);\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            x.identifier = x.reserved = true;\n        }\n        return x;\n    }\n\n    function stmt(s, f) {\n        var x = symbol(s);\n        x.fud = f;\n        return reserve_name(x);\n    }\n\n    function disrupt_stmt(s, f) {\n        var x = stmt(s, f);\n        x.disrupt = true;\n    }\n\n    function labeled_stmt(s, f) {\n        var x = stmt(s, function labeled() {\n            var the_statement;\n            if (funct.breakage) {\n                funct.breakage.push(this);\n            } else {\n                funct.breakage = [this];\n            }\n            the_statement = f.apply(this);\n            if (funct.breakage.length > 1) {\n                funct.breakage.pop();\n            } else {\n                delete funct.breakage;\n            }\n            return the_statement;\n        });\n        x.labeled = true;\n    }\n\n    function prefix(s, f) {\n        var x = symbol(s, 150);\n        reserve_name(x);\n        x.nud = function () {\n            var that = this;\n            that.arity = 'prefix';\n            if (typeof f === 'function') {\n                that = f(that);\n                if (that.arity !== 'prefix') {\n                    return that;\n                }\n            } else {\n                if (s === 'typeof') {\n                    one_space();\n                } else {\n                    no_space_only();\n                }\n                that.first = expression(150);\n            }\n            switch (that.id) {\n            case '++':\n            case '--':\n                if (!option.plusplus) {\n                    that.warn('unexpected_a');\n                } else if ((!that.first.identifier || that.first.reserved) &&\n                        that.first.id !== '.' && that.first.id !== '[') {\n                    that.warn('bad_operand');\n                }\n                break;\n            default:\n                if (that.first.arity === 'prefix' ||\n                        that.first.arity === 'function') {\n                    that.warn('unexpected_a');\n                }\n            }\n            return that;\n        };\n        return x;\n    }\n\n\n    function type(s, t, nud) {\n        var x = symbol(s);\n        x.arity = t;\n        if (nud) {\n            x.nud = nud;\n        }\n        return x;\n    }\n\n\n    function reserve(s, f) {\n        var x = symbol(s);\n        x.identifier = x.reserved = true;\n        if (typeof f === 'function') {\n            x.nud = f;\n        }\n        return x;\n    }\n\n\n    function constant(name) {\n        var x = reserve(name);\n        x.string = name;\n        x.nud = return_this;\n        return x;\n    }\n\n\n    function reservevar(s, v) {\n        return reserve(s, function () {\n            if (typeof v === 'function') {\n                v(this);\n            }\n            return this;\n        });\n    }\n\n\n    function infix(s, p, f, w) {\n        var x = symbol(s, p);\n        reserve_name(x);\n        x.led = function (left) {\n            this.arity = 'infix';\n            if (!w) {\n                spaces(prev_token, token);\n                spaces();\n            }\n            if (!option.bitwise && this.bitwise) {\n                this.warn('unexpected_a');\n            }\n            if (typeof f === 'function') {\n                return f(left, this);\n            }\n            this.first = left;\n            this.second = expression(p);\n            return this;\n        };\n        return x;\n    }\n\n    function expected_relation(node, message) {\n        if (node.assign) {\n            node.warn(message || 'conditional_assignment');\n        }\n        return node;\n    }\n\n    function expected_condition(node, message) {\n        switch (node.id) {\n        case '[':\n        case '-':\n            if (node.arity !== 'infix') {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        case 'false':\n        case 'function':\n        case 'Infinity':\n        case 'NaN':\n        case 'null':\n        case 'true':\n        case 'undefined':\n        case 'void':\n        case '(number)':\n        case '(regexp)':\n        case '(string)':\n        case '{':\n        case '?':\n        case '~':\n            node.warn(message || 'weird_condition');\n            break;\n        case '(':\n            if (node.first.id === 'new' ||\n                    (node.first.string === 'Boolean') ||\n                    (node.first.id === '.' &&\n                        numbery[node.first.second.string] === true)) {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        }\n        return node;\n    }\n\n    function check_relation(node) {\n        switch (node.arity) {\n        case 'prefix':\n            switch (node.id) {\n            case '{':\n            case '[':\n                node.warn('unexpected_a');\n                break;\n            case '!':\n                node.warn('confusing_a');\n                break;\n            }\n            break;\n        case 'function':\n        case 'regexp':\n            node.warn('unexpected_a');\n            break;\n        default:\n            if (node.id  === 'NaN') {\n                node.warn('isNaN');\n            } else if (node.relation) {\n                node.warn('weird_relation');\n            }\n        }\n        return node;\n    }\n\n\n    function relation(s, eqeq) {\n        var x = infix(s, 100, function (left, that) {\n            check_relation(left);\n            if (eqeq && !option.eqeq) {\n                that.warn('expected_a_b', eqeq, that.id);\n            }\n            var right = expression(100);\n            if (are_similar(left, right) ||\n                    ((left.id === '(string)' || left.id === '(number)') &&\n                    (right.id === '(string)' || right.id === '(number)'))) {\n                that.warn('weird_relation');\n            } else if (left.id === 'typeof') {\n                if (right.id !== '(string)') {\n                    right.warn(\"expected_string_a\", artifact(right));\n                } else if (right.string === 'undefined' ||\n                        right.string === 'null') {\n                    left.warn(\"unexpected_typeof_a\", right.string);\n                }\n            } else if (right.id === 'typeof') {\n                if (left.id !== '(string)') {\n                    left.warn(\"expected_string_a\", artifact(left));\n                } else if (left.string === 'undefined' ||\n                        left.string === 'null') {\n                    right.warn(\"unexpected_typeof_a\", left.string);\n                }\n            }\n            that.first = left;\n            that.second = check_relation(right);\n            return that;\n        });\n        x.relation = true;\n        return x;\n    }\n\n    function lvalue(that, s) {\n        var master;\n        if (that.identifier) {\n            master = scope[that.string];\n            if (master) {\n                if (scope[that.string].writeable !== true) {\n                    that.warn('read_only');\n                }\n                master.used -= 1;\n                if (s === '=') {\n                    master.init = true;\n                }\n            }\n        } else if (that.id === '.' || that.id === '[') {\n            if (!that.first || that.first.string === 'arguments') {\n                that.warn('bad_assignment');\n            }\n        } else {\n            that.warn('bad_assignment');\n        }\n    }\n\n\n    function assignop(s, op) {\n        var x = infix(s, 20, function (left, that) {\n            var next;\n            that.first = left;\n            lvalue(left, s);\n            that.second = expression(20);\n            if (that.id === '=' && are_similar(that.first, that.second)) {\n                that.warn('weird_assignment');\n            }\n            next = that;\n            while (next_token.id === '=') {\n                lvalue(next.second, '=');\n                next_token.first = next.second;\n                next.second = next_token;\n                next = next_token;\n                advance('=');\n                next.second = expression(20);\n            }\n            return that;\n        });\n        x.assign = true;\n        if (op) {\n            if (syntax[op].bitwise) {\n                x.bitwise = true;\n            }\n        }\n        return x;\n    }\n\n\n    function bitwise(s, p) {\n        var x = infix(s, p, 'number');\n        x.bitwise = true;\n        return x;\n    }\n\n\n    function suffix(s) {\n        var x = symbol(s, 150);\n        x.led = function (left) {\n            no_space_only(prev_token, token);\n            if (!option.plusplus) {\n                this.warn('unexpected_a');\n            } else if ((!left.identifier || left.reserved) &&\n                    left.id !== '.' && left.id !== '[') {\n                this.warn('bad_operand');\n            }\n            this.first = left;\n            this.arity = 'suffix';\n            return this;\n        };\n        return x;\n    }\n\n\n    function optional_identifier(variable) {\n        if (next_token.identifier) {\n            advance();\n            if (token.reserved && variable) {\n                token.warn('expected_identifier_a_reserved');\n            }\n            return token.string;\n        }\n    }\n\n\n    function identifier(variable) {\n        var i = optional_identifier(variable);\n        if (!i) {\n            next_token.stop(token.id === 'function' && next_token.id === '('\n                ? 'name_function'\n                : 'expected_identifier_a');\n        }\n        return i;\n    }\n\n\n    function statement() {\n\n        var label, preamble, the_statement;\n\n// We don't like the empty statement.\n\n        if (next_token.id === ';') {\n            next_token.warn('unexpected_a');\n            semicolon();\n            return;\n        }\n\n// Is this a labeled statement?\n\n        if (next_token.identifier && !next_token.reserved && peek().id === ':') {\n            edge('label');\n            label = next_token;\n            advance();\n            advance(':');\n            define('label', label);\n            if (next_token.labeled !== true || funct === global_funct) {\n                label.stop('unexpected_label_a');\n            } else if (jx.test(label.string + ':')) {\n                label.warn('url');\n            }\n            next_token.label = label;\n            label.init = true;\n            label.statement = next_token;\n        }\n\n// Parse the statement.\n\n        preamble = next_token;\n        if (token.id !== 'else') {\n            edge();\n        }\n        step_in('statement');\n        the_statement = expression(0, true);\n        if (the_statement) {\n\n// Look for the final semicolon.\n\n            if (the_statement.arity === 'statement') {\n                if (the_statement.id === 'switch' ||\n                        (the_statement.block && the_statement.id !== 'do')) {\n                    spaces();\n                } else {\n                    semicolon();\n                }\n            } else {\n\n// If this is an expression statement, determine if it is acceptable.\n// We do not like\n//      new Blah;\n// statements. If it is to be used at all, new should only be used to make\n// objects, not side effects. The expression statements we do like do\n// assignment or invocation or delete.\n\n                if (the_statement.id === '(') {\n                    if (the_statement.first.id === 'new') {\n                        next_token.warn('bad_new');\n                    }\n                } else if (the_statement.id === '++' ||\n                        the_statement.id === '--') {\n                    lvalue(the_statement.first);\n                } else if (!the_statement.assign &&\n                        the_statement.id !== 'delete') {\n                    if (!option.closure || !preamble.comments) {\n                        preamble.warn('assignment_function_expression');\n                    }\n                }\n                semicolon();\n            }\n        }\n        step_out();\n        if (label) {\n            label.dead = true;\n        }\n        return the_statement;\n    }\n\n\n    function statements() {\n        var array = [], disruptor, the_statement;\n\n// A disrupt statement may not be followed by any other statement.\n// If the last statement is disrupt, then the sequence is disrupt.\n\n        while (next_token.postscript !== true) {\n            if (next_token.id === ';') {\n                next_token.warn('unexpected_a');\n                semicolon();\n            } else {\n                if (next_token.string === 'use strict') {\n                    if ((!node_js) || funct !== global_funct || array.length > 0) {\n                        next_token.warn('function_strict');\n                    }\n                    use_strict();\n                }\n                if (disruptor) {\n                    next_token.warn('unreachable_a_b', next_token.string,\n                        disruptor.string);\n                    disruptor = null;\n                }\n                the_statement = statement();\n                if (the_statement) {\n                    array.push(the_statement);\n                    if (the_statement.disrupt) {\n                        disruptor = the_statement;\n                        array.disrupt = true;\n                    }\n                }\n            }\n        }\n        return array;\n    }\n\n\n    function block(kind) {\n\n// A block is a sequence of statements wrapped in braces.\n\n        var array,\n            curly = next_token,\n            old_block_var = block_var,\n            old_in_block = in_block,\n            old_strict_mode = strict_mode;\n\n        in_block = kind !== 'function' && kind !== 'try' && kind !== 'catch';\n        block_var = [];\n        if (curly.id === '{') {\n            spaces();\n            advance('{');\n            step_in();\n            if (kind === 'function' && !use_strict() && !old_strict_mode &&\n                    !option.sloppy && funct.level === 1) {\n                next_token.warn('missing_use_strict');\n            }\n            array = statements();\n            strict_mode = old_strict_mode;\n            step_out('}', curly);\n        } else if (in_block) {\n            curly.stop('expected_a_b', '{', artifact());\n        } else {\n            curly.warn('expected_a_b', '{', artifact());\n            array = [statement()];\n            array.disrupt = array[0].disrupt;\n        }\n        if (kind !== 'catch' && array.length === 0) {\n            curly.warn('empty_block');\n        }\n        block_var.forEach(function (name) {\n            scope[name].dead = true;\n        });\n        block_var = old_block_var;\n        in_block = old_in_block;\n        return array;\n    }\n\n\n    function tally_property(name) {\n        if (option.properties && typeof property[name] !== 'number') {\n            token.warn('unexpected_property_a', name);\n        }\n        if (property[name]) {\n            property[name] += 1;\n        } else {\n            property[name] = 1;\n        }\n    }\n\n\n// ECMAScript parser\n\n    (function () {\n        var x = symbol('(identifier)');\n        x.nud = function () {\n            var name = this.string,\n                master = scope[name],\n                writeable;\n\n// If the master is not in scope, then we may have an undeclared variable.\n// Check the predefined list. If it was predefined, create the global\n// variable.\n\n            if (!master) {\n                writeable = predefined[name];\n                if (typeof writeable === 'boolean') {\n                    global_scope[name] = master = {\n                        dead: false,\n                        function: global_funct,\n                        kind: 'var',\n                        string: name,\n                        writeable: writeable\n                    };\n\n// But if the variable is not in scope, and is not predefined, and if we are not\n// in the global scope, then we have an undefined variable error.\n\n                } else {\n                    token.warn('used_before_a');\n                }\n            } else {\n                this.master = master;\n            }\n\n// Annotate uses that cross scope boundaries.\n\n            if (master) {\n                if (master.kind === 'label') {\n                    this.warn('a_label');\n                } else {\n                    if (master.dead === true || master.dead === funct) {\n                        this.warn('a_scope');\n                    }\n                    master.used += 1;\n                    if (master.function !== funct) {\n                        if (master.function === global_funct) {\n                            funct.global.push(name);\n                        } else {\n                            master.function.closure.push(name);\n                            funct.outer.push(name);\n                        }\n                    }\n                }\n            }\n            return this;\n        };\n        x.identifier = true;\n    }());\n\n\n// Build the syntax table by declaring the syntactic elements.\n\n    type('(array)', 'array');\n    type('(function)', 'function');\n    type('(number)', 'number', return_this);\n    type('(object)', 'object');\n    type('(string)', 'string', return_this);\n    type('(boolean)', 'boolean', return_this);\n    type('(regexp)', 'regexp', return_this);\n\n    ultimate('(begin)');\n    ultimate('(end)');\n    ultimate('(error)');\n    postscript(symbol('}'));\n    symbol(')');\n    symbol(']');\n    postscript(symbol('\"'));\n    postscript(symbol('\\''));\n    symbol(';');\n    symbol(':');\n    symbol(',');\n    symbol('#');\n    symbol('@');\n    symbol('*/');\n    postscript(reserve('case'));\n    reserve('catch');\n    postscript(reserve('default'));\n    reserve('else');\n    reserve('finally');\n\n    reservevar('arguments', function (x) {\n        if (strict_mode && funct === global_funct) {\n            x.warn('strict');\n        }\n        funct.arguments = true;\n    });\n    reservevar('eval');\n    constant('false', 'boolean');\n    constant('Infinity', 'number');\n    constant('NaN', 'number');\n    constant('null', '');\n    reservevar('this', function (x) {\n        if (strict_mode && funct.statement && funct.name.charAt(0) > 'Z') {\n            x.warn('strict');\n        }\n    });\n    constant('true', 'boolean');\n    constant('undefined', '');\n\n    infix('?', 30, function (left, that) {\n        step_in('?');\n        that.first = expected_condition(expected_relation(left));\n        that.second = expression(0);\n        spaces();\n        step_out();\n        var colon = next_token;\n        advance(':');\n        step_in(':');\n        spaces();\n        that.third = expression(10);\n        that.arity = 'ternary';\n        if (are_similar(that.second, that.third)) {\n            colon.warn('weird_ternary');\n        } else if (are_similar(that.first, that.second)) {\n            that.warn('use_or');\n        }\n        step_out();\n        return that;\n    });\n\n    infix('||', 40, function (left, that) {\n        function paren_check(that) {\n            if (that.id === '&&' && !that.paren) {\n                that.warn('and');\n            }\n            return that;\n        }\n\n        that.first = paren_check(expected_condition(expected_relation(left)));\n        that.second = paren_check(expected_relation(expression(40)));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    infix('&&', 50, function (left, that) {\n        that.first = expected_condition(expected_relation(left));\n        that.second = expected_relation(expression(50));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    prefix('void', function (that) {\n        that.first = expression(0);\n        that.warn('expected_a_b', 'undefined', 'void');\n        return that;\n    });\n\n    bitwise('|', 70);\n    bitwise('^', 80);\n    bitwise('&', 90);\n\n    relation('==', '===');\n    relation('===');\n    relation('!=', '!==');\n    relation('!==');\n    relation('<');\n    relation('>');\n    relation('<=');\n    relation('>=');\n\n    bitwise('<<', 120);\n    bitwise('>>', 120);\n    bitwise('>>>', 120);\n\n    infix('in', 120, function (left, that) {\n        that.warn('infix_in');\n        that.left = left;\n        that.right = expression(130);\n        return that;\n    });\n    infix('instanceof', 120);\n    infix('+', 130, function (left, that) {\n        if (left.id === '(number)') {\n            if (left.number === 0) {\n                left.warn('unexpected_a', '0');\n            }\n        } else if (left.id === '(string)') {\n            if (left.string === '') {\n                left.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        var right = expression(130);\n        if (right.id === '(number)') {\n            if (right.number === 0) {\n                right.warn('unexpected_a', '0');\n            }\n        } else if (right.id === '(string)') {\n            if (right.string === '') {\n                right.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        if (left.id === right.id) {\n            if (left.id === '(string)' || left.id === '(number)') {\n                if (left.id === '(string)') {\n                    left.string += right.string;\n                    if (jx.test(left.string)) {\n                        left.warn('url');\n                    }\n                } else {\n                    left.number += right.number;\n                }\n                left.thru = right.thru;\n                return left;\n            }\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('+');\n    prefix('+++', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('+++', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('-', 130, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(130);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number -= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('-');\n    prefix('---', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('---', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('*', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number *= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('/', 140, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number /= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('%', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number %= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n\n    suffix('++');\n    prefix('++');\n\n    suffix('--');\n    prefix('--');\n    prefix('delete', function (that) {\n        one_space();\n        var p = expression(0);\n        if (!p || (p.id !== '.' && p.id !== '[')) {\n            next_token.warn('deleted');\n        }\n        that.first = p;\n        return that;\n    });\n\n\n    prefix('~', function (that) {\n        no_space_only();\n        if (!option.bitwise) {\n            that.warn('unexpected_a');\n        }\n        that.first = expression(150);\n        return that;\n    });\n    function banger(that) {\n        no_space_only();\n        that.first = expected_condition(expression(150));\n        if (bang[that.first.id] === that || that.first.assign) {\n            that.warn('confusing_a');\n        }\n        return that;\n    }\n    prefix('!', banger);\n    prefix('!!', banger);\n    prefix('typeof');\n    prefix('new', function (that) {\n        one_space();\n        var c = expression(160), n, p, v;\n        that.first = c;\n        if (c.id !== 'function') {\n            if (c.identifier) {\n                switch (c.string) {\n                case 'Object':\n                    token.warn('use_object');\n                    break;\n                case 'Array':\n                    if (next_token.id === '(') {\n                        p = next_token;\n                        p.first = this;\n                        advance('(');\n                        if (next_token.id !== ')') {\n                            n = expression(0);\n                            p.second = [n];\n                            if (n.id === '(string)' || next_token.id === ',') {\n                                p.warn('use_array');\n                            }\n                            while (next_token.id === ',') {\n                                advance(',');\n                                p.second.push(expression(0));\n                            }\n                        } else {\n                            token.warn('use_array');\n                        }\n                        advance(')', p);\n                        return p;\n                    }\n                    token.warn('use_array');\n                    break;\n                case 'Number':\n                case 'String':\n                case 'Boolean':\n                case 'Math':\n                case 'JSON':\n                    c.warn('not_a_constructor');\n                    break;\n                case 'Function':\n                    if (!option.evil) {\n                        next_token.warn('function_eval');\n                    }\n                    break;\n                case 'Date':\n                case 'RegExp':\n                case 'this':\n                    break;\n                default:\n                    if (c.id !== 'function') {\n                        v = c.string.charAt(0);\n                        if (!option.newcap && (v < 'A' || v > 'Z')) {\n                            token.warn('constructor_name_a');\n                        }\n                    }\n                }\n            } else {\n                if (c.id !== '.' && c.id !== '[' && c.id !== '(') {\n                    token.warn('bad_constructor');\n                }\n            }\n        } else {\n            that.warn('weird_new');\n        }\n        if (next_token.id !== '(') {\n            next_token.warn('missing_a', '()');\n        }\n        return that;\n    });\n\n    infix('(', 160, function (left, that) {\n        var e, p;\n        if (indent && indent.mode === 'expression') {\n            no_space(prev_token, token);\n        } else {\n            no_space_only(prev_token, token);\n        }\n        if (!left.immed && left.id === 'function') {\n            next_token.warn('wrap_immediate');\n        }\n        p = [];\n        if (left.identifier) {\n            if (left.string.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {\n                if (left.string !== 'Number' && left.string !== 'String' &&\n                        left.string !== 'Boolean' && left.string !== 'Date') {\n                    if (left.string === 'Math') {\n                        left.warn('not_a_function');\n                    } else if (left.string === 'Object') {\n                        token.warn('use_object');\n                    } else if (left.string === 'Array' || !option.newcap) {\n                        left.warn('missing_a', 'new');\n                    }\n                }\n            } else if (left.string === 'JSON') {\n                left.warn('not_a_function');\n            }\n        } else if (left.id === '.') {\n            if (left.second.string === 'split' &&\n                    left.first.id === '(string)') {\n                left.second.warn('use_array');\n            }\n        }\n        step_in();\n        if (next_token.id !== ')') {\n            no_space();\n            for (;;) {\n                edge();\n                e = expression(10);\n                if (left.string === 'Boolean' && (e.id === '!' || e.id === '~')) {\n                    e.warn('weird_condition');\n                }\n                p.push(e);\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', that);\n        if (typeof left === 'object') {\n            if (left.string === 'parseInt' && p.length === 1) {\n                left.warn('radix');\n            } else if (left.string === 'String' && p.length >= 1 && p[0].id === '(string)') {\n                left.warn('unexpected_a');\n            }\n            if (!option.evil) {\n                if (left.string === 'eval' || left.string === 'Function' ||\n                        left.string === 'execScript') {\n                    left.warn('evil');\n                } else if (p[0] && p[0].id === '(string)' &&\n                        (left.string === 'setTimeout' ||\n                        left.string === 'setInterval')) {\n                    left.warn('implied_evil');\n                }\n            }\n            if (!left.identifier && left.id !== '.' && left.id !== '[' &&\n                    left.id !== '(' && left.id !== '&&' && left.id !== '||' &&\n                    left.id !== '?') {\n                left.warn('bad_invocation');\n            }\n            if (left.id === '.') {\n                if (p.length > 0 &&\n                        left.first && left.first.first &&\n                        are_similar(p[0], left.first.first)) {\n                    if (left.second.string === 'call' ||\n                            (left.second.string === 'apply' && (p.length === 1 ||\n                            (p[1].arity === 'prefix' && p[1].id === '[')))) {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n                if (left.second.string === 'toString') {\n                    if (left.first.id === '(string)' || left.first.id === '(number)') {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n            }\n        }\n        that.first = left;\n        that.second = p;\n        return that;\n    }, true);\n\n    prefix('(', function (that) {\n        step_in('expression');\n        no_space();\n        edge();\n        if (next_token.id === 'function') {\n            next_token.immed = true;\n        }\n        var value = expression(0);\n        value.paren = true;\n        no_space();\n        step_out(')', that);\n        if (value.id === 'function') {\n            switch (next_token.id) {\n            case '(':\n                next_token.warn('move_invocation');\n                break;\n            case '.':\n            case '[':\n                next_token.warn('unexpected_a');\n                break;\n            default:\n                that.warn('bad_wrap');\n            }\n        } else if (!value.arity) {\n            if (!option.closure || !that.comments) {\n                that.warn('unexpected_a');\n            }\n        }\n        return value;\n    });\n\n    infix('.', 170, function (left, that) {\n        no_space(prev_token, token);\n        no_space();\n        var name = identifier();\n        if (typeof name === 'string') {\n            tally_property(name);\n        }\n        that.first = left;\n        that.second = token;\n        if (left && left.string === 'arguments' &&\n                (name === 'callee' || name === 'caller')) {\n            left.warn('avoid_a', 'arguments.' + name);\n        } else if (!option.evil && left && left.string === 'document' &&\n                (name === 'write' || name === 'writeln')) {\n            left.warn('write_is_wrong');\n        } else if (!option.stupid && syx.test(name)) {\n            token.warn('sync_a');\n        }\n        if (!option.evil && (name === 'eval' || name === 'execScript')) {\n            next_token.warn('evil');\n        }\n        return that;\n    }, true);\n\n    infix('[', 170, function (left, that) {\n        var e, s;\n        no_space_only(prev_token, token);\n        no_space();\n        step_in();\n        edge();\n        e = expression(0);\n        switch (e.id) {\n        case '(number)':\n            if (e.id === '(number)' && left.id === 'arguments') {\n                left.warn('use_param');\n            }\n            break;\n        case '(string)':\n            if (!option.evil &&\n                    (e.string === 'eval' || e.string === 'execScript')) {\n                e.warn('evil');\n            } else if (!option.sub && ix.test(e.string)) {\n                s = syntax[e.string];\n                if (!s || !s.reserved) {\n                    e.warn('subscript');\n                }\n            }\n            tally_property(e.string);\n            break;\n        }\n        step_out(']', that);\n        no_space(prev_token, token);\n        that.first = left;\n        that.second = e;\n        return that;\n    }, true);\n\n    prefix('[', function (that) {\n        that.first = [];\n        step_in('array');\n        while (next_token.id !== '(end)') {\n            while (next_token.id === ',') {\n                next_token.warn('unexpected_a');\n                advance(',');\n            }\n            if (next_token.id === ']') {\n                break;\n            }\n            indent.wrap = false;\n            edge();\n            that.first.push(expression(10));\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id === ']') {\n                    token.warn('unexpected_a');\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        step_out(']', that);\n        return that;\n    }, 170);\n\n\n    function property_name() {\n        var id = optional_identifier();\n        if (!id) {\n            if (next_token.id === '(string)') {\n                id = next_token.string;\n                advance();\n            } else if (next_token.id === '(number)') {\n                id = next_token.number.toString();\n                advance();\n            }\n        }\n        return id;\n    }\n\n\n\n    assignop('=');\n    assignop('+=', '+');\n    assignop('-=', '-');\n    assignop('*=', '*');\n    assignop('/=', '/').nud = function () {\n        next_token.stop('slash_equal');\n    };\n    assignop('%=', '%');\n    assignop('&=', '&');\n    assignop('|=', '|');\n    assignop('^=', '^');\n    assignop('<<=', '<<');\n    assignop('>>=', '>>');\n    assignop('>>>=', '>>>');\n\n    function function_parameters() {\n        var id, parameters = [], paren = next_token;\n        advance('(');\n        token.function = funct;\n        step_in();\n        no_space();\n        if (next_token.id !== ')') {\n            for (;;) {\n                edge();\n                id = identifier();\n                define('parameter', token);\n                parameters.push(id);\n                token.init = true;\n                token.writeable = true;\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', paren);\n        return parameters;\n    }\n\n    function do_function(func, name) {\n        var old_funct = funct,\n            old_option = option,\n            old_scope = scope;\n        scope = Object.create(old_scope);\n        funct = {\n            closure: [],\n            global: [],\n            level: old_funct.level + 1,\n            line: next_token.line,\n            loopage: 0,\n            name: name || '\\'' + (anonname || '').replace(nx, sanitize) + '\\'',\n            outer: [],\n            scope: scope\n        };\n        funct.parameter = function_parameters();\n        func.function = funct;\n        option = Object.create(old_option);\n        functions.push(funct);\n        if (name) {\n            func.name = name;\n            func.string = name;\n            define('function', func);\n            func.init = true;\n            func.used += 1;\n        }\n        func.writeable = false;\n        one_space();\n        func.block = block('function');\n        Object.keys(scope).forEach(function (name) {\n            var master = scope[name];\n            if (!master.used && master.kind !== 'exception' &&\n                    (master.kind !== 'parameter' || !option.unparam)) {\n                master.warn('unused_a');\n            } else if (!master.init) {\n                master.warn('uninitialized_a');\n            }\n        });\n        funct = old_funct;\n        option = old_option;\n        scope = old_scope;\n    }\n\n    prefix('{', function (that) {\n        var get, i, j, name, set, seen = Object.create(null);\n        that.first = [];\n        step_in();\n        while (next_token.id !== '}') {\n            indent.wrap = false;\n\n// JSLint recognizes the ES5 extension for get/set in object literals,\n// but requires that they be used in pairs.\n\n            edge();\n            if (next_token.string === 'get' && peek().id !== ':') {\n                get = next_token;\n                advance('get');\n                one_space_only();\n                name = next_token;\n                i = property_name();\n                if (!i) {\n                    next_token.stop('missing_property');\n                }\n                get.string = '';\n                do_function(get);\n                if (funct.loopage) {\n                    get.warn('function_loop');\n                }\n                if (get.function.parameter.length) {\n                    get.warn('parameter_a_get_b', get.function.parameter[0], i);\n                }\n                comma();\n                set = next_token;\n                spaces();\n                edge();\n                advance('set');\n                set.string = '';\n                one_space_only();\n                j = property_name();\n                if (i !== j) {\n                    token.stop('expected_a_b', i, j || next_token.string);\n                }\n                do_function(set);\n                if (set.block.length === 0) {\n                    token.warn('missing_a', 'throw');\n                }\n                if (set.function.parameter.length === 0) {\n                    set.stop('parameter_set_a', 'value');\n                } else if (set.function.parameter[0] !== 'value') {\n                    set.stop('expected_a_b', 'value',\n                        set.function.parameter[0]);\n                }\n                name.first = [get, set];\n            } else {\n                name = next_token;\n                i = property_name();\n                if (typeof i !== 'string') {\n                    next_token.stop('missing_property');\n                }\n                advance(':');\n                spaces();\n                name.first = expression(10);\n            }\n            that.first.push(name);\n            if (seen[i] === true) {\n                next_token.warn('duplicate_a', i);\n            }\n            seen[i] = true;\n            tally_property(i);\n            if (next_token.id !== ',') {\n                break;\n            }\n            for (;;) {\n                comma();\n                if (next_token.id !== ',') {\n                    break;\n                }\n                next_token.warn('unexpected_a');\n            }\n            if (next_token.id === '}') {\n                token.warn('unexpected_a');\n            }\n        }\n        step_out('}', that);\n        return that;\n    });\n\n    stmt('{', function () {\n        next_token.warn('statement_block');\n        this.arity = 'statement';\n        this.block = statements();\n        this.disrupt = this.block.disrupt;\n        advance('}', this);\n        return this;\n    });\n\n    stmt('/*global', directive);\n    stmt('/*globals', directive);\n    stmt('/*jslint', directive);\n    stmt('/*member', directive);\n    stmt('/*members', directive);\n    stmt('/*property', directive);\n    stmt('/*properties', directive);\n\n    stmt('var', function () {\n\n// JavaScript does not have block scope. It only has function scope. So,\n// declaring a variable in a block can have unexpected consequences.\n\n// var.first will contain an array, the array containing name tokens\n// and assignment tokens.\n\n        var assign, id, name;\n\n        if (funct.loopage) {\n            next_token.warn('var_loop');\n        } else if (funct.varstatement && !option.vars) {\n            next_token.warn('combine_var');\n        }\n        if (funct !== global_funct) {\n            funct.varstatement = true;\n        }\n        this.arity = 'statement';\n        this.first = [];\n        step_in('var');\n        for (;;) {\n            name = next_token;\n            id = identifier(true);\n            define('var', name);\n            name.dead = funct;\n            if (next_token.id === '=') {\n                if (funct === global_funct && !name.writeable) {\n                    name.warn('read_only');\n                }\n                assign = next_token;\n                assign.first = name;\n                spaces();\n                advance('=');\n                spaces();\n                if (next_token.id === 'undefined') {\n                    token.warn('unnecessary_initialize', id);\n                }\n                if (peek(0).id === '=' && next_token.identifier) {\n                    next_token.stop('var_a_not');\n                }\n                assign.second = expression(0);\n                assign.arity = 'infix';\n                name.init = true;\n                this.first.push(assign);\n            } else {\n                this.first.push(name);\n            }\n            name.dead = false;\n            name.writeable = true;\n            if (next_token.id !== ',') {\n                break;\n            }\n            comma();\n            indent.wrap = false;\n            if (var_mode && next_token.line === token.line &&\n                    this.first.length === 1) {\n                var_mode = null;\n                indent.open = false;\n                indent.at -= option.indent;\n            }\n            spaces();\n            edge();\n        }\n        var_mode = null;\n        step_out();\n        return this;\n    });\n\n    stmt('function', function () {\n        one_space();\n        if (in_block) {\n            token.warn('function_block');\n        }\n        var name = next_token,\n            id = identifier(true);\n        define('var', name);\n        if (!name.writeable) {\n            name.warn('read_only');\n        }\n        name.init = true;\n        name.statement = true;\n        no_space();\n        this.arity = 'statement';\n        do_function(this, id);\n        if (next_token.id === '(' && next_token.line === token.line) {\n            next_token.stop('function_statement');\n        }\n        return this;\n    });\n\n    prefix('function', function (that) {\n        var id = optional_identifier(true), name;\n        if (id) {\n            name = token;\n            no_space();\n        } else {\n            id = '';\n            one_space();\n        }\n        do_function(that, id);\n        if (name) {\n            name.function = that.function;\n        }\n        if (funct.loopage) {\n            that.warn('function_loop');\n        }\n        switch (next_token.id) {\n        case ';':\n        case '(':\n        case ')':\n        case ',':\n        case ']':\n        case '}':\n        case ':':\n        case '(end)':\n            break;\n        case '.':\n            if (peek().string !== 'bind' || peek(1).id !== '(') {\n                next_token.warn('unexpected_a');\n            }\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n        that.arity = 'function';\n        return that;\n    });\n\n    stmt('if', function () {\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('if');\n        if (next_token.id === 'else') {\n            if (this.block.disrupt) {\n                next_token.warn(this.elif ? 'use_nested_if' : 'unnecessary_else');\n            }\n            one_space();\n            advance('else');\n            one_space();\n            if (next_token.id === 'if') {\n                next_token.elif = true;\n                this.else = statement(true);\n            } else {\n                this.else = block('else');\n            }\n            if (this.else.disrupt && this.block.disrupt) {\n                this.disrupt = true;\n            }\n        }\n        return this;\n    });\n\n    stmt('try', function () {\n\n// try.first    The catch variable\n// try.second   The catch clause\n// try.third    The finally clause\n// try.block    The try block\n\n        var exception_variable, paren;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('try');\n        if (next_token.id === 'catch') {\n            one_space();\n            advance('catch');\n            one_space();\n            paren = next_token;\n            advance('(');\n            step_in('control');\n            no_space();\n            edge();\n            exception_variable = next_token;\n            this.first = identifier();\n            define('exception', exception_variable);\n            exception_variable.init = true;\n            no_space();\n            step_out(')', paren);\n            one_space();\n            this.second = block('catch');\n            if (this.second.length) {\n                if (this.first === 'ignore') {\n                    exception_variable.warn('unexpected_a');\n                }\n            } else {\n                if (this.first !== 'ignore') {\n                    exception_variable.warn('expected_a_b', 'ignore',\n                        exception_variable.string);\n                }\n            }\n            exception_variable.dead = true;\n        }\n        if (next_token.id === 'finally') {\n            one_space();\n            advance('finally');\n            one_space();\n            this.third = block('finally');\n        } else if (!this.second) {\n            next_token.stop('expected_a_b', 'catch', artifact());\n        }\n        return this;\n    });\n\n    labeled_stmt('while', function () {\n        one_space();\n        var paren = next_token;\n        funct.loopage += 1;\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_relation(expression(0));\n        if (this.first.id !== 'true') {\n            expected_condition(this.first, 'unexpected_a');\n        }\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('while');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        funct.loopage -= 1;\n        return this;\n    });\n\n    reserve('with');\n\n    labeled_stmt('switch', function () {\n\n// switch.first         the switch expression\n// switch.second        the array of cases. A case is 'case' or 'default' token:\n//    case.first        the array of case expressions\n//    case.second       the array of statements\n// If all of the arrays of statements are disrupt, then the switch is disrupt.\n\n        var cases = [],\n            old_in_block = in_block,\n            particular,\n            that = token,\n            the_case = next_token;\n\n        function find_duplicate_case(value) {\n            if (are_similar(particular, value)) {\n                value.warn('duplicate_a');\n            }\n        }\n\n        one_space();\n        advance('(');\n        no_space();\n        step_in();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', the_case);\n        one_space();\n        advance('{');\n        step_in();\n        in_block = true;\n        this.second = [];\n        if (that.from !== next_token.from && !option.white) {\n            next_token.warn('expected_a_at_b_c', next_token.string, that.from, next_token.from);\n        }\n        while (next_token.id === 'case') {\n            the_case = next_token;\n            the_case.first = [];\n            the_case.arity = 'case';\n            for (;;) {\n                spaces();\n                edge('case');\n                advance('case');\n                one_space();\n                particular = expression(0);\n                cases.forEach(find_duplicate_case);\n                cases.push(particular);\n                the_case.first.push(particular);\n                if (particular.id === 'NaN') {\n                    particular.warn('unexpected_a');\n                }\n                no_space_only();\n                advance(':');\n                if (next_token.id !== 'case') {\n                    break;\n                }\n            }\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                if (!the_case.second[the_case.second.length - 1].disrupt) {\n                    next_token.warn('missing_a_after_b', 'break', 'case');\n                }\n            } else {\n                next_token.warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.second.length === 0) {\n            next_token.warn('missing_a', 'case');\n        }\n        if (next_token.id === 'default') {\n            spaces();\n            the_case = next_token;\n            the_case.arity = 'case';\n            edge('case');\n            advance('default');\n            no_space_only();\n            advance(':');\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                this.disrupt = the_case.second[the_case.second.length - 1].disrupt;\n            } else {\n                the_case.warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.break) {\n            this.disrupt = false;\n        }\n        spaces();\n        step_out('}', this);\n        in_block = old_in_block;\n        return this;\n    });\n\n    stmt('debugger', function () {\n        if (!option.debug) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        return this;\n    });\n\n    labeled_stmt('do', function () {\n        funct.loopage += 1;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('do');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        one_space();\n        advance('while');\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in();\n        no_space();\n        edge();\n        this.first = expected_condition(expected_relation(expression(0)), 'unexpected_a');\n        no_space();\n        step_out(')', paren);\n        funct.loopage -= 1;\n        return this;\n    });\n\n    labeled_stmt('for', function () {\n\n        var blok, filter, master, ok = false, paren = next_token, value;\n        this.arity = 'statement';\n        funct.loopage += 1;\n        advance('(');\n        if (next_token.id === ';') {\n            no_space();\n            advance(';');\n            no_space();\n            advance(';');\n            no_space();\n            advance(')');\n            blok = block('for');\n        } else {\n            step_in('control');\n            spaces(this, paren);\n            no_space();\n            if (next_token.id === 'var') {\n                next_token.stop('move_var');\n            }\n            edge();\n            if (peek(0).id === 'in') {\n                this.forin = true;\n                value = expression(1000);\n                master = value.master;\n                if (master.kind !== 'var' || master.function !== funct ||\n                        !master.writeable || master.dead) {\n                    value.warn('bad_in_a');\n                }\n                master.init = true;\n                master.used -= 1;\n                this.first = value;\n                advance('in');\n                this.second = expression(20);\n                step_out(')', paren);\n                blok = block('for');\n                if (!option.forin) {\n                    if (blok.length === 1 && typeof blok[0] === 'object') {\n                        if (blok[0].id === 'if' && !blok[0].else) {\n                            filter = blok[0].first;\n                            while (filter.id === '&&') {\n                                filter = filter.first;\n                            }\n                            switch (filter.id) {\n                            case '===':\n                            case '!==':\n                                ok = filter.first.id === '['\n                                    ? are_similar(filter.first.first, this.second) &&\n                                        are_similar(filter.first.second, this.first)\n                                    : filter.first.id === 'typeof' &&\n                                        filter.first.first.id === '[' &&\n                                        are_similar(filter.first.first.first, this.second) &&\n                                        are_similar(filter.first.first.second, this.first);\n                                break;\n                            case '(':\n                                ok = filter.first.id === '.' && ((\n                                    are_similar(filter.first.first, this.second) &&\n                                    filter.first.second.string === 'hasOwnProperty' &&\n                                    are_similar(filter.second[0], this.first)\n                                ) || (\n                                    filter.first.first.id === '.' &&\n                                    filter.first.first.first.first &&\n                                    filter.first.first.first.first.string === 'Object' &&\n                                    filter.first.first.first.id === '.' &&\n                                    filter.first.first.first.second.string === 'prototype' &&\n                                    filter.first.first.second.string === 'hasOwnProperty' &&\n                                    filter.first.second.string === 'call' &&\n                                    are_similar(filter.second[0], this.second) &&\n                                    are_similar(filter.second[1], this.first)\n                                ));\n                                break;\n                            }\n                        } else if (blok[0].id === 'switch') {\n                            ok = blok[0].id === 'switch' &&\n                                blok[0].first.id === 'typeof' &&\n                                blok[0].first.first.id === '[' &&\n                                are_similar(blok[0].first.first.first, this.second) &&\n                                are_similar(blok[0].first.first.second, this.first);\n                        }\n                    }\n                    if (!ok) {\n                        this.warn('for_if');\n                    }\n                }\n            } else {\n                edge();\n                this.first = [];\n                for (;;) {\n                    this.first.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                semicolon();\n                edge();\n                this.second = expected_relation(expression(0));\n                if (this.second.id !== 'true') {\n                    expected_condition(this.second, 'unexpected_a');\n                }\n                semicolon(token);\n                if (next_token.id === ';') {\n                    next_token.stop('expected_a_b', ')', ';');\n                }\n                this.third = [];\n                edge();\n                for (;;) {\n                    this.third.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                no_space();\n                step_out(')', paren);\n                one_space();\n                blok = block('for');\n            }\n        }\n        if (blok.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        this.block = blok;\n        funct.loopage -= 1;\n        return this;\n    });\n\n    function optional_label(that) {\n        var label = next_token.string,\n            master;\n        that.arity = 'statement';\n        if (!funct.breakage || (!option.continue && that.id === 'continue')) {\n            that.warn('unexpected_a');\n        } else if (next_token.identifier && token.line === next_token.line) {\n            one_space_only();\n            master = scope[label];\n            if (!master || master.kind !== 'label') {\n                next_token.warn('not_a_label');\n            } else if (master.dead || master.function !== funct) {\n                next_token.warn('not_a_scope');\n            } else {\n                master.used += 1;\n                if (that.id === 'break') {\n                    master.statement.break = true;\n                }\n                if (funct.breakage[funct.breakage.length - 1] === master.statement) {\n                    next_token.warn('unexpected_a');\n                }\n            }\n            that.first = next_token;\n            advance();\n        } else {\n            if (that.id === 'break') {\n                funct.breakage[funct.breakage.length - 1].break = true;\n            }\n        }\n        return that;\n\n    }\n\n    disrupt_stmt('break', function () {\n        return optional_label(this);\n    });\n\n    disrupt_stmt('continue', function () {\n        return optional_label(this);\n    });\n\n    disrupt_stmt('return', function () {\n        if (funct === global_funct) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        if (next_token.id !== ';' && next_token.line === token.line) {\n            if (option.closure) {\n                spaces();\n            } else {\n                one_space_only();\n            }\n            if (next_token.id === '/' || next_token.id === '(regexp)') {\n                next_token.warn('wrap_regexp');\n            }\n            this.first = expression(0);\n            if (this.first.assign) {\n                this.first.warn('unexpected_a');\n            }\n        }\n        return this;\n    });\n\n    disrupt_stmt('throw', function () {\n        this.arity = 'statement';\n        one_space_only();\n        this.first = expression(20);\n        return this;\n    });\n\n\n//  Superfluous reserved words\n\n    reserve('class');\n    reserve('const');\n    reserve('enum');\n    reserve('export');\n    reserve('extends');\n    reserve('import');\n    reserve('super');\n\n// Harmony reserved words\n\n    reserve('implements');\n    reserve('interface');\n    reserve('let');\n    reserve('package');\n    reserve('private');\n    reserve('protected');\n    reserve('public');\n    reserve('static');\n    reserve('yield');\n\n\n// Parse JSON\n\n    function json_value() {\n\n        function json_object() {\n            var brace = next_token, object = Object.create(null);\n            advance('{');\n            if (next_token.id !== '}') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    if (next_token.id !== '(string)') {\n                        next_token.warn('expected_string_a');\n                    }\n                    if (object[next_token.string] === true) {\n                        next_token.warn('duplicate_a');\n                    } else if (next_token.string === '__proto__') {\n                        next_token.warn('dangling_a');\n                    } else {\n                        object[next_token.string] = true;\n                    }\n                    advance();\n                    advance(':');\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === '}') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance('}', brace);\n        }\n\n        function json_array() {\n            var bracket = next_token;\n            advance('[');\n            if (next_token.id !== ']') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === ']') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance(']', bracket);\n        }\n\n        switch (next_token.id) {\n        case '{':\n            json_object();\n            break;\n        case '[':\n            json_array();\n            break;\n        case 'true':\n        case 'false':\n        case 'null':\n        case '(number)':\n        case '(string)':\n            advance();\n            break;\n        case '-':\n            advance('-');\n            no_space_only();\n            advance('(number)');\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n    }\n\n\n// The actual JSLINT function itself.\n\n    itself = function JSLint(the_source, the_option) {\n\n        var i, predef, tree;\n        itself.errors = [];\n        itself.tree = '';\n        itself.properties = '';\n        begin = prev_token = token = next_token =\n            Object.create(syntax['(begin)']);\n        tokens = [];\n        predefined = Object.create(null);\n        add_to_predefined(standard);\n        property = Object.create(null);\n        if (the_option) {\n            option = Object.create(the_option);\n            predef = option.predef;\n            if (predef) {\n                if (Array.isArray(predef)) {\n                    for (i = 0; i < predef.length; i += 1) {\n                        predefined[predef[i]] = true;\n                    }\n                } else if (typeof predef === 'object') {\n                    add_to_predefined(predef);\n                }\n            }\n        } else {\n            option = Object.create(null);\n        }\n        option.indent = +option.indent || 4;\n        option.maxerr = +option.maxerr || 50;\n        global_scope = scope = Object.create(null);\n        global_funct = funct = {\n            scope: scope,\n            loopage: 0,\n            level: 0\n        };\n        functions = [funct];\n        block_var = [];\n\n        comments = [];\n        comments_off = false;\n        in_block = false;\n        indent = null;\n        json_mode = false;\n        lookahead = [];\n        node_js = false;\n        prereg = true;\n        strict_mode = false;\n        var_mode = null;\n        warnings = 0;\n        lex.init(the_source);\n\n        assume();\n\n        try {\n            advance();\n            if (next_token.id === '(number)') {\n                next_token.stop('unexpected_a');\n            } else {\n                switch (next_token.id) {\n                case '{':\n                case '[':\n                    comments_off = true;\n                    json_mode = true;\n                    json_value();\n                    break;\n                default:\n\n// If the first token is a semicolon, ignore it. This is sometimes used when\n// files are intended to be appended to files that may be sloppy. A sloppy\n// file may be depending on semicolon insertion on its last line.\n\n                    step_in(1);\n                    if (next_token.id === ';' && !node_js) {\n                        semicolon();\n                    }\n                    tree = statements();\n                    begin.first = tree;\n                    itself.tree = begin;\n                    if (tree.disrupt) {\n                        prev_token.warn('weird_program');\n                    }\n                }\n            }\n            indent = null;\n            advance('(end)');\n            itself.property = property;\n        } catch (e) {\n            if (e) {        // ~~\n                itself.errors.push({\n                    reason    : e.message,\n                    line      : e.line || next_token.line,\n                    character : e.character || next_token.from\n                }, null);\n            }\n        }\n        return itself.errors.length === 0;\n    };\n\n    function unique(array) {\n        array = array.sort();\n        var i, length = 0, previous, value;\n        for (i = 0; i < array.length; i += 1) {\n            value = array[i];\n            if (value !== previous) {\n                array[length] = value;\n                previous = value;\n                length += 1;\n            }\n        }\n        array.length = length;\n        return array;\n    }\n\n// Data summary.\n\n    itself.data = function () {\n        var data = {functions: []},\n            function_data,\n            i,\n            the_function,\n            the_scope;\n        data.errors = itself.errors;\n        data.json = json_mode;\n        data.global = unique(Object.keys(global_scope));\n\n        function selects(name) {\n            var kind = the_scope[name].kind;\n            switch (kind) {\n            case 'var':\n            case 'exception':\n            case 'label':\n                function_data[kind].push(name);\n                break;\n            }\n        }\n\n        for (i = 1; i < functions.length; i += 1) {\n            the_function = functions[i];\n            function_data = {\n                name: the_function.name,\n                line: the_function.line,\n                level: the_function.level,\n                parameter: the_function.parameter,\n                var: [],\n                exception: [],\n                closure: unique(the_function.closure),\n                outer: unique(the_function.outer),\n                global: unique(the_function.global),\n                label: []\n            };\n            the_scope = the_function.scope;\n            Object.keys(the_scope).forEach(selects);\n            function_data.var.sort();\n            function_data.exception.sort();\n            function_data.label.sort();\n            data.functions.push(function_data);\n        }\n        data.tokens = tokens;\n        return data;\n    };\n\n    itself.error_report = function (data) {\n        var evidence, i, output = [], warning;\n        if (data.errors.length) {\n            if (data.json) {\n                output.push('<cite>JSON: bad.</cite><br>');\n            }\n            for (i = 0; i < data.errors.length; i += 1) {\n                warning = data.errors[i];\n                if (warning) {\n                    evidence = warning.evidence || '';\n                    output.push('<cite>');\n                    if (isFinite(warning.line)) {\n                        output.push('<address>line ' +\n                            String(warning.line) +\n                            ' character ' + String(warning.character) +\n                            '</address>');\n                    }\n                    output.push(warning.reason.entityify() + '</cite>');\n                    if (evidence) {\n                        output.push('<pre>' + evidence.entityify() + '</pre>');\n                    }\n                }\n            }\n        }\n        return output.join('');\n    };\n\n\n    itself.report = function (data) {\n        var dl, i, j, names, output = [], the_function;\n\n        function detail(h, array) {\n            var comma_needed = false;\n            if (array.length) {\n                output.push(\"<dt>\" + h + \"</dt><dd>\");\n                array.forEach(function (item) {\n                    output.push((comma_needed ? ', ' : '') + item);\n                    comma_needed = true;\n                });\n                output.push(\"</dd>\");\n            }\n        }\n\n        output.push('<dl class=level0>');\n        if (data.global.length) {\n            detail('global', data.global);\n            dl = true;\n        } else if (data.json) {\n            if (!data.errors.length) {\n                output.push(\"<dt>JSON: good.</dt>\");\n            }\n        } else {\n            output.push(\"<dt><i>No new global variables introduced.</i></dt>\");\n        }\n        if (dl) {\n            output.push(\"</dl>\");\n        } else {\n            output[0] = '';\n        }\n\n        if (data.functions) {\n            for (i = 0; i < data.functions.length; i += 1) {\n                the_function = data.functions[i];\n                names = [];\n                if (the_function.params) {\n                    for (j = 0; j < the_function.params.length; j += 1) {\n                        names[j] = the_function.params[j].string;\n                    }\n                }\n                output.push('<dl class=level' + the_function.level +\n                    '><address>line ' + String(the_function.line) +\n                    '</address>' + the_function.name.entityify());\n                detail('parameter', the_function.parameter);\n                detail('variable', the_function.var);\n                detail('exception', the_function.exception);\n                detail('closure', the_function.closure);\n                detail('outer', the_function.outer);\n                detail('global', the_function.global);\n                detail('label', the_function.label);\n                output.push('</dl>');\n            }\n        }\n        return output.join('');\n    };\n\n    itself.properties_report = function (property) {\n        if (!property) {\n            return '';\n        }\n        var i,\n            key,\n            keys = Object.keys(property).sort(),\n            mem = '   ',\n            name,\n            not_first = false,\n            output = ['/*properties'];\n        for (i = 0; i < keys.length; i += 1) {\n            key = keys[i];\n            if (property[key] > 0) {\n                if (not_first) {\n                    mem += ',';\n                }\n                name = ix.test(key)\n                    ? key\n                    : '\\'' + key.replace(nx, sanitize) + '\\'';\n                if (mem.length + name.length >= 80) {\n                    output.push(mem);\n                    mem = '    ';\n                } else {\n                    mem += ' ';\n                }\n                mem += name;\n                not_first = true;\n            }\n        }\n        output.push(mem, '*/\\n');\n        return output.join('\\n');\n    };\n\n    itself.color = function (data) {\n        var from,\n            i = 1,\n            level,\n            line,\n            result = [],\n            thru,\n            data_token = data.tokens[0];\n        while (data_token && data_token.id !== '(end)') {\n            from = data_token.from;\n            line = data_token.line;\n            thru = data_token.thru;\n            level = data_token.function.level;\n            do {\n                thru = data_token.thru;\n                data_token = data.tokens[i];\n                i += 1;\n            } while (data_token && data_token.line === line &&\n                    data_token.from - thru < 5 &&\n                    level === data_token.function.level);\n            result.push({\n                line: line,\n                level: level,\n                from: from,\n                thru: thru\n            });\n        }\n        return result;\n    };\n\n    itself.jslint = itself;\n\n    itself.edition = '2013-11-23';\n\n    return itself;\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jslint-2014-01-26.js":"// jslint.js\n// 2014-01-26\n\n// Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// The Software shall be used for Good, not Evil.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// WARNING: JSLint will hurt your feelings.\n\n// JSLINT is a global function. It takes two parameters.\n\n//     var myResult = JSLINT(source, option);\n\n// The first parameter is either a string or an array of strings. If it is a\n// string, it will be split on '\\n' or '\\r'. If it is an array of strings, it\n// is assumed that each string represents one line. The source can be a\n// JavaScript text or a JSON text.\n\n// The second parameter is an optional object of options that control the\n// operation of JSLINT. Most of the options are booleans: They are all\n// optional and have a default value of false. One of the options, predef,\n// can be an array of names, which will be used to declare global variables,\n// or an object whose keys are used as global names, with a boolean value\n// that determines if they are assignable.\n\n// If it checks out, JSLINT returns true. Otherwise, it returns false.\n\n// If false, you can inspect JSLINT.errors to find out the problems.\n// JSLINT.errors is an array of objects containing these properties:\n\n//  {\n//      line      : The line (relative to 0) at which the lint was found\n//      character : The character (relative to 0) at which the lint was found\n//      reason    : The problem\n//      evidence  : The text line in which the problem occurred\n//      raw       : The raw message before the details were inserted\n//      a         : The first detail\n//      b         : The second detail\n//      c         : The third detail\n//      d         : The fourth detail\n//  }\n\n// If a stopping error was found, a null will be the last element of the\n// JSLINT.errors array. A stopping error means that JSLint was not confident\n// enough to continue. It does not necessarily mean that the error was\n// especially heinous.\n\n// You can request a data structure that contains JSLint's results.\n\n//     var myData = JSLINT.data();\n\n// It returns a structure with this form:\n\n//     {\n//         errors: [\n//             {\n//                 line: NUMBER,\n//                 character: NUMBER,\n//                 reason: STRING,\n//                 evidence: STRING\n//             }\n//         ],\n//         functions: [\n//             {\n//                 name: STRING,\n//                 line: NUMBER,\n//                 level: NUMBER,\n//                 parameter: [\n//                     STRING\n//                 ],\n//                 var: [\n//                     STRING\n//                 ],\n//                 exception: [\n//                     STRING\n//                 ],\n//                 closure: [\n//                     STRING\n//                 ],\n//                 outer: [\n//                     STRING\n//                 ],\n//                 global: [\n//                     STRING\n//                 ],\n//                 label: [\n//                     STRING\n//                 ]\n//             }\n//         ],\n//         global: [\n//             STRING\n//         ],\n//         member: {\n//             STRING: NUMBER\n//         },\n//         json: BOOLEAN\n//     }\n\n// You can request a Function Report, which shows all of the functions\n// and the parameters and vars that they use. This can be used to find\n// implied global variables and other problems. The report is in HTML and\n// can be inserted into an HTML <body>. It should be given the result of the\n// JSLINT.data function.\n\n//     var myReport = JSLINT.report(data);\n\n// You can request an HTML error report.\n\n//     var myErrorReport = JSLINT.error_report(data);\n\n// You can obtain an object containing all of the properties found in the\n// file. JSLINT.property contains an object containing a key for each\n// property used in the program, the value being the number of times that\n// property name was used in the file.\n\n// You can request a properties report, which produces a list of the program's\n// properties in the form of a /*properties*/ declaration.\n\n//      var myPropertyReport = JSLINT.properties_report(JSLINT.property);\n\n// You can obtain the parse tree that JSLint constructed while parsing. The\n// latest tree is kept in JSLINT.tree. A nice stringification can be produced\n// with\n\n//     JSON.stringify(JSLINT.tree, [\n//         'string',  'arity', 'name',  'first',\n//         'second', 'third', 'block', 'else'\n//     ], 4));\n\n// You can request a context coloring table. It contains information that can be\n// applied to the file that was analyzed. Context coloring colors functions\n// based on their nesting level, and variables on the color of the functions\n// in which they are defined.\n\n//      var myColorization = JSLINT.color(data);\n\n// It returns an array containing objects of this form:\n\n//      {\n//          from: COLUMN,\n//          thru: COLUMN,\n//          line: ROW,\n//          level: 0 or higher\n//      }\n\n// JSLint provides three inline directives. They look like slashstar comments,\n// and allow for setting options, declaring global variables, and establishing a\n// set of allowed property names.\n\n// These directives respect function scope.\n\n// The jslint directive is a special comment that can set one or more options.\n// For example:\n\n/*jslint\n    evil: true, nomen: true, regexp: true, todo: true\n*/\n\n// The current option set is\n\n//     ass        true, if assignment expressions should be allowed\n//     bitwise    true, if bitwise operators should be allowed\n//     browser    true, if the standard browser globals should be predefined\n//     closure    true, if Google Closure idioms should be tolerated\n//     continue   true, if the continuation statement should be tolerated\n//     debug      true, if debugger statements should be allowed\n//     devel      true, if logging should be allowed (console, alert, etc.)\n//     eqeq       true, if == should be allowed\n//     evil       true, if eval should be allowed\n//     forin      true, if for in statements need not filter\n//     indent     the indentation factor\n//     maxerr     the maximum number of errors to allow\n//     maxlen     the maximum length of a source line\n//     newcap     true, if constructor names capitalization is ignored\n//     node       true, if Node.js globals should be predefined\n//     nomen      true, if names may have dangling _\n//     passfail   true, if the scan should stop on first error\n//     plusplus   true, if increment/decrement should be allowed\n//     properties true, if all property names must be declared with /*properties*/\n//     regexp     true, if the . should be allowed in regexp literals\n//     rhino      true, if the Rhino environment globals should be predefined\n//     unparam    true, if unused parameters should be tolerated\n//     sloppy     true, if the 'use strict'; pragma is optional\n//     stupid     true, if really stupid practices are tolerated\n//     sub        true, if all forms of subscript notation are tolerated\n//     todo       true, if TODO comments are tolerated\n//     vars       true, if multiple var statements per function should be allowed\n//     white      true, if sloppy whitespace is tolerated\n\n// The properties directive declares an exclusive list of property names.\n// Any properties named in the program that are not in the list will\n// produce a warning.\n\n// For example:\n\n/*properties\n    '\\b', '\\t', '\\n', '\\f', '\\r', '!', '!=', '!==', '\"', '%', '\\'', '(begin)',\n    '(error)', '*', '+', '-', '/', '<', '<=', '==', '===', '>', '>=', '\\\\', a,\n    a_label, a_scope, already_defined, and, apply, arguments, arity, ass,\n    assign, assignment_expression, assignment_function_expression, at, avoid_a,\n    b, bad_assignment, bad_constructor, bad_in_a, bad_invocation, bad_new,\n    bad_number, bad_operand, bad_wrap, bitwise, block, break, breakage, browser,\n    c, call, charAt, charCodeAt, character, closure, code, color, combine_var,\n    comments, conditional_assignment, confusing_a, confusing_regexp,\n    constructor_name_a, continue, control_a, couch, create, d, dangling_a, data,\n    dead, debug, deleted, devel, disrupt, duplicate_a, edge, edition, elif,\n    else, empty_block, empty_case, empty_class, entityify, eqeq, error_report,\n    errors, evidence, evil, exception, exec, expected_a_at_b_c, expected_a_b,\n    expected_a_b_from_c_d, expected_id_a, expected_identifier_a,\n    expected_identifier_a_reserved, expected_number_a, expected_operator_a,\n    expected_positive_a, expected_small_a, expected_space_a_b,\n    expected_string_a, f, first, flag, floor, forEach, for_if, forin, from,\n    fromCharCode, fud, function, function_block, function_eval, function_loop,\n    function_statement, function_strict, functions, global, hasOwnProperty, id,\n    identifier, identifier_function, immed, implied_evil, indent, indexOf,\n    infix_in, init, insecure_a, isAlpha, isArray, isDigit, isNaN, join, jslint,\n    json, keys, kind, label, labeled, lbp, leading_decimal_a, led, left, length,\n    level, line, loopage, master, match, maxerr, maxlen, message, missing_a,\n    missing_a_after_b, missing_property, missing_space_a_b, missing_use_strict,\n    mode, move_invocation, move_var, n, name, name_function, nested_comment,\n    newcap, node, nomen, not, not_a_constructor, not_a_defined, not_a_function,\n    not_a_label, not_a_scope, not_greater, nud, number, octal_a, open, outer,\n    parameter, parameter_a_get_b, parameter_arguments_a, parameter_set_a,\n    params, paren, passfail, plusplus, pop, postscript, predef, properties,\n    properties_report, property, prototype, push, quote, r, radix, raw,\n    read_only, reason, redefinition_a_b, regexp, relation, replace, report,\n    reserved, reserved_a, rhino, right, scanned_a_b, scope, search, second,\n    shift, slash_equal, slice, sloppy, sort, split, statement, statement_block,\n    stop, stopping, strange_loop, strict, string, stupid, sub, subscript,\n    substr, supplant, sync_a, t, tag_a_in_b, test, third, thru, toString, todo,\n    todo_comment, token, tokens, too_long, too_many, trailing_decimal_a, tree,\n    unclosed, unclosed_comment, unclosed_regexp, unescaped_a, unexpected_a,\n    unexpected_char_a, unexpected_comment, unexpected_label_a,\n    unexpected_property_a, unexpected_space_a_b, unexpected_typeof_a,\n    uninitialized_a, unnecessary_else, unnecessary_initialize, unnecessary_use,\n    unparam, unreachable_a_b, unsafe, unused_a, url, use_array, use_braces,\n    use_nested_if, use_object, use_or, use_param, use_spaces, used,\n    used_before_a, var, var_a_not, var_loop, vars, varstatement, warn, warning,\n    was, weird_assignment, weird_condition, weird_new, weird_program,\n    weird_relation, weird_ternary, white, wrap, wrap_immediate, wrap_regexp,\n    write_is_wrong, writeable\n*/\n\n// The global directive is used to declare global variables that can\n// be accessed by the program. If a declaration is true, then the variable\n// is writeable. Otherwise, it is read-only.\n\n// We build the application inside a function so that we produce only a single\n// global variable. That function will be invoked immediately, and its return\n// value is the JSLINT function itself. That function is also an object that\n// can contain data and other functions.\n\nvar JSLINT = (function () {\n    'use strict';\n\n    function array_to_object(array, value) {\n\n// Make an object from an array of keys and a common value.\n\n        var i, length = array.length, object = Object.create(null);\n        for (i = 0; i < length; i += 1) {\n            object[array[i]] = value;\n        }\n        return object;\n    }\n\n\n    var allowed_option = {\n            ass       : true,\n            bitwise   : true,\n            browser   : true,\n            closure   : true,\n            continue  : true,\n            couch     : true,\n            debug     : true,\n            devel     : true,\n            eqeq      : true,\n            evil      : true,\n            forin     : true,\n            indent    :   10,\n            maxerr    : 1000,\n            maxlen    :  256,\n            newcap    : true,\n            node      : true,\n            nomen     : true,\n            passfail  : true,\n            plusplus  : true,\n            properties: true,\n            regexp    : true,\n            rhino     : true,\n            unparam   : true,\n            sloppy    : true,\n            stupid    : true,\n            sub       : true,\n            todo      : true,\n            vars      : true,\n            white     : true\n        },\n        anonname,       // The guessed name for anonymous functions.\n\n// These are operators that should not be used with the ! operator.\n\n        bang = {\n            '<'  : true,\n            '<=' : true,\n            '==' : true,\n            '===': true,\n            '!==': true,\n            '!=' : true,\n            '>'  : true,\n            '>=' : true,\n            '+'  : true,\n            '-'  : true,\n            '*'  : true,\n            '/'  : true,\n            '%'  : true\n        },\n        begin,          // The root token\n        block_var,     // vars defined in the current block\n\n// browser contains a set of global names that are commonly provided by a\n// web browser environment.\n\n        browser = array_to_object([\n            'clearInterval', 'clearTimeout', 'document', 'event', 'FormData',\n            'frames', 'history', 'Image', 'localStorage', 'location', 'name',\n            'navigator', 'Option', 'parent', 'screen', 'sessionStorage',\n            'setInterval', 'setTimeout', 'Storage', 'window', 'XMLHttpRequest'\n        ], false),\n\n// bundle contains the text messages.\n\n        bundle = {\n            a_label: \"'{a}' is a statement label.\",\n            a_scope: \"'{a}' used out of scope.\",\n            already_defined: \"'{a}' is already defined.\",\n            and: \"The '&&' subexpression should be wrapped in parens.\",\n            assignment_expression: \"Unexpected assignment expression.\",\n            assignment_function_expression: \"Expected an assignment or \" +\n                \"function call and instead saw an expression.\",\n            avoid_a: \"Avoid '{a}'.\",\n            bad_assignment: \"Bad assignment.\",\n            bad_constructor: \"Bad constructor.\",\n            bad_in_a: \"Bad for in variable '{a}'.\",\n            bad_invocation: \"Bad invocation.\",\n            bad_new: \"Do not use 'new' for side effects.\",\n            bad_number: \"Bad number '{a}'.\",\n            bad_operand: \"Bad operand.\",\n            bad_wrap: \"Do not wrap function literals in parens unless they \" +\n                \"are to be immediately invoked.\",\n            combine_var: \"Combine this with the previous 'var' statement.\",\n            conditional_assignment: \"Expected a conditional expression and \" +\n                \"instead saw an assignment.\",\n            confusing_a: \"Confusing use of '{a}'.\",\n            confusing_regexp: \"Confusing regular expression.\",\n            constructor_name_a: \"A constructor name '{a}' should start with \" +\n                \"an uppercase letter.\",\n            control_a: \"Unexpected control character '{a}'.\",\n            dangling_a: \"Unexpected dangling '_' in '{a}'.\",\n            deleted: \"Only properties should be deleted.\",\n            duplicate_a: \"Duplicate '{a}'.\",\n            empty_block: \"Empty block.\",\n            empty_case: \"Empty case.\",\n            empty_class: \"Empty class.\",\n            evil: \"eval is evil.\",\n            expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n            expected_a_b_from_c_d: \"Expected '{a}' to match '{b}' from line \" +\n                \"{c} and instead saw '{d}'.\",\n            expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n            expected_id_a: \"Expected an id, and instead saw #{a}.\",\n            expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n            expected_identifier_a_reserved: \"Expected an identifier and \" +\n                \"instead saw '{a}' (a reserved word).\",\n            expected_number_a: \"Expected a number and instead saw '{a}'.\",\n            expected_operator_a: \"Expected an operator and instead saw '{a}'.\",\n            expected_positive_a: \"Expected a positive number and instead saw '{a}'\",\n            expected_small_a: \"Expected a small positive integer and instead saw '{a}'\",\n            expected_space_a_b: \"Expected exactly one space between '{a}' and '{b}'.\",\n            expected_string_a: \"Expected a string and instead saw '{a}'.\",\n            for_if: \"The body of a for in should be wrapped in an if \" +\n                \"statement to filter unwanted properties from the prototype.\",\n            function_block: \"Function statements should not be placed in blocks.\" +\n                \"Use a function expression or move the statement to the top of \" +\n                \"the outer function.\",\n            function_eval: \"The Function constructor is eval.\",\n            function_loop: \"Don't make functions within a loop.\",\n            function_statement: \"Function statements are not invocable. \" +\n                \"Wrap the whole function invocation in parens.\",\n            function_strict: \"Use the function form of 'use strict'.\",\n            identifier_function: \"Expected an identifier in an assignment \" +\n                \"and instead saw a function invocation.\",\n            implied_evil: \"Implied eval is evil. Pass a function instead of a string.\",\n            infix_in: \"Unexpected 'in'. Compare with undefined, or use the \" +\n                \"hasOwnProperty method instead.\",\n            insecure_a: \"Insecure '{a}'.\",\n            isNaN: \"Use the isNaN function to compare with NaN.\",\n            leading_decimal_a: \"A leading decimal point can be confused with a dot: '.{a}'.\",\n            missing_a: \"Missing '{a}'.\",\n            missing_a_after_b: \"Missing '{a}' after '{b}'.\",\n            missing_property: \"Missing property name.\",\n            missing_space_a_b: \"Missing space between '{a}' and '{b}'.\",\n            missing_use_strict: \"Missing 'use strict' statement.\",\n            move_invocation: \"Move the invocation into the parens that \" +\n                \"contain the function.\",\n            move_var: \"Move 'var' declarations to the top of the function.\",\n            name_function: \"Missing name in function statement.\",\n            nested_comment: \"Nested comment.\",\n            not: \"Nested not.\",\n            not_a_constructor: \"Do not use {a} as a constructor.\",\n            not_a_defined: \"'{a}' has not been fully defined yet.\",\n            not_a_function: \"'{a}' is not a function.\",\n            not_a_label: \"'{a}' is not a label.\",\n            not_a_scope: \"'{a}' is out of scope.\",\n            not_greater: \"'{a}' should not be greater than '{b}'.\",\n            octal_a: \"Don't use octal: '{a}'. Use '\\\\u....' instead.\",\n            parameter_arguments_a: \"Do not mutate parameter '{a}' when using 'arguments'.\",\n            parameter_a_get_b: \"Unexpected parameter '{a}' in get {b} function.\",\n            parameter_set_a: \"Expected parameter (value) in set {a} function.\",\n            radix: \"Missing radix parameter.\",\n            read_only: \"Read only.\",\n            redefinition_a_b: \"Redefinition of '{a}' from line {b}.\",\n            reserved_a: \"Reserved name '{a}'.\",\n            scanned_a_b: \"{a} ({b}% scanned).\",\n            slash_equal: \"A regular expression literal can be confused with '/='.\",\n            statement_block: \"Expected to see a statement and instead saw a block.\",\n            stopping: \"Stopping.\",\n            strange_loop: \"Strange loop.\",\n            strict: \"Strict violation.\",\n            subscript: \"['{a}'] is better written in dot notation.\",\n            sync_a: \"Unexpected sync method: '{a}'.\",\n            tag_a_in_b: \"A '<{a}>' must be within '<{b}>'.\",\n            todo_comment: \"Unexpected TODO comment.\",\n            too_long: \"Line too long.\",\n            too_many: \"Too many errors.\",\n            trailing_decimal_a: \"A trailing decimal point can be confused \" +\n                \"with a dot: '.{a}'.\",\n            unclosed: \"Unclosed string.\",\n            unclosed_comment: \"Unclosed comment.\",\n            unclosed_regexp: \"Unclosed regular expression.\",\n            unescaped_a: \"Unescaped '{a}'.\",\n            unexpected_a: \"Unexpected '{a}'.\",\n            unexpected_char_a: \"Unexpected character '{a}'.\",\n            unexpected_comment: \"Unexpected comment.\",\n            unexpected_label_a: \"Unexpected label '{a}'.\",\n            unexpected_property_a: \"Unexpected /*property*/ '{a}'.\",\n            unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n            unexpected_typeof_a: \"Unexpected 'typeof'. \" +\n                \"Use '===' to compare directly with {a}.\",\n            uninitialized_a: \"Uninitialized '{a}'.\",\n            unnecessary_else: \"Unnecessary 'else' after disruption.\",\n            unnecessary_initialize: \"It is not necessary to initialize '{a}' \" +\n                \"to 'undefined'.\",\n            unnecessary_use: \"Unnecessary 'use strict'.\",\n            unreachable_a_b: \"Unreachable '{a}' after '{b}'.\",\n            unsafe: \"Unsafe character.\",\n            unused_a: \"Unused '{a}'.\",\n            url: \"JavaScript URL.\",\n            use_array: \"Use the array literal notation [].\",\n            use_braces: \"Spaces are hard to count. Use {{a}}.\",\n            use_nested_if: \"Expected 'else { if' and instead saw 'else if'.\",\n            use_object: \"Use the object literal notation {} or Object.create(null).\",\n            use_or: \"Use the || operator.\",\n            use_param: \"Use a named parameter.\",\n            use_spaces: \"Use spaces, not tabs.\",\n            used_before_a: \"'{a}' was used before it was defined.\",\n            var_a_not: \"Variable {a} was not declared correctly.\",\n            var_loop: \"Don't declare variables in a loop.\",\n            weird_assignment: \"Weird assignment.\",\n            weird_condition: \"Weird condition.\",\n            weird_new: \"Weird construction. Delete 'new'.\",\n            weird_program: \"Weird program.\",\n            weird_relation: \"Weird relation.\",\n            weird_ternary: \"Weird ternary.\",\n            wrap_immediate: \"Wrap an immediate function invocation in \" +\n                \"parentheses to assist the reader in understanding that the \" +\n                \"expression is the result of a function, and not the \" +\n                \"function itself.\",\n            wrap_regexp: \"Wrap the /regexp/ literal in parens to \" +\n                \"disambiguate the slash operator.\",\n            write_is_wrong: \"document.write can be a form of eval.\"\n        },\n        closure = array_to_object([\n            'goog'\n        ], false),\n        comments,\n        comments_off,\n        couch = array_to_object([\n            'emit', 'getRow', 'isArray', 'log', 'provides', 'registerType',\n            'require', 'send', 'start', 'sum', 'toJSON'\n        ], false),\n\n        descapes = {\n            'b': '\\b',\n            't': '\\t',\n            'n': '\\n',\n            'f': '\\f',\n            'r': '\\r',\n            '\"': '\"',\n            '/': '/',\n            '\\\\': '\\\\',\n            '!': '!'\n        },\n\n        devel = array_to_object([\n            'alert', 'confirm', 'console', 'Debug', 'opera', 'prompt', 'WSH'\n        ], false),\n        directive,\n        escapes = {\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\\'': '\\\\\\'',\n            '\"' : '\\\\\"',\n            '/' : '\\\\/',\n            '\\\\': '\\\\\\\\'\n        },\n\n        funct,          // The current function\n\n        functions,      // All of the functions\n        global_funct,   // The global body\n        global_scope,   // The global scope\n        in_block,       // Where function statements are not allowed\n        indent,\n        itself,         // JSLINT itself\n        json_mode,\n        lex,            // the tokenizer\n        lines,\n        lookahead,\n        node = array_to_object([\n            'Buffer', 'clearImmediate', 'clearInterval', 'clearTimeout',\n            'console', 'exports', 'global', 'module', 'process', 'querystring',\n            'require', 'setImmediate', 'setInterval', 'setTimeout',\n            '__dirname', '__filename'\n        ], false),\n        node_js,\n        numbery = array_to_object(['indexOf', 'lastIndexOf', 'search'], true),\n        next_token,\n        option,\n        predefined,     // Global variables defined by option\n        prereg,\n        prev_token,\n        property,\n        protosymbol,\n        regexp_flag = array_to_object(['g', 'i', 'm'], true),\n        return_this = function return_this() {\n            return this;\n        },\n        rhino = array_to_object([\n            'defineClass', 'deserialize', 'gc', 'help', 'load', 'loadClass',\n            'print', 'quit', 'readFile', 'readUrl', 'runCommand', 'seal',\n            'serialize', 'spawn', 'sync', 'toint32', 'version'\n        ], false),\n\n        scope,      // An object containing an object for each variable in scope\n        semicolon_coda = array_to_object([';', '\"', '\\'', ')'], true),\n\n// standard contains the global names that are provided by the\n// ECMAScript standard.\n\n        standard = array_to_object([\n            'Array', 'Boolean', 'Date', 'decodeURI', 'decodeURIComponent',\n            'encodeURI', 'encodeURIComponent', 'Error', 'eval', 'EvalError',\n            'Function', 'isFinite', 'isNaN', 'JSON', 'Map', 'Math', 'Number',\n            'Object', 'parseInt', 'parseFloat', 'Promise', 'Proxy',\n            'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set',\n            'String', 'Symbol', 'SyntaxError', 'System', 'TypeError',\n            'URIError', 'WeakMap', 'WeakSet'\n        ], false),\n\n        strict_mode,\n        syntax = Object.create(null),\n        token,\n        tokens,\n        var_mode,\n        warnings,\n\n// Regular expressions. Some of these are stupidly long.\n\n// carriage return, carriage return linefeed, or linefeed\n        crlfx = /\\r\\n?|\\n/,\n// unsafe characters that are silently deleted by one or more browsers\n        cx = /[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n// identifier\n        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,\n// javascript url\n        jx = /^(?:javascript|jscript|ecmascript|vbscript)\\s*:/i,\n// star slash\n        lx = /\\*\\/|\\/\\*/,\n// characters in strings that need escapement\n        nx = /[\\u0000-\\u001f'\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n// sync\n        syx = /Sync$/,\n// comment todo\n        tox = /^\\W*to\\s*do(?:\\W|$)/i,\n// token\n        tx = /^\\s*([(){}\\[\\]\\?.,:;'\"~#@`]|={1,3}|\\/(\\*(jslint|properties|property|members?|globals?)?|=|\\/)?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|[\\^%]=?|&[&=]?|\\|[|=]?|>{1,3}=?|<(?:[\\/=!]|\\!(\\[|--)?|<=?)?|\\!(\\!|==?)?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+(?:[xX][0-9a-fA-F]+|\\.[0-9]*)?(?:[eE][+\\-]?[0-9]+)?)/;\n\n\n    if (typeof String.prototype.entityify !== 'function') {\n        String.prototype.entityify = function () {\n            return this\n                .replace(/&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;');\n        };\n    }\n\n    if (typeof String.prototype.isAlpha !== 'function') {\n        String.prototype.isAlpha = function () {\n            return (this >= 'a' && this <= 'z\\uffff') ||\n                (this >= 'A' && this <= 'Z\\uffff');\n        };\n    }\n\n    if (typeof String.prototype.isDigit !== 'function') {\n        String.prototype.isDigit = function () {\n            return (this >= '0' && this <= '9');\n        };\n    }\n\n    if (typeof String.prototype.supplant !== 'function') {\n        String.prototype.supplant = function (o) {\n            return this.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n                var replacement = o[b];\n                return typeof replacement === 'string' ||\n                    typeof replacement === 'number' ? replacement : a;\n            });\n        };\n    }\n\n\n    function sanitize(a) {\n\n//  Escapify a troublesome character.\n\n        return escapes[a] ||\n            '\\\\u' + ('0000' + a.charCodeAt().toString(16)).slice(-4);\n    }\n\n\n    function add_to_predefined(group) {\n        Object.keys(group).forEach(function (name) {\n            predefined[name] = group[name];\n        });\n    }\n\n\n    function assume() {\n        if (option.browser) {\n            add_to_predefined(browser);\n            option.browser = false;\n        }\n        if (option.closure) {\n            add_to_predefined(closure);\n        }\n        if (option.couch) {\n            add_to_predefined(couch);\n            option.couch = false;\n        }\n        if (option.devel) {\n            add_to_predefined(devel);\n            option.devel = false;\n        }\n        if (option.node) {\n            add_to_predefined(node);\n            option.node = false;\n            node_js = true;\n        }\n        if (option.rhino) {\n            add_to_predefined(rhino);\n            option.rhino = false;\n        }\n    }\n\n\n// Produce an error warning.\n\n    function artifact(tok) {\n        if (!tok) {\n            tok = next_token;\n        }\n        return tok.id === '(number)' ? tok.number : tok.string;\n    }\n\n    function quit(message, line, character) {\n        throw {\n            name: 'JSLintError',\n            line: line,\n            character: character,\n            message: bundle.scanned_a_b.supplant({\n                a: bundle[message] || message,\n                b: Math.floor((line / lines.length) * 100)\n            })\n        };\n    }\n\n    function warn(code, line, character, a, b, c, d) {\n        var warning = {         // ~~\n            id: '(error)',\n            raw: bundle[code] || code,\n            code: code,\n            evidence: lines[line - 1] || '',\n            line: line,\n            character: character,\n            a: a || artifact(this),\n            b: b,\n            c: c,\n            d: d\n        };\n        warning.reason = warning.raw.supplant(warning);\n        itself.errors.push(warning);\n        if (option.passfail) {\n            quit('stopping', line, character);\n        }\n        warnings += 1;\n        if (warnings >= option.maxerr) {\n            quit('too_many', line, character);\n        }\n        return warning;\n    }\n\n    function stop(code, line, character, a, b, c, d) {\n        var warning = warn(code, line, character, a, b, c, d);\n        quit('stopping', warning.line, warning.character);\n    }\n\n    function expected_at(at) {\n        if (!option.white && next_token.from !== at) {\n            next_token.warn('expected_a_at_b_c', '', at, next_token.from);\n        }\n    }\n\n// lexical analysis and token construction\n\n    lex = (function lex() {\n        var character, c, from, length, line, pos, source_row;\n\n// Private lex methods\n\n        function next_line() {\n            var at;\n            character = 1;\n            source_row = lines[line];\n            line += 1;\n            if (source_row === undefined) {\n                return false;\n            }\n            at = source_row.search(/\\t/);\n            if (at >= 0) {\n                if (option.white) {\n                    source_row = source_row.replace(/\\t/g, ' ');\n                } else {\n                    warn('use_spaces', line, at + 1);\n                }\n            }\n            at = source_row.search(cx);\n            if (at >= 0) {\n                warn('unsafe', line, at);\n            }\n            if (option.maxlen && option.maxlen < source_row.length) {\n                warn('too_long', line, source_row.length);\n            }\n            return true;\n        }\n\n// Produce a token object.  The token inherits from a syntax symbol.\n\n        function it(type, value) {\n            var id, the_token;\n            if (type === '(string)') {\n                if (jx.test(value)) {\n                    warn('url', line, from);\n                }\n            }\n            the_token = Object.create(syntax[(\n                type === '(punctuator)' || (type === '(identifier)' &&\n                        Object.prototype.hasOwnProperty.call(syntax, value))\n                    ? value\n                    : type\n            )] || syntax['(error)']);\n            if (type === '(identifier)') {\n                the_token.identifier = true;\n                if (value === '__iterator__' || value === '__proto__') {\n                    stop('reserved_a', line, from, value);\n                } else if (!option.nomen &&\n                        (value.charAt(0) === '_' ||\n                        value.charAt(value.length - 1) === '_')) {\n                    warn('dangling_a', line, from, value);\n                }\n            }\n            if (type === '(number)') {\n                the_token.number = +value;\n            } else if (value !== undefined) {\n                the_token.string = String(value);\n            }\n            the_token.line = line;\n            the_token.from = from;\n            the_token.thru = character;\n            if (comments.length) {\n                the_token.comments = comments;\n                comments = [];\n            }\n            id = the_token.id;\n            prereg = id && (\n                ('(,=:[!&|?{};~+-*%^<>'.indexOf(id.charAt(id.length - 1)) >= 0) ||\n                id === 'return' || id === 'case'\n            );\n            return the_token;\n        }\n\n        function match(x) {\n            var exec = x.exec(source_row), first;\n            if (exec) {\n                length = exec[0].length;\n                first = exec[1];\n                c = first.charAt(0);\n                source_row = source_row.slice(length);\n                from = character + length - first.length;\n                character += length;\n                return first;\n            }\n            for (;;) {\n                if (!source_row) {\n                    if (!option.white) {\n                        warn('unexpected_char_a', line, character - 1, '(space)');\n                    }\n                    return;\n                }\n                c = source_row.charAt(0);\n                if (c !== ' ') {\n                    break;\n                }\n                source_row = source_row.slice(1);\n                character += 1;\n            }\n            stop('unexpected_char_a', line, character, c);\n\n        }\n\n        function string(x) {\n            var ch, at = 0, r = '', result;\n\n            function hex(n) {\n                var i = parseInt(source_row.substr(at + 1, n), 16);\n                at += n;\n                if (i >= 32 && i <= 126 &&\n                        i !== 34 && i !== 92 && i !== 39) {\n                    warn('unexpected_a', line, character, '\\\\');\n                }\n                character += n;\n                ch = String.fromCharCode(i);\n            }\n\n            if (json_mode && x !== '\"') {\n                warn('expected_a_b', line, character, '\"', x);\n            }\n\n            for (;;) {\n                while (at >= source_row.length) {\n                    at = 0;\n                    if (!next_line()) {\n                        stop('unclosed', line - 1, from);\n                    }\n                }\n                ch = source_row.charAt(at);\n                if (ch === x) {\n                    character += 1;\n                    source_row = source_row.slice(at + 1);\n                    result = it('(string)', r);\n                    result.quote = x;\n                    return result;\n                }\n                if (ch < ' ') {\n                    if (ch === '\\n' || ch === '\\r') {\n                        break;\n                    }\n                    warn('control_a', line, character + at,\n                        source_row.slice(0, at));\n                } else if (ch === '\\\\') {\n                    at += 1;\n                    character += 1;\n                    ch = source_row.charAt(at);\n                    switch (ch) {\n                    case '':\n                        warn('unexpected_a', line, character, '\\\\');\n                        next_line();\n                        at = -1;\n                        break;\n                    case '\\'':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\\\'');\n                        }\n                        break;\n                    case 'u':\n                        hex(4);\n                        break;\n                    case 'v':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\v');\n                        }\n                        ch = '\\v';\n                        break;\n                    case 'x':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\x');\n                        }\n                        hex(2);\n                        break;\n                    default:\n                        if (typeof descapes[ch] !== 'string') {\n                            warn(ch >= '0' && ch <= '7' ? 'octal_a' : 'unexpected_a',\n                                line, character, '\\\\' + ch);\n                        } else {\n                            ch = descapes[ch];\n                        }\n                    }\n                }\n                r += ch;\n                character += 1;\n                at += 1;\n            }\n        }\n\n        function number(snippet) {\n            var digit;\n            if (source_row.charAt(0).isAlpha()) {\n                warn('expected_space_a_b',\n                    line, character, c, source_row.charAt(0));\n            }\n            if (c === '0') {\n                digit = snippet.charAt(1);\n                if (digit.isDigit()) {\n                    if (token.id !== '.') {\n                        warn('unexpected_a', line, character, snippet);\n                    }\n                } else if (json_mode && (digit === 'x' || digit === 'X')) {\n                    warn('unexpected_a', line, character, '0x');\n                }\n            }\n            if (snippet.slice(snippet.length - 1) === '.') {\n                warn('trailing_decimal_a', line, character, snippet);\n            }\n            digit = +snippet;\n            if (!isFinite(digit)) {\n                warn('bad_number', line, character, snippet);\n            }\n            snippet = digit;\n            return it('(number)', snippet);\n        }\n\n        function comment(snippet, type) {\n            if (comments_off) {\n                warn('unexpected_comment', line, character);\n            } else if (!option.todo && tox.test(snippet)) {\n                warn('todo_comment', line, character);\n            }\n            comments.push({\n                id: type,\n                from: from,\n                thru: character,\n                line: line,\n                string: snippet\n            });\n        }\n\n        function regexp() {\n            var at = 0,\n                b,\n                bit,\n                depth = 0,\n                flag = '',\n                high,\n                letter,\n                low,\n                potential,\n                quote,\n                result;\n            for (;;) {\n                b = true;\n                c = source_row.charAt(at);\n                at += 1;\n                switch (c) {\n                case '':\n                    stop('unclosed_regexp', line, from);\n                    return;\n                case '/':\n                    if (depth > 0) {\n                        warn('unescaped_a', line, from + at, '/');\n                    }\n                    c = source_row.slice(0, at - 1);\n                    potential = Object.create(regexp_flag);\n                    for (;;) {\n                        letter = source_row.charAt(at);\n                        if (potential[letter] !== true) {\n                            break;\n                        }\n                        potential[letter] = false;\n                        at += 1;\n                        flag += letter;\n                    }\n                    if (source_row.charAt(at).isAlpha()) {\n                        stop('unexpected_a', line, from, source_row.charAt(at));\n                    }\n                    character += at;\n                    source_row = source_row.slice(at);\n                    quote = source_row.charAt(0);\n                    if (quote === '/' || quote === '*') {\n                        stop('confusing_regexp', line, from);\n                    }\n                    result = it('(regexp)', c);\n                    result.flag = flag;\n                    return result;\n                case '\\\\':\n                    c = source_row.charAt(at);\n                    if (c < ' ') {\n                        warn('control_a', line, from + at, String(c));\n                    } else if (c === '<') {\n                        warn('unexpected_a', line, from + at, '\\\\');\n                    }\n                    at += 1;\n                    break;\n                case '(':\n                    depth += 1;\n                    b = false;\n                    if (source_row.charAt(at) === '?') {\n                        at += 1;\n                        switch (source_row.charAt(at)) {\n                        case ':':\n                        case '=':\n                        case '!':\n                            at += 1;\n                            break;\n                        default:\n                            warn('expected_a_b', line, from + at,\n                                ':', source_row.charAt(at));\n                        }\n                    }\n                    break;\n                case '|':\n                    b = false;\n                    break;\n                case ')':\n                    if (depth === 0) {\n                        warn('unescaped_a', line, from + at, ')');\n                    } else {\n                        depth -= 1;\n                    }\n                    break;\n                case ' ':\n                    pos = 1;\n                    while (source_row.charAt(at) === ' ') {\n                        at += 1;\n                        pos += 1;\n                    }\n                    if (pos > 1) {\n                        warn('use_braces', line, from + at, pos);\n                    }\n                    break;\n                case '[':\n                    c = source_row.charAt(at);\n                    if (c === '^') {\n                        at += 1;\n                        if (!option.regexp) {\n                            warn('insecure_a', line, from + at, c);\n                        } else if (source_row.charAt(at) === ']') {\n                            stop('unescaped_a', line, from + at, '^');\n                        }\n                    }\n                    bit = false;\n                    if (c === ']') {\n                        warn('empty_class', line, from + at - 1);\n                        bit = true;\n                    }\nklass:              do {\n                        c = source_row.charAt(at);\n                        at += 1;\n                        switch (c) {\n                        case '[':\n                        case '^':\n                            warn('unescaped_a', line, from + at, c);\n                            bit = true;\n                            break;\n                        case '-':\n                            if (bit) {\n                                bit = false;\n                            } else {\n                                warn('unescaped_a', line, from + at, '-');\n                                bit = true;\n                            }\n                            break;\n                        case ']':\n                            if (!bit) {\n                                warn('unescaped_a', line, from + at - 1, '-');\n                            }\n                            break klass;\n                        case '\\\\':\n                            c = source_row.charAt(at);\n                            if (c < ' ') {\n                                warn('control_a', line, from + at, String(c));\n                            } else if (c === '<') {\n                                warn('unexpected_a', line, from + at, '\\\\');\n                            }\n                            at += 1;\n                            bit = true;\n                            break;\n                        case '/':\n                            warn('unescaped_a', line, from + at - 1, '/');\n                            bit = true;\n                            break;\n                        default:\n                            bit = true;\n                        }\n                    } while (c);\n                    break;\n                case '.':\n                    if (!option.regexp) {\n                        warn('insecure_a', line, from + at, c);\n                    }\n                    break;\n                case ']':\n                case '?':\n                case '{':\n                case '}':\n                case '+':\n                case '*':\n                    warn('unescaped_a', line, from + at, c);\n                    break;\n                }\n                if (b) {\n                    switch (source_row.charAt(at)) {\n                    case '?':\n                    case '+':\n                    case '*':\n                        at += 1;\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        break;\n                    case '{':\n                        at += 1;\n                        c = source_row.charAt(at);\n                        if (c < '0' || c > '9') {\n                            warn('expected_number_a', line,\n                                from + at, c);\n                        }\n                        at += 1;\n                        low = +c;\n                        for (;;) {\n                            c = source_row.charAt(at);\n                            if (c < '0' || c > '9') {\n                                break;\n                            }\n                            at += 1;\n                            low = +c + (low * 10);\n                        }\n                        high = low;\n                        if (c === ',') {\n                            at += 1;\n                            high = Infinity;\n                            c = source_row.charAt(at);\n                            if (c >= '0' && c <= '9') {\n                                at += 1;\n                                high = +c;\n                                for (;;) {\n                                    c = source_row.charAt(at);\n                                    if (c < '0' || c > '9') {\n                                        break;\n                                    }\n                                    at += 1;\n                                    high = +c + (high * 10);\n                                }\n                            }\n                        }\n                        if (source_row.charAt(at) !== '}') {\n                            warn('expected_a_b', line, from + at,\n                                '}', c);\n                        } else {\n                            at += 1;\n                        }\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        if (low > high) {\n                            warn('not_greater', line, from + at,\n                                low, high);\n                        }\n                        break;\n                    }\n                }\n            }\n            c = source_row.slice(0, at - 1);\n            character += at;\n            source_row = source_row.slice(at);\n            return it('(regexp)', c);\n        }\n\n// Public lex methods\n\n        return {\n            init: function (source) {\n                if (typeof source === 'string') {\n                    lines = source.split(crlfx);\n                } else {\n                    lines = source;\n                }\n                line = 0;\n                next_line();\n                from = 1;\n            },\n\n// token -- this is called by advance to get the next token.\n\n            token: function () {\n                var first, i, snippet;\n\n                for (;;) {\n                    while (!source_row) {\n                        if (!next_line()) {\n                            return it('(end)');\n                        }\n                    }\n                    snippet = match(tx);\n                    if (snippet) {\n\n//      identifier\n\n                        first = snippet.charAt(0);\n                        if (first.isAlpha() || first === '_' || first === '$') {\n                            return it('(identifier)', snippet);\n                        }\n\n//      number\n\n                        if (first.isDigit()) {\n                            return number(snippet);\n                        }\n                        switch (snippet) {\n\n//      string\n\n                        case '\"':\n                        case \"'\":\n                            return string(snippet);\n\n//      // comment\n\n                        case '//':\n                            comment(source_row, '//');\n                            source_row = '';\n                            break;\n\n//      /* comment\n\n                        case '/*':\n                            for (;;) {\n                                i = source_row.search(lx);\n                                if (i >= 0) {\n                                    break;\n                                }\n                                character = source_row.length;\n                                comment(source_row);\n                                from = 0;\n                                if (!next_line()) {\n                                    stop('unclosed_comment', line, character);\n                                }\n                            }\n                            comment(source_row.slice(0, i), '/*');\n                            character += i + 2;\n                            if (source_row.charAt(i) === '/') {\n                                stop('nested_comment', line, character);\n                            }\n                            source_row = source_row.slice(i + 2);\n                            break;\n\n                        case '':\n                            break;\n//      /\n                        case '/':\n                            if (token.id === '/=') {\n                                stop('slash_equal', line, from);\n                            }\n                            return prereg\n                                ? regexp()\n                                : it('(punctuator)', snippet);\n\n//      punctuator\n                        default:\n                            return it('(punctuator)', snippet);\n                        }\n                    }\n                }\n            }\n        };\n    }());\n\n    function define(kind, token) {\n\n// Define a name.\n\n        var name = token.string,\n            master = scope[name];       // The current definition of the name\n\n// vars are created with a deadzone, so that the expression that initializes\n// the var cannot access the var. Functions are not writeable.\n\n        token.dead = false;\n        token.init = false;\n        token.kind = kind;\n        token.master = master;\n        token.used = 0;\n        token.writeable = true;\n\n// Global variables are a little weird. They can be defined multiple times.\n// Some predefined global vars are (or should) not be writeable.\n\n        if (kind === 'var' && funct === global_funct) {\n            if (!master) {\n                if (predefined[name] === false) {\n                    token.writeable = false;\n                }\n                global_scope[name] = token;\n            }\n        } else {\n\n// It is an error if the name has already been defined in this scope, except\n// when reusing an exception variable name.\n\n            if (master) {\n                if (master.function === funct) {\n                    if (master.kind !== 'exception' || kind !== 'exception' ||\n                            !master.dead) {\n                        token.warn('already_defined', name);\n                    }\n                } else if (master.function !== global_funct) {\n                    if (kind === 'var') {\n                        token.warn('redefinition_a_b', name, master.line);\n                    }\n                }\n            }\n            scope[name] = token;\n            if (kind === 'var') {\n                block_var.push(name);\n            }\n        }\n    }\n\n    function peek(distance) {\n\n// Peek ahead to a future token. The distance is how far ahead to look. The\n// default is the next token.\n\n        var found, slot = 0;\n\n        distance = distance || 0;\n        while (slot <= distance) {\n            found = lookahead[slot];\n            if (!found) {\n                found = lookahead[slot] = lex.token();\n            }\n            slot += 1;\n        }\n        return found;\n    }\n\n\n    function advance(id, match) {\n\n// Produce the next token, also looking for programming errors.\n\n        if (indent) {\n\n// If indentation checking was requested, then inspect all of the line breakings.\n// The var statement is tricky because the names might be aligned or not. We\n// look at the first line break after the var to determine the programmer's\n// intention.\n\n            if (var_mode && next_token.line !== token.line) {\n                if ((var_mode !== indent || !next_token.edge) &&\n                        next_token.from === indent.at -\n                        (next_token.edge ? option.indent : 0)) {\n                    var dent = indent;\n                    for (;;) {\n                        dent.at -= option.indent;\n                        if (dent === var_mode) {\n                            break;\n                        }\n                        dent = dent.was;\n                    }\n                    dent.open = false;\n                }\n                var_mode = null;\n            }\n            if (next_token.id === '?' && indent.mode === ':' &&\n                    token.line !== next_token.line) {\n                indent.at -= option.indent;\n            }\n            if (indent.open) {\n\n// If the token is an edge.\n\n                if (next_token.edge) {\n                    if (next_token.edge === 'label') {\n                        expected_at(1);\n                    } else if (next_token.edge === 'case' || indent.mode === 'statement') {\n                        expected_at(indent.at - option.indent);\n                    } else if (indent.mode !== 'array' || next_token.line !== token.line) {\n                        expected_at(indent.at);\n                    }\n\n// If the token is not an edge, but is the first token on the line.\n\n                } else if (next_token.line !== token.line) {\n                    if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                    indent.wrap = true;\n                }\n            } else if (next_token.line !== token.line) {\n                if (next_token.edge) {\n                    expected_at(indent.at);\n                } else {\n                    indent.wrap = true;\n                    if (indent.mode === 'statement' || indent.mode === 'var') {\n                        expected_at(indent.at + option.indent);\n                    } else if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                }\n            }\n        }\n\n        switch (token.id) {\n        case '(number)':\n            if (next_token.id === '.') {\n                next_token.warn('trailing_decimal_a');\n            }\n            break;\n        case '-':\n            if (next_token.id === '-' || next_token.id === '--') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        case '+':\n            if (next_token.id === '+' || next_token.id === '++') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        }\n        if (token.id === '(string)' || token.identifier) {\n            anonname = token.string;\n        }\n\n        if (id && next_token.id !== id) {\n            if (match) {\n                next_token.warn('expected_a_b_from_c_d', id,\n                    match.id, match.line, artifact());\n            } else if (!next_token.identifier || next_token.string !== id) {\n                next_token.warn('expected_a_b', id, artifact());\n            }\n        }\n        prev_token = token;\n        token = next_token;\n        next_token = lookahead.shift() || lex.token();\n        next_token.function = funct;\n        tokens.push(next_token);\n    }\n\n\n    function do_globals() {\n        var name, writeable;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            writeable = false;\n            if (next_token.id === ':') {\n                advance(':');\n                switch (next_token.id) {\n                case 'true':\n                    writeable = predefined[name] !== false;\n                    advance('true');\n                    break;\n                case 'false':\n                    advance('false');\n                    break;\n                default:\n                    next_token.stop('unexpected_a');\n                }\n            }\n            predefined[name] = writeable;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    function do_jslint() {\n        var name, value;\n        while (next_token.id === '(string)' || next_token.identifier) {\n            name = next_token.string;\n            if (!allowed_option[name]) {\n                next_token.stop('unexpected_a');\n            }\n            advance();\n            if (next_token.id !== ':') {\n                next_token.stop('expected_a_b', ':', artifact());\n            }\n            advance(':');\n            if (typeof allowed_option[name] === 'number') {\n                value = next_token.number;\n                if (value > allowed_option[name] || value <= 0 ||\n                        Math.floor(value) !== value) {\n                    next_token.stop('expected_small_a');\n                }\n                option[name] = value;\n            } else {\n                if (next_token.id === 'true') {\n                    option[name] = true;\n                } else if (next_token.id === 'false') {\n                    option[name] = false;\n                } else {\n                    next_token.stop('unexpected_a');\n                }\n            }\n            advance();\n            if (next_token.id === ',') {\n                advance(',');\n            }\n        }\n        assume();\n    }\n\n\n    function do_properties() {\n        var name;\n        option.properties = true;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            if (next_token.id === ':') {\n                for (;;) {\n                    advance();\n                    if (next_token.id !== '(string)' && !next_token.identifier) {\n                        break;\n                    }\n                }\n            }\n            property[name] = 0;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    directive = function directive() {\n        var command = this.id,\n            old_comments_off = comments_off,\n            old_indent = indent;\n        comments_off = true;\n        indent = null;\n        if (next_token.line === token.line && next_token.from === token.thru) {\n            next_token.warn('missing_space_a_b', artifact(token), artifact());\n        }\n        if (lookahead.length > 0) {\n            this.warn('unexpected_a');\n        }\n        switch (command) {\n        case '/*properties':\n        case '/*property':\n        case '/*members':\n        case '/*member':\n            do_properties();\n            break;\n        case '/*jslint':\n            do_jslint();\n            break;\n        case '/*globals':\n        case '/*global':\n            do_globals();\n            break;\n        default:\n            this.stop('unexpected_a');\n        }\n        comments_off = old_comments_off;\n        advance('*/');\n        indent = old_indent;\n    };\n\n\n// Indentation intention\n\n    function edge(mode) {\n        next_token.edge = indent ? indent.open && (mode || 'edge') : '';\n    }\n\n\n    function step_in(mode) {\n        var open;\n        if (typeof mode === 'number') {\n            indent = {\n                at: +mode,\n                open: true,\n                was: indent\n            };\n        } else if (!indent) {\n            indent = {\n                at: 1,\n                mode: 'statement',\n                open: true\n            };\n        } else if (mode === 'statement') {\n            indent = {\n                at: indent.at,\n                open: true,\n                was: indent\n            };\n        } else {\n            open = mode === 'var' || next_token.line !== token.line;\n            indent = {\n                at: (open || mode === 'control'\n                    ? indent.at + option.indent\n                    : indent.at) + (indent.wrap ? option.indent : 0),\n                mode: mode,\n                open: open,\n                was: indent\n            };\n            if (mode === 'var' && open) {\n                var_mode = indent;\n            }\n        }\n    }\n\n    function step_out(id, symbol) {\n        if (id) {\n            if (indent && indent.open) {\n                indent.at -= option.indent;\n                edge();\n            }\n            advance(id, symbol);\n        }\n        if (indent) {\n            indent = indent.was;\n        }\n    }\n\n// Functions for conformance of whitespace.\n\n    function one_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && !option.white &&\n                (token.line !== right.line ||\n                token.thru + 1 !== right.from)) {\n            right.warn('expected_space_a_b', artifact(token), artifact(right));\n        }\n    }\n\n    function one_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru + 1 !== right.from))) {\n            right.warn('expected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if ((!option.white) &&\n                left.thru !== right.from && left.line === right.line) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru !== right.from))) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function spaces(left, right) {\n        if (!option.white) {\n            left = left || token;\n            right = right || next_token;\n            if (left.thru === right.from && left.line === right.line) {\n                right.warn('missing_space_a_b', artifact(left), artifact(right));\n            }\n        }\n    }\n\n    function comma() {\n        if (next_token.id !== ',') {\n            warn('expected_a_b', token.line, token.thru, ',', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(',');\n            spaces();\n        }\n    }\n\n\n    function semicolon() {\n        if (next_token.id !== ';') {\n            warn('expected_a_b', token.line, token.thru, ';', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(';');\n            if (semicolon_coda[next_token.id] !== true) {\n                spaces();\n            }\n        }\n    }\n\n    function use_strict() {\n        if (next_token.string === 'use strict') {\n            if (strict_mode) {\n                next_token.warn('unnecessary_use');\n            }\n            edge();\n            advance();\n            semicolon();\n            strict_mode = true;\n            return true;\n        }\n        return false;\n    }\n\n\n    function are_similar(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (Array.isArray(a)) {\n            if (Array.isArray(b) && a.length === b.length) {\n                var i;\n                for (i = 0; i < a.length; i += 1) {\n                    if (!are_similar(a[i], b[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n        if (Array.isArray(b)) {\n            return false;\n        }\n        if (a.id === '(number)' && b.id === '(number)') {\n            return a.number === b.number;\n        }\n        if (a.arity === b.arity && a.string === b.string) {\n            switch (a.arity) {\n            case undefined:\n                return a.string === b.string;\n            case 'prefix':\n            case 'suffix':\n                return a.id === b.id && are_similar(a.first, b.first) &&\n                    a.id !== '{' && a.id !== '[';\n            case 'infix':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second);\n            case 'ternary':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second) &&\n                    are_similar(a.third, b.third);\n            case 'function':\n            case 'regexp':\n                return false;\n            default:\n                return true;\n            }\n        }\n        if (a.id === '.' && b.id === '[' && b.arity === 'infix') {\n            return a.second.string === b.second.string && b.second.id === '(string)';\n        }\n        if (a.id === '[' && a.arity === 'infix' && b.id === '.') {\n            return a.second.string === b.second.string && a.second.id === '(string)';\n        }\n        return false;\n    }\n\n\n// This is the heart of JSLINT, the Pratt parser. In addition to parsing, it\n// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is\n// like .nud except that it is only used on the first token of a statement.\n// Having .fud makes it much easier to define statement-oriented languages like\n// JavaScript. I retained Pratt's nomenclature.\n\n// .nud     Null denotation\n// .fud     First null denotation\n// .led     Left denotation\n//  lbp     Left binding power\n//  rbp     Right binding power\n\n// They are elements of the parsing method called Top Down Operator Precedence.\n\n    function expression(rbp, initial) {\n\n// rbp is the right binding power.\n// initial indicates that this is the first expression of a statement.\n\n        var left;\n        if (next_token.id === '(end)') {\n            token.stop('unexpected_a', next_token.id);\n        }\n        advance();\n        if (initial) {\n            anonname = 'anonymous';\n        }\n        if (initial === true && token.fud) {\n            left = token.fud();\n        } else {\n            if (token.nud) {\n                left = token.nud();\n            } else {\n                if (next_token.id === '(number)' && token.id === '.') {\n                    token.warn('leading_decimal_a', artifact());\n                    advance();\n                    return token;\n                }\n                token.stop('expected_identifier_a', artifact(token));\n            }\n            while (rbp < next_token.lbp) {\n                advance();\n                left = token.led(left);\n            }\n        }\n        if (left && left.assign && !initial) {\n            if (!option.ass) {\n                left.warn('assignment_expression');\n            }\n            if (left.id !== '=' && left.first.master) {\n                left.first.master.used = true;\n            }\n        }\n        return left;\n    }\n\n    protosymbol = {\n        nud: function () {\n            this.stop('unexpected_a');\n        },\n        led: function () {\n            this.stop('expected_operator_a');\n        },\n        warn: function (code, a, b, c, d) {\n            if (!this.warning) {\n                this.warning = warn(code, this.line || 0, this.from || 0,\n                    a || artifact(this), b, c, d);\n            }\n        },\n        stop: function (code, a, b, c, d) {\n            this.warning = undefined;\n            this.warn(code, a, b, c, d);\n            return quit('stopping', this.line, this.character);\n        },\n        lbp: 0\n    };\n\n// Functional constructors for making the symbols that will be inherited by\n// tokens.\n\n    function symbol(s, bp) {\n        var x = syntax[s];\n        if (!x) {\n            x = Object.create(protosymbol);\n            x.id = x.string = s;\n            x.lbp = bp || 0;\n            syntax[s] = x;\n        }\n        return x;\n    }\n\n    function postscript(x) {\n        x.postscript = true;\n        return x;\n    }\n\n    function ultimate(s) {\n        var x = symbol(s, 0);\n        x.from = 1;\n        x.thru = 1;\n        x.line = 0;\n        x.edge = 'edge';\n        x.string = s;\n        return postscript(x);\n    }\n\n    function reserve_name(x) {\n        var c = x.id.charAt(0);\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            x.identifier = x.reserved = true;\n        }\n        return x;\n    }\n\n    function stmt(s, f) {\n        var x = symbol(s);\n        x.fud = f;\n        return reserve_name(x);\n    }\n\n    function disrupt_stmt(s, f) {\n        var x = stmt(s, f);\n        x.disrupt = true;\n    }\n\n    function labeled_stmt(s, f) {\n        var x = stmt(s, function labeled() {\n            var the_statement;\n            if (funct.breakage) {\n                funct.breakage.push(this);\n            } else {\n                funct.breakage = [this];\n            }\n            the_statement = f.apply(this);\n            if (funct.breakage.length > 1) {\n                funct.breakage.pop();\n            } else {\n                delete funct.breakage;\n            }\n            return the_statement;\n        });\n        x.labeled = true;\n    }\n\n    function prefix(s, f) {\n        var x = symbol(s, 150);\n        reserve_name(x);\n        x.nud = function () {\n            var that = this;\n            that.arity = 'prefix';\n            if (typeof f === 'function') {\n                that = f(that);\n                if (that.arity !== 'prefix') {\n                    return that;\n                }\n            } else {\n                if (s === 'typeof') {\n                    one_space();\n                } else {\n                    no_space_only();\n                }\n                that.first = expression(150);\n            }\n            switch (that.id) {\n            case '++':\n            case '--':\n                if (!option.plusplus) {\n                    that.warn('unexpected_a');\n                } else if ((!that.first.identifier || that.first.reserved) &&\n                        that.first.id !== '.' && that.first.id !== '[') {\n                    that.warn('bad_operand');\n                }\n                break;\n            default:\n                if (that.first.arity === 'prefix' ||\n                        that.first.arity === 'function') {\n                    that.warn('unexpected_a');\n                }\n            }\n            return that;\n        };\n        return x;\n    }\n\n\n    function type(s, t, nud) {\n        var x = symbol(s);\n        x.arity = t;\n        if (nud) {\n            x.nud = nud;\n        }\n        return x;\n    }\n\n\n    function reserve(s, f) {\n        var x = symbol(s);\n        x.identifier = x.reserved = true;\n        if (typeof f === 'function') {\n            x.nud = f;\n        }\n        return x;\n    }\n\n\n    function constant(name) {\n        var x = reserve(name);\n        x.string = name;\n        x.nud = return_this;\n        return x;\n    }\n\n\n    function reservevar(s, v) {\n        return reserve(s, function () {\n            if (typeof v === 'function') {\n                v(this);\n            }\n            return this;\n        });\n    }\n\n\n    function infix(s, p, f, w) {\n        var x = symbol(s, p);\n        reserve_name(x);\n        x.led = function (left) {\n            this.arity = 'infix';\n            if (!w) {\n                spaces(prev_token, token);\n                spaces();\n            }\n            if (!option.bitwise && this.bitwise) {\n                this.warn('unexpected_a');\n            }\n            if (typeof f === 'function') {\n                return f(left, this);\n            }\n            this.first = left;\n            this.second = expression(p);\n            return this;\n        };\n        return x;\n    }\n\n    function expected_relation(node, message) {\n        if (node.assign) {\n            node.warn(message || 'conditional_assignment');\n        }\n        return node;\n    }\n\n    function expected_condition(node, message) {\n        switch (node.id) {\n        case '[':\n        case '-':\n            if (node.arity !== 'infix') {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        case 'false':\n        case 'function':\n        case 'Infinity':\n        case 'NaN':\n        case 'null':\n        case 'true':\n        case 'undefined':\n        case 'void':\n        case '(number)':\n        case '(regexp)':\n        case '(string)':\n        case '{':\n        case '?':\n        case '~':\n            node.warn(message || 'weird_condition');\n            break;\n        case '(':\n            if (node.first.id === 'new' ||\n                    (node.first.string === 'Boolean') ||\n                    (node.first.id === '.' &&\n                        numbery[node.first.second.string] === true)) {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        }\n        return node;\n    }\n\n    function check_relation(node) {\n        switch (node.arity) {\n        case 'prefix':\n            switch (node.id) {\n            case '{':\n            case '[':\n                node.warn('unexpected_a');\n                break;\n            case '!':\n                node.warn('confusing_a');\n                break;\n            }\n            break;\n        case 'function':\n        case 'regexp':\n            node.warn('unexpected_a');\n            break;\n        default:\n            if (node.id  === 'NaN') {\n                node.warn('isNaN');\n            } else if (node.relation) {\n                node.warn('weird_relation');\n            }\n        }\n        return node;\n    }\n\n\n    function relation(s, eqeq) {\n        var x = infix(s, 100, function (left, that) {\n            check_relation(left);\n            if (eqeq && !option.eqeq) {\n                that.warn('expected_a_b', eqeq, that.id);\n            }\n            var right = expression(100);\n            if (are_similar(left, right) ||\n                    ((left.id === '(string)' || left.id === '(number)') &&\n                    (right.id === '(string)' || right.id === '(number)'))) {\n                that.warn('weird_relation');\n            } else if (left.id === 'typeof') {\n                if (right.id !== '(string)') {\n                    right.warn(\"expected_string_a\", artifact(right));\n                } else if (right.string === 'undefined' ||\n                        right.string === 'null') {\n                    left.warn(\"unexpected_typeof_a\", right.string);\n                }\n            } else if (right.id === 'typeof') {\n                if (left.id !== '(string)') {\n                    left.warn(\"expected_string_a\", artifact(left));\n                } else if (left.string === 'undefined' ||\n                        left.string === 'null') {\n                    right.warn(\"unexpected_typeof_a\", left.string);\n                }\n            }\n            that.first = left;\n            that.second = check_relation(right);\n            return that;\n        });\n        x.relation = true;\n        return x;\n    }\n\n    function lvalue(that, s) {\n        var master;\n        if (that.identifier) {\n            master = scope[that.string];\n            if (master) {\n                if (scope[that.string].writeable !== true) {\n                    that.warn('read_only');\n                }\n                master.used -= 1;\n                if (s === '=') {\n                    master.init = true;\n                }\n            }\n        } else if (that.id === '.' || that.id === '[') {\n            if (!that.first || that.first.string === 'arguments') {\n                that.warn('bad_assignment');\n            }\n        } else {\n            that.warn('bad_assignment');\n        }\n    }\n\n\n    function assignop(s, op) {\n        var x = infix(s, 20, function (left, that) {\n            var next;\n            that.first = left;\n            lvalue(left, s);\n            that.second = expression(20);\n            if (that.id === '=' && are_similar(that.first, that.second)) {\n                that.warn('weird_assignment');\n            }\n            next = that;\n            while (next_token.id === '=') {\n                lvalue(next.second, '=');\n                next_token.first = next.second;\n                next.second = next_token;\n                next = next_token;\n                advance('=');\n                next.second = expression(20);\n            }\n            return that;\n        });\n        x.assign = true;\n        if (op) {\n            if (syntax[op].bitwise) {\n                x.bitwise = true;\n            }\n        }\n        return x;\n    }\n\n\n    function bitwise(s, p) {\n        var x = infix(s, p, 'number');\n        x.bitwise = true;\n        return x;\n    }\n\n\n    function suffix(s) {\n        var x = symbol(s, 150);\n        x.led = function (left) {\n            no_space_only(prev_token, token);\n            if (!option.plusplus) {\n                this.warn('unexpected_a');\n            } else if ((!left.identifier || left.reserved) &&\n                    left.id !== '.' && left.id !== '[') {\n                this.warn('bad_operand');\n            }\n            this.first = left;\n            this.arity = 'suffix';\n            return this;\n        };\n        return x;\n    }\n\n\n    function optional_identifier(variable) {\n        if (next_token.identifier) {\n            advance();\n            if (token.reserved && variable) {\n                token.warn('expected_identifier_a_reserved');\n            }\n            return token.string;\n        }\n    }\n\n\n    function identifier(variable) {\n        var i = optional_identifier(variable);\n        if (!i) {\n            next_token.stop(token.id === 'function' && next_token.id === '('\n                ? 'name_function'\n                : 'expected_identifier_a');\n        }\n        return i;\n    }\n\n\n    function statement() {\n\n        var label, preamble, the_statement;\n\n// We don't like the empty statement.\n\n        if (next_token.id === ';') {\n            next_token.warn('unexpected_a');\n            semicolon();\n            return;\n        }\n\n// Is this a labeled statement?\n\n        if (next_token.identifier && !next_token.reserved && peek().id === ':') {\n            edge('label');\n            label = next_token;\n            advance();\n            advance(':');\n            define('label', label);\n            if (next_token.labeled !== true || funct === global_funct) {\n                label.stop('unexpected_label_a');\n            } else if (jx.test(label.string + ':')) {\n                label.warn('url');\n            }\n            next_token.label = label;\n            label.init = true;\n            label.statement = next_token;\n        }\n\n// Parse the statement.\n\n        preamble = next_token;\n        if (token.id !== 'else') {\n            edge();\n        }\n        step_in('statement');\n        the_statement = expression(0, true);\n        if (the_statement) {\n\n// Look for the final semicolon.\n\n            if (the_statement.arity === 'statement') {\n                if (the_statement.id === 'switch' ||\n                        (the_statement.block && the_statement.id !== 'do')) {\n                    spaces();\n                } else {\n                    semicolon();\n                }\n            } else {\n\n// If this is an expression statement, determine if it is acceptable.\n// We do not like\n//      new Blah;\n// statements. If it is to be used at all, new should only be used to make\n// objects, not side effects. The expression statements we do like do\n// assignment or invocation or delete.\n\n                if (the_statement.id === '(') {\n                    if (the_statement.first.id === 'new') {\n                        next_token.warn('bad_new');\n                    }\n                } else if (the_statement.id === '++' ||\n                        the_statement.id === '--') {\n                    lvalue(the_statement.first);\n                } else if (!the_statement.assign &&\n                        the_statement.id !== 'delete') {\n                    if (!option.closure || !preamble.comments) {\n                        preamble.warn('assignment_function_expression');\n                    }\n                }\n                semicolon();\n            }\n        }\n        step_out();\n        if (label) {\n            label.dead = true;\n        }\n        return the_statement;\n    }\n\n\n    function statements() {\n        var array = [], disruptor, the_statement;\n\n// A disrupt statement may not be followed by any other statement.\n// If the last statement is disrupt, then the sequence is disrupt.\n\n        while (next_token.postscript !== true) {\n            if (next_token.id === ';') {\n                next_token.warn('unexpected_a');\n                semicolon();\n            } else {\n                if (next_token.string === 'use strict') {\n                    if ((!node_js) || funct !== global_funct || array.length > 0) {\n                        next_token.warn('function_strict');\n                    }\n                    use_strict();\n                }\n                if (disruptor) {\n                    next_token.warn('unreachable_a_b', next_token.string,\n                        disruptor.string);\n                    disruptor = null;\n                }\n                the_statement = statement();\n                if (the_statement) {\n                    array.push(the_statement);\n                    if (the_statement.disrupt) {\n                        disruptor = the_statement;\n                        array.disrupt = true;\n                    }\n                }\n            }\n        }\n        return array;\n    }\n\n\n    function block(kind) {\n\n// A block is a sequence of statements wrapped in braces.\n\n        var array,\n            curly = next_token,\n            old_block_var = block_var,\n            old_in_block = in_block,\n            old_strict_mode = strict_mode;\n\n        in_block = kind !== 'function' && kind !== 'try' && kind !== 'catch';\n        block_var = [];\n        if (curly.id === '{') {\n            spaces();\n            advance('{');\n            step_in();\n            if (kind === 'function' && !use_strict() && !old_strict_mode &&\n                    !option.sloppy && funct.level === 1) {\n                next_token.warn('missing_use_strict');\n            }\n            array = statements();\n            strict_mode = old_strict_mode;\n            step_out('}', curly);\n        } else if (in_block) {\n            curly.stop('expected_a_b', '{', artifact());\n        } else {\n            curly.warn('expected_a_b', '{', artifact());\n            array = [statement()];\n            array.disrupt = array[0].disrupt;\n        }\n        if (kind !== 'catch' && array.length === 0) {\n            curly.warn('empty_block');\n        }\n        block_var.forEach(function (name) {\n            scope[name].dead = true;\n        });\n        block_var = old_block_var;\n        in_block = old_in_block;\n        return array;\n    }\n\n\n    function tally_property(name) {\n        if (option.properties && typeof property[name] !== 'number') {\n            token.warn('unexpected_property_a', name);\n        }\n        if (property[name]) {\n            property[name] += 1;\n        } else {\n            property[name] = 1;\n        }\n    }\n\n\n// ECMAScript parser\n\n    (function () {\n        var x = symbol('(identifier)');\n        x.nud = function () {\n            var name = this.string,\n                master = scope[name],\n                writeable;\n\n// If the master is not in scope, then we may have an undeclared variable.\n// Check the predefined list. If it was predefined, create the global\n// variable.\n\n            if (!master) {\n                writeable = predefined[name];\n                if (typeof writeable === 'boolean') {\n                    global_scope[name] = master = {\n                        dead: false,\n                        function: global_funct,\n                        kind: 'var',\n                        string: name,\n                        writeable: writeable\n                    };\n\n// But if the variable is not in scope, and is not predefined, and if we are not\n// in the global scope, then we have an undefined variable error.\n\n                } else {\n                    token.warn('used_before_a');\n                }\n            } else {\n                this.master = master;\n            }\n\n// Annotate uses that cross scope boundaries.\n\n            if (master) {\n                if (master.kind === 'label') {\n                    this.warn('a_label');\n                } else {\n                    if (master.dead === true || master.dead === funct) {\n                        this.warn('a_scope');\n                    }\n                    master.used += 1;\n                    if (master.function !== funct) {\n                        if (master.function === global_funct) {\n                            funct.global.push(name);\n                        } else {\n                            master.function.closure.push(name);\n                            funct.outer.push(name);\n                        }\n                    }\n                }\n            }\n            return this;\n        };\n        x.identifier = true;\n    }());\n\n\n// Build the syntax table by declaring the syntactic elements.\n\n    type('(array)', 'array');\n    type('(function)', 'function');\n    type('(number)', 'number', return_this);\n    type('(object)', 'object');\n    type('(string)', 'string', return_this);\n    type('(boolean)', 'boolean', return_this);\n    type('(regexp)', 'regexp', return_this);\n\n    ultimate('(begin)');\n    ultimate('(end)');\n    ultimate('(error)');\n    postscript(symbol('}'));\n    symbol(')');\n    symbol(']');\n    postscript(symbol('\"'));\n    postscript(symbol('\\''));\n    symbol(';');\n    symbol(':');\n    symbol(',');\n    symbol('#');\n    symbol('@');\n    symbol('*/');\n    postscript(reserve('case'));\n    reserve('catch');\n    postscript(reserve('default'));\n    reserve('else');\n    reserve('finally');\n\n    reservevar('arguments', function (x) {\n        if (strict_mode && funct === global_funct) {\n            x.warn('strict');\n        }\n        funct.arguments = true;\n    });\n    reservevar('eval');\n    constant('false', 'boolean');\n    constant('Infinity', 'number');\n    constant('NaN', 'number');\n    constant('null', '');\n    reservevar('this', function (x) {\n        if (strict_mode && funct.statement && funct.name.charAt(0) > 'Z') {\n            x.warn('strict');\n        }\n    });\n    constant('true', 'boolean');\n    constant('undefined', '');\n\n    infix('?', 30, function (left, that) {\n        step_in('?');\n        that.first = expected_condition(expected_relation(left));\n        that.second = expression(0);\n        spaces();\n        step_out();\n        var colon = next_token;\n        advance(':');\n        step_in(':');\n        spaces();\n        that.third = expression(10);\n        that.arity = 'ternary';\n        if (are_similar(that.second, that.third)) {\n            colon.warn('weird_ternary');\n        } else if (are_similar(that.first, that.second)) {\n            that.warn('use_or');\n        }\n        step_out();\n        return that;\n    });\n\n    infix('||', 40, function (left, that) {\n        function paren_check(that) {\n            if (that.id === '&&' && !that.paren) {\n                that.warn('and');\n            }\n            return that;\n        }\n\n        that.first = paren_check(expected_condition(expected_relation(left)));\n        that.second = paren_check(expected_relation(expression(40)));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    infix('&&', 50, function (left, that) {\n        that.first = expected_condition(expected_relation(left));\n        that.second = expected_relation(expression(50));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    prefix('void', function (that) {\n        that.first = expression(0);\n        that.warn('expected_a_b', 'undefined', 'void');\n        return that;\n    });\n\n    bitwise('|', 70);\n    bitwise('^', 80);\n    bitwise('&', 90);\n\n    relation('==', '===');\n    relation('===');\n    relation('!=', '!==');\n    relation('!==');\n    relation('<');\n    relation('>');\n    relation('<=');\n    relation('>=');\n\n    bitwise('<<', 120);\n    bitwise('>>', 120);\n    bitwise('>>>', 120);\n\n    infix('in', 120, function (left, that) {\n        that.warn('infix_in');\n        that.left = left;\n        that.right = expression(130);\n        return that;\n    });\n    infix('instanceof', 120);\n    infix('+', 130, function (left, that) {\n        if (left.id === '(number)') {\n            if (left.number === 0) {\n                left.warn('unexpected_a', '0');\n            }\n        } else if (left.id === '(string)') {\n            if (left.string === '') {\n                left.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        var right = expression(130);\n        if (right.id === '(number)') {\n            if (right.number === 0) {\n                right.warn('unexpected_a', '0');\n            }\n        } else if (right.id === '(string)') {\n            if (right.string === '') {\n                right.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        if (left.id === right.id) {\n            if (left.id === '(string)' || left.id === '(number)') {\n                if (left.id === '(string)') {\n                    left.string += right.string;\n                    if (jx.test(left.string)) {\n                        left.warn('url');\n                    }\n                } else {\n                    left.number += right.number;\n                }\n                left.thru = right.thru;\n                return left;\n            }\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('+');\n    prefix('+++', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('+++', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('-', 130, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(130);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number -= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('-');\n    prefix('---', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('---', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('*', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number *= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('/', 140, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number /= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('%', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number %= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n\n    suffix('++');\n    prefix('++');\n\n    suffix('--');\n    prefix('--');\n    prefix('delete', function (that) {\n        one_space();\n        var p = expression(0);\n        if (!p || (p.id !== '.' && p.id !== '[')) {\n            next_token.warn('deleted');\n        }\n        that.first = p;\n        return that;\n    });\n\n\n    prefix('~', function (that) {\n        no_space_only();\n        if (!option.bitwise) {\n            that.warn('unexpected_a');\n        }\n        that.first = expression(150);\n        return that;\n    });\n    function banger(that) {\n        no_space_only();\n        that.first = expected_condition(expression(150));\n        if (bang[that.first.id] === that || that.first.assign) {\n            that.warn('confusing_a');\n        }\n        return that;\n    }\n    prefix('!', banger);\n    prefix('!!', banger);\n    prefix('typeof');\n    prefix('new', function (that) {\n        one_space();\n        var c = expression(160), n, p, v;\n        that.first = c;\n        if (c.id !== 'function') {\n            if (c.identifier) {\n                switch (c.string) {\n                case 'Object':\n                    token.warn('use_object');\n                    break;\n                case 'Array':\n                    if (next_token.id === '(') {\n                        p = next_token;\n                        p.first = this;\n                        advance('(');\n                        if (next_token.id !== ')') {\n                            n = expression(0);\n                            p.second = [n];\n                            if (n.id === '(string)' || next_token.id === ',') {\n                                p.warn('use_array');\n                            }\n                            while (next_token.id === ',') {\n                                advance(',');\n                                p.second.push(expression(0));\n                            }\n                        } else {\n                            token.warn('use_array');\n                        }\n                        advance(')', p);\n                        return p;\n                    }\n                    token.warn('use_array');\n                    break;\n                case 'Number':\n                case 'String':\n                case 'Boolean':\n                case 'Math':\n                case 'JSON':\n                    c.warn('not_a_constructor');\n                    break;\n                case 'Function':\n                    if (!option.evil) {\n                        next_token.warn('function_eval');\n                    }\n                    break;\n                case 'Date':\n                case 'RegExp':\n                case 'this':\n                    break;\n                default:\n                    if (c.id !== 'function') {\n                        v = c.string.charAt(0);\n                        if (!option.newcap && (v < 'A' || v > 'Z')) {\n                            token.warn('constructor_name_a');\n                        }\n                    }\n                }\n            } else {\n                if (c.id !== '.' && c.id !== '[' && c.id !== '(') {\n                    token.warn('bad_constructor');\n                }\n            }\n        } else {\n            that.warn('weird_new');\n        }\n        if (next_token.id !== '(') {\n            next_token.warn('missing_a', '()');\n        }\n        return that;\n    });\n\n    infix('(', 160, function (left, that) {\n        var e, p;\n        if (indent && indent.mode === 'expression') {\n            no_space(prev_token, token);\n        } else {\n            no_space_only(prev_token, token);\n        }\n        if (!left.immed && left.id === 'function') {\n            next_token.warn('wrap_immediate');\n        }\n        p = [];\n        if (left.identifier) {\n            if (left.string.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {\n                if (left.string !== 'Number' && left.string !== 'String' &&\n                        left.string !== 'Boolean' && left.string !== 'Date') {\n                    if (left.string === 'Math') {\n                        left.warn('not_a_function');\n                    } else if (left.string === 'Object') {\n                        token.warn('use_object');\n                    } else if (left.string === 'Array' || !option.newcap) {\n                        left.warn('missing_a', 'new');\n                    }\n                }\n            } else if (left.string === 'JSON') {\n                left.warn('not_a_function');\n            }\n        } else if (left.id === '.') {\n            if (left.second.string === 'split' &&\n                    left.first.id === '(string)') {\n                left.second.warn('use_array');\n            }\n        }\n        step_in();\n        if (next_token.id !== ')') {\n            no_space();\n            for (;;) {\n                edge();\n                e = expression(10);\n                if (left.string === 'Boolean' && (e.id === '!' || e.id === '~')) {\n                    e.warn('weird_condition');\n                }\n                p.push(e);\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', that);\n        if (typeof left === 'object') {\n            if (left.string === 'parseInt' && p.length === 1) {\n                left.warn('radix');\n            } else if (left.string === 'String' && p.length >= 1 && p[0].id === '(string)') {\n                left.warn('unexpected_a');\n            }\n            if (!option.evil) {\n                if (left.string === 'eval' || left.string === 'Function' ||\n                        left.string === 'execScript') {\n                    left.warn('evil');\n                } else if (p[0] && p[0].id === '(string)' &&\n                        (left.string === 'setTimeout' ||\n                        left.string === 'setInterval')) {\n                    left.warn('implied_evil');\n                }\n            }\n            if (!left.identifier && left.id !== '.' && left.id !== '[' &&\n                    left.id !== '(' && left.id !== '&&' && left.id !== '||' &&\n                    left.id !== '?') {\n                left.warn('bad_invocation');\n            }\n            if (left.id === '.') {\n                if (p.length > 0 &&\n                        left.first && left.first.first &&\n                        are_similar(p[0], left.first.first)) {\n                    if (left.second.string === 'call' ||\n                            (left.second.string === 'apply' && (p.length === 1 ||\n                            (p[1].arity === 'prefix' && p[1].id === '[')))) {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n                if (left.second.string === 'toString') {\n                    if (left.first.id === '(string)' || left.first.id === '(number)') {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n            }\n        }\n        that.first = left;\n        that.second = p;\n        return that;\n    }, true);\n\n    prefix('(', function (that) {\n        step_in('expression');\n        no_space();\n        edge();\n        if (next_token.id === 'function') {\n            next_token.immed = true;\n        }\n        var value = expression(0);\n        value.paren = true;\n        no_space();\n        step_out(')', that);\n        if (value.id === 'function') {\n            switch (next_token.id) {\n            case '(':\n                next_token.warn('move_invocation');\n                break;\n            case '.':\n            case '[':\n                next_token.warn('unexpected_a');\n                break;\n            default:\n                that.warn('bad_wrap');\n            }\n        } else if (!value.arity) {\n            if (!option.closure || !that.comments) {\n                that.warn('unexpected_a');\n            }\n        }\n        return value;\n    });\n\n    infix('.', 170, function (left, that) {\n        no_space(prev_token, token);\n        no_space();\n        var name = identifier();\n        if (typeof name === 'string') {\n            tally_property(name);\n        }\n        that.first = left;\n        that.second = token;\n        if (left && left.string === 'arguments' &&\n                (name === 'callee' || name === 'caller')) {\n            left.warn('avoid_a', 'arguments.' + name);\n        } else if (!option.evil && left && left.string === 'document' &&\n                (name === 'write' || name === 'writeln')) {\n            left.warn('write_is_wrong');\n        } else if (!option.stupid && syx.test(name)) {\n            token.warn('sync_a');\n        }\n        if (!option.evil && (name === 'eval' || name === 'execScript')) {\n            next_token.warn('evil');\n        }\n        return that;\n    }, true);\n\n    infix('[', 170, function (left, that) {\n        var e, s;\n        no_space_only(prev_token, token);\n        no_space();\n        step_in();\n        edge();\n        e = expression(0);\n        switch (e.id) {\n        case '(number)':\n            if (e.id === '(number)' && left.id === 'arguments') {\n                left.warn('use_param');\n            }\n            break;\n        case '(string)':\n            if (!option.evil &&\n                    (e.string === 'eval' || e.string === 'execScript')) {\n                e.warn('evil');\n            } else if (!option.sub && ix.test(e.string)) {\n                s = syntax[e.string];\n                if (!s || !s.reserved) {\n                    e.warn('subscript');\n                }\n            }\n            tally_property(e.string);\n            break;\n        }\n        step_out(']', that);\n        no_space(prev_token, token);\n        that.first = left;\n        that.second = e;\n        return that;\n    }, true);\n\n    prefix('[', function (that) {\n        that.first = [];\n        step_in('array');\n        while (next_token.id !== '(end)') {\n            while (next_token.id === ',') {\n                next_token.warn('unexpected_a');\n                advance(',');\n            }\n            if (next_token.id === ']') {\n                break;\n            }\n            indent.wrap = false;\n            edge();\n            that.first.push(expression(10));\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id === ']') {\n                    token.warn('unexpected_a');\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        step_out(']', that);\n        return that;\n    }, 170);\n\n\n    function property_name() {\n        var id = optional_identifier();\n        if (!id) {\n            if (next_token.id === '(string)') {\n                id = next_token.string;\n                advance();\n            } else if (next_token.id === '(number)') {\n                id = next_token.number.toString();\n                advance();\n            }\n        }\n        return id;\n    }\n\n\n\n    assignop('=');\n    assignop('+=', '+');\n    assignop('-=', '-');\n    assignop('*=', '*');\n    assignop('/=', '/').nud = function () {\n        next_token.stop('slash_equal');\n    };\n    assignop('%=', '%');\n    assignop('&=', '&');\n    assignop('|=', '|');\n    assignop('^=', '^');\n    assignop('<<=', '<<');\n    assignop('>>=', '>>');\n    assignop('>>>=', '>>>');\n\n    function function_parameters() {\n        var id, parameters = [], paren = next_token;\n        advance('(');\n        token.function = funct;\n        step_in();\n        no_space();\n        if (next_token.id !== ')') {\n            for (;;) {\n                edge();\n                id = identifier();\n                define('parameter', token);\n                parameters.push(id);\n                token.init = true;\n                token.writeable = true;\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', paren);\n        return parameters;\n    }\n\n    function do_function(func, name) {\n        var old_funct = funct,\n            old_option = option,\n            old_scope = scope;\n        scope = Object.create(old_scope);\n        funct = {\n            closure: [],\n            global: [],\n            level: old_funct.level + 1,\n            line: next_token.line,\n            loopage: 0,\n            name: name || '\\'' + (anonname || '').replace(nx, sanitize) + '\\'',\n            outer: [],\n            scope: scope\n        };\n        funct.parameter = function_parameters();\n        func.function = funct;\n        option = Object.create(old_option);\n        functions.push(funct);\n        if (name) {\n            func.name = name;\n            func.string = name;\n            define('function', func);\n            func.init = true;\n            func.used += 1;\n        }\n        func.writeable = false;\n        one_space();\n        func.block = block('function');\n        Object.keys(scope).forEach(function (name) {\n            var master = scope[name];\n            if (!master.used && master.kind !== 'exception' &&\n                    (master.kind !== 'parameter' || !option.unparam)) {\n                master.warn('unused_a');\n            } else if (!master.init) {\n                master.warn('uninitialized_a');\n            }\n        });\n        funct = old_funct;\n        option = old_option;\n        scope = old_scope;\n    }\n\n    prefix('{', function (that) {\n        var get, i, j, name, set, seen = Object.create(null);\n        that.first = [];\n        step_in();\n        while (next_token.id !== '}') {\n            indent.wrap = false;\n\n// JSLint recognizes the ES5 extension for get/set in object literals,\n// but requires that they be used in pairs.\n\n            edge();\n            if (next_token.string === 'get' && peek().id !== ':') {\n                get = next_token;\n                advance('get');\n                one_space_only();\n                name = next_token;\n                i = property_name();\n                if (!i) {\n                    next_token.stop('missing_property');\n                }\n                get.string = '';\n                do_function(get);\n                if (funct.loopage) {\n                    get.warn('function_loop');\n                }\n                if (get.function.parameter.length) {\n                    get.warn('parameter_a_get_b', get.function.parameter[0], i);\n                }\n                comma();\n                set = next_token;\n                spaces();\n                edge();\n                advance('set');\n                set.string = '';\n                one_space_only();\n                j = property_name();\n                if (i !== j) {\n                    token.stop('expected_a_b', i, j || next_token.string);\n                }\n                do_function(set);\n                if (set.block.length === 0) {\n                    token.warn('missing_a', 'throw');\n                }\n                if (set.function.parameter.length === 0) {\n                    set.stop('parameter_set_a', 'value');\n                } else if (set.function.parameter[0] !== 'value') {\n                    set.stop('expected_a_b', 'value',\n                        set.function.parameter[0]);\n                }\n                name.first = [get, set];\n            } else {\n                name = next_token;\n                i = property_name();\n                if (typeof i !== 'string') {\n                    next_token.stop('missing_property');\n                }\n                advance(':');\n                spaces();\n                name.first = expression(10);\n            }\n            that.first.push(name);\n            if (seen[i] === true) {\n                next_token.warn('duplicate_a', i);\n            }\n            seen[i] = true;\n            tally_property(i);\n            if (next_token.id !== ',') {\n                break;\n            }\n            for (;;) {\n                comma();\n                if (next_token.id !== ',') {\n                    break;\n                }\n                next_token.warn('unexpected_a');\n            }\n            if (next_token.id === '}') {\n                token.warn('unexpected_a');\n            }\n        }\n        step_out('}', that);\n        return that;\n    });\n\n    stmt('{', function () {\n        next_token.warn('statement_block');\n        this.arity = 'statement';\n        this.block = statements();\n        this.disrupt = this.block.disrupt;\n        advance('}', this);\n        return this;\n    });\n\n    stmt('/*global', directive);\n    stmt('/*globals', directive);\n    stmt('/*jslint', directive);\n    stmt('/*member', directive);\n    stmt('/*members', directive);\n    stmt('/*property', directive);\n    stmt('/*properties', directive);\n\n    stmt('var', function () {\n\n// JavaScript does not have block scope. It only has function scope. So,\n// declaring a variable in a block can have unexpected consequences.\n\n// var.first will contain an array, the array containing name tokens\n// and assignment tokens.\n\n        var assign, id, name;\n\n        if (funct.loopage) {\n            next_token.warn('var_loop');\n        } else if (funct.varstatement && !option.vars) {\n            next_token.warn('combine_var');\n        }\n        if (funct !== global_funct) {\n            funct.varstatement = true;\n        }\n        this.arity = 'statement';\n        this.first = [];\n        step_in('var');\n        for (;;) {\n            name = next_token;\n            id = identifier(true);\n            define('var', name);\n            name.dead = funct;\n            if (next_token.id === '=') {\n                if (funct === global_funct && !name.writeable) {\n                    name.warn('read_only');\n                }\n                assign = next_token;\n                assign.first = name;\n                spaces();\n                advance('=');\n                spaces();\n                if (next_token.id === 'undefined') {\n                    token.warn('unnecessary_initialize', id);\n                }\n                if (peek(0).id === '=' && next_token.identifier) {\n                    next_token.stop('var_a_not');\n                }\n                assign.second = expression(0);\n                assign.arity = 'infix';\n                name.init = true;\n                this.first.push(assign);\n            } else {\n                this.first.push(name);\n            }\n            name.dead = false;\n            name.writeable = true;\n            if (next_token.id !== ',') {\n                break;\n            }\n            comma();\n            indent.wrap = false;\n            if (var_mode && next_token.line === token.line &&\n                    this.first.length === 1) {\n                var_mode = null;\n                indent.open = false;\n                indent.at -= option.indent;\n            }\n            spaces();\n            edge();\n        }\n        var_mode = null;\n        step_out();\n        return this;\n    });\n\n    stmt('function', function () {\n        one_space();\n        if (in_block) {\n            token.warn('function_block');\n        }\n        var name = next_token,\n            id = identifier(true);\n        define('var', name);\n        if (!name.writeable) {\n            name.warn('read_only');\n        }\n        name.init = true;\n        name.statement = true;\n        no_space();\n        this.arity = 'statement';\n        do_function(this, id);\n        if (next_token.id === '(' && next_token.line === token.line) {\n            next_token.stop('function_statement');\n        }\n        return this;\n    });\n\n    prefix('function', function (that) {\n        var id = optional_identifier(true), name;\n        if (id) {\n            name = token;\n            no_space();\n        } else {\n            id = '';\n            one_space();\n        }\n        do_function(that, id);\n        if (name) {\n            name.function = that.function;\n        }\n        if (funct.loopage) {\n            that.warn('function_loop');\n        }\n        switch (next_token.id) {\n        case ';':\n        case '(':\n        case ')':\n        case ',':\n        case ']':\n        case '}':\n        case ':':\n        case '(end)':\n            break;\n        case '.':\n            if (peek().string !== 'bind' || peek(1).id !== '(') {\n                next_token.warn('unexpected_a');\n            }\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n        that.arity = 'function';\n        return that;\n    });\n\n    stmt('if', function () {\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('if');\n        if (next_token.id === 'else') {\n            if (this.block.disrupt) {\n                next_token.warn(this.elif ? 'use_nested_if' : 'unnecessary_else');\n            }\n            one_space();\n            advance('else');\n            one_space();\n            if (next_token.id === 'if') {\n                next_token.elif = true;\n                this.else = statement(true);\n            } else {\n                this.else = block('else');\n            }\n            if (this.else.disrupt && this.block.disrupt) {\n                this.disrupt = true;\n            }\n        }\n        return this;\n    });\n\n    stmt('try', function () {\n\n// try.first    The catch variable\n// try.second   The catch clause\n// try.third    The finally clause\n// try.block    The try block\n\n        var exception_variable, paren;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('try');\n        if (next_token.id === 'catch') {\n            one_space();\n            advance('catch');\n            one_space();\n            paren = next_token;\n            advance('(');\n            step_in('control');\n            no_space();\n            edge();\n            exception_variable = next_token;\n            this.first = identifier();\n            define('exception', exception_variable);\n            exception_variable.init = true;\n            no_space();\n            step_out(')', paren);\n            one_space();\n            this.second = block('catch');\n            if (this.second.length) {\n                if (this.first === 'ignore') {\n                    exception_variable.warn('unexpected_a');\n                }\n            } else {\n                if (this.first !== 'ignore') {\n                    exception_variable.warn('expected_a_b', 'ignore',\n                        exception_variable.string);\n                }\n            }\n            exception_variable.dead = true;\n        }\n        if (next_token.id === 'finally') {\n            one_space();\n            advance('finally');\n            one_space();\n            this.third = block('finally');\n        } else if (!this.second) {\n            next_token.stop('expected_a_b', 'catch', artifact());\n        }\n        return this;\n    });\n\n    labeled_stmt('while', function () {\n        one_space();\n        var paren = next_token;\n        funct.loopage += 1;\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_relation(expression(0));\n        if (this.first.id !== 'true') {\n            expected_condition(this.first, 'unexpected_a');\n        }\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('while');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        funct.loopage -= 1;\n        return this;\n    });\n\n    reserve('with');\n\n    labeled_stmt('switch', function () {\n\n// switch.first         the switch expression\n// switch.second        the array of cases. A case is 'case' or 'default' token:\n//    case.first        the array of case expressions\n//    case.second       the array of statements\n// If all of the arrays of statements are disrupt, then the switch is disrupt.\n\n        var cases = [],\n            old_in_block = in_block,\n            particular,\n            that = token,\n            the_case = next_token;\n\n        function find_duplicate_case(value) {\n            if (are_similar(particular, value)) {\n                value.warn('duplicate_a');\n            }\n        }\n\n        one_space();\n        advance('(');\n        no_space();\n        step_in();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', the_case);\n        one_space();\n        advance('{');\n        step_in();\n        in_block = true;\n        this.second = [];\n        if (that.from !== next_token.from && !option.white) {\n            next_token.warn('expected_a_at_b_c', next_token.string, that.from, next_token.from);\n        }\n        while (next_token.id === 'case') {\n            the_case = next_token;\n            the_case.first = [];\n            the_case.arity = 'case';\n            for (;;) {\n                spaces();\n                edge('case');\n                advance('case');\n                one_space();\n                particular = expression(0);\n                cases.forEach(find_duplicate_case);\n                cases.push(particular);\n                the_case.first.push(particular);\n                if (particular.id === 'NaN') {\n                    particular.warn('unexpected_a');\n                }\n                no_space_only();\n                advance(':');\n                if (next_token.id !== 'case') {\n                    break;\n                }\n            }\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                if (!the_case.second[the_case.second.length - 1].disrupt) {\n                    next_token.warn('missing_a_after_b', 'break', 'case');\n                }\n            } else {\n                next_token.warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.second.length === 0) {\n            next_token.warn('missing_a', 'case');\n        }\n        if (next_token.id === 'default') {\n            spaces();\n            the_case = next_token;\n            the_case.arity = 'case';\n            edge('case');\n            advance('default');\n            no_space_only();\n            advance(':');\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                this.disrupt = the_case.second[the_case.second.length - 1].disrupt;\n            } else {\n                the_case.warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.break) {\n            this.disrupt = false;\n        }\n        spaces();\n        step_out('}', this);\n        in_block = old_in_block;\n        return this;\n    });\n\n    stmt('debugger', function () {\n        if (!option.debug) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        return this;\n    });\n\n    labeled_stmt('do', function () {\n        funct.loopage += 1;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('do');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        one_space();\n        advance('while');\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in();\n        no_space();\n        edge();\n        this.first = expected_condition(expected_relation(expression(0)), 'unexpected_a');\n        no_space();\n        step_out(')', paren);\n        funct.loopage -= 1;\n        return this;\n    });\n\n    labeled_stmt('for', function () {\n\n        var blok, filter, master, ok = false, paren = next_token, value;\n        this.arity = 'statement';\n        funct.loopage += 1;\n        advance('(');\n        if (next_token.id === ';') {\n            no_space();\n            advance(';');\n            no_space();\n            advance(';');\n            no_space();\n            advance(')');\n            blok = block('for');\n        } else {\n            step_in('control');\n            spaces(this, paren);\n            no_space();\n            if (next_token.id === 'var') {\n                next_token.stop('move_var');\n            }\n            edge();\n            if (peek(0).id === 'in') {\n                this.forin = true;\n                value = expression(1000);\n                master = value.master;\n                if (!master) {\n                    value.stop('bad_in_a');\n                }\n                if (master.kind !== 'var' || master.function !== funct ||\n                        !master.writeable || master.dead) {\n                    value.warn('bad_in_a');\n                }\n                master.init = true;\n                master.used -= 1;\n                this.first = value;\n                advance('in');\n                this.second = expression(20);\n                step_out(')', paren);\n                blok = block('for');\n                if (!option.forin) {\n                    if (blok.length === 1 && typeof blok[0] === 'object') {\n                        if (blok[0].id === 'if' && !blok[0].else) {\n                            filter = blok[0].first;\n                            while (filter.id === '&&') {\n                                filter = filter.first;\n                            }\n                            switch (filter.id) {\n                            case '===':\n                            case '!==':\n                                ok = filter.first.id === '['\n                                    ? are_similar(filter.first.first, this.second) &&\n                                        are_similar(filter.first.second, this.first)\n                                    : filter.first.id === 'typeof' &&\n                                        filter.first.first.id === '[' &&\n                                        are_similar(filter.first.first.first, this.second) &&\n                                        are_similar(filter.first.first.second, this.first);\n                                break;\n                            case '(':\n                                ok = filter.first.id === '.' && ((\n                                    are_similar(filter.first.first, this.second) &&\n                                    filter.first.second.string === 'hasOwnProperty' &&\n                                    are_similar(filter.second[0], this.first)\n                                ) || (\n                                    filter.first.first.id === '.' &&\n                                    filter.first.first.first.first &&\n                                    filter.first.first.first.first.string === 'Object' &&\n                                    filter.first.first.first.id === '.' &&\n                                    filter.first.first.first.second.string === 'prototype' &&\n                                    filter.first.first.second.string === 'hasOwnProperty' &&\n                                    filter.first.second.string === 'call' &&\n                                    are_similar(filter.second[0], this.second) &&\n                                    are_similar(filter.second[1], this.first)\n                                ));\n                                break;\n                            }\n                        } else if (blok[0].id === 'switch') {\n                            ok = blok[0].id === 'switch' &&\n                                blok[0].first.id === 'typeof' &&\n                                blok[0].first.first.id === '[' &&\n                                are_similar(blok[0].first.first.first, this.second) &&\n                                are_similar(blok[0].first.first.second, this.first);\n                        }\n                    }\n                    if (!ok) {\n                        this.warn('for_if');\n                    }\n                }\n            } else {\n                edge();\n                this.first = [];\n                for (;;) {\n                    this.first.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                semicolon();\n                edge();\n                this.second = expected_relation(expression(0));\n                if (this.second.id !== 'true') {\n                    expected_condition(this.second, 'unexpected_a');\n                }\n                semicolon(token);\n                if (next_token.id === ';') {\n                    next_token.stop('expected_a_b', ')', ';');\n                }\n                this.third = [];\n                edge();\n                for (;;) {\n                    this.third.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                no_space();\n                step_out(')', paren);\n                one_space();\n                blok = block('for');\n            }\n        }\n        if (blok.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        this.block = blok;\n        funct.loopage -= 1;\n        return this;\n    });\n\n    function optional_label(that) {\n        var label = next_token.string,\n            master;\n        that.arity = 'statement';\n        if (!funct.breakage || (!option.continue && that.id === 'continue')) {\n            that.warn('unexpected_a');\n        } else if (next_token.identifier && token.line === next_token.line) {\n            one_space_only();\n            master = scope[label];\n            if (!master || master.kind !== 'label') {\n                next_token.warn('not_a_label');\n            } else if (master.dead || master.function !== funct) {\n                next_token.warn('not_a_scope');\n            } else {\n                master.used += 1;\n                if (that.id === 'break') {\n                    master.statement.break = true;\n                }\n                if (funct.breakage[funct.breakage.length - 1] === master.statement) {\n                    next_token.warn('unexpected_a');\n                }\n            }\n            that.first = next_token;\n            advance();\n        } else {\n            if (that.id === 'break') {\n                funct.breakage[funct.breakage.length - 1].break = true;\n            }\n        }\n        return that;\n\n    }\n\n    disrupt_stmt('break', function () {\n        return optional_label(this);\n    });\n\n    disrupt_stmt('continue', function () {\n        return optional_label(this);\n    });\n\n    disrupt_stmt('return', function () {\n        if (funct === global_funct) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        if (next_token.id !== ';' && next_token.line === token.line) {\n            if (option.closure) {\n                spaces();\n            } else {\n                one_space_only();\n            }\n            if (next_token.id === '/' || next_token.id === '(regexp)') {\n                next_token.warn('wrap_regexp');\n            }\n            this.first = expression(0);\n            if (this.first.assign) {\n                this.first.warn('unexpected_a');\n            }\n        }\n        return this;\n    });\n\n    disrupt_stmt('throw', function () {\n        this.arity = 'statement';\n        one_space_only();\n        this.first = expression(20);\n        return this;\n    });\n\n\n//  Superfluous reserved words\n\n    reserve('class');\n    reserve('const');\n    reserve('enum');\n    reserve('export');\n    reserve('extends');\n    reserve('import');\n    reserve('super');\n\n// Harmony reserved words\n\n    reserve('implements');\n    reserve('interface');\n    reserve('let');\n    reserve('package');\n    reserve('private');\n    reserve('protected');\n    reserve('public');\n    reserve('static');\n    reserve('yield');\n\n\n// Parse JSON\n\n    function json_value() {\n\n        function json_object() {\n            var brace = next_token, object = Object.create(null);\n            advance('{');\n            if (next_token.id !== '}') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    if (next_token.id !== '(string)') {\n                        next_token.warn('expected_string_a');\n                    }\n                    if (object[next_token.string] === true) {\n                        next_token.warn('duplicate_a');\n                    } else if (next_token.string === '__proto__') {\n                        next_token.warn('dangling_a');\n                    } else {\n                        object[next_token.string] = true;\n                    }\n                    advance();\n                    advance(':');\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === '}') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance('}', brace);\n        }\n\n        function json_array() {\n            var bracket = next_token;\n            advance('[');\n            if (next_token.id !== ']') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === ']') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance(']', bracket);\n        }\n\n        switch (next_token.id) {\n        case '{':\n            json_object();\n            break;\n        case '[':\n            json_array();\n            break;\n        case 'true':\n        case 'false':\n        case 'null':\n        case '(number)':\n        case '(string)':\n            advance();\n            break;\n        case '-':\n            advance('-');\n            no_space_only();\n            advance('(number)');\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n    }\n\n\n// The actual JSLINT function itself.\n\n    itself = function JSLint(the_source, the_option) {\n\n        var i, predef, tree;\n        itself.errors = [];\n        itself.tree = '';\n        itself.properties = '';\n        begin = prev_token = token = next_token =\n            Object.create(syntax['(begin)']);\n        tokens = [];\n        predefined = Object.create(null);\n        add_to_predefined(standard);\n        property = Object.create(null);\n        if (the_option) {\n            option = Object.create(the_option);\n            predef = option.predef;\n            if (predef) {\n                if (Array.isArray(predef)) {\n                    for (i = 0; i < predef.length; i += 1) {\n                        predefined[predef[i]] = true;\n                    }\n                } else if (typeof predef === 'object') {\n                    add_to_predefined(predef);\n                }\n            }\n        } else {\n            option = Object.create(null);\n        }\n        option.indent = +option.indent || 4;\n        option.maxerr = +option.maxerr || 50;\n        global_scope = scope = Object.create(null);\n        global_funct = funct = {\n            scope: scope,\n            loopage: 0,\n            level: 0\n        };\n        functions = [funct];\n        block_var = [];\n\n        comments = [];\n        comments_off = false;\n        in_block = false;\n        indent = null;\n        json_mode = false;\n        lookahead = [];\n        node_js = false;\n        prereg = true;\n        strict_mode = false;\n        var_mode = null;\n        warnings = 0;\n        lex.init(the_source);\n\n        assume();\n\n        try {\n            advance();\n            if (next_token.id === '(number)') {\n                next_token.stop('unexpected_a');\n            } else {\n                switch (next_token.id) {\n                case '{':\n                case '[':\n                    comments_off = true;\n                    json_mode = true;\n                    json_value();\n                    break;\n                default:\n\n// If the first token is a semicolon, ignore it. This is sometimes used when\n// files are intended to be appended to files that may be sloppy. A sloppy\n// file may be depending on semicolon insertion on its last line.\n\n                    step_in(1);\n                    if (next_token.id === ';' && !node_js) {\n                        semicolon();\n                    }\n                    tree = statements();\n                    begin.first = tree;\n                    itself.tree = begin;\n                    if (tree.disrupt) {\n                        prev_token.warn('weird_program');\n                    }\n                }\n            }\n            indent = null;\n            advance('(end)');\n            itself.property = property;\n        } catch (e) {\n            if (e) {        // ~~\n                itself.errors.push({\n                    reason    : e.message,\n                    line      : e.line || next_token.line,\n                    character : e.character || next_token.from\n                }, null);\n            }\n        }\n        return itself.errors.length === 0;\n    };\n\n    function unique(array) {\n        array = array.sort();\n        var i, length = 0, previous, value;\n        for (i = 0; i < array.length; i += 1) {\n            value = array[i];\n            if (value !== previous) {\n                array[length] = value;\n                previous = value;\n                length += 1;\n            }\n        }\n        array.length = length;\n        return array;\n    }\n\n// Data summary.\n\n    itself.data = function () {\n        var data = {functions: []},\n            function_data,\n            i,\n            the_function,\n            the_scope;\n        data.errors = itself.errors;\n        data.json = json_mode;\n        data.global = unique(Object.keys(global_scope));\n\n        function selects(name) {\n            var kind = the_scope[name].kind;\n            switch (kind) {\n            case 'var':\n            case 'exception':\n            case 'label':\n                function_data[kind].push(name);\n                break;\n            }\n        }\n\n        for (i = 1; i < functions.length; i += 1) {\n            the_function = functions[i];\n            function_data = {\n                name: the_function.name,\n                line: the_function.line,\n                level: the_function.level,\n                parameter: the_function.parameter,\n                var: [],\n                exception: [],\n                closure: unique(the_function.closure),\n                outer: unique(the_function.outer),\n                global: unique(the_function.global),\n                label: []\n            };\n            the_scope = the_function.scope;\n            Object.keys(the_scope).forEach(selects);\n            function_data.var.sort();\n            function_data.exception.sort();\n            function_data.label.sort();\n            data.functions.push(function_data);\n        }\n        data.tokens = tokens;\n        return data;\n    };\n\n    itself.error_report = function (data) {\n        var evidence, i, output = [], warning;\n        if (data.errors.length) {\n            if (data.json) {\n                output.push('<cite>JSON: bad.</cite><br>');\n            }\n            for (i = 0; i < data.errors.length; i += 1) {\n                warning = data.errors[i];\n                if (warning) {\n                    evidence = warning.evidence || '';\n                    output.push('<cite>');\n                    if (isFinite(warning.line)) {\n                        output.push('<address>line ' +\n                            String(warning.line) +\n                            ' character ' + String(warning.character) +\n                            '</address>');\n                    }\n                    output.push(warning.reason.entityify() + '</cite>');\n                    if (evidence) {\n                        output.push('<pre>' + evidence.entityify() + '</pre>');\n                    }\n                }\n            }\n        }\n        return output.join('');\n    };\n\n\n    itself.report = function (data) {\n        var dl, i, j, names, output = [], the_function;\n\n        function detail(h, array) {\n            var comma_needed = false;\n            if (array.length) {\n                output.push(\"<dt>\" + h + \"</dt><dd>\");\n                array.forEach(function (item) {\n                    output.push((comma_needed ? ', ' : '') + item);\n                    comma_needed = true;\n                });\n                output.push(\"</dd>\");\n            }\n        }\n\n        output.push('<dl class=level0>');\n        if (data.global.length) {\n            detail('global', data.global);\n            dl = true;\n        } else if (data.json) {\n            if (!data.errors.length) {\n                output.push(\"<dt>JSON: good.</dt>\");\n            }\n        } else {\n            output.push(\"<dt><i>No new global variables introduced.</i></dt>\");\n        }\n        if (dl) {\n            output.push(\"</dl>\");\n        } else {\n            output[0] = '';\n        }\n\n        if (data.functions) {\n            for (i = 0; i < data.functions.length; i += 1) {\n                the_function = data.functions[i];\n                names = [];\n                if (the_function.params) {\n                    for (j = 0; j < the_function.params.length; j += 1) {\n                        names[j] = the_function.params[j].string;\n                    }\n                }\n                output.push('<dl class=level' + the_function.level +\n                    '><address>line ' + String(the_function.line) +\n                    '</address>' + the_function.name.entityify());\n                detail('parameter', the_function.parameter);\n                detail('variable', the_function.var);\n                detail('exception', the_function.exception);\n                detail('closure', the_function.closure);\n                detail('outer', the_function.outer);\n                detail('global', the_function.global);\n                detail('label', the_function.label);\n                output.push('</dl>');\n            }\n        }\n        return output.join('');\n    };\n\n    itself.properties_report = function (property) {\n        if (!property) {\n            return '';\n        }\n        var i,\n            key,\n            keys = Object.keys(property).sort(),\n            mem = '   ',\n            name,\n            not_first = false,\n            output = ['/*properties'];\n        for (i = 0; i < keys.length; i += 1) {\n            key = keys[i];\n            if (property[key] > 0) {\n                if (not_first) {\n                    mem += ',';\n                }\n                name = ix.test(key)\n                    ? key\n                    : '\\'' + key.replace(nx, sanitize) + '\\'';\n                if (mem.length + name.length >= 80) {\n                    output.push(mem);\n                    mem = '    ';\n                } else {\n                    mem += ' ';\n                }\n                mem += name;\n                not_first = true;\n            }\n        }\n        output.push(mem, '*/\\n');\n        return output.join('\\n');\n    };\n\n    itself.color = function (data) {\n        var from,\n            i = 1,\n            level,\n            line,\n            result = [],\n            thru,\n            data_token = data.tokens[0];\n        while (data_token && data_token.id !== '(end)') {\n            from = data_token.from;\n            line = data_token.line;\n            thru = data_token.thru;\n            level = data_token.function.level;\n            do {\n                thru = data_token.thru;\n                data_token = data.tokens[i];\n                i += 1;\n            } while (data_token && data_token.line === line &&\n                    data_token.from - thru < 5 &&\n                    level === data_token.function.level);\n            result.push({\n                line: line,\n                level: level,\n                from: from,\n                thru: thru\n            });\n        }\n        return result;\n    };\n\n    itself.jslint = itself;\n\n    itself.edition = '2014-01-26';\n\n    return itself;\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jslint-2014-02-06.js":"// jslint.js\n// 2014-02-06\n\n// Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// The Software shall be used for Good, not Evil.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// WARNING: JSLint will hurt your feelings.\n\n// JSLINT is a global function. It takes two parameters.\n\n//     var myResult = JSLINT(source, option);\n\n// The first parameter is either a string or an array of strings. If it is a\n// string, it will be split on '\\n' or '\\r'. If it is an array of strings, it\n// is assumed that each string represents one line. The source can be a\n// JavaScript text or a JSON text.\n\n// The second parameter is an optional object of options that control the\n// operation of JSLINT. Most of the options are booleans: They are all\n// optional and have a default value of false. One of the options, predef,\n// can be an array of names, which will be used to declare global variables,\n// or an object whose keys are used as global names, with a boolean value\n// that determines if they are assignable.\n\n// If it checks out, JSLINT returns true. Otherwise, it returns false.\n\n// If false, you can inspect JSLINT.errors to find out the problems.\n// JSLINT.errors is an array of objects containing these properties:\n\n//  {\n//      line      : The line (relative to 0) at which the lint was found\n//      character : The character (relative to 0) at which the lint was found\n//      reason    : The problem\n//      evidence  : The text line in which the problem occurred\n//      raw       : The raw message before the details were inserted\n//      a         : The first detail\n//      b         : The second detail\n//      c         : The third detail\n//      d         : The fourth detail\n//  }\n\n// If a stopping error was found, a null will be the last element of the\n// JSLINT.errors array. A stopping error means that JSLint was not confident\n// enough to continue. It does not necessarily mean that the error was\n// especially heinous.\n\n// You can request a data structure that contains JSLint's results.\n\n//     var myData = JSLINT.data();\n\n// It returns a structure with this form:\n\n//     {\n//         errors: [\n//             {\n//                 line: NUMBER,\n//                 character: NUMBER,\n//                 reason: STRING,\n//                 evidence: STRING\n//             }\n//         ],\n//         functions: [\n//             {\n//                 name: STRING,\n//                 line: NUMBER,\n//                 level: NUMBER,\n//                 parameter: [\n//                     STRING\n//                 ],\n//                 var: [\n//                     STRING\n//                 ],\n//                 exception: [\n//                     STRING\n//                 ],\n//                 closure: [\n//                     STRING\n//                 ],\n//                 outer: [\n//                     STRING\n//                 ],\n//                 global: [\n//                     STRING\n//                 ],\n//                 label: [\n//                     STRING\n//                 ]\n//             }\n//         ],\n//         global: [\n//             STRING\n//         ],\n//         member: {\n//             STRING: NUMBER\n//         },\n//         json: BOOLEAN\n//     }\n\n// You can request a Function Report, which shows all of the functions\n// and the parameters and vars that they use. This can be used to find\n// implied global variables and other problems. The report is in HTML and\n// can be inserted into an HTML <body>. It should be given the result of the\n// JSLINT.data function.\n\n//     var myReport = JSLINT.report(data);\n\n// You can request an HTML error report.\n\n//     var myErrorReport = JSLINT.error_report(data);\n\n// You can obtain an object containing all of the properties found in the\n// file. JSLINT.property contains an object containing a key for each\n// property used in the program, the value being the number of times that\n// property name was used in the file.\n\n// You can request a properties report, which produces a list of the program's\n// properties in the form of a /*properties*/ declaration.\n\n//      var myPropertyReport = JSLINT.properties_report(JSLINT.property);\n\n// You can obtain the parse tree that JSLint constructed while parsing. The\n// latest tree is kept in JSLINT.tree. A nice stringification can be produced\n// with\n\n//     JSON.stringify(JSLINT.tree, [\n//         'string',  'arity', 'name',  'first',\n//         'second', 'third', 'block', 'else'\n//     ], 4));\n\n// You can request a context coloring table. It contains information that can be\n// applied to the file that was analyzed. Context coloring colors functions\n// based on their nesting level, and variables on the color of the functions\n// in which they are defined.\n\n//      var myColorization = JSLINT.color(data);\n\n// It returns an array containing objects of this form:\n\n//      {\n//          from: COLUMN,\n//          thru: COLUMN,\n//          line: ROW,\n//          level: 0 or higher\n//      }\n\n// JSLint provides three inline directives. They look like slashstar comments,\n// and allow for setting options, declaring global variables, and establishing a\n// set of allowed property names.\n\n// These directives respect function scope.\n\n// The jslint directive is a special comment that can set one or more options.\n// For example:\n\n/*jslint\n    evil: true, nomen: true, regexp: true, todo: true\n*/\n\n// The current option set is\n\n//     ass        true, if assignment expressions should be allowed\n//     bitwise    true, if bitwise operators should be allowed\n//     browser    true, if the standard browser globals should be predefined\n//     closure    true, if Google Closure idioms should be tolerated\n//     continue   true, if the continuation statement should be tolerated\n//     debug      true, if debugger statements should be allowed\n//     devel      true, if logging should be allowed (console, alert, etc.)\n//     eqeq       true, if == should be allowed\n//     evil       true, if eval should be allowed\n//     forin      true, if for in statements need not filter\n//     indent     the indentation factor\n//     maxerr     the maximum number of errors to allow\n//     maxlen     the maximum length of a source line\n//     newcap     true, if constructor names capitalization is ignored\n//     node       true, if Node.js globals should be predefined\n//     nomen      true, if names may have dangling _\n//     passfail   true, if the scan should stop on first error\n//     plusplus   true, if increment/decrement should be allowed\n//     properties true, if all property names must be declared with /*properties*/\n//     regexp     true, if the . should be allowed in regexp literals\n//     rhino      true, if the Rhino environment globals should be predefined\n//     unparam    true, if unused parameters should be tolerated\n//     sloppy     true, if the 'use strict'; pragma is optional\n//     stupid     true, if really stupid practices are tolerated\n//     sub        true, if all forms of subscript notation are tolerated\n//     todo       true, if TODO comments are tolerated\n//     vars       true, if multiple var statements per function should be allowed\n//     white      true, if sloppy whitespace is tolerated\n\n// The properties directive declares an exclusive list of property names.\n// Any properties named in the program that are not in the list will\n// produce a warning.\n\n// For example:\n\n/*properties\n    '\\b', '\\t', '\\n', '\\f', '\\r', '!', '!=', '!==', '\"', '%', '\\'', '(begin)',\n    '(error)', '*', '+', '-', '/', '<', '<=', '==', '===', '>', '>=', '\\\\', a,\n    a_label, a_scope, already_defined, and, apply, arguments, arity, ass,\n    assign, assignment_expression, assignment_function_expression, at, avoid_a,\n    b, bad_assignment, bad_constructor, bad_in_a, bad_invocation, bad_new,\n    bad_number, bad_operand, bad_wrap, bitwise, block, break, breakage, browser,\n    c, call, charAt, charCodeAt, character, closure, code, color, combine_var,\n    comments, conditional_assignment, confusing_a, confusing_regexp,\n    constructor_name_a, continue, control_a, couch, create, d, dangling_a, data,\n    dead, debug, deleted, devel, disrupt, duplicate_a, edge, edition, elif,\n    else, empty_block, empty_case, empty_class, entityify, eqeq, error_report,\n    errors, evidence, evil, exception, exec, expected_a_at_b_c, expected_a_b,\n    expected_a_b_from_c_d, expected_id_a, expected_identifier_a,\n    expected_identifier_a_reserved, expected_number_a, expected_operator_a,\n    expected_positive_a, expected_small_a, expected_space_a_b,\n    expected_string_a, f, first, flag, floor, forEach, for_if, forin, from,\n    fromCharCode, fud, function, function_block, function_eval, function_loop,\n    function_statement, function_strict, functions, global, hasOwnProperty, id,\n    identifier, identifier_function, immed, implied_evil, indent, indexOf,\n    infix_in, init, insecure_a, isAlpha, isArray, isDigit, isNaN, join, jslint,\n    json, keys, kind, label, labeled, lbp, leading_decimal_a, led, left, length,\n    level, line, loopage, master, match, maxerr, maxlen, message, missing_a,\n    missing_a_after_b, missing_property, missing_space_a_b, missing_use_strict,\n    mode, move_invocation, move_var, n, name, name_function, nested_comment,\n    newcap, node, nomen, not, not_a_constructor, not_a_defined, not_a_function,\n    not_a_label, not_a_scope, not_greater, nud, number, octal_a, open, outer,\n    parameter, parameter_a_get_b, parameter_arguments_a, parameter_set_a,\n    params, paren, passfail, plusplus, pop, postscript, predef, properties,\n    properties_report, property, prototype, push, quote, r, radix, raw,\n    read_only, reason, redefinition_a_b, regexp, relation, replace, report,\n    reserved, reserved_a, rhino, right, scanned_a_b, scope, search, second,\n    shift, slash_equal, slice, sloppy, sort, split, statement, statement_block,\n    stop, stopping, strange_loop, strict, string, stupid, sub, subscript,\n    substr, supplant, sync_a, t, tag_a_in_b, test, third, thru, toString, todo,\n    todo_comment, token, tokens, too_long, too_many, trailing_decimal_a, tree,\n    unclosed, unclosed_comment, unclosed_regexp, unescaped_a, unexpected_a,\n    unexpected_char_a, unexpected_comment, unexpected_label_a,\n    unexpected_property_a, unexpected_space_a_b, unexpected_typeof_a,\n    uninitialized_a, unnecessary_else, unnecessary_initialize, unnecessary_use,\n    unparam, unreachable_a_b, unsafe, unused_a, url, use_array, use_braces,\n    use_nested_if, use_object, use_or, use_param, use_spaces, used,\n    used_before_a, var, var_a_not, var_loop, vars, varstatement, warn, warning,\n    was, weird_assignment, weird_condition, weird_new, weird_program,\n    weird_relation, weird_ternary, white, wrap, wrap_immediate, wrap_regexp,\n    write_is_wrong, writeable\n*/\n\n// The global directive is used to declare global variables that can\n// be accessed by the program. If a declaration is true, then the variable\n// is writeable. Otherwise, it is read-only.\n\n// We build the application inside a function so that we produce only a single\n// global variable. That function will be invoked immediately, and its return\n// value is the JSLINT function itself. That function is also an object that\n// can contain data and other functions.\n\nvar JSLINT = (function () {\n    'use strict';\n\n    function array_to_object(array, value) {\n\n// Make an object from an array of keys and a common value.\n\n        var i, length = array.length, object = Object.create(null);\n        for (i = 0; i < length; i += 1) {\n            object[array[i]] = value;\n        }\n        return object;\n    }\n\n\n    var allowed_option = {\n            ass       : true,\n            bitwise   : true,\n            browser   : true,\n            closure   : true,\n            continue  : true,\n            couch     : true,\n            debug     : true,\n            devel     : true,\n            eqeq      : true,\n            evil      : true,\n            forin     : true,\n            indent    :   10,\n            maxerr    : 1000,\n            maxlen    :  256,\n            newcap    : true,\n            node      : true,\n            nomen     : true,\n            passfail  : true,\n            plusplus  : true,\n            properties: true,\n            regexp    : true,\n            rhino     : true,\n            unparam   : true,\n            sloppy    : true,\n            stupid    : true,\n            sub       : true,\n            todo      : true,\n            vars      : true,\n            white     : true\n        },\n        anonname,       // The guessed name for anonymous functions.\n\n// These are operators that should not be used with the ! operator.\n\n        bang = {\n            '<'  : true,\n            '<=' : true,\n            '==' : true,\n            '===': true,\n            '!==': true,\n            '!=' : true,\n            '>'  : true,\n            '>=' : true,\n            '+'  : true,\n            '-'  : true,\n            '*'  : true,\n            '/'  : true,\n            '%'  : true\n        },\n        begin,          // The root token\n        block_var,     // vars defined in the current block\n\n// browser contains a set of global names that are commonly provided by a\n// web browser environment.\n\n        browser = array_to_object([\n            'clearInterval', 'clearTimeout', 'document', 'event', 'FormData',\n            'frames', 'history', 'Image', 'localStorage', 'location', 'name',\n            'navigator', 'Option', 'parent', 'screen', 'sessionStorage',\n            'setInterval', 'setTimeout', 'Storage', 'window', 'XMLHttpRequest'\n        ], false),\n\n// bundle contains the text messages.\n\n        bundle = {\n            a_label: \"'{a}' is a statement label.\",\n            a_scope: \"'{a}' used out of scope.\",\n            already_defined: \"'{a}' is already defined.\",\n            and: \"The '&&' subexpression should be wrapped in parens.\",\n            assignment_expression: \"Unexpected assignment expression.\",\n            assignment_function_expression: \"Expected an assignment or \" +\n                \"function call and instead saw an expression.\",\n            avoid_a: \"Avoid '{a}'.\",\n            bad_assignment: \"Bad assignment.\",\n            bad_constructor: \"Bad constructor.\",\n            bad_in_a: \"Bad for in variable '{a}'.\",\n            bad_invocation: \"Bad invocation.\",\n            bad_new: \"Do not use 'new' for side effects.\",\n            bad_number: \"Bad number '{a}'.\",\n            bad_operand: \"Bad operand.\",\n            bad_wrap: \"Do not wrap function literals in parens unless they \" +\n                \"are to be immediately invoked.\",\n            combine_var: \"Combine this with the previous 'var' statement.\",\n            conditional_assignment: \"Expected a conditional expression and \" +\n                \"instead saw an assignment.\",\n            confusing_a: \"Confusing use of '{a}'.\",\n            confusing_regexp: \"Confusing regular expression.\",\n            constructor_name_a: \"A constructor name '{a}' should start with \" +\n                \"an uppercase letter.\",\n            control_a: \"Unexpected control character '{a}'.\",\n            dangling_a: \"Unexpected dangling '_' in '{a}'.\",\n            deleted: \"Only properties should be deleted.\",\n            duplicate_a: \"Duplicate '{a}'.\",\n            empty_block: \"Empty block.\",\n            empty_case: \"Empty case.\",\n            empty_class: \"Empty class.\",\n            evil: \"eval is evil.\",\n            expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n            expected_a_b_from_c_d: \"Expected '{a}' to match '{b}' from line \" +\n                \"{c} and instead saw '{d}'.\",\n            expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n            expected_id_a: \"Expected an id, and instead saw #{a}.\",\n            expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n            expected_identifier_a_reserved: \"Expected an identifier and \" +\n                \"instead saw '{a}' (a reserved word).\",\n            expected_number_a: \"Expected a number and instead saw '{a}'.\",\n            expected_operator_a: \"Expected an operator and instead saw '{a}'.\",\n            expected_positive_a: \"Expected a positive number and instead saw '{a}'\",\n            expected_small_a: \"Expected a small positive integer and instead saw '{a}'\",\n            expected_space_a_b: \"Expected exactly one space between '{a}' and '{b}'.\",\n            expected_string_a: \"Expected a string and instead saw '{a}'.\",\n            for_if: \"The body of a for in should be wrapped in an if \" +\n                \"statement to filter unwanted properties from the prototype.\",\n            function_block: \"Function statements should not be placed in blocks.\" +\n                \"Use a function expression or move the statement to the top of \" +\n                \"the outer function.\",\n            function_eval: \"The Function constructor is eval.\",\n            function_loop: \"Don't make functions within a loop.\",\n            function_statement: \"Function statements are not invocable. \" +\n                \"Wrap the whole function invocation in parens.\",\n            function_strict: \"Use the function form of 'use strict'.\",\n            identifier_function: \"Expected an identifier in an assignment \" +\n                \"and instead saw a function invocation.\",\n            implied_evil: \"Implied eval is evil. Pass a function instead of a string.\",\n            infix_in: \"Unexpected 'in'. Compare with undefined, or use the \" +\n                \"hasOwnProperty method instead.\",\n            insecure_a: \"Insecure '{a}'.\",\n            isNaN: \"Use the isNaN function to compare with NaN.\",\n            leading_decimal_a: \"A leading decimal point can be confused with a dot: '.{a}'.\",\n            missing_a: \"Missing '{a}'.\",\n            missing_a_after_b: \"Missing '{a}' after '{b}'.\",\n            missing_property: \"Missing property name.\",\n            missing_space_a_b: \"Missing space between '{a}' and '{b}'.\",\n            missing_use_strict: \"Missing 'use strict' statement.\",\n            move_invocation: \"Move the invocation into the parens that \" +\n                \"contain the function.\",\n            move_var: \"Move 'var' declarations to the top of the function.\",\n            name_function: \"Missing name in function statement.\",\n            nested_comment: \"Nested comment.\",\n            not: \"Nested not.\",\n            not_a_constructor: \"Do not use {a} as a constructor.\",\n            not_a_defined: \"'{a}' has not been fully defined yet.\",\n            not_a_function: \"'{a}' is not a function.\",\n            not_a_label: \"'{a}' is not a label.\",\n            not_a_scope: \"'{a}' is out of scope.\",\n            not_greater: \"'{a}' should not be greater than '{b}'.\",\n            octal_a: \"Don't use octal: '{a}'. Use '\\\\u....' instead.\",\n            parameter_arguments_a: \"Do not mutate parameter '{a}' when using 'arguments'.\",\n            parameter_a_get_b: \"Unexpected parameter '{a}' in get {b} function.\",\n            parameter_set_a: \"Expected parameter (value) in set {a} function.\",\n            radix: \"Missing radix parameter.\",\n            read_only: \"Read only.\",\n            redefinition_a_b: \"Redefinition of '{a}' from line {b}.\",\n            reserved_a: \"Reserved name '{a}'.\",\n            scanned_a_b: \"{a} ({b}% scanned).\",\n            slash_equal: \"A regular expression literal can be confused with '/='.\",\n            statement_block: \"Expected to see a statement and instead saw a block.\",\n            stopping: \"Stopping.\",\n            strange_loop: \"Strange loop.\",\n            strict: \"Strict violation.\",\n            subscript: \"['{a}'] is better written in dot notation.\",\n            sync_a: \"Unexpected sync method: '{a}'.\",\n            tag_a_in_b: \"A '<{a}>' must be within '<{b}>'.\",\n            todo_comment: \"Unexpected TODO comment.\",\n            too_long: \"Line too long.\",\n            too_many: \"Too many errors.\",\n            trailing_decimal_a: \"A trailing decimal point can be confused \" +\n                \"with a dot: '.{a}'.\",\n            unclosed: \"Unclosed string.\",\n            unclosed_comment: \"Unclosed comment.\",\n            unclosed_regexp: \"Unclosed regular expression.\",\n            unescaped_a: \"Unescaped '{a}'.\",\n            unexpected_a: \"Unexpected '{a}'.\",\n            unexpected_char_a: \"Unexpected character '{a}'.\",\n            unexpected_comment: \"Unexpected comment.\",\n            unexpected_label_a: \"Unexpected label '{a}'.\",\n            unexpected_property_a: \"Unexpected /*property*/ '{a}'.\",\n            unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n            unexpected_typeof_a: \"Unexpected 'typeof'. \" +\n                \"Use '===' to compare directly with {a}.\",\n            uninitialized_a: \"Uninitialized '{a}'.\",\n            unnecessary_else: \"Unnecessary 'else' after disruption.\",\n            unnecessary_initialize: \"It is not necessary to initialize '{a}' \" +\n                \"to 'undefined'.\",\n            unnecessary_use: \"Unnecessary 'use strict'.\",\n            unreachable_a_b: \"Unreachable '{a}' after '{b}'.\",\n            unsafe: \"Unsafe character.\",\n            unused_a: \"Unused '{a}'.\",\n            url: \"JavaScript URL.\",\n            use_array: \"Use the array literal notation [].\",\n            use_braces: \"Spaces are hard to count. Use {{a}}.\",\n            use_nested_if: \"Expected 'else { if' and instead saw 'else if'.\",\n            use_object: \"Use the object literal notation {} or Object.create(null).\",\n            use_or: \"Use the || operator.\",\n            use_param: \"Use a named parameter.\",\n            use_spaces: \"Use spaces, not tabs.\",\n            used_before_a: \"'{a}' was used before it was defined.\",\n            var_a_not: \"Variable {a} was not declared correctly.\",\n            var_loop: \"Don't declare variables in a loop.\",\n            weird_assignment: \"Weird assignment.\",\n            weird_condition: \"Weird condition.\",\n            weird_new: \"Weird construction. Delete 'new'.\",\n            weird_program: \"Weird program.\",\n            weird_relation: \"Weird relation.\",\n            weird_ternary: \"Weird ternary.\",\n            wrap_immediate: \"Wrap an immediate function invocation in \" +\n                \"parentheses to assist the reader in understanding that the \" +\n                \"expression is the result of a function, and not the \" +\n                \"function itself.\",\n            wrap_regexp: \"Wrap the /regexp/ literal in parens to \" +\n                \"disambiguate the slash operator.\",\n            write_is_wrong: \"document.write can be a form of eval.\"\n        },\n        closure = array_to_object([\n            'goog'\n        ], false),\n        comments,\n        comments_off,\n        couch = array_to_object([\n            'emit', 'getRow', 'isArray', 'log', 'provides', 'registerType',\n            'require', 'send', 'start', 'sum', 'toJSON'\n        ], false),\n\n        descapes = {\n            'b': '\\b',\n            't': '\\t',\n            'n': '\\n',\n            'f': '\\f',\n            'r': '\\r',\n            '\"': '\"',\n            '/': '/',\n            '\\\\': '\\\\',\n            '!': '!'\n        },\n\n        devel = array_to_object([\n            'alert', 'confirm', 'console', 'Debug', 'opera', 'prompt', 'WSH'\n        ], false),\n        directive,\n        escapes = {\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\\'': '\\\\\\'',\n            '\"' : '\\\\\"',\n            '/' : '\\\\/',\n            '\\\\': '\\\\\\\\'\n        },\n\n        funct,          // The current function\n\n        functions,      // All of the functions\n        global_funct,   // The global body\n        global_scope,   // The global scope\n        in_block,       // Where function statements are not allowed\n        indent,\n        itself,         // JSLINT itself\n        json_mode,\n        lex,            // the tokenizer\n        lines,\n        lookahead,\n        node = array_to_object([\n            'Buffer', 'clearImmediate', 'clearInterval', 'clearTimeout',\n            'console', 'exports', 'global', 'module', 'process', 'querystring',\n            'require', 'setImmediate', 'setInterval', 'setTimeout',\n            '__dirname', '__filename'\n        ], false),\n        node_js,\n        numbery = array_to_object(['indexOf', 'lastIndexOf', 'search'], true),\n        next_token,\n        option,\n        predefined,     // Global variables defined by option\n        prereg,\n        prev_token,\n        property,\n        protosymbol,\n        regexp_flag = array_to_object(['g', 'i', 'm'], true),\n        return_this = function return_this() {\n            return this;\n        },\n        rhino = array_to_object([\n            'defineClass', 'deserialize', 'gc', 'help', 'load', 'loadClass',\n            'print', 'quit', 'readFile', 'readUrl', 'runCommand', 'seal',\n            'serialize', 'spawn', 'sync', 'toint32', 'version'\n        ], false),\n\n        scope,      // An object containing an object for each variable in scope\n        semicolon_coda = array_to_object([';', '\"', '\\'', ')'], true),\n\n// standard contains the global names that are provided by the\n// ECMAScript standard.\n\n        standard = array_to_object([\n            'Array', 'Boolean', 'Date', 'decodeURI', 'decodeURIComponent',\n            'encodeURI', 'encodeURIComponent', 'Error', 'eval', 'EvalError',\n            'Function', 'isFinite', 'isNaN', 'JSON', 'Map', 'Math', 'Number',\n            'Object', 'parseInt', 'parseFloat', 'Promise', 'Proxy',\n            'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set',\n            'String', 'Symbol', 'SyntaxError', 'System', 'TypeError',\n            'URIError', 'WeakMap', 'WeakSet'\n        ], false),\n\n        strict_mode,\n        syntax = Object.create(null),\n        token,\n        tokens,\n        var_mode,\n        warnings,\n\n// Regular expressions. Some of these are stupidly long.\n\n// carriage return, carriage return linefeed, or linefeed\n        crlfx = /\\r\\n?|\\n/,\n// unsafe characters that are silently deleted by one or more browsers\n        cx = /[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n// identifier\n        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,\n// javascript url\n        jx = /^(?:javascript|jscript|ecmascript|vbscript)\\s*:/i,\n// star slash\n        lx = /\\*\\/|\\/\\*/,\n// characters in strings that need escapement\n        nx = /[\\u0000-\\u001f'\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n// sync\n        syx = /Sync$/,\n// comment todo\n        tox = /^\\W*to\\s*do(?:\\W|$)/i,\n// token\n        tx = /^\\s*([(){}\\[\\]\\?.,:;'\"~#@`]|={1,3}|\\/(\\*(jslint|properties|property|members?|globals?)?|=|\\/)?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|[\\^%]=?|&[&=]?|\\|[|=]?|>{1,3}=?|<(?:[\\/=!]|\\!(\\[|--)?|<=?)?|\\!(\\!|==?)?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+(?:[xX][0-9a-fA-F]+|\\.[0-9]*)?(?:[eE][+\\-]?[0-9]+)?)/;\n\n\n    if (typeof String.prototype.entityify !== 'function') {\n        String.prototype.entityify = function () {\n            return this\n                .replace(/&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;');\n        };\n    }\n\n    if (typeof String.prototype.isAlpha !== 'function') {\n        String.prototype.isAlpha = function () {\n            return (this >= 'a' && this <= 'z\\uffff') ||\n                (this >= 'A' && this <= 'Z\\uffff');\n        };\n    }\n\n    if (typeof String.prototype.isDigit !== 'function') {\n        String.prototype.isDigit = function () {\n            return (this >= '0' && this <= '9');\n        };\n    }\n\n    if (typeof String.prototype.supplant !== 'function') {\n        String.prototype.supplant = function (o) {\n            return this.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n                var replacement = o[b];\n                return typeof replacement === 'string' ||\n                    typeof replacement === 'number' ? replacement : a;\n            });\n        };\n    }\n\n\n    function sanitize(a) {\n\n//  Escapify a troublesome character.\n\n        return escapes[a] ||\n            '\\\\u' + ('0000' + a.charCodeAt().toString(16)).slice(-4);\n    }\n\n\n    function add_to_predefined(group) {\n        Object.keys(group).forEach(function (name) {\n            predefined[name] = group[name];\n        });\n    }\n\n\n    function assume() {\n        if (option.browser) {\n            add_to_predefined(browser);\n            option.browser = false;\n        }\n        if (option.closure) {\n            add_to_predefined(closure);\n        }\n        if (option.couch) {\n            add_to_predefined(couch);\n            option.couch = false;\n        }\n        if (option.devel) {\n            add_to_predefined(devel);\n            option.devel = false;\n        }\n        if (option.node) {\n            add_to_predefined(node);\n            option.node = false;\n            node_js = true;\n        }\n        if (option.rhino) {\n            add_to_predefined(rhino);\n            option.rhino = false;\n        }\n    }\n\n\n// Produce an error warning.\n\n    function artifact(tok) {\n        if (!tok) {\n            tok = next_token;\n        }\n        return tok.id === '(number)' ? tok.number : tok.string;\n    }\n\n    function quit(message, line, character) {\n        throw {\n            name: 'JSLintError',\n            line: line,\n            character: character,\n            message: bundle.scanned_a_b.supplant({\n                a: bundle[message] || message,\n                b: Math.floor((line / lines.length) * 100)\n            })\n        };\n    }\n\n    function warn(code, line, character, a, b, c, d) {\n        var warning = {         // ~~\n            id: '(error)',\n            raw: bundle[code] || code,\n            code: code,\n            evidence: lines[line - 1] || '',\n            line: line,\n            character: character,\n            a: a || artifact(this),\n            b: b,\n            c: c,\n            d: d\n        };\n        warning.reason = warning.raw.supplant(warning);\n        itself.errors.push(warning);\n        if (option.passfail) {\n            quit('stopping', line, character);\n        }\n        warnings += 1;\n        if (warnings >= option.maxerr) {\n            quit('too_many', line, character);\n        }\n        return warning;\n    }\n\n    function stop(code, line, character, a, b, c, d) {\n        var warning = warn(code, line, character, a, b, c, d);\n        quit('stopping', warning.line, warning.character);\n    }\n\n    function expected_at(at) {\n        if (!option.white && next_token.from !== at) {\n            next_token.warn('expected_a_at_b_c', '', at, next_token.from);\n        }\n    }\n\n// lexical analysis and token construction\n\n    lex = (function lex() {\n        var character, c, from, length, line, pos, source_row;\n\n// Private lex methods\n\n        function next_line() {\n            var at;\n            character = 1;\n            source_row = lines[line];\n            line += 1;\n            if (source_row === undefined) {\n                return false;\n            }\n            at = source_row.search(/\\t/);\n            if (at >= 0) {\n                if (option.white) {\n                    source_row = source_row.replace(/\\t/g, ' ');\n                } else {\n                    warn('use_spaces', line, at + 1);\n                }\n            }\n            at = source_row.search(cx);\n            if (at >= 0) {\n                warn('unsafe', line, at);\n            }\n            if (option.maxlen && option.maxlen < source_row.length) {\n                warn('too_long', line, source_row.length);\n            }\n            return true;\n        }\n\n// Produce a token object.  The token inherits from a syntax symbol.\n\n        function it(type, value) {\n            var id, the_token;\n            if (type === '(string)') {\n                if (jx.test(value)) {\n                    warn('url', line, from);\n                }\n            }\n            the_token = Object.create(syntax[(\n                type === '(punctuator)' || (type === '(identifier)' &&\n                        Object.prototype.hasOwnProperty.call(syntax, value))\n                    ? value\n                    : type\n            )] || syntax['(error)']);\n            if (type === '(identifier)') {\n                the_token.identifier = true;\n                if (value === '__iterator__' || value === '__proto__') {\n                    stop('reserved_a', line, from, value);\n                } else if (!option.nomen &&\n                        (value.charAt(0) === '_' ||\n                        value.charAt(value.length - 1) === '_')) {\n                    warn('dangling_a', line, from, value);\n                }\n            }\n            if (type === '(number)') {\n                the_token.number = +value;\n            } else if (value !== undefined) {\n                the_token.string = String(value);\n            }\n            the_token.line = line;\n            the_token.from = from;\n            the_token.thru = character;\n            if (comments.length) {\n                the_token.comments = comments;\n                comments = [];\n            }\n            id = the_token.id;\n            prereg = id && (\n                ('(,=:[!&|?{};~+-*%^<>'.indexOf(id.charAt(id.length - 1)) >= 0) ||\n                id === 'return' || id === 'case'\n            );\n            return the_token;\n        }\n\n        function match(x) {\n            var exec = x.exec(source_row), first;\n            if (exec) {\n                length = exec[0].length;\n                first = exec[1];\n                c = first.charAt(0);\n                source_row = source_row.slice(length);\n                from = character + length - first.length;\n                character += length;\n                return first;\n            }\n            for (;;) {\n                if (!source_row) {\n                    if (!option.white) {\n                        warn('unexpected_char_a', line, character - 1, '(space)');\n                    }\n                    return;\n                }\n                c = source_row.charAt(0);\n                if (c !== ' ') {\n                    break;\n                }\n                source_row = source_row.slice(1);\n                character += 1;\n            }\n            stop('unexpected_char_a', line, character, c);\n\n        }\n\n        function string(x) {\n            var ch, at = 0, r = '', result;\n\n            function hex(n) {\n                var i = parseInt(source_row.substr(at + 1, n), 16);\n                at += n;\n                if (i >= 32 && i <= 126 &&\n                        i !== 34 && i !== 92 && i !== 39) {\n                    warn('unexpected_a', line, character, '\\\\');\n                }\n                character += n;\n                ch = String.fromCharCode(i);\n            }\n\n            if (json_mode && x !== '\"') {\n                warn('expected_a_b', line, character, '\"', x);\n            }\n\n            for (;;) {\n                while (at >= source_row.length) {\n                    at = 0;\n                    if (!next_line()) {\n                        stop('unclosed', line - 1, from);\n                    }\n                }\n                ch = source_row.charAt(at);\n                if (ch === x) {\n                    character += 1;\n                    source_row = source_row.slice(at + 1);\n                    result = it('(string)', r);\n                    result.quote = x;\n                    return result;\n                }\n                if (ch < ' ') {\n                    if (ch === '\\n' || ch === '\\r') {\n                        break;\n                    }\n                    warn('control_a', line, character + at,\n                        source_row.slice(0, at));\n                } else if (ch === '\\\\') {\n                    at += 1;\n                    character += 1;\n                    ch = source_row.charAt(at);\n                    switch (ch) {\n                    case '':\n                        warn('unexpected_a', line, character, '\\\\');\n                        next_line();\n                        at = -1;\n                        break;\n                    case '\\'':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\\\'');\n                        }\n                        break;\n                    case 'u':\n                        hex(4);\n                        break;\n                    case 'v':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\v');\n                        }\n                        ch = '\\v';\n                        break;\n                    case 'x':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\x');\n                        }\n                        hex(2);\n                        break;\n                    default:\n                        if (typeof descapes[ch] !== 'string') {\n                            warn(ch >= '0' && ch <= '7' ? 'octal_a' : 'unexpected_a',\n                                line, character, '\\\\' + ch);\n                        } else {\n                            ch = descapes[ch];\n                        }\n                    }\n                }\n                r += ch;\n                character += 1;\n                at += 1;\n            }\n        }\n\n        function number(snippet) {\n            var digit;\n            if (source_row.charAt(0).isAlpha()) {\n                warn('expected_space_a_b',\n                    line, character, c, source_row.charAt(0));\n            }\n            if (c === '0') {\n                digit = snippet.charAt(1);\n                if (digit.isDigit()) {\n                    if (token.id !== '.') {\n                        warn('unexpected_a', line, character, snippet);\n                    }\n                } else if (json_mode && (digit === 'x' || digit === 'X')) {\n                    warn('unexpected_a', line, character, '0x');\n                }\n            }\n            if (snippet.slice(snippet.length - 1) === '.') {\n                warn('trailing_decimal_a', line, character, snippet);\n            }\n            digit = +snippet;\n            if (!isFinite(digit)) {\n                warn('bad_number', line, character, snippet);\n            }\n            snippet = digit;\n            return it('(number)', snippet);\n        }\n\n        function comment(snippet, type) {\n            if (comments_off) {\n                warn('unexpected_comment', line, character);\n            } else if (!option.todo && tox.test(snippet)) {\n                warn('todo_comment', line, character);\n            }\n            comments.push({\n                id: type,\n                from: from,\n                thru: character,\n                line: line,\n                string: snippet\n            });\n        }\n\n        function regexp() {\n            var at = 0,\n                b,\n                bit,\n                depth = 0,\n                flag = '',\n                high,\n                letter,\n                low,\n                potential,\n                quote,\n                result;\n            for (;;) {\n                b = true;\n                c = source_row.charAt(at);\n                at += 1;\n                switch (c) {\n                case '':\n                    stop('unclosed_regexp', line, from);\n                    return;\n                case '/':\n                    if (depth > 0) {\n                        warn('unescaped_a', line, from + at, '/');\n                    }\n                    c = source_row.slice(0, at - 1);\n                    potential = Object.create(regexp_flag);\n                    for (;;) {\n                        letter = source_row.charAt(at);\n                        if (potential[letter] !== true) {\n                            break;\n                        }\n                        potential[letter] = false;\n                        at += 1;\n                        flag += letter;\n                    }\n                    if (source_row.charAt(at).isAlpha()) {\n                        stop('unexpected_a', line, from, source_row.charAt(at));\n                    }\n                    character += at;\n                    source_row = source_row.slice(at);\n                    quote = source_row.charAt(0);\n                    if (quote === '/' || quote === '*') {\n                        stop('confusing_regexp', line, from);\n                    }\n                    result = it('(regexp)', c);\n                    result.flag = flag;\n                    return result;\n                case '\\\\':\n                    c = source_row.charAt(at);\n                    if (c < ' ') {\n                        warn('control_a', line, from + at, String(c));\n                    } else if (c === '<') {\n                        warn('unexpected_a', line, from + at, '\\\\');\n                    }\n                    at += 1;\n                    break;\n                case '(':\n                    depth += 1;\n                    b = false;\n                    if (source_row.charAt(at) === '?') {\n                        at += 1;\n                        switch (source_row.charAt(at)) {\n                        case ':':\n                        case '=':\n                        case '!':\n                            at += 1;\n                            break;\n                        default:\n                            warn('expected_a_b', line, from + at,\n                                ':', source_row.charAt(at));\n                        }\n                    }\n                    break;\n                case '|':\n                    b = false;\n                    break;\n                case ')':\n                    if (depth === 0) {\n                        warn('unescaped_a', line, from + at, ')');\n                    } else {\n                        depth -= 1;\n                    }\n                    break;\n                case ' ':\n                    pos = 1;\n                    while (source_row.charAt(at) === ' ') {\n                        at += 1;\n                        pos += 1;\n                    }\n                    if (pos > 1) {\n                        warn('use_braces', line, from + at, pos);\n                    }\n                    break;\n                case '[':\n                    c = source_row.charAt(at);\n                    if (c === '^') {\n                        at += 1;\n                        if (!option.regexp) {\n                            warn('insecure_a', line, from + at, c);\n                        } else if (source_row.charAt(at) === ']') {\n                            stop('unescaped_a', line, from + at, '^');\n                        }\n                    }\n                    bit = false;\n                    if (c === ']') {\n                        warn('empty_class', line, from + at - 1);\n                        bit = true;\n                    }\nklass:              do {\n                        c = source_row.charAt(at);\n                        at += 1;\n                        switch (c) {\n                        case '[':\n                        case '^':\n                            warn('unescaped_a', line, from + at, c);\n                            bit = true;\n                            break;\n                        case '-':\n                            if (bit) {\n                                bit = false;\n                            } else {\n                                warn('unescaped_a', line, from + at, '-');\n                                bit = true;\n                            }\n                            break;\n                        case ']':\n                            if (!bit) {\n                                warn('unescaped_a', line, from + at - 1, '-');\n                            }\n                            break klass;\n                        case '\\\\':\n                            c = source_row.charAt(at);\n                            if (c < ' ') {\n                                warn('control_a', line, from + at, String(c));\n                            } else if (c === '<') {\n                                warn('unexpected_a', line, from + at, '\\\\');\n                            }\n                            at += 1;\n                            bit = true;\n                            break;\n                        case '/':\n                            warn('unescaped_a', line, from + at - 1, '/');\n                            bit = true;\n                            break;\n                        default:\n                            bit = true;\n                        }\n                    } while (c);\n                    break;\n                case '.':\n                    if (!option.regexp) {\n                        warn('insecure_a', line, from + at, c);\n                    }\n                    break;\n                case ']':\n                case '?':\n                case '{':\n                case '}':\n                case '+':\n                case '*':\n                    warn('unescaped_a', line, from + at, c);\n                    break;\n                }\n                if (b) {\n                    switch (source_row.charAt(at)) {\n                    case '?':\n                    case '+':\n                    case '*':\n                        at += 1;\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        break;\n                    case '{':\n                        at += 1;\n                        c = source_row.charAt(at);\n                        if (c < '0' || c > '9') {\n                            warn('expected_number_a', line,\n                                from + at, c);\n                        }\n                        at += 1;\n                        low = +c;\n                        for (;;) {\n                            c = source_row.charAt(at);\n                            if (c < '0' || c > '9') {\n                                break;\n                            }\n                            at += 1;\n                            low = +c + (low * 10);\n                        }\n                        high = low;\n                        if (c === ',') {\n                            at += 1;\n                            high = Infinity;\n                            c = source_row.charAt(at);\n                            if (c >= '0' && c <= '9') {\n                                at += 1;\n                                high = +c;\n                                for (;;) {\n                                    c = source_row.charAt(at);\n                                    if (c < '0' || c > '9') {\n                                        break;\n                                    }\n                                    at += 1;\n                                    high = +c + (high * 10);\n                                }\n                            }\n                        }\n                        if (source_row.charAt(at) !== '}') {\n                            warn('expected_a_b', line, from + at,\n                                '}', c);\n                        } else {\n                            at += 1;\n                        }\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        if (low > high) {\n                            warn('not_greater', line, from + at,\n                                low, high);\n                        }\n                        break;\n                    }\n                }\n            }\n            c = source_row.slice(0, at - 1);\n            character += at;\n            source_row = source_row.slice(at);\n            return it('(regexp)', c);\n        }\n\n// Public lex methods\n\n        return {\n            init: function (source) {\n                if (typeof source === 'string') {\n                    lines = source.split(crlfx);\n                } else {\n                    lines = source;\n                }\n                line = 0;\n                next_line();\n                from = 1;\n            },\n\n// token -- this is called by advance to get the next token.\n\n            token: function () {\n                var first, i, snippet;\n\n                for (;;) {\n                    while (!source_row) {\n                        if (!next_line()) {\n                            return it('(end)');\n                        }\n                    }\n                    snippet = match(tx);\n                    if (snippet) {\n\n//      identifier\n\n                        first = snippet.charAt(0);\n                        if (first.isAlpha() || first === '_' || first === '$') {\n                            return it('(identifier)', snippet);\n                        }\n\n//      number\n\n                        if (first.isDigit()) {\n                            return number(snippet);\n                        }\n                        switch (snippet) {\n\n//      string\n\n                        case '\"':\n                        case \"'\":\n                            return string(snippet);\n\n//      // comment\n\n                        case '//':\n                            comment(source_row, '//');\n                            source_row = '';\n                            break;\n\n//      /* comment\n\n                        case '/*':\n                            for (;;) {\n                                i = source_row.search(lx);\n                                if (i >= 0) {\n                                    break;\n                                }\n                                character = source_row.length;\n                                comment(source_row);\n                                from = 0;\n                                if (!next_line()) {\n                                    stop('unclosed_comment', line, character);\n                                }\n                            }\n                            comment(source_row.slice(0, i), '/*');\n                            character += i + 2;\n                            if (source_row.charAt(i) === '/') {\n                                stop('nested_comment', line, character);\n                            }\n                            source_row = source_row.slice(i + 2);\n                            break;\n\n                        case '':\n                            break;\n//      /\n                        case '/':\n                            if (token.id === '/=') {\n                                stop('slash_equal', line, from);\n                            }\n                            return prereg\n                                ? regexp()\n                                : it('(punctuator)', snippet);\n\n//      punctuator\n                        default:\n                            return it('(punctuator)', snippet);\n                        }\n                    }\n                }\n            }\n        };\n    }());\n\n    function define(kind, token) {\n\n// Define a name.\n\n        var name = token.string,\n            master = scope[name];       // The current definition of the name\n\n// vars are created with a deadzone, so that the expression that initializes\n// the var cannot access the var. Functions are not writeable.\n\n        token.dead = false;\n        token.init = false;\n        token.kind = kind;\n        token.master = master;\n        token.used = 0;\n        token.writeable = true;\n\n// Global variables are a little weird. They can be defined multiple times.\n// Some predefined global vars are (or should) not be writeable.\n\n        if (kind === 'var' && funct === global_funct) {\n            if (!master) {\n                if (predefined[name] === false) {\n                    token.writeable = false;\n                }\n                global_scope[name] = token;\n            }\n        } else {\n\n// It is an error if the name has already been defined in this scope, except\n// when reusing an exception variable name.\n\n            if (master) {\n                if (master.function === funct) {\n                    if (master.kind !== 'exception' || kind !== 'exception' ||\n                            !master.dead) {\n                        token.warn('already_defined', name);\n                    }\n                } else if (master.function !== global_funct) {\n                    if (kind === 'var') {\n                        token.warn('redefinition_a_b', name, master.line);\n                    }\n                }\n            }\n            scope[name] = token;\n            if (kind === 'var') {\n                block_var.push(name);\n            }\n        }\n    }\n\n    function peek(distance) {\n\n// Peek ahead to a future token. The distance is how far ahead to look. The\n// default is the next token.\n\n        var found, slot = 0;\n\n        distance = distance || 0;\n        while (slot <= distance) {\n            found = lookahead[slot];\n            if (!found) {\n                found = lookahead[slot] = lex.token();\n            }\n            slot += 1;\n        }\n        return found;\n    }\n\n\n    function advance(id, match) {\n\n// Produce the next token, also looking for programming errors.\n\n        if (indent) {\n\n// If indentation checking was requested, then inspect all of the line breakings.\n// The var statement is tricky because the names might be aligned or not. We\n// look at the first line break after the var to determine the programmer's\n// intention.\n\n            if (var_mode && next_token.line !== token.line) {\n                if ((var_mode !== indent || !next_token.edge) &&\n                        next_token.from === indent.at -\n                        (next_token.edge ? option.indent : 0)) {\n                    var dent = indent;\n                    for (;;) {\n                        dent.at -= option.indent;\n                        if (dent === var_mode) {\n                            break;\n                        }\n                        dent = dent.was;\n                    }\n                    dent.open = false;\n                }\n                var_mode = null;\n            }\n            if (next_token.id === '?' && indent.mode === ':' &&\n                    token.line !== next_token.line) {\n                indent.at -= option.indent;\n            }\n            if (indent.open) {\n\n// If the token is an edge.\n\n                if (next_token.edge) {\n                    if (next_token.edge === 'label') {\n                        expected_at(1);\n                    } else if (next_token.edge === 'case' || indent.mode === 'statement') {\n                        expected_at(indent.at - option.indent);\n                    } else if (indent.mode !== 'array' || next_token.line !== token.line) {\n                        expected_at(indent.at);\n                    }\n\n// If the token is not an edge, but is the first token on the line.\n\n                } else if (next_token.line !== token.line) {\n                    if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                    indent.wrap = true;\n                }\n            } else if (next_token.line !== token.line) {\n                if (next_token.edge) {\n                    expected_at(indent.at);\n                } else {\n                    indent.wrap = true;\n                    if (indent.mode === 'statement' || indent.mode === 'var') {\n                        expected_at(indent.at + option.indent);\n                    } else if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                }\n            }\n        }\n\n        switch (token.id) {\n        case '(number)':\n            if (next_token.id === '.') {\n                next_token.warn('trailing_decimal_a');\n            }\n            break;\n        case '-':\n            if (next_token.id === '-' || next_token.id === '--') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        case '+':\n            if (next_token.id === '+' || next_token.id === '++') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        }\n        if (token.id === '(string)' || token.identifier) {\n            anonname = token.string;\n        }\n\n        if (id && next_token.id !== id) {\n            if (match) {\n                next_token.warn('expected_a_b_from_c_d', id,\n                    match.id, match.line, artifact());\n            } else if (!next_token.identifier || next_token.string !== id) {\n                next_token.warn('expected_a_b', id, artifact());\n            }\n        }\n        prev_token = token;\n        token = next_token;\n        next_token = lookahead.shift() || lex.token();\n        next_token.function = funct;\n        tokens.push(next_token);\n    }\n\n\n    function do_globals() {\n        var name, writeable;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            writeable = false;\n            if (next_token.id === ':') {\n                advance(':');\n                switch (next_token.id) {\n                case 'true':\n                    writeable = predefined[name] !== false;\n                    advance('true');\n                    break;\n                case 'false':\n                    advance('false');\n                    break;\n                default:\n                    next_token.stop('unexpected_a');\n                }\n            }\n            predefined[name] = writeable;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    function do_jslint() {\n        var name, value;\n        while (next_token.id === '(string)' || next_token.identifier) {\n            name = next_token.string;\n            if (!allowed_option[name]) {\n                next_token.stop('unexpected_a');\n            }\n            advance();\n            if (next_token.id !== ':') {\n                next_token.stop('expected_a_b', ':', artifact());\n            }\n            advance(':');\n            if (typeof allowed_option[name] === 'number') {\n                value = next_token.number;\n                if (value > allowed_option[name] || value <= 0 ||\n                        Math.floor(value) !== value) {\n                    next_token.stop('expected_small_a');\n                }\n                option[name] = value;\n            } else {\n                if (next_token.id === 'true') {\n                    option[name] = true;\n                } else if (next_token.id === 'false') {\n                    option[name] = false;\n                } else {\n                    next_token.stop('unexpected_a');\n                }\n            }\n            advance();\n            if (next_token.id === ',') {\n                advance(',');\n            }\n        }\n        assume();\n    }\n\n\n    function do_properties() {\n        var name;\n        option.properties = true;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            if (next_token.id === ':') {\n                for (;;) {\n                    advance();\n                    if (next_token.id !== '(string)' && !next_token.identifier) {\n                        break;\n                    }\n                }\n            }\n            property[name] = 0;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    directive = function directive() {\n        var command = this.id,\n            old_comments_off = comments_off,\n            old_indent = indent;\n        comments_off = true;\n        indent = null;\n        if (next_token.line === token.line && next_token.from === token.thru) {\n            next_token.warn('missing_space_a_b', artifact(token), artifact());\n        }\n        if (lookahead.length > 0) {\n            this.warn('unexpected_a');\n        }\n        switch (command) {\n        case '/*properties':\n        case '/*property':\n        case '/*members':\n        case '/*member':\n            do_properties();\n            break;\n        case '/*jslint':\n            do_jslint();\n            break;\n        case '/*globals':\n        case '/*global':\n            do_globals();\n            break;\n        default:\n            this.stop('unexpected_a');\n        }\n        comments_off = old_comments_off;\n        advance('*/');\n        indent = old_indent;\n    };\n\n\n// Indentation intention\n\n    function edge(mode) {\n        next_token.edge = indent ? indent.open && (mode || 'edge') : '';\n    }\n\n\n    function step_in(mode) {\n        var open;\n        if (typeof mode === 'number') {\n            indent = {\n                at: +mode,\n                open: true,\n                was: indent\n            };\n        } else if (!indent) {\n            indent = {\n                at: 1,\n                mode: 'statement',\n                open: true\n            };\n        } else if (mode === 'statement') {\n            indent = {\n                at: indent.at,\n                open: true,\n                was: indent\n            };\n        } else {\n            open = mode === 'var' || next_token.line !== token.line;\n            indent = {\n                at: (open || mode === 'control'\n                    ? indent.at + option.indent\n                    : indent.at) + (indent.wrap ? option.indent : 0),\n                mode: mode,\n                open: open,\n                was: indent\n            };\n            if (mode === 'var' && open) {\n                var_mode = indent;\n            }\n        }\n    }\n\n    function step_out(id, symbol) {\n        if (id) {\n            if (indent && indent.open) {\n                indent.at -= option.indent;\n                edge();\n            }\n            advance(id, symbol);\n        }\n        if (indent) {\n            indent = indent.was;\n        }\n    }\n\n// Functions for conformance of whitespace.\n\n    function one_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && !option.white &&\n                (token.line !== right.line ||\n                token.thru + 1 !== right.from)) {\n            right.warn('expected_space_a_b', artifact(token), artifact(right));\n        }\n    }\n\n    function one_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru + 1 !== right.from))) {\n            right.warn('expected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if ((!option.white) &&\n                left.thru !== right.from && left.line === right.line) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru !== right.from))) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function spaces(left, right) {\n        if (!option.white) {\n            left = left || token;\n            right = right || next_token;\n            if (left.thru === right.from && left.line === right.line) {\n                right.warn('missing_space_a_b', artifact(left), artifact(right));\n            }\n        }\n    }\n\n    function comma() {\n        if (next_token.id !== ',') {\n            warn('expected_a_b', token.line, token.thru, ',', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(',');\n            spaces();\n        }\n    }\n\n\n    function semicolon() {\n        if (next_token.id !== ';') {\n            warn('expected_a_b', token.line, token.thru, ';', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(';');\n            if (semicolon_coda[next_token.id] !== true) {\n                spaces();\n            }\n        }\n    }\n\n    function use_strict() {\n        if (next_token.string === 'use strict') {\n            if (strict_mode) {\n                next_token.warn('unnecessary_use');\n            }\n            edge();\n            advance();\n            semicolon();\n            strict_mode = true;\n            return true;\n        }\n        return false;\n    }\n\n\n    function are_similar(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (Array.isArray(a)) {\n            if (Array.isArray(b) && a.length === b.length) {\n                var i;\n                for (i = 0; i < a.length; i += 1) {\n                    if (!are_similar(a[i], b[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n        if (Array.isArray(b)) {\n            return false;\n        }\n        if (a.id === '(number)' && b.id === '(number)') {\n            return a.number === b.number;\n        }\n        if (a.arity === b.arity && a.string === b.string) {\n            switch (a.arity) {\n            case undefined:\n                return a.string === b.string;\n            case 'prefix':\n            case 'suffix':\n                return a.id === b.id && are_similar(a.first, b.first) &&\n                    a.id !== '{' && a.id !== '[';\n            case 'infix':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second);\n            case 'ternary':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second) &&\n                    are_similar(a.third, b.third);\n            case 'function':\n            case 'regexp':\n                return false;\n            default:\n                return true;\n            }\n        }\n        if (a.id === '.' && b.id === '[' && b.arity === 'infix') {\n            return a.second.string === b.second.string && b.second.id === '(string)';\n        }\n        if (a.id === '[' && a.arity === 'infix' && b.id === '.') {\n            return a.second.string === b.second.string && a.second.id === '(string)';\n        }\n        return false;\n    }\n\n\n// This is the heart of JSLINT, the Pratt parser. In addition to parsing, it\n// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is\n// like .nud except that it is only used on the first token of a statement.\n// Having .fud makes it much easier to define statement-oriented languages like\n// JavaScript. I retained Pratt's nomenclature.\n\n// .nud     Null denotation\n// .fud     First null denotation\n// .led     Left denotation\n//  lbp     Left binding power\n//  rbp     Right binding power\n\n// They are elements of the parsing method called Top Down Operator Precedence.\n\n    function expression(rbp, initial) {\n\n// rbp is the right binding power.\n// initial indicates that this is the first expression of a statement.\n\n        var left;\n        if (next_token.id === '(end)') {\n            token.stop('unexpected_a', next_token.id);\n        }\n        advance();\n        if (initial) {\n            anonname = 'anonymous';\n        }\n        if (initial === true && token.fud) {\n            left = token.fud();\n        } else {\n            if (token.nud) {\n                left = token.nud();\n            } else {\n                if (next_token.id === '(number)' && token.id === '.') {\n                    token.warn('leading_decimal_a', artifact());\n                    advance();\n                    return token;\n                }\n                token.stop('expected_identifier_a', artifact(token));\n            }\n            while (rbp < next_token.lbp) {\n                advance();\n                left = token.led(left);\n            }\n        }\n        if (left && left.assign && !initial) {\n            if (!option.ass) {\n                left.warn('assignment_expression');\n            }\n            if (left.id !== '=' && left.first.master) {\n                left.first.master.used = true;\n            }\n        }\n        return left;\n    }\n\n    protosymbol = {\n        nud: function () {\n            this.stop('unexpected_a');\n        },\n        led: function () {\n            this.stop('expected_operator_a');\n        },\n        warn: function (code, a, b, c, d) {\n            if (!this.warning) {\n                this.warning = warn(code, this.line || 0, this.from || 0,\n                    a || artifact(this), b, c, d);\n            }\n        },\n        stop: function (code, a, b, c, d) {\n            this.warning = undefined;\n            this.warn(code, a, b, c, d);\n            return quit('stopping', this.line, this.character);\n        },\n        lbp: 0\n    };\n\n// Functional constructors for making the symbols that will be inherited by\n// tokens.\n\n    function symbol(s, bp) {\n        var x = syntax[s];\n        if (!x) {\n            x = Object.create(protosymbol);\n            x.id = x.string = s;\n            x.lbp = bp || 0;\n            syntax[s] = x;\n        }\n        return x;\n    }\n\n    function postscript(x) {\n        x.postscript = true;\n        return x;\n    }\n\n    function ultimate(s) {\n        var x = symbol(s, 0);\n        x.from = 1;\n        x.thru = 1;\n        x.line = 0;\n        x.edge = 'edge';\n        x.string = s;\n        return postscript(x);\n    }\n\n    function reserve_name(x) {\n        var c = x.id.charAt(0);\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            x.identifier = x.reserved = true;\n        }\n        return x;\n    }\n\n    function stmt(s, f) {\n        var x = symbol(s);\n        x.fud = f;\n        return reserve_name(x);\n    }\n\n    function disrupt_stmt(s, f) {\n        var x = stmt(s, f);\n        x.disrupt = true;\n    }\n\n    function labeled_stmt(s, f) {\n        var x = stmt(s, function labeled() {\n            var the_statement;\n            if (funct.breakage) {\n                funct.breakage.push(this);\n            } else {\n                funct.breakage = [this];\n            }\n            the_statement = f.apply(this);\n            if (funct.breakage.length > 1) {\n                funct.breakage.pop();\n            } else {\n                delete funct.breakage;\n            }\n            return the_statement;\n        });\n        x.labeled = true;\n    }\n\n    function prefix(s, f) {\n        var x = symbol(s, 150);\n        reserve_name(x);\n        x.nud = function () {\n            var that = this;\n            that.arity = 'prefix';\n            if (typeof f === 'function') {\n                that = f(that);\n                if (that.arity !== 'prefix') {\n                    return that;\n                }\n            } else {\n                if (s === 'typeof') {\n                    one_space();\n                } else {\n                    no_space_only();\n                }\n                that.first = expression(150);\n            }\n            switch (that.id) {\n            case '++':\n            case '--':\n                if (!option.plusplus) {\n                    that.warn('unexpected_a');\n                } else if ((!that.first.identifier || that.first.reserved) &&\n                        that.first.id !== '.' && that.first.id !== '[') {\n                    that.warn('bad_operand');\n                }\n                break;\n            default:\n                if (that.first.arity === 'prefix' ||\n                        that.first.arity === 'function') {\n                    that.warn('unexpected_a');\n                }\n            }\n            return that;\n        };\n        return x;\n    }\n\n\n    function type(s, t, nud) {\n        var x = symbol(s);\n        x.arity = t;\n        if (nud) {\n            x.nud = nud;\n        }\n        return x;\n    }\n\n\n    function reserve(s, f) {\n        var x = symbol(s);\n        x.identifier = x.reserved = true;\n        if (typeof f === 'function') {\n            x.nud = f;\n        }\n        return x;\n    }\n\n\n    function constant(name) {\n        var x = reserve(name);\n        x.string = name;\n        x.nud = return_this;\n        return x;\n    }\n\n\n    function reservevar(s, v) {\n        return reserve(s, function () {\n            if (typeof v === 'function') {\n                v(this);\n            }\n            return this;\n        });\n    }\n\n\n    function infix(s, p, f, w) {\n        var x = symbol(s, p);\n        reserve_name(x);\n        x.led = function (left) {\n            this.arity = 'infix';\n            if (!w) {\n                spaces(prev_token, token);\n                spaces();\n            }\n            if (!option.bitwise && this.bitwise) {\n                this.warn('unexpected_a');\n            }\n            if (typeof f === 'function') {\n                return f(left, this);\n            }\n            this.first = left;\n            this.second = expression(p);\n            return this;\n        };\n        return x;\n    }\n\n    function expected_relation(node, message) {\n        if (node.assign) {\n            node.warn(message || 'conditional_assignment');\n        }\n        return node;\n    }\n\n    function expected_condition(node, message) {\n        switch (node.id) {\n        case '[':\n        case '-':\n            if (node.arity !== 'infix') {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        case 'false':\n        case 'function':\n        case 'Infinity':\n        case 'NaN':\n        case 'null':\n        case 'true':\n        case 'undefined':\n        case 'void':\n        case '(number)':\n        case '(regexp)':\n        case '(string)':\n        case '{':\n        case '?':\n        case '~':\n            node.warn(message || 'weird_condition');\n            break;\n        case '(':\n            if (node.first.id === 'new' ||\n                    (node.first.string === 'Boolean') ||\n                    (node.first.id === '.' &&\n                        numbery[node.first.second.string] === true)) {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        }\n        return node;\n    }\n\n    function check_relation(node) {\n        switch (node.arity) {\n        case 'prefix':\n            switch (node.id) {\n            case '{':\n            case '[':\n                node.warn('unexpected_a');\n                break;\n            case '!':\n                node.warn('confusing_a');\n                break;\n            }\n            break;\n        case 'function':\n        case 'regexp':\n            node.warn('unexpected_a');\n            break;\n        default:\n            if (node.id  === 'NaN') {\n                node.warn('isNaN');\n            } else if (node.relation) {\n                node.warn('weird_relation');\n            }\n        }\n        return node;\n    }\n\n\n    function relation(s, eqeq) {\n        var x = infix(s, 100, function (left, that) {\n            check_relation(left);\n            if (eqeq && !option.eqeq) {\n                that.warn('expected_a_b', eqeq, that.id);\n            }\n            var right = expression(100);\n            if (are_similar(left, right) ||\n                    ((left.id === '(string)' || left.id === '(number)') &&\n                    (right.id === '(string)' || right.id === '(number)'))) {\n                that.warn('weird_relation');\n            } else if (left.id === 'typeof') {\n                if (right.id !== '(string)') {\n                    right.warn(\"expected_string_a\", artifact(right));\n                } else if (right.string === 'undefined' ||\n                        right.string === 'null') {\n                    left.warn(\"unexpected_typeof_a\", right.string);\n                }\n            } else if (right.id === 'typeof') {\n                if (left.id !== '(string)') {\n                    left.warn(\"expected_string_a\", artifact(left));\n                } else if (left.string === 'undefined' ||\n                        left.string === 'null') {\n                    right.warn(\"unexpected_typeof_a\", left.string);\n                }\n            }\n            that.first = left;\n            that.second = check_relation(right);\n            return that;\n        });\n        x.relation = true;\n        return x;\n    }\n\n    function lvalue(that, s) {\n        var master;\n        if (that.identifier) {\n            master = scope[that.string];\n            if (master) {\n                if (scope[that.string].writeable !== true) {\n                    that.warn('read_only');\n                }\n                master.used -= 1;\n                if (s === '=') {\n                    master.init = true;\n                }\n            }\n        } else if (that.id === '.' || that.id === '[') {\n            if (!that.first || that.first.string === 'arguments') {\n                that.warn('bad_assignment');\n            }\n        } else {\n            that.warn('bad_assignment');\n        }\n    }\n\n\n    function assignop(s, op) {\n        var x = infix(s, 20, function (left, that) {\n            var next;\n            that.first = left;\n            lvalue(left, s);\n            that.second = expression(20);\n            if (that.id === '=' && are_similar(that.first, that.second)) {\n                that.warn('weird_assignment');\n            }\n            next = that;\n            while (next_token.id === '=') {\n                lvalue(next.second, '=');\n                next_token.first = next.second;\n                next.second = next_token;\n                next = next_token;\n                advance('=');\n                next.second = expression(20);\n            }\n            return that;\n        });\n        x.assign = true;\n        if (op) {\n            if (syntax[op].bitwise) {\n                x.bitwise = true;\n            }\n        }\n        return x;\n    }\n\n\n    function bitwise(s, p) {\n        var x = infix(s, p, 'number');\n        x.bitwise = true;\n        return x;\n    }\n\n\n    function suffix(s) {\n        var x = symbol(s, 150);\n        x.led = function (left) {\n            no_space_only(prev_token, token);\n            if (!option.plusplus) {\n                this.warn('unexpected_a');\n            } else if ((!left.identifier || left.reserved) &&\n                    left.id !== '.' && left.id !== '[') {\n                this.warn('bad_operand');\n            }\n            this.first = left;\n            this.arity = 'suffix';\n            return this;\n        };\n        return x;\n    }\n\n\n    function optional_identifier(variable) {\n        if (next_token.identifier) {\n            advance();\n            if (token.reserved && variable) {\n                token.warn('expected_identifier_a_reserved');\n            }\n            return token.string;\n        }\n    }\n\n\n    function identifier(variable) {\n        var i = optional_identifier(variable);\n        if (!i) {\n            next_token.stop(token.id === 'function' && next_token.id === '('\n                ? 'name_function'\n                : 'expected_identifier_a');\n        }\n        return i;\n    }\n\n\n    function statement() {\n\n        var label, preamble, the_statement;\n\n// We don't like the empty statement.\n\n        if (next_token.id === ';') {\n            next_token.warn('unexpected_a');\n            semicolon();\n            return;\n        }\n\n// Is this a labeled statement?\n\n        if (next_token.identifier && !next_token.reserved && peek().id === ':') {\n            edge('label');\n            label = next_token;\n            advance();\n            advance(':');\n            define('label', label);\n            if (next_token.labeled !== true || funct === global_funct) {\n                label.stop('unexpected_label_a');\n            } else if (jx.test(label.string + ':')) {\n                label.warn('url');\n            }\n            next_token.label = label;\n            label.init = true;\n            label.statement = next_token;\n        }\n\n// Parse the statement.\n\n        preamble = next_token;\n        if (token.id !== 'else') {\n            edge();\n        }\n        step_in('statement');\n        the_statement = expression(0, true);\n        if (the_statement) {\n\n// Look for the final semicolon.\n\n            if (the_statement.arity === 'statement') {\n                if (the_statement.id === 'switch' ||\n                        (the_statement.block && the_statement.id !== 'do')) {\n                    spaces();\n                } else {\n                    semicolon();\n                }\n            } else {\n\n// If this is an expression statement, determine if it is acceptable.\n// We do not like\n//      new Blah;\n// statements. If it is to be used at all, new should only be used to make\n// objects, not side effects. The expression statements we do like do\n// assignment or invocation or delete.\n\n                if (the_statement.id === '(') {\n                    if (the_statement.first.id === 'new') {\n                        next_token.warn('bad_new');\n                    }\n                } else if (the_statement.id === '++' ||\n                        the_statement.id === '--') {\n                    lvalue(the_statement.first);\n                } else if (!the_statement.assign &&\n                        the_statement.id !== 'delete') {\n                    if (!option.closure || !preamble.comments) {\n                        preamble.warn('assignment_function_expression');\n                    }\n                }\n                semicolon();\n            }\n        }\n        step_out();\n        if (label) {\n            label.dead = true;\n        }\n        return the_statement;\n    }\n\n\n    function statements() {\n        var array = [], disruptor, the_statement;\n\n// A disrupt statement may not be followed by any other statement.\n// If the last statement is disrupt, then the sequence is disrupt.\n\n        while (next_token.postscript !== true) {\n            if (next_token.id === ';') {\n                next_token.warn('unexpected_a');\n                semicolon();\n            } else {\n                if (next_token.string === 'use strict') {\n                    if ((!node_js) || funct !== global_funct || array.length > 0) {\n                        next_token.warn('function_strict');\n                    }\n                    use_strict();\n                }\n                if (disruptor) {\n                    next_token.warn('unreachable_a_b', next_token.string,\n                        disruptor.string);\n                    disruptor = null;\n                }\n                the_statement = statement();\n                if (the_statement) {\n                    array.push(the_statement);\n                    if (the_statement.disrupt) {\n                        disruptor = the_statement;\n                        array.disrupt = true;\n                    }\n                }\n            }\n        }\n        return array;\n    }\n\n\n    function block(kind) {\n\n// A block is a sequence of statements wrapped in braces.\n\n        var array,\n            curly = next_token,\n            old_block_var = block_var,\n            old_in_block = in_block,\n            old_strict_mode = strict_mode;\n\n        in_block = kind !== 'function' && kind !== 'try' && kind !== 'catch';\n        block_var = [];\n        if (curly.id === '{') {\n            spaces();\n            advance('{');\n            step_in();\n            if (kind === 'function' && !use_strict() && !old_strict_mode &&\n                    !option.sloppy && funct.level === 1) {\n                next_token.warn('missing_use_strict');\n            }\n            array = statements();\n            strict_mode = old_strict_mode;\n            step_out('}', curly);\n        } else if (in_block) {\n            curly.stop('expected_a_b', '{', artifact());\n        } else {\n            curly.warn('expected_a_b', '{', artifact());\n            array = [statement()];\n            array.disrupt = array[0].disrupt;\n        }\n        if (kind !== 'catch' && array.length === 0 && !option.debug) {\n            curly.warn('empty_block');\n        }\n        block_var.forEach(function (name) {\n            scope[name].dead = true;\n        });\n        block_var = old_block_var;\n        in_block = old_in_block;\n        return array;\n    }\n\n\n    function tally_property(name) {\n        if (option.properties && typeof property[name] !== 'number') {\n            token.warn('unexpected_property_a', name);\n        }\n        if (property[name]) {\n            property[name] += 1;\n        } else {\n            property[name] = 1;\n        }\n    }\n\n\n// ECMAScript parser\n\n    (function () {\n        var x = symbol('(identifier)');\n        x.nud = function () {\n            var name = this.string,\n                master = scope[name],\n                writeable;\n\n// If the master is not in scope, then we may have an undeclared variable.\n// Check the predefined list. If it was predefined, create the global\n// variable.\n\n            if (!master) {\n                writeable = predefined[name];\n                if (typeof writeable === 'boolean') {\n                    global_scope[name] = master = {\n                        dead: false,\n                        function: global_funct,\n                        kind: 'var',\n                        string: name,\n                        writeable: writeable\n                    };\n\n// But if the variable is not in scope, and is not predefined, and if we are not\n// in the global scope, then we have an undefined variable error.\n\n                } else {\n                    token.warn('used_before_a');\n                }\n            } else {\n                this.master = master;\n            }\n\n// Annotate uses that cross scope boundaries.\n\n            if (master) {\n                if (master.kind === 'label') {\n                    this.warn('a_label');\n                } else {\n                    if (master.dead === true || master.dead === funct) {\n                        this.warn('a_scope');\n                    }\n                    master.used += 1;\n                    if (master.function !== funct) {\n                        if (master.function === global_funct) {\n                            funct.global.push(name);\n                        } else {\n                            master.function.closure.push(name);\n                            funct.outer.push(name);\n                        }\n                    }\n                }\n            }\n            return this;\n        };\n        x.identifier = true;\n    }());\n\n\n// Build the syntax table by declaring the syntactic elements.\n\n    type('(array)', 'array');\n    type('(function)', 'function');\n    type('(number)', 'number', return_this);\n    type('(object)', 'object');\n    type('(string)', 'string', return_this);\n    type('(boolean)', 'boolean', return_this);\n    type('(regexp)', 'regexp', return_this);\n\n    ultimate('(begin)');\n    ultimate('(end)');\n    ultimate('(error)');\n    postscript(symbol('}'));\n    symbol(')');\n    symbol(']');\n    postscript(symbol('\"'));\n    postscript(symbol('\\''));\n    symbol(';');\n    symbol(':');\n    symbol(',');\n    symbol('#');\n    symbol('@');\n    symbol('*/');\n    postscript(reserve('case'));\n    reserve('catch');\n    postscript(reserve('default'));\n    reserve('else');\n    reserve('finally');\n\n    reservevar('arguments', function (x) {\n        if (strict_mode && funct === global_funct) {\n            x.warn('strict');\n        }\n        funct.arguments = true;\n    });\n    reservevar('eval');\n    constant('false', 'boolean');\n    constant('Infinity', 'number');\n    constant('NaN', 'number');\n    constant('null', '');\n    reservevar('this', function (x) {\n        if (strict_mode && funct.statement && funct.name.charAt(0) > 'Z') {\n            x.warn('strict');\n        }\n    });\n    constant('true', 'boolean');\n    constant('undefined', '');\n\n    infix('?', 30, function (left, that) {\n        step_in('?');\n        that.first = expected_condition(expected_relation(left));\n        that.second = expression(0);\n        spaces();\n        step_out();\n        var colon = next_token;\n        advance(':');\n        step_in(':');\n        spaces();\n        that.third = expression(10);\n        that.arity = 'ternary';\n        if (are_similar(that.second, that.third)) {\n            colon.warn('weird_ternary');\n        } else if (are_similar(that.first, that.second)) {\n            that.warn('use_or');\n        }\n        step_out();\n        return that;\n    });\n\n    infix('||', 40, function (left, that) {\n        function paren_check(that) {\n            if (that.id === '&&' && !that.paren) {\n                that.warn('and');\n            }\n            return that;\n        }\n\n        that.first = paren_check(expected_condition(expected_relation(left)));\n        that.second = paren_check(expected_relation(expression(40)));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    infix('&&', 50, function (left, that) {\n        that.first = expected_condition(expected_relation(left));\n        that.second = expected_relation(expression(50));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    prefix('void', function (that) {\n        that.first = expression(0);\n        that.warn('expected_a_b', 'undefined', 'void');\n        return that;\n    });\n\n    bitwise('|', 70);\n    bitwise('^', 80);\n    bitwise('&', 90);\n\n    relation('==', '===');\n    relation('===');\n    relation('!=', '!==');\n    relation('!==');\n    relation('<');\n    relation('>');\n    relation('<=');\n    relation('>=');\n\n    bitwise('<<', 120);\n    bitwise('>>', 120);\n    bitwise('>>>', 120);\n\n    infix('in', 120, function (left, that) {\n        that.warn('infix_in');\n        that.left = left;\n        that.right = expression(130);\n        return that;\n    });\n    infix('instanceof', 120);\n    infix('+', 130, function (left, that) {\n        if (left.id === '(number)') {\n            if (left.number === 0) {\n                left.warn('unexpected_a', '0');\n            }\n        } else if (left.id === '(string)') {\n            if (left.string === '') {\n                left.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        var right = expression(130);\n        if (right.id === '(number)') {\n            if (right.number === 0) {\n                right.warn('unexpected_a', '0');\n            }\n        } else if (right.id === '(string)') {\n            if (right.string === '') {\n                right.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        if (left.id === right.id) {\n            if (left.id === '(string)' || left.id === '(number)') {\n                if (left.id === '(string)') {\n                    left.string += right.string;\n                    if (jx.test(left.string)) {\n                        left.warn('url');\n                    }\n                } else {\n                    left.number += right.number;\n                }\n                left.thru = right.thru;\n                return left;\n            }\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('+');\n    prefix('+++', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('+++', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('-', 130, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(130);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number -= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('-');\n    prefix('---', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('---', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('*', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number *= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('/', 140, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number /= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('%', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number %= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n\n    suffix('++');\n    prefix('++');\n\n    suffix('--');\n    prefix('--');\n    prefix('delete', function (that) {\n        one_space();\n        var p = expression(0);\n        if (!p || (p.id !== '.' && p.id !== '[')) {\n            next_token.warn('deleted');\n        }\n        that.first = p;\n        return that;\n    });\n\n\n    prefix('~', function (that) {\n        no_space_only();\n        if (!option.bitwise) {\n            that.warn('unexpected_a');\n        }\n        that.first = expression(150);\n        return that;\n    });\n    function banger(that) {\n        no_space_only();\n        that.first = expected_condition(expression(150));\n        if (bang[that.first.id] === that || that.first.assign) {\n            that.warn('confusing_a');\n        }\n        return that;\n    }\n    prefix('!', banger);\n    prefix('!!', banger);\n    prefix('typeof');\n    prefix('new', function (that) {\n        one_space();\n        var c = expression(160), n, p, v;\n        that.first = c;\n        if (c.id !== 'function') {\n            if (c.identifier) {\n                switch (c.string) {\n                case 'Object':\n                    token.warn('use_object');\n                    break;\n                case 'Array':\n                    if (next_token.id === '(') {\n                        p = next_token;\n                        p.first = this;\n                        advance('(');\n                        if (next_token.id !== ')') {\n                            n = expression(0);\n                            p.second = [n];\n                            if (n.id === '(string)' || next_token.id === ',') {\n                                p.warn('use_array');\n                            }\n                            while (next_token.id === ',') {\n                                advance(',');\n                                p.second.push(expression(0));\n                            }\n                        } else {\n                            token.warn('use_array');\n                        }\n                        advance(')', p);\n                        return p;\n                    }\n                    token.warn('use_array');\n                    break;\n                case 'Number':\n                case 'String':\n                case 'Boolean':\n                case 'Math':\n                case 'JSON':\n                    c.warn('not_a_constructor');\n                    break;\n                case 'Function':\n                    if (!option.evil) {\n                        next_token.warn('function_eval');\n                    }\n                    break;\n                case 'Date':\n                case 'RegExp':\n                case 'this':\n                    break;\n                default:\n                    if (c.id !== 'function') {\n                        v = c.string.charAt(0);\n                        if (!option.newcap && (v < 'A' || v > 'Z')) {\n                            token.warn('constructor_name_a');\n                        }\n                    }\n                }\n            } else {\n                if (c.id !== '.' && c.id !== '[' && c.id !== '(') {\n                    token.warn('bad_constructor');\n                }\n            }\n        } else {\n            that.warn('weird_new');\n        }\n        if (next_token.id !== '(') {\n            next_token.warn('missing_a', '()');\n        }\n        return that;\n    });\n\n    infix('(', 160, function (left, that) {\n        var e, p;\n        if (indent && indent.mode === 'expression') {\n            no_space(prev_token, token);\n        } else {\n            no_space_only(prev_token, token);\n        }\n        if (!left.immed && left.id === 'function') {\n            next_token.warn('wrap_immediate');\n        }\n        p = [];\n        if (left.identifier) {\n            if (left.string.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {\n                if (left.string !== 'Number' && left.string !== 'String' &&\n                        left.string !== 'Boolean' && left.string !== 'Date') {\n                    if (left.string === 'Math') {\n                        left.warn('not_a_function');\n                    } else if (left.string === 'Object') {\n                        token.warn('use_object');\n                    } else if (left.string === 'Array' || !option.newcap) {\n                        left.warn('missing_a', 'new');\n                    }\n                }\n            } else if (left.string === 'JSON') {\n                left.warn('not_a_function');\n            }\n        } else if (left.id === '.') {\n            if (left.second.string === 'split' &&\n                    left.first.id === '(string)') {\n                left.second.warn('use_array');\n            }\n        }\n        step_in();\n        if (next_token.id !== ')') {\n            no_space();\n            for (;;) {\n                edge();\n                e = expression(10);\n                if (left.string === 'Boolean' && (e.id === '!' || e.id === '~')) {\n                    e.warn('weird_condition');\n                }\n                p.push(e);\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', that);\n        if (typeof left === 'object') {\n            if (left.string === 'parseInt' && p.length === 1) {\n                left.warn('radix');\n            } else if (left.string === 'String' && p.length >= 1 && p[0].id === '(string)') {\n                left.warn('unexpected_a');\n            }\n            if (!option.evil) {\n                if (left.string === 'eval' || left.string === 'Function' ||\n                        left.string === 'execScript') {\n                    left.warn('evil');\n                } else if (p[0] && p[0].id === '(string)' &&\n                        (left.string === 'setTimeout' ||\n                        left.string === 'setInterval')) {\n                    left.warn('implied_evil');\n                }\n            }\n            if (!left.identifier && left.id !== '.' && left.id !== '[' &&\n                    left.id !== '(' && left.id !== '&&' && left.id !== '||' &&\n                    left.id !== '?') {\n                left.warn('bad_invocation');\n            }\n            if (left.id === '.') {\n                if (p.length > 0 &&\n                        left.first && left.first.first &&\n                        are_similar(p[0], left.first.first)) {\n                    if (left.second.string === 'call' ||\n                            (left.second.string === 'apply' && (p.length === 1 ||\n                            (p[1].arity === 'prefix' && p[1].id === '[')))) {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n                if (left.second.string === 'toString') {\n                    if (left.first.id === '(string)' || left.first.id === '(number)') {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n            }\n        }\n        that.first = left;\n        that.second = p;\n        return that;\n    }, true);\n\n    prefix('(', function (that) {\n        step_in('expression');\n        no_space();\n        edge();\n        if (next_token.id === 'function') {\n            next_token.immed = true;\n        }\n        var value = expression(0);\n        value.paren = true;\n        no_space();\n        step_out(')', that);\n        if (value.id === 'function') {\n            switch (next_token.id) {\n            case '(':\n                next_token.warn('move_invocation');\n                break;\n            case '.':\n            case '[':\n                next_token.warn('unexpected_a');\n                break;\n            default:\n                that.warn('bad_wrap');\n            }\n        } else if (!value.arity) {\n            if (!option.closure || !that.comments) {\n                that.warn('unexpected_a');\n            }\n        }\n        return value;\n    });\n\n    infix('.', 170, function (left, that) {\n        no_space(prev_token, token);\n        no_space();\n        var name = identifier();\n        if (typeof name === 'string') {\n            tally_property(name);\n        }\n        that.first = left;\n        that.second = token;\n        if (left && left.string === 'arguments' &&\n                (name === 'callee' || name === 'caller')) {\n            left.warn('avoid_a', 'arguments.' + name);\n        } else if (!option.evil && left && left.string === 'document' &&\n                (name === 'write' || name === 'writeln')) {\n            left.warn('write_is_wrong');\n        } else if (!option.stupid && syx.test(name)) {\n            token.warn('sync_a');\n        }\n        if (!option.evil && (name === 'eval' || name === 'execScript')) {\n            next_token.warn('evil');\n        }\n        return that;\n    }, true);\n\n    infix('[', 170, function (left, that) {\n        var e, s;\n        no_space_only(prev_token, token);\n        no_space();\n        step_in();\n        edge();\n        e = expression(0);\n        switch (e.id) {\n        case '(number)':\n            if (e.id === '(number)' && left.id === 'arguments') {\n                left.warn('use_param');\n            }\n            break;\n        case '(string)':\n            if (!option.evil &&\n                    (e.string === 'eval' || e.string === 'execScript')) {\n                e.warn('evil');\n            } else if (!option.sub && ix.test(e.string)) {\n                s = syntax[e.string];\n                if (!s || !s.reserved) {\n                    e.warn('subscript');\n                }\n            }\n            tally_property(e.string);\n            break;\n        }\n        step_out(']', that);\n        no_space(prev_token, token);\n        that.first = left;\n        that.second = e;\n        return that;\n    }, true);\n\n    prefix('[', function (that) {\n        that.first = [];\n        step_in('array');\n        while (next_token.id !== '(end)') {\n            while (next_token.id === ',') {\n                next_token.warn('unexpected_a');\n                advance(',');\n            }\n            if (next_token.id === ']') {\n                break;\n            }\n            indent.wrap = false;\n            edge();\n            that.first.push(expression(10));\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id === ']') {\n                    token.warn('unexpected_a');\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        step_out(']', that);\n        return that;\n    }, 170);\n\n\n    function property_name() {\n        var id = optional_identifier();\n        if (!id) {\n            if (next_token.id === '(string)') {\n                id = next_token.string;\n                advance();\n            } else if (next_token.id === '(number)') {\n                id = next_token.number.toString();\n                advance();\n            }\n        }\n        return id;\n    }\n\n\n\n    assignop('=');\n    assignop('+=', '+');\n    assignop('-=', '-');\n    assignop('*=', '*');\n    assignop('/=', '/').nud = function () {\n        next_token.stop('slash_equal');\n    };\n    assignop('%=', '%');\n    assignop('&=', '&');\n    assignop('|=', '|');\n    assignop('^=', '^');\n    assignop('<<=', '<<');\n    assignop('>>=', '>>');\n    assignop('>>>=', '>>>');\n\n    function function_parameters() {\n        var id, parameters = [], paren = next_token;\n        advance('(');\n        token.function = funct;\n        step_in();\n        no_space();\n        if (next_token.id !== ')') {\n            for (;;) {\n                edge();\n                id = identifier();\n                define('parameter', token);\n                parameters.push(id);\n                token.init = true;\n                token.writeable = true;\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', paren);\n        return parameters;\n    }\n\n    function do_function(func, name) {\n        var old_funct = funct,\n            old_option = option,\n            old_scope = scope;\n        scope = Object.create(old_scope);\n        funct = {\n            closure: [],\n            global: [],\n            level: old_funct.level + 1,\n            line: next_token.line,\n            loopage: 0,\n            name: name || '\\'' + (anonname || '').replace(nx, sanitize) + '\\'',\n            outer: [],\n            scope: scope\n        };\n        funct.parameter = function_parameters();\n        func.function = funct;\n        option = Object.create(old_option);\n        functions.push(funct);\n        if (name) {\n            func.name = name;\n            func.string = name;\n            define('function', func);\n            func.init = true;\n            func.used += 1;\n        }\n        func.writeable = false;\n        one_space();\n        func.block = block('function');\n        Object.keys(scope).forEach(function (name) {\n            var master = scope[name];\n            if (!master.used && master.kind !== 'exception' &&\n                    (master.kind !== 'parameter' || !option.unparam)) {\n                master.warn('unused_a');\n            } else if (!master.init) {\n                master.warn('uninitialized_a');\n            }\n        });\n        funct = old_funct;\n        option = old_option;\n        scope = old_scope;\n    }\n\n    prefix('{', function (that) {\n        var get, i, j, name, set, seen = Object.create(null);\n        that.first = [];\n        step_in();\n        while (next_token.id !== '}') {\n            indent.wrap = false;\n\n// JSLint recognizes the ES5 extension for get/set in object literals,\n// but requires that they be used in pairs.\n\n            edge();\n            if (next_token.string === 'get' && peek().id !== ':') {\n                get = next_token;\n                advance('get');\n                one_space_only();\n                name = next_token;\n                i = property_name();\n                if (!i) {\n                    next_token.stop('missing_property');\n                }\n                get.string = '';\n                do_function(get);\n                if (funct.loopage) {\n                    get.warn('function_loop');\n                }\n                if (get.function.parameter.length) {\n                    get.warn('parameter_a_get_b', get.function.parameter[0], i);\n                }\n                comma();\n                set = next_token;\n                spaces();\n                edge();\n                advance('set');\n                set.string = '';\n                one_space_only();\n                j = property_name();\n                if (i !== j) {\n                    token.stop('expected_a_b', i, j || next_token.string);\n                }\n                do_function(set);\n                if (set.block.length === 0) {\n                    token.warn('missing_a', 'throw');\n                }\n                if (set.function.parameter.length === 0) {\n                    set.stop('parameter_set_a', 'value');\n                } else if (set.function.parameter[0] !== 'value') {\n                    set.stop('expected_a_b', 'value',\n                        set.function.parameter[0]);\n                }\n                name.first = [get, set];\n            } else {\n                name = next_token;\n                i = property_name();\n                if (typeof i !== 'string') {\n                    next_token.stop('missing_property');\n                }\n                advance(':');\n                spaces();\n                name.first = expression(10);\n            }\n            that.first.push(name);\n            if (seen[i] === true) {\n                next_token.warn('duplicate_a', i);\n            }\n            seen[i] = true;\n            tally_property(i);\n            if (next_token.id !== ',') {\n                break;\n            }\n            for (;;) {\n                comma();\n                if (next_token.id !== ',') {\n                    break;\n                }\n                next_token.warn('unexpected_a');\n            }\n            if (next_token.id === '}') {\n                token.warn('unexpected_a');\n            }\n        }\n        step_out('}', that);\n        return that;\n    });\n\n    stmt('{', function () {\n        next_token.warn('statement_block');\n        this.arity = 'statement';\n        this.block = statements();\n        this.disrupt = this.block.disrupt;\n        advance('}', this);\n        return this;\n    });\n\n    stmt('/*global', directive);\n    stmt('/*globals', directive);\n    stmt('/*jslint', directive);\n    stmt('/*member', directive);\n    stmt('/*members', directive);\n    stmt('/*property', directive);\n    stmt('/*properties', directive);\n\n    stmt('var', function () {\n\n// JavaScript does not have block scope. It only has function scope. So,\n// declaring a variable in a block can have unexpected consequences.\n\n// var.first will contain an array, the array containing name tokens\n// and assignment tokens.\n\n        var assign, id, name;\n\n        if (funct.loopage) {\n            next_token.warn('var_loop');\n        } else if (funct.varstatement && !option.vars) {\n            next_token.warn('combine_var');\n        }\n        if (funct !== global_funct) {\n            funct.varstatement = true;\n        }\n        this.arity = 'statement';\n        this.first = [];\n        step_in('var');\n        for (;;) {\n            name = next_token;\n            id = identifier(true);\n            define('var', name);\n            name.dead = funct;\n            if (next_token.id === '=') {\n                if (funct === global_funct && !name.writeable) {\n                    name.warn('read_only');\n                }\n                assign = next_token;\n                assign.first = name;\n                spaces();\n                advance('=');\n                spaces();\n                if (next_token.id === 'undefined') {\n                    token.warn('unnecessary_initialize', id);\n                }\n                if (peek(0).id === '=' && next_token.identifier) {\n                    next_token.stop('var_a_not');\n                }\n                assign.second = expression(0);\n                assign.arity = 'infix';\n                name.init = true;\n                this.first.push(assign);\n            } else {\n                this.first.push(name);\n            }\n            name.dead = false;\n            name.writeable = true;\n            if (next_token.id !== ',') {\n                break;\n            }\n            comma();\n            indent.wrap = false;\n            if (var_mode && next_token.line === token.line &&\n                    this.first.length === 1) {\n                var_mode = null;\n                indent.open = false;\n                indent.at -= option.indent;\n            }\n            spaces();\n            edge();\n        }\n        var_mode = null;\n        step_out();\n        return this;\n    });\n\n    stmt('function', function () {\n        one_space();\n        if (in_block) {\n            token.warn('function_block');\n        }\n        var name = next_token,\n            id = identifier(true);\n        define('var', name);\n        if (!name.writeable) {\n            name.warn('read_only');\n        }\n        name.init = true;\n        name.statement = true;\n        no_space();\n        this.arity = 'statement';\n        do_function(this, id);\n        if (next_token.id === '(' && next_token.line === token.line) {\n            next_token.stop('function_statement');\n        }\n        return this;\n    });\n\n    prefix('function', function (that) {\n        var id = optional_identifier(true), name;\n        if (id) {\n            name = token;\n            no_space();\n        } else {\n            id = '';\n            one_space();\n        }\n        do_function(that, id);\n        if (name) {\n            name.function = that.function;\n        }\n        if (funct.loopage) {\n            that.warn('function_loop');\n        }\n        switch (next_token.id) {\n        case ';':\n        case '(':\n        case ')':\n        case ',':\n        case ']':\n        case '}':\n        case ':':\n        case '(end)':\n            break;\n        case '.':\n            if (peek().string !== 'bind' || peek(1).id !== '(') {\n                next_token.warn('unexpected_a');\n            }\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n        that.arity = 'function';\n        return that;\n    });\n\n    stmt('if', function () {\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('if');\n        if (next_token.id === 'else') {\n            if (this.block.disrupt) {\n                next_token.warn(this.elif ? 'use_nested_if' : 'unnecessary_else');\n            }\n            one_space();\n            advance('else');\n            one_space();\n            if (next_token.id === 'if') {\n                next_token.elif = true;\n                this.else = statement(true);\n            } else {\n                this.else = block('else');\n            }\n            if (this.else.disrupt && this.block.disrupt) {\n                this.disrupt = true;\n            }\n        }\n        return this;\n    });\n\n    stmt('try', function () {\n\n// try.first    The catch variable\n// try.second   The catch clause\n// try.third    The finally clause\n// try.block    The try block\n\n        var exception_variable, paren;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('try');\n        if (next_token.id === 'catch') {\n            one_space();\n            advance('catch');\n            one_space();\n            paren = next_token;\n            advance('(');\n            step_in('control');\n            no_space();\n            edge();\n            exception_variable = next_token;\n            this.first = identifier();\n            define('exception', exception_variable);\n            exception_variable.init = true;\n            no_space();\n            step_out(')', paren);\n            one_space();\n            this.second = block('catch');\n            if (this.second.length) {\n                if (this.first === 'ignore') {\n                    exception_variable.warn('unexpected_a');\n                }\n            } else {\n                if (this.first !== 'ignore') {\n                    exception_variable.warn('expected_a_b', 'ignore',\n                        exception_variable.string);\n                }\n            }\n            exception_variable.dead = true;\n        }\n        if (next_token.id === 'finally') {\n            one_space();\n            advance('finally');\n            one_space();\n            this.third = block('finally');\n        } else if (!this.second) {\n            next_token.stop('expected_a_b', 'catch', artifact());\n        }\n        return this;\n    });\n\n    labeled_stmt('while', function () {\n        one_space();\n        var paren = next_token;\n        funct.loopage += 1;\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_relation(expression(0));\n        if (this.first.id !== 'true') {\n            expected_condition(this.first, 'unexpected_a');\n        }\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('while');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        funct.loopage -= 1;\n        return this;\n    });\n\n    reserve('with');\n\n    labeled_stmt('switch', function () {\n\n// switch.first         the switch expression\n// switch.second        the array of cases. A case is 'case' or 'default' token:\n//    case.first        the array of case expressions\n//    case.second       the array of statements\n// If all of the arrays of statements are disrupt, then the switch is disrupt.\n\n        var cases = [],\n            old_in_block = in_block,\n            particular,\n            that = token,\n            the_case = next_token;\n\n        function find_duplicate_case(value) {\n            if (are_similar(particular, value)) {\n                value.warn('duplicate_a');\n            }\n        }\n\n        one_space();\n        advance('(');\n        no_space();\n        step_in();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', the_case);\n        one_space();\n        advance('{');\n        step_in();\n        in_block = true;\n        this.second = [];\n        if (that.from !== next_token.from && !option.white) {\n            next_token.warn('expected_a_at_b_c', next_token.string, that.from, next_token.from);\n        }\n        while (next_token.id === 'case') {\n            the_case = next_token;\n            the_case.first = [];\n            the_case.arity = 'case';\n            for (;;) {\n                spaces();\n                edge('case');\n                advance('case');\n                one_space();\n                particular = expression(0);\n                cases.forEach(find_duplicate_case);\n                cases.push(particular);\n                the_case.first.push(particular);\n                if (particular.id === 'NaN') {\n                    particular.warn('unexpected_a');\n                }\n                no_space_only();\n                advance(':');\n                if (next_token.id !== 'case') {\n                    break;\n                }\n            }\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                if (!the_case.second[the_case.second.length - 1].disrupt) {\n                    next_token.warn('missing_a_after_b', 'break', 'case');\n                }\n            } else {\n                next_token.warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.second.length === 0) {\n            next_token.warn('missing_a', 'case');\n        }\n        if (next_token.id === 'default') {\n            spaces();\n            the_case = next_token;\n            the_case.arity = 'case';\n            edge('case');\n            advance('default');\n            no_space_only();\n            advance(':');\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                this.disrupt = the_case.second[the_case.second.length - 1].disrupt;\n            } else {\n                the_case.warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.break) {\n            this.disrupt = false;\n        }\n        spaces();\n        step_out('}', this);\n        in_block = old_in_block;\n        return this;\n    });\n\n    stmt('debugger', function () {\n        if (!option.debug) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        return this;\n    });\n\n    labeled_stmt('do', function () {\n        funct.loopage += 1;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('do');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        one_space();\n        advance('while');\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in();\n        no_space();\n        edge();\n        this.first = expected_condition(expected_relation(expression(0)), 'unexpected_a');\n        no_space();\n        step_out(')', paren);\n        funct.loopage -= 1;\n        return this;\n    });\n\n    labeled_stmt('for', function () {\n\n        var blok, filter, master, ok = false, paren = next_token, value;\n        this.arity = 'statement';\n        funct.loopage += 1;\n        advance('(');\n        if (next_token.id === ';') {\n            no_space();\n            advance(';');\n            no_space();\n            advance(';');\n            no_space();\n            advance(')');\n            blok = block('for');\n        } else {\n            step_in('control');\n            spaces(this, paren);\n            no_space();\n            if (next_token.id === 'var') {\n                next_token.stop('move_var');\n            }\n            edge();\n            if (peek(0).id === 'in') {\n                this.forin = true;\n                value = expression(1000);\n                master = value.master;\n                if (!master) {\n                    value.stop('bad_in_a');\n                }\n                if (master.kind !== 'var' || master.function !== funct ||\n                        !master.writeable || master.dead) {\n                    value.warn('bad_in_a');\n                }\n                master.init = true;\n                master.used -= 1;\n                this.first = value;\n                advance('in');\n                this.second = expression(20);\n                step_out(')', paren);\n                blok = block('for');\n                if (!option.forin) {\n                    if (blok.length === 1 && typeof blok[0] === 'object') {\n                        if (blok[0].id === 'if' && !blok[0].else) {\n                            filter = blok[0].first;\n                            while (filter.id === '&&') {\n                                filter = filter.first;\n                            }\n                            switch (filter.id) {\n                            case '===':\n                            case '!==':\n                                ok = filter.first.id === '['\n                                    ? are_similar(filter.first.first, this.second) &&\n                                        are_similar(filter.first.second, this.first)\n                                    : filter.first.id === 'typeof' &&\n                                        filter.first.first.id === '[' &&\n                                        are_similar(filter.first.first.first, this.second) &&\n                                        are_similar(filter.first.first.second, this.first);\n                                break;\n                            case '(':\n                                ok = filter.first.id === '.' && ((\n                                    are_similar(filter.first.first, this.second) &&\n                                    filter.first.second.string === 'hasOwnProperty' &&\n                                    are_similar(filter.second[0], this.first)\n                                ) || (\n                                    filter.first.first.id === '.' &&\n                                    filter.first.first.first.first &&\n                                    filter.first.first.first.first.string === 'Object' &&\n                                    filter.first.first.first.id === '.' &&\n                                    filter.first.first.first.second.string === 'prototype' &&\n                                    filter.first.first.second.string === 'hasOwnProperty' &&\n                                    filter.first.second.string === 'call' &&\n                                    are_similar(filter.second[0], this.second) &&\n                                    are_similar(filter.second[1], this.first)\n                                ));\n                                break;\n                            }\n                        } else if (blok[0].id === 'switch') {\n                            ok = blok[0].id === 'switch' &&\n                                blok[0].first.id === 'typeof' &&\n                                blok[0].first.first.id === '[' &&\n                                are_similar(blok[0].first.first.first, this.second) &&\n                                are_similar(blok[0].first.first.second, this.first);\n                        }\n                    }\n                    if (!ok) {\n                        this.warn('for_if');\n                    }\n                }\n            } else {\n                edge();\n                this.first = [];\n                for (;;) {\n                    this.first.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                semicolon();\n                edge();\n                this.second = expected_relation(expression(0));\n                if (this.second.id !== 'true') {\n                    expected_condition(this.second, 'unexpected_a');\n                }\n                semicolon(token);\n                if (next_token.id === ';') {\n                    next_token.stop('expected_a_b', ')', ';');\n                }\n                this.third = [];\n                edge();\n                for (;;) {\n                    this.third.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                no_space();\n                step_out(')', paren);\n                one_space();\n                blok = block('for');\n            }\n        }\n        if (blok.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        this.block = blok;\n        funct.loopage -= 1;\n        return this;\n    });\n\n    function optional_label(that) {\n        var label = next_token.string,\n            master;\n        that.arity = 'statement';\n        if (!funct.breakage || (!option.continue && that.id === 'continue')) {\n            that.warn('unexpected_a');\n        } else if (next_token.identifier && token.line === next_token.line) {\n            one_space_only();\n            master = scope[label];\n            if (!master || master.kind !== 'label') {\n                next_token.warn('not_a_label');\n            } else if (master.dead || master.function !== funct) {\n                next_token.warn('not_a_scope');\n            } else {\n                master.used += 1;\n                if (that.id === 'break') {\n                    master.statement.break = true;\n                }\n                if (funct.breakage[funct.breakage.length - 1] === master.statement) {\n                    next_token.warn('unexpected_a');\n                }\n            }\n            that.first = next_token;\n            advance();\n        } else {\n            if (that.id === 'break') {\n                funct.breakage[funct.breakage.length - 1].break = true;\n            }\n        }\n        return that;\n\n    }\n\n    disrupt_stmt('break', function () {\n        return optional_label(this);\n    });\n\n    disrupt_stmt('continue', function () {\n        return optional_label(this);\n    });\n\n    disrupt_stmt('return', function () {\n        if (funct === global_funct) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        if (next_token.id !== ';' && next_token.line === token.line) {\n            if (option.closure) {\n                spaces();\n            } else {\n                one_space_only();\n            }\n            if (next_token.id === '/' || next_token.id === '(regexp)') {\n                next_token.warn('wrap_regexp');\n            }\n            this.first = expression(0);\n            if (this.first.assign) {\n                this.first.warn('unexpected_a');\n            }\n        }\n        return this;\n    });\n\n    disrupt_stmt('throw', function () {\n        this.arity = 'statement';\n        one_space_only();\n        this.first = expression(20);\n        return this;\n    });\n\n\n//  Superfluous reserved words\n\n    reserve('class');\n    reserve('const');\n    reserve('enum');\n    reserve('export');\n    reserve('extends');\n    reserve('import');\n    reserve('super');\n\n// Harmony reserved words\n\n    reserve('implements');\n    reserve('interface');\n    reserve('let');\n    reserve('package');\n    reserve('private');\n    reserve('protected');\n    reserve('public');\n    reserve('static');\n    reserve('yield');\n\n\n// Parse JSON\n\n    function json_value() {\n\n        function json_object() {\n            var brace = next_token, object = Object.create(null);\n            advance('{');\n            if (next_token.id !== '}') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    if (next_token.id !== '(string)') {\n                        next_token.warn('expected_string_a');\n                    }\n                    if (object[next_token.string] === true) {\n                        next_token.warn('duplicate_a');\n                    } else if (next_token.string === '__proto__') {\n                        next_token.warn('dangling_a');\n                    } else {\n                        object[next_token.string] = true;\n                    }\n                    advance();\n                    advance(':');\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === '}') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance('}', brace);\n        }\n\n        function json_array() {\n            var bracket = next_token;\n            advance('[');\n            if (next_token.id !== ']') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === ']') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance(']', bracket);\n        }\n\n        switch (next_token.id) {\n        case '{':\n            json_object();\n            break;\n        case '[':\n            json_array();\n            break;\n        case 'true':\n        case 'false':\n        case 'null':\n        case '(number)':\n        case '(string)':\n            advance();\n            break;\n        case '-':\n            advance('-');\n            no_space_only();\n            advance('(number)');\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n    }\n\n\n// The actual JSLINT function itself.\n\n    itself = function JSLint(the_source, the_option) {\n\n        var i, predef, tree;\n        itself.errors = [];\n        itself.tree = '';\n        itself.properties = '';\n        begin = prev_token = token = next_token =\n            Object.create(syntax['(begin)']);\n        tokens = [];\n        predefined = Object.create(null);\n        add_to_predefined(standard);\n        property = Object.create(null);\n        if (the_option) {\n            option = Object.create(the_option);\n            predef = option.predef;\n            if (predef) {\n                if (Array.isArray(predef)) {\n                    for (i = 0; i < predef.length; i += 1) {\n                        predefined[predef[i]] = true;\n                    }\n                } else if (typeof predef === 'object') {\n                    add_to_predefined(predef);\n                }\n            }\n        } else {\n            option = Object.create(null);\n        }\n        option.indent = +option.indent || 4;\n        option.maxerr = +option.maxerr || 50;\n        global_scope = scope = Object.create(null);\n        global_funct = funct = {\n            scope: scope,\n            loopage: 0,\n            level: 0\n        };\n        functions = [funct];\n        block_var = [];\n\n        comments = [];\n        comments_off = false;\n        in_block = false;\n        indent = null;\n        json_mode = false;\n        lookahead = [];\n        node_js = false;\n        prereg = true;\n        strict_mode = false;\n        var_mode = null;\n        warnings = 0;\n        lex.init(the_source);\n\n        assume();\n\n        try {\n            advance();\n            if (next_token.id === '(number)') {\n                next_token.stop('unexpected_a');\n            } else {\n                switch (next_token.id) {\n                case '{':\n                case '[':\n                    comments_off = true;\n                    json_mode = true;\n                    json_value();\n                    break;\n                default:\n\n// If the first token is a semicolon, ignore it. This is sometimes used when\n// files are intended to be appended to files that may be sloppy. A sloppy\n// file may be depending on semicolon insertion on its last line.\n\n                    step_in(1);\n                    if (next_token.id === ';' && !node_js) {\n                        semicolon();\n                    }\n                    tree = statements();\n                    begin.first = tree;\n                    itself.tree = begin;\n                    if (tree.disrupt) {\n                        prev_token.warn('weird_program');\n                    }\n                }\n            }\n            indent = null;\n            advance('(end)');\n            itself.property = property;\n        } catch (e) {\n            if (e) {        // ~~\n                itself.errors.push({\n                    reason    : e.message,\n                    line      : e.line || next_token.line,\n                    character : e.character || next_token.from\n                }, null);\n            }\n        }\n        return itself.errors.length === 0;\n    };\n\n    function unique(array) {\n        array = array.sort();\n        var i, length = 0, previous, value;\n        for (i = 0; i < array.length; i += 1) {\n            value = array[i];\n            if (value !== previous) {\n                array[length] = value;\n                previous = value;\n                length += 1;\n            }\n        }\n        array.length = length;\n        return array;\n    }\n\n// Data summary.\n\n    itself.data = function () {\n        var data = {functions: []},\n            function_data,\n            i,\n            the_function,\n            the_scope;\n        data.errors = itself.errors;\n        data.json = json_mode;\n        data.global = unique(Object.keys(global_scope));\n\n        function selects(name) {\n            var kind = the_scope[name].kind;\n            switch (kind) {\n            case 'var':\n            case 'exception':\n            case 'label':\n                function_data[kind].push(name);\n                break;\n            }\n        }\n\n        for (i = 1; i < functions.length; i += 1) {\n            the_function = functions[i];\n            function_data = {\n                name: the_function.name,\n                line: the_function.line,\n                level: the_function.level,\n                parameter: the_function.parameter,\n                var: [],\n                exception: [],\n                closure: unique(the_function.closure),\n                outer: unique(the_function.outer),\n                global: unique(the_function.global),\n                label: []\n            };\n            the_scope = the_function.scope;\n            Object.keys(the_scope).forEach(selects);\n            function_data.var.sort();\n            function_data.exception.sort();\n            function_data.label.sort();\n            data.functions.push(function_data);\n        }\n        data.tokens = tokens;\n        return data;\n    };\n\n    itself.error_report = function (data) {\n        var evidence, i, output = [], warning;\n        if (data.errors.length) {\n            if (data.json) {\n                output.push('<cite>JSON: bad.</cite><br>');\n            }\n            for (i = 0; i < data.errors.length; i += 1) {\n                warning = data.errors[i];\n                if (warning) {\n                    evidence = warning.evidence || '';\n                    output.push('<cite>');\n                    if (isFinite(warning.line)) {\n                        output.push('<address>line ' +\n                            String(warning.line) +\n                            ' character ' + String(warning.character) +\n                            '</address>');\n                    }\n                    output.push(warning.reason.entityify() + '</cite>');\n                    if (evidence) {\n                        output.push('<pre>' + evidence.entityify() + '</pre>');\n                    }\n                }\n            }\n        }\n        return output.join('');\n    };\n\n\n    itself.report = function (data) {\n        var dl, i, j, names, output = [], the_function;\n\n        function detail(h, array) {\n            var comma_needed = false;\n            if (array.length) {\n                output.push(\"<dt>\" + h + \"</dt><dd>\");\n                array.forEach(function (item) {\n                    output.push((comma_needed ? ', ' : '') + item);\n                    comma_needed = true;\n                });\n                output.push(\"</dd>\");\n            }\n        }\n\n        output.push('<dl class=level0>');\n        if (data.global.length) {\n            detail('global', data.global);\n            dl = true;\n        } else if (data.json) {\n            if (!data.errors.length) {\n                output.push(\"<dt>JSON: good.</dt>\");\n            }\n        } else {\n            output.push(\"<dt><i>No new global variables introduced.</i></dt>\");\n        }\n        if (dl) {\n            output.push(\"</dl>\");\n        } else {\n            output[0] = '';\n        }\n\n        if (data.functions) {\n            for (i = 0; i < data.functions.length; i += 1) {\n                the_function = data.functions[i];\n                names = [];\n                if (the_function.params) {\n                    for (j = 0; j < the_function.params.length; j += 1) {\n                        names[j] = the_function.params[j].string;\n                    }\n                }\n                output.push('<dl class=level' + the_function.level +\n                    '><address>line ' + String(the_function.line) +\n                    '</address>' + the_function.name.entityify());\n                detail('parameter', the_function.parameter);\n                detail('variable', the_function.var);\n                detail('exception', the_function.exception);\n                detail('closure', the_function.closure);\n                detail('outer', the_function.outer);\n                detail('global', the_function.global);\n                detail('label', the_function.label);\n                output.push('</dl>');\n            }\n        }\n        return output.join('');\n    };\n\n    itself.properties_report = function (property) {\n        if (!property) {\n            return '';\n        }\n        var i,\n            key,\n            keys = Object.keys(property).sort(),\n            mem = '   ',\n            name,\n            not_first = false,\n            output = ['/*properties'];\n        for (i = 0; i < keys.length; i += 1) {\n            key = keys[i];\n            if (property[key] > 0) {\n                if (not_first) {\n                    mem += ',';\n                }\n                name = ix.test(key)\n                    ? key\n                    : '\\'' + key.replace(nx, sanitize) + '\\'';\n                if (mem.length + name.length >= 80) {\n                    output.push(mem);\n                    mem = '    ';\n                } else {\n                    mem += ' ';\n                }\n                mem += name;\n                not_first = true;\n            }\n        }\n        output.push(mem, '*/\\n');\n        return output.join('\\n');\n    };\n\n    itself.color = function (data) {\n        var from,\n            i = 1,\n            level,\n            line,\n            result = [],\n            thru,\n            data_token = data.tokens[0];\n        while (data_token && data_token.id !== '(end)') {\n            from = data_token.from;\n            line = data_token.line;\n            thru = data_token.thru;\n            level = data_token.function.level;\n            do {\n                thru = data_token.thru;\n                data_token = data.tokens[i];\n                i += 1;\n            } while (data_token && data_token.line === line &&\n                    data_token.from - thru < 5 &&\n                    level === data_token.function.level);\n            result.push({\n                line: line,\n                level: level,\n                from: from,\n                thru: thru\n            });\n        }\n        return result;\n    };\n\n    itself.jslint = itself;\n\n    itself.edition = '2014-02-06';\n\n    return itself;\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jslint-2014-04-21.js":"// jslint.js\n// 2014-04-21\n\n// Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// The Software shall be used for Good, not Evil.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// WARNING: JSLint will hurt your feelings.\n\n// JSLINT is a global function. It takes two parameters.\n\n//     var myResult = JSLINT(source, option);\n\n// The first parameter is either a string or an array of strings. If it is a\n// string, it will be split on '\\n' or '\\r'. If it is an array of strings, it\n// is assumed that each string represents one line. The source can be a\n// JavaScript text or a JSON text.\n\n// The second parameter is an optional object of options that control the\n// operation of JSLINT. Most of the options are booleans: They are all\n// optional and have a default value of false. One of the options, predef,\n// can be an array of names, which will be used to declare global variables,\n// or an object whose keys are used as global names, with a boolean value\n// that determines if they are assignable.\n\n// If it checks out, JSLINT returns true. Otherwise, it returns false.\n\n// If false, you can inspect JSLINT.errors to find out the problems.\n// JSLINT.errors is an array of objects containing these properties:\n\n//  {\n//      line      : The line (relative to 0) at which the lint was found\n//      character : The character (relative to 0) at which the lint was found\n//      reason    : The problem\n//      evidence  : The text line in which the problem occurred\n//      raw       : The raw message before the details were inserted\n//      a         : The first detail\n//      b         : The second detail\n//      c         : The third detail\n//      d         : The fourth detail\n//  }\n\n// If a stopping error was found, a null will be the last element of the\n// JSLINT.errors array. A stopping error means that JSLint was not confident\n// enough to continue. It does not necessarily mean that the error was\n// especially heinous.\n\n// You can request a data structure that contains JSLint's results.\n\n//     var myData = JSLINT.data();\n\n// It returns a structure with this form:\n\n//     {\n//         errors: [\n//             {\n//                 line: NUMBER,\n//                 character: NUMBER,\n//                 reason: STRING,\n//                 evidence: STRING\n//             }\n//         ],\n//         functions: [\n//             {\n//                 name: STRING,\n//                 line: NUMBER,\n//                 level: NUMBER,\n//                 parameter: [\n//                     STRING\n//                 ],\n//                 var: [\n//                     STRING\n//                 ],\n//                 exception: [\n//                     STRING\n//                 ],\n//                 closure: [\n//                     STRING\n//                 ],\n//                 outer: [\n//                     STRING\n//                 ],\n//                 global: [\n//                     STRING\n//                 ],\n//                 label: [\n//                     STRING\n//                 ]\n//             }\n//         ],\n//         global: [\n//             STRING\n//         ],\n//         member: {\n//             STRING: NUMBER\n//         },\n//         json: BOOLEAN\n//     }\n\n// You can request a Function Report, which shows all of the functions\n// and the parameters and vars that they use. This can be used to find\n// implied global variables and other problems. The report is in HTML and\n// can be inserted into an HTML <body>. It should be given the result of the\n// JSLINT.data function.\n\n//     var myReport = JSLINT.report(data);\n\n// You can request an HTML error report.\n\n//     var myErrorReport = JSLINT.error_report(data);\n\n// You can obtain an object containing all of the properties found in the\n// file. JSLINT.property contains an object containing a key for each\n// property used in the program, the value being the number of times that\n// property name was used in the file.\n\n// You can request a properties report, which produces a list of the program's\n// properties in the form of a /*properties*/ declaration.\n\n//      var myPropertyReport = JSLINT.properties_report(JSLINT.property);\n\n// You can obtain the parse tree that JSLint constructed while parsing. The\n// latest tree is kept in JSLINT.tree. A nice stringification can be produced\n// with\n\n//     JSON.stringify(JSLINT.tree, [\n//         'string',  'arity', 'name',  'first',\n//         'second', 'third', 'block', 'else'\n//     ], 4));\n\n// You can request a context coloring table. It contains information that can be\n// applied to the file that was analyzed. Context coloring colors functions\n// based on their nesting level, and variables on the color of the functions\n// in which they are defined.\n\n//      var myColorization = JSLINT.color(data);\n\n// It returns an array containing objects of this form:\n\n//      {\n//          from: COLUMN,\n//          thru: COLUMN,\n//          line: ROW,\n//          level: 0 or higher\n//      }\n\n// JSLint provides three inline directives. They look like slashstar comments,\n// and allow for setting options, declaring global variables, and establishing a\n// set of allowed property names.\n\n// These directives respect function scope.\n\n// The jslint directive is a special comment that can set one or more options.\n// For example:\n\n/*jslint\n    evil: true, nomen: true, regexp: true, todo: true\n*/\n\n// The current option set is\n\n//     ass        true, if assignment expressions should be allowed\n//     bitwise    true, if bitwise operators should be allowed\n//     browser    true, if the standard browser globals should be predefined\n//     closure    true, if Google Closure idioms should be tolerated\n//     continue   true, if the continuation statement should be tolerated\n//     debug      true, if debugger statements should be allowed\n//     devel      true, if logging should be allowed (console, alert, etc.)\n//     eqeq       true, if == should be allowed\n//     evil       true, if eval should be allowed\n//     forin      true, if for in statements need not filter\n//     indent     the indentation factor\n//     maxerr     the maximum number of errors to allow\n//     maxlen     the maximum length of a source line\n//     newcap     true, if constructor names capitalization is ignored\n//     node       true, if Node.js globals should be predefined\n//     nomen      true, if names may have dangling _\n//     passfail   true, if the scan should stop on first error\n//     plusplus   true, if increment/decrement should be allowed\n//     properties true, if all property names must be declared with /*properties*/\n//     regexp     true, if the . should be allowed in regexp literals\n//     rhino      true, if the Rhino environment globals should be predefined\n//     unparam    true, if unused parameters should be tolerated\n//     sloppy     true, if the 'use strict'; pragma is optional\n//     stupid     true, if really stupid practices are tolerated\n//     sub        true, if all forms of subscript notation are tolerated\n//     todo       true, if TODO comments are tolerated\n//     vars       true, if multiple var statements per function should be allowed\n//     white      true, if sloppy whitespace is tolerated\n\n// The properties directive declares an exclusive list of property names.\n// Any properties named in the program that are not in the list will\n// produce a warning.\n\n// For example:\n\n/*properties\n    '\\b', '\\t', '\\n', '\\f', '\\r', '!', '!=', '!==', '\"', '%', '\\'', '(begin)',\n    '(error)', '*', '+', '-', '/', '<', '<=', '==', '===', '>', '>=', '\\\\', a,\n    a_label, a_scope, already_defined, and, apply, arguments, arity, ass,\n    assign, assignment_expression, assignment_function_expression, at, avoid_a,\n    b, bad_assignment, bad_constructor, bad_in_a, bad_invocation, bad_new,\n    bad_number, bad_operand, bad_wrap, bitwise, block, break, breakage, browser,\n    c, call, charAt, charCodeAt, character, closure, code, color, combine_var,\n    comments, conditional_assignment, confusing_a, confusing_regexp,\n    constructor_name_a, continue, control_a, couch, create, d, dangling_a, data,\n    dead, debug, deleted, devel, disrupt, duplicate_a, edge, edition, elif,\n    else, empty_block, empty_case, empty_class, entityify, eqeq, error_report,\n    errors, evidence, evil, exception, exec, expected_a_at_b_c, expected_a_b,\n    expected_a_b_from_c_d, expected_id_a, expected_identifier_a,\n    expected_identifier_a_reserved, expected_number_a, expected_operator_a,\n    expected_positive_a, expected_small_a, expected_space_a_b,\n    expected_string_a, f, first, flag, floor, forEach, for_if, forin, from,\n    fromCharCode, fud, function, function_block, function_eval, function_loop,\n    function_statement, function_strict, functions, global, hasOwnProperty, id,\n    identifier, identifier_function, immed, implied_evil, indent, indexOf,\n    infix_in, init, insecure_a, isAlpha, isArray, isDigit, isNaN, join, jslint,\n    json, keys, kind, label, labeled, lbp, leading_decimal_a, led, left, length,\n    level, line, loopage, master, match, maxerr, maxlen, message, missing_a,\n    missing_a_after_b, missing_property, missing_space_a_b, missing_use_strict,\n    mode, move_invocation, move_var, n, name, name_function, nested_comment,\n    newcap, node, nomen, not, not_a_constructor, not_a_defined, not_a_function,\n    not_a_label, not_a_scope, not_greater, nud, number, octal_a, open, outer,\n    parameter, parameter_a_get_b, parameter_arguments_a, parameter_set_a,\n    params, paren, passfail, plusplus, pop, postscript, predef, properties,\n    properties_report, property, prototype, push, quote, r, radix, raw,\n    read_only, reason, redefinition_a_b, regexp, relation, replace, report,\n    reserved, reserved_a, rhino, right, scanned_a_b, scope, search, second,\n    shift, slash_equal, slice, sloppy, sort, split, statement, statement_block,\n    stop, stopping, strange_loop, strict, string, stupid, sub, subscript,\n    substr, supplant, sync_a, t, tag_a_in_b, test, third, thru, toString, todo,\n    todo_comment, token, tokens, too_long, too_many, trailing_decimal_a, tree,\n    unclosed, unclosed_comment, unclosed_regexp, unescaped_a, unexpected_a,\n    unexpected_char_a, unexpected_comment, unexpected_label_a,\n    unexpected_property_a, unexpected_space_a_b, unexpected_typeof_a,\n    uninitialized_a, unnecessary_else, unnecessary_initialize, unnecessary_use,\n    unparam, unreachable_a_b, unsafe, unused_a, url, use_array, use_braces,\n    use_nested_if, use_object, use_or, use_param, use_spaces, used,\n    used_before_a, var, var_a_not, var_loop, vars, varstatement, warn, warning,\n    was, weird_assignment, weird_condition, weird_new, weird_program,\n    weird_relation, weird_ternary, white, wrap, wrap_immediate, wrap_regexp,\n    write_is_wrong, writeable\n*/\n\n// The global directive is used to declare global variables that can\n// be accessed by the program. If a declaration is true, then the variable\n// is writeable. Otherwise, it is read-only.\n\n// We build the application inside a function so that we produce only a single\n// global variable. That function will be invoked immediately, and its return\n// value is the JSLINT function itself. That function is also an object that\n// can contain data and other functions.\n\nvar JSLINT = (function () {\n    'use strict';\n\n    function array_to_object(array, value) {\n\n// Make an object from an array of keys and a common value.\n\n        var i, length = array.length, object = Object.create(null);\n        for (i = 0; i < length; i += 1) {\n            object[array[i]] = value;\n        }\n        return object;\n    }\n\n\n    var allowed_option = {\n            ass       : true,\n            bitwise   : true,\n            browser   : true,\n            closure   : true,\n            continue  : true,\n            couch     : true,\n            debug     : true,\n            devel     : true,\n            eqeq      : true,\n            evil      : true,\n            forin     : true,\n            indent    :   10,\n            maxerr    : 1000,\n            maxlen    :  256,\n            newcap    : true,\n            node      : true,\n            nomen     : true,\n            passfail  : true,\n            plusplus  : true,\n            properties: true,\n            regexp    : true,\n            rhino     : true,\n            unparam   : true,\n            sloppy    : true,\n            stupid    : true,\n            sub       : true,\n            todo      : true,\n            vars      : true,\n            white     : true\n        },\n        anonname,       // The guessed name for anonymous functions.\n\n// These are operators that should not be used with the ! operator.\n\n        bang = {\n            '<'  : true,\n            '<=' : true,\n            '==' : true,\n            '===': true,\n            '!==': true,\n            '!=' : true,\n            '>'  : true,\n            '>=' : true,\n            '+'  : true,\n            '-'  : true,\n            '*'  : true,\n            '/'  : true,\n            '%'  : true\n        },\n        begin,          // The root token\n        block_var,     // vars defined in the current block\n\n// browser contains a set of global names that are commonly provided by a\n// web browser environment.\n\n        browser = array_to_object([\n            'clearInterval', 'clearTimeout', 'document', 'event', 'FormData',\n            'frames', 'history', 'Image', 'localStorage', 'location', 'name',\n            'navigator', 'Option', 'parent', 'screen', 'sessionStorage',\n            'setInterval', 'setTimeout', 'Storage', 'window', 'XMLHttpRequest'\n        ], false),\n\n// bundle contains the text messages.\n\n        bundle = {\n            a_label: \"'{a}' is a statement label.\",\n            a_scope: \"'{a}' used out of scope.\",\n            already_defined: \"'{a}' is already defined.\",\n            and: \"The '&&' subexpression should be wrapped in parens.\",\n            assignment_expression: \"Unexpected assignment expression.\",\n            assignment_function_expression: \"Expected an assignment or \" +\n                \"function call and instead saw an expression.\",\n            avoid_a: \"Avoid '{a}'.\",\n            bad_assignment: \"Bad assignment.\",\n            bad_constructor: \"Bad constructor.\",\n            bad_in_a: \"Bad for in variable '{a}'.\",\n            bad_invocation: \"Bad invocation.\",\n            bad_new: \"Do not use 'new' for side effects.\",\n            bad_number: \"Bad number '{a}'.\",\n            bad_operand: \"Bad operand.\",\n            bad_wrap: \"Do not wrap function literals in parens unless they \" +\n                \"are to be immediately invoked.\",\n            combine_var: \"Combine this with the previous 'var' statement.\",\n            conditional_assignment: \"Expected a conditional expression and \" +\n                \"instead saw an assignment.\",\n            confusing_a: \"Confusing use of '{a}'.\",\n            confusing_regexp: \"Confusing regular expression.\",\n            constructor_name_a: \"A constructor name '{a}' should start with \" +\n                \"an uppercase letter.\",\n            control_a: \"Unexpected control character '{a}'.\",\n            dangling_a: \"Unexpected dangling '_' in '{a}'.\",\n            deleted: \"Only properties should be deleted.\",\n            duplicate_a: \"Duplicate '{a}'.\",\n            empty_block: \"Empty block.\",\n            empty_case: \"Empty case.\",\n            empty_class: \"Empty class.\",\n            evil: \"eval is evil.\",\n            expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n            expected_a_b_from_c_d: \"Expected '{a}' to match '{b}' from line \" +\n                \"{c} and instead saw '{d}'.\",\n            expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n            expected_id_a: \"Expected an id, and instead saw #{a}.\",\n            expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n            expected_identifier_a_reserved: \"Expected an identifier and \" +\n                \"instead saw '{a}' (a reserved word).\",\n            expected_number_a: \"Expected a number and instead saw '{a}'.\",\n            expected_operator_a: \"Expected an operator and instead saw '{a}'.\",\n            expected_positive_a: \"Expected a positive number and instead saw '{a}'\",\n            expected_small_a: \"Expected a small positive integer and instead saw '{a}'\",\n            expected_space_a_b: \"Expected exactly one space between '{a}' and '{b}'.\",\n            expected_string_a: \"Expected a string and instead saw '{a}'.\",\n            for_if: \"The body of a for in should be wrapped in an if \" +\n                \"statement to filter unwanted properties from the prototype.\",\n            function_block: \"Function statements should not be placed in blocks.\" +\n                \"Use a function expression or move the statement to the top of \" +\n                \"the outer function.\",\n            function_eval: \"The Function constructor is eval.\",\n            function_loop: \"Don't make functions within a loop.\",\n            function_statement: \"Function statements are not invocable. \" +\n                \"Wrap the whole function invocation in parens.\",\n            function_strict: \"Use the function form of 'use strict'.\",\n            identifier_function: \"Expected an identifier in an assignment \" +\n                \"and instead saw a function invocation.\",\n            implied_evil: \"Implied eval is evil. Pass a function instead of a string.\",\n            infix_in: \"Unexpected 'in'. Compare with undefined, or use the \" +\n                \"hasOwnProperty method instead.\",\n            insecure_a: \"Insecure '{a}'.\",\n            isNaN: \"Use the isNaN function to compare with NaN.\",\n            leading_decimal_a: \"A leading decimal point can be confused with a dot: '.{a}'.\",\n            missing_a: \"Missing '{a}'.\",\n            missing_a_after_b: \"Missing '{a}' after '{b}'.\",\n            missing_property: \"Missing property name.\",\n            missing_space_a_b: \"Missing space between '{a}' and '{b}'.\",\n            missing_use_strict: \"Missing 'use strict' statement.\",\n            move_invocation: \"Move the invocation into the parens that \" +\n                \"contain the function.\",\n            move_var: \"Move 'var' declarations to the top of the function.\",\n            name_function: \"Missing name in function statement.\",\n            nested_comment: \"Nested comment.\",\n            not: \"Nested not.\",\n            not_a_constructor: \"Do not use {a} as a constructor.\",\n            not_a_defined: \"'{a}' has not been fully defined yet.\",\n            not_a_function: \"'{a}' is not a function.\",\n            not_a_label: \"'{a}' is not a label.\",\n            not_a_scope: \"'{a}' is out of scope.\",\n            not_greater: \"'{a}' should not be greater than '{b}'.\",\n            octal_a: \"Don't use octal: '{a}'. Use '\\\\u....' instead.\",\n            parameter_arguments_a: \"Do not mutate parameter '{a}' when using 'arguments'.\",\n            parameter_a_get_b: \"Unexpected parameter '{a}' in get {b} function.\",\n            parameter_set_a: \"Expected parameter (value) in set {a} function.\",\n            radix: \"Missing radix parameter.\",\n            read_only: \"Read only.\",\n            redefinition_a_b: \"Redefinition of '{a}' from line {b}.\",\n            reserved_a: \"Reserved name '{a}'.\",\n            scanned_a_b: \"{a} ({b}% scanned).\",\n            slash_equal: \"A regular expression literal can be confused with '/='.\",\n            statement_block: \"Expected to see a statement and instead saw a block.\",\n            stopping: \"Stopping.\",\n            strange_loop: \"Strange loop.\",\n            strict: \"Strict violation.\",\n            subscript: \"['{a}'] is better written in dot notation.\",\n            sync_a: \"Unexpected sync method: '{a}'.\",\n            tag_a_in_b: \"A '<{a}>' must be within '<{b}>'.\",\n            todo_comment: \"Unexpected TODO comment.\",\n            too_long: \"Line too long.\",\n            too_many: \"Too many errors.\",\n            trailing_decimal_a: \"A trailing decimal point can be confused \" +\n                \"with a dot: '.{a}'.\",\n            unclosed: \"Unclosed string.\",\n            unclosed_comment: \"Unclosed comment.\",\n            unclosed_regexp: \"Unclosed regular expression.\",\n            unescaped_a: \"Unescaped '{a}'.\",\n            unexpected_a: \"Unexpected '{a}'.\",\n            unexpected_char_a: \"Unexpected character '{a}'.\",\n            unexpected_comment: \"Unexpected comment.\",\n            unexpected_label_a: \"Unexpected label '{a}'.\",\n            unexpected_property_a: \"Unexpected /*property*/ '{a}'.\",\n            unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n            unexpected_typeof_a: \"Unexpected 'typeof'. \" +\n                \"Use '===' to compare directly with {a}.\",\n            uninitialized_a: \"Uninitialized '{a}'.\",\n            unnecessary_else: \"Unnecessary 'else' after disruption.\",\n            unnecessary_initialize: \"It is not necessary to initialize '{a}' \" +\n                \"to 'undefined'.\",\n            unnecessary_use: \"Unnecessary 'use strict'.\",\n            unreachable_a_b: \"Unreachable '{a}' after '{b}'.\",\n            unsafe: \"Unsafe character.\",\n            unused_a: \"Unused '{a}'.\",\n            url: \"JavaScript URL.\",\n            use_array: \"Use the array literal notation [].\",\n            use_braces: \"Spaces are hard to count. Use {{a}}.\",\n            use_nested_if: \"Expected 'else { if' and instead saw 'else if'.\",\n            use_object: \"Use the object literal notation {} or Object.create(null).\",\n            use_or: \"Use the || operator.\",\n            use_param: \"Use a named parameter.\",\n            use_spaces: \"Use spaces, not tabs.\",\n            used_before_a: \"'{a}' was used before it was defined.\",\n            var_a_not: \"Variable {a} was not declared correctly.\",\n            var_loop: \"Don't declare variables in a loop.\",\n            weird_assignment: \"Weird assignment.\",\n            weird_condition: \"Weird condition.\",\n            weird_new: \"Weird construction. Delete 'new'.\",\n            weird_program: \"Weird program.\",\n            weird_relation: \"Weird relation.\",\n            weird_ternary: \"Weird ternary.\",\n            wrap_immediate: \"Wrap an immediate function invocation in \" +\n                \"parentheses to assist the reader in understanding that the \" +\n                \"expression is the result of a function, and not the \" +\n                \"function itself.\",\n            wrap_regexp: \"Wrap the /regexp/ literal in parens to \" +\n                \"disambiguate the slash operator.\",\n            write_is_wrong: \"document.write can be a form of eval.\"\n        },\n        closure = array_to_object([\n            'goog'\n        ], false),\n        comments,\n        comments_off,\n        couch = array_to_object([\n            'emit', 'getRow', 'isArray', 'log', 'provides', 'registerType',\n            'require', 'send', 'start', 'sum', 'toJSON'\n        ], false),\n\n        descapes = {\n            'b': '\\b',\n            't': '\\t',\n            'n': '\\n',\n            'f': '\\f',\n            'r': '\\r',\n            '\"': '\"',\n            '/': '/',\n            '\\\\': '\\\\',\n            '!': '!'\n        },\n\n        devel = array_to_object([\n            'alert', 'confirm', 'console', 'Debug', 'opera', 'prompt', 'WSH'\n        ], false),\n        directive,\n        escapes = {\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\\'': '\\\\\\'',\n            '\"' : '\\\\\"',\n            '/' : '\\\\/',\n            '\\\\': '\\\\\\\\'\n        },\n\n        funct,          // The current function\n\n        functions,      // All of the functions\n        global_funct,   // The global body\n        global_scope,   // The global scope\n        in_block,       // Where function statements are not allowed\n        indent,\n        itself,         // JSLINT itself\n        json_mode,\n        lex,            // the tokenizer\n        lines,\n        lookahead,\n        node = array_to_object([\n            'Buffer', 'clearImmediate', 'clearInterval', 'clearTimeout',\n            'console', 'exports', 'global', 'module', 'process',\n            'require', 'setImmediate', 'setInterval', 'setTimeout',\n            '__dirname', '__filename'\n        ], false),\n        node_js,\n        numbery = array_to_object(['indexOf', 'lastIndexOf', 'search'], true),\n        next_token,\n        option,\n        predefined,     // Global variables defined by option\n        prereg,\n        prev_token,\n        property,\n        protosymbol,\n        regexp_flag = array_to_object(['g', 'i', 'm'], true),\n        return_this = function return_this() {\n            return this;\n        },\n        rhino = array_to_object([\n            'defineClass', 'deserialize', 'gc', 'help', 'load', 'loadClass',\n            'print', 'quit', 'readFile', 'readUrl', 'runCommand', 'seal',\n            'serialize', 'spawn', 'sync', 'toint32', 'version'\n        ], false),\n\n        scope,      // An object containing an object for each variable in scope\n        semicolon_coda = array_to_object([';', '\"', '\\'', ')'], true),\n\n// standard contains the global names that are provided by the\n// ECMAScript standard.\n\n        standard = array_to_object([\n            'Array', 'Boolean', 'Date', 'decodeURI', 'decodeURIComponent',\n            'encodeURI', 'encodeURIComponent', 'Error', 'eval', 'EvalError',\n            'Function', 'isFinite', 'isNaN', 'JSON', 'Map', 'Math', 'Number',\n            'Object', 'parseInt', 'parseFloat', 'Promise', 'Proxy',\n            'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set',\n            'String', 'Symbol', 'SyntaxError', 'System', 'TypeError',\n            'URIError', 'WeakMap', 'WeakSet'\n        ], false),\n\n        strict_mode,\n        syntax = Object.create(null),\n        token,\n        tokens,\n        var_mode,\n        warnings,\n\n// Regular expressions. Some of these are stupidly long.\n\n// carriage return, carriage return linefeed, or linefeed\n        crlfx = /\\r\\n?|\\n/,\n// unsafe characters that are silently deleted by one or more browsers\n        cx = /[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n// identifier\n        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,\n// javascript url\n        jx = /^(?:javascript|jscript|ecmascript|vbscript)\\s*:/i,\n// star slash\n        lx = /\\*\\/|\\/\\*/,\n// characters in strings that need escapement\n        nx = /[\\u0000-\\u001f'\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n// sync\n        syx = /Sync$/,\n// comment todo\n        tox = /^\\W*to\\s*do(?:\\W|$)/i,\n// token\n        tx = /^\\s*([(){}\\[\\]\\?.,:;'\"~#@`]|={1,3}|\\/(\\*(jslint|properties|property|members?|globals?)?|=|\\/)?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|[\\^%]=?|&[&=]?|\\|[|=]?|>{1,3}=?|<(?:[\\/=!]|\\!(\\[|--)?|<=?)?|\\!(\\!|==?)?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+(?:[xX][0-9a-fA-F]+|\\.[0-9]*)?(?:[eE][+\\-]?[0-9]+)?)/;\n\n\n    if (typeof String.prototype.entityify !== 'function') {\n        String.prototype.entityify = function () {\n            return this\n                .replace(/&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;');\n        };\n    }\n\n    if (typeof String.prototype.isAlpha !== 'function') {\n        String.prototype.isAlpha = function () {\n            return (this >= 'a' && this <= 'z\\uffff') ||\n                (this >= 'A' && this <= 'Z\\uffff');\n        };\n    }\n\n    if (typeof String.prototype.isDigit !== 'function') {\n        String.prototype.isDigit = function () {\n            return (this >= '0' && this <= '9');\n        };\n    }\n\n    if (typeof String.prototype.supplant !== 'function') {\n        String.prototype.supplant = function (o) {\n            return this.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n                var replacement = o[b];\n                return typeof replacement === 'string' ||\n                    typeof replacement === 'number' ? replacement : a;\n            });\n        };\n    }\n\n\n    function sanitize(a) {\n\n//  Escapify a troublesome character.\n\n        return escapes[a] ||\n            '\\\\u' + ('0000' + a.charCodeAt().toString(16)).slice(-4);\n    }\n\n\n    function add_to_predefined(group) {\n        Object.keys(group).forEach(function (name) {\n            predefined[name] = group[name];\n        });\n    }\n\n\n    function assume() {\n        if (option.browser) {\n            add_to_predefined(browser);\n            option.browser = false;\n        }\n        if (option.closure) {\n            add_to_predefined(closure);\n        }\n        if (option.couch) {\n            add_to_predefined(couch);\n            option.couch = false;\n        }\n        if (option.devel) {\n            add_to_predefined(devel);\n            option.devel = false;\n        }\n        if (option.node) {\n            add_to_predefined(node);\n            option.node = false;\n            node_js = true;\n        }\n        if (option.rhino) {\n            add_to_predefined(rhino);\n            option.rhino = false;\n        }\n    }\n\n\n// Produce an error warning.\n\n    function artifact(tok) {\n        if (!tok) {\n            tok = next_token;\n        }\n        return tok.id === '(number)' ? tok.number : tok.string;\n    }\n\n    function quit(message, line, character) {\n        throw {\n            name: 'JSLintError',\n            line: line,\n            character: character,\n            message: bundle.scanned_a_b.supplant({\n                a: bundle[message] || message,\n                b: Math.floor((line / lines.length) * 100)\n            })\n        };\n    }\n\n    function warn(code, line, character, a, b, c, d) {\n        var warning = {         // ~~\n            id: '(error)',\n            raw: bundle[code] || code,\n            code: code,\n            evidence: lines[line - 1] || '',\n            line: line,\n            character: character,\n            a: a || artifact(this),\n            b: b,\n            c: c,\n            d: d\n        };\n        warning.reason = warning.raw.supplant(warning);\n        itself.errors.push(warning);\n        if (option.passfail) {\n            quit('stopping', line, character);\n        }\n        warnings += 1;\n        if (warnings >= option.maxerr) {\n            quit('too_many', line, character);\n        }\n        return warning;\n    }\n\n    function stop(code, line, character, a, b, c, d) {\n        var warning = warn(code, line, character, a, b, c, d);\n        quit('stopping', warning.line, warning.character);\n    }\n\n    function expected_at(at) {\n        if (!option.white && next_token.from !== at) {\n            next_token.warn('expected_a_at_b_c', '', at, next_token.from);\n        }\n    }\n\n// lexical analysis and token construction\n\n    lex = (function lex() {\n        var character, c, from, length, line, pos, source_row;\n\n// Private lex methods\n\n        function next_line() {\n            var at;\n            character = 1;\n            source_row = lines[line];\n            line += 1;\n            if (source_row === undefined) {\n                return false;\n            }\n            at = source_row.search(/\\t/);\n            if (at >= 0) {\n                if (option.white) {\n                    source_row = source_row.replace(/\\t/g, ' ');\n                } else {\n                    warn('use_spaces', line, at + 1);\n                }\n            }\n            at = source_row.search(cx);\n            if (at >= 0) {\n                warn('unsafe', line, at);\n            }\n            if (option.maxlen && option.maxlen < source_row.length) {\n                warn('too_long', line, source_row.length);\n            }\n            return true;\n        }\n\n// Produce a token object.  The token inherits from a syntax symbol.\n\n        function it(type, value) {\n            var id, the_token;\n            if (type === '(string)') {\n                if (jx.test(value)) {\n                    warn('url', line, from);\n                }\n            }\n            the_token = Object.create(syntax[(\n                type === '(punctuator)' || (type === '(identifier)' &&\n                        Object.prototype.hasOwnProperty.call(syntax, value))\n                    ? value\n                    : type\n            )] || syntax['(error)']);\n            if (type === '(identifier)') {\n                the_token.identifier = true;\n                if (value === '__iterator__' || value === '__proto__') {\n                    stop('reserved_a', line, from, value);\n                } else if (!option.nomen &&\n                        (value.charAt(0) === '_' ||\n                        value.charAt(value.length - 1) === '_')) {\n                    warn('dangling_a', line, from, value);\n                }\n            }\n            if (type === '(number)') {\n                the_token.number = +value;\n            } else if (value !== undefined) {\n                the_token.string = String(value);\n            }\n            the_token.line = line;\n            the_token.from = from;\n            the_token.thru = character;\n            if (comments.length) {\n                the_token.comments = comments;\n                comments = [];\n            }\n            id = the_token.id;\n            prereg = id && (\n                ('(,=:[!&|?{};~+-*%^<>'.indexOf(id.charAt(id.length - 1)) >= 0) ||\n                id === 'return' || id === 'case'\n            );\n            return the_token;\n        }\n\n        function match(x) {\n            var exec = x.exec(source_row), first;\n            if (exec) {\n                length = exec[0].length;\n                first = exec[1];\n                c = first.charAt(0);\n                source_row = source_row.slice(length);\n                from = character + length - first.length;\n                character += length;\n                return first;\n            }\n            for (;;) {\n                if (!source_row) {\n                    if (!option.white) {\n                        warn('unexpected_char_a', line, character - 1, '(space)');\n                    }\n                    return;\n                }\n                c = source_row.charAt(0);\n                if (c !== ' ') {\n                    break;\n                }\n                source_row = source_row.slice(1);\n                character += 1;\n            }\n            stop('unexpected_char_a', line, character, c);\n\n        }\n\n        function string(x) {\n            var ch, at = 0, r = '', result;\n\n            function hex(n) {\n                var i = parseInt(source_row.substr(at + 1, n), 16);\n                at += n;\n                if (i >= 32 && i <= 126 &&\n                        i !== 34 && i !== 92 && i !== 39) {\n                    warn('unexpected_a', line, character, '\\\\');\n                }\n                character += n;\n                ch = String.fromCharCode(i);\n            }\n\n            if (json_mode && x !== '\"') {\n                warn('expected_a_b', line, character, '\"', x);\n            }\n\n            for (;;) {\n                while (at >= source_row.length) {\n                    at = 0;\n                    if (!next_line()) {\n                        stop('unclosed', line - 1, from);\n                    }\n                }\n                ch = source_row.charAt(at);\n                if (ch === x) {\n                    character += 1;\n                    source_row = source_row.slice(at + 1);\n                    result = it('(string)', r);\n                    result.quote = x;\n                    return result;\n                }\n                if (ch < ' ') {\n                    if (ch === '\\n' || ch === '\\r') {\n                        break;\n                    }\n                    warn('control_a', line, character + at,\n                        source_row.slice(0, at));\n                } else if (ch === '\\\\') {\n                    at += 1;\n                    character += 1;\n                    ch = source_row.charAt(at);\n                    switch (ch) {\n                    case '':\n                        warn('unexpected_a', line, character, '\\\\');\n                        next_line();\n                        at = -1;\n                        break;\n                    case '\\'':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\\\'');\n                        }\n                        break;\n                    case 'u':\n                        hex(4);\n                        break;\n                    case 'v':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\v');\n                        }\n                        ch = '\\v';\n                        break;\n                    case 'x':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\x');\n                        }\n                        hex(2);\n                        break;\n                    default:\n                        if (typeof descapes[ch] !== 'string') {\n                            warn(ch >= '0' && ch <= '7' ? 'octal_a' : 'unexpected_a',\n                                line, character, '\\\\' + ch);\n                        } else {\n                            ch = descapes[ch];\n                        }\n                    }\n                }\n                r += ch;\n                character += 1;\n                at += 1;\n            }\n        }\n\n        function number(snippet) {\n            var digit;\n            if (source_row.charAt(0).isAlpha()) {\n                warn('expected_space_a_b',\n                    line, character, c, source_row.charAt(0));\n            }\n            if (c === '0') {\n                digit = snippet.charAt(1);\n                if (digit.isDigit()) {\n                    if (token.id !== '.') {\n                        warn('unexpected_a', line, character, snippet);\n                    }\n                } else if (json_mode && (digit === 'x' || digit === 'X')) {\n                    warn('unexpected_a', line, character, '0x');\n                }\n            }\n            if (snippet.slice(snippet.length - 1) === '.') {\n                warn('trailing_decimal_a', line, character, snippet);\n            }\n            digit = +snippet;\n            if (!isFinite(digit)) {\n                warn('bad_number', line, character, snippet);\n            }\n            snippet = digit;\n            return it('(number)', snippet);\n        }\n\n        function comment(snippet, type) {\n            if (comments_off) {\n                warn('unexpected_comment', line, character);\n            } else if (!option.todo && tox.test(snippet)) {\n                warn('todo_comment', line, character);\n            }\n            comments.push({\n                id: type,\n                from: from,\n                thru: character,\n                line: line,\n                string: snippet\n            });\n        }\n\n        function regexp() {\n            var at = 0,\n                b,\n                bit,\n                depth = 0,\n                flag = '',\n                high,\n                letter,\n                low,\n                potential,\n                quote,\n                result;\n            for (;;) {\n                b = true;\n                c = source_row.charAt(at);\n                at += 1;\n                switch (c) {\n                case '':\n                    stop('unclosed_regexp', line, from);\n                    return;\n                case '/':\n                    if (depth > 0) {\n                        warn('unescaped_a', line, from + at, '/');\n                    }\n                    c = source_row.slice(0, at - 1);\n                    potential = Object.create(regexp_flag);\n                    for (;;) {\n                        letter = source_row.charAt(at);\n                        if (potential[letter] !== true) {\n                            break;\n                        }\n                        potential[letter] = false;\n                        at += 1;\n                        flag += letter;\n                    }\n                    if (source_row.charAt(at).isAlpha()) {\n                        stop('unexpected_a', line, from, source_row.charAt(at));\n                    }\n                    character += at;\n                    source_row = source_row.slice(at);\n                    quote = source_row.charAt(0);\n                    if (quote === '/' || quote === '*') {\n                        stop('confusing_regexp', line, from);\n                    }\n                    result = it('(regexp)', c);\n                    result.flag = flag;\n                    return result;\n                case '\\\\':\n                    c = source_row.charAt(at);\n                    if (c < ' ') {\n                        warn('control_a', line, from + at, String(c));\n                    } else if (c === '<') {\n                        warn('unexpected_a', line, from + at, '\\\\');\n                    }\n                    at += 1;\n                    break;\n                case '(':\n                    depth += 1;\n                    b = false;\n                    if (source_row.charAt(at) === '?') {\n                        at += 1;\n                        switch (source_row.charAt(at)) {\n                        case ':':\n                        case '=':\n                        case '!':\n                            at += 1;\n                            break;\n                        default:\n                            warn('expected_a_b', line, from + at,\n                                ':', source_row.charAt(at));\n                        }\n                    }\n                    break;\n                case '|':\n                    b = false;\n                    break;\n                case ')':\n                    if (depth === 0) {\n                        warn('unescaped_a', line, from + at, ')');\n                    } else {\n                        depth -= 1;\n                    }\n                    break;\n                case ' ':\n                    pos = 1;\n                    while (source_row.charAt(at) === ' ') {\n                        at += 1;\n                        pos += 1;\n                    }\n                    if (pos > 1) {\n                        warn('use_braces', line, from + at, pos);\n                    }\n                    break;\n                case '[':\n                    c = source_row.charAt(at);\n                    if (c === '^') {\n                        at += 1;\n                        if (!option.regexp) {\n                            warn('insecure_a', line, from + at, c);\n                        } else if (source_row.charAt(at) === ']') {\n                            stop('unescaped_a', line, from + at, '^');\n                        }\n                    }\n                    bit = false;\n                    if (c === ']') {\n                        warn('empty_class', line, from + at - 1);\n                        bit = true;\n                    }\nklass:              do {\n                        c = source_row.charAt(at);\n                        at += 1;\n                        switch (c) {\n                        case '[':\n                        case '^':\n                            warn('unescaped_a', line, from + at, c);\n                            bit = true;\n                            break;\n                        case '-':\n                            if (bit) {\n                                bit = false;\n                            } else {\n                                warn('unescaped_a', line, from + at, '-');\n                                bit = true;\n                            }\n                            break;\n                        case ']':\n                            if (!bit) {\n                                warn('unescaped_a', line, from + at - 1, '-');\n                            }\n                            break klass;\n                        case '\\\\':\n                            c = source_row.charAt(at);\n                            if (c < ' ') {\n                                warn('control_a', line, from + at, String(c));\n                            } else if (c === '<') {\n                                warn('unexpected_a', line, from + at, '\\\\');\n                            }\n                            at += 1;\n                            bit = true;\n                            break;\n                        case '/':\n                            warn('unescaped_a', line, from + at - 1, '/');\n                            bit = true;\n                            break;\n                        default:\n                            bit = true;\n                        }\n                    } while (c);\n                    break;\n                case '.':\n                    if (!option.regexp) {\n                        warn('insecure_a', line, from + at, c);\n                    }\n                    break;\n                case ']':\n                case '?':\n                case '{':\n                case '}':\n                case '+':\n                case '*':\n                    warn('unescaped_a', line, from + at, c);\n                    break;\n                }\n                if (b) {\n                    switch (source_row.charAt(at)) {\n                    case '?':\n                    case '+':\n                    case '*':\n                        at += 1;\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        break;\n                    case '{':\n                        at += 1;\n                        c = source_row.charAt(at);\n                        if (c < '0' || c > '9') {\n                            warn('expected_number_a', line,\n                                from + at, c);\n                        }\n                        at += 1;\n                        low = +c;\n                        for (;;) {\n                            c = source_row.charAt(at);\n                            if (c < '0' || c > '9') {\n                                break;\n                            }\n                            at += 1;\n                            low = +c + (low * 10);\n                        }\n                        high = low;\n                        if (c === ',') {\n                            at += 1;\n                            high = Infinity;\n                            c = source_row.charAt(at);\n                            if (c >= '0' && c <= '9') {\n                                at += 1;\n                                high = +c;\n                                for (;;) {\n                                    c = source_row.charAt(at);\n                                    if (c < '0' || c > '9') {\n                                        break;\n                                    }\n                                    at += 1;\n                                    high = +c + (high * 10);\n                                }\n                            }\n                        }\n                        if (source_row.charAt(at) !== '}') {\n                            warn('expected_a_b', line, from + at,\n                                '}', c);\n                        } else {\n                            at += 1;\n                        }\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        if (low > high) {\n                            warn('not_greater', line, from + at,\n                                low, high);\n                        }\n                        break;\n                    }\n                }\n            }\n            c = source_row.slice(0, at - 1);\n            character += at;\n            source_row = source_row.slice(at);\n            return it('(regexp)', c);\n        }\n\n// Public lex methods\n\n        return {\n            init: function (source) {\n                if (typeof source === 'string') {\n                    lines = source.split(crlfx);\n                } else {\n                    lines = source;\n                }\n                line = 0;\n                next_line();\n                from = 1;\n            },\n\n// token -- this is called by advance to get the next token.\n\n            token: function () {\n                var first, i, snippet;\n\n                for (;;) {\n                    while (!source_row) {\n                        if (!next_line()) {\n                            return it('(end)');\n                        }\n                    }\n                    snippet = match(tx);\n                    if (snippet) {\n\n//      identifier\n\n                        first = snippet.charAt(0);\n                        if (first.isAlpha() || first === '_' || first === '$') {\n                            return it('(identifier)', snippet);\n                        }\n\n//      number\n\n                        if (first.isDigit()) {\n                            return number(snippet);\n                        }\n                        switch (snippet) {\n\n//      string\n\n                        case '\"':\n                        case \"'\":\n                            return string(snippet);\n\n//      // comment\n\n                        case '//':\n                            comment(source_row, '//');\n                            source_row = '';\n                            break;\n\n//      /* comment\n\n                        case '/*':\n                            for (;;) {\n                                i = source_row.search(lx);\n                                if (i >= 0) {\n                                    break;\n                                }\n                                character = source_row.length;\n                                comment(source_row);\n                                from = 0;\n                                if (!next_line()) {\n                                    stop('unclosed_comment', line, character);\n                                }\n                            }\n                            comment(source_row.slice(0, i), '/*');\n                            character += i + 2;\n                            if (source_row.charAt(i) === '/') {\n                                stop('nested_comment', line, character);\n                            }\n                            source_row = source_row.slice(i + 2);\n                            break;\n\n                        case '':\n                            break;\n//      /\n                        case '/':\n                            if (token.id === '/=') {\n                                stop('slash_equal', line, from);\n                            }\n                            return prereg\n                                ? regexp()\n                                : it('(punctuator)', snippet);\n\n//      punctuator\n                        default:\n                            return it('(punctuator)', snippet);\n                        }\n                    }\n                }\n            }\n        };\n    }());\n\n    function define(kind, token) {\n\n// Define a name.\n\n        var name = token.string,\n            master = scope[name];       // The current definition of the name\n\n// vars are created with a deadzone, so that the expression that initializes\n// the var cannot access the var. Functions are not writeable.\n\n        token.dead = false;\n        token.init = false;\n        token.kind = kind;\n        token.master = master;\n        token.used = 0;\n        token.writeable = true;\n\n// Global variables are a little weird. They can be defined multiple times.\n// Some predefined global vars are (or should) not be writeable.\n\n        if (kind === 'var' && funct === global_funct) {\n            if (!master) {\n                if (predefined[name] === false) {\n                    token.writeable = false;\n                }\n                global_scope[name] = token;\n            }\n        } else {\n\n// It is an error if the name has already been defined in this scope, except\n// when reusing an exception variable name.\n\n            if (master) {\n                if (master.function === funct) {\n                    if (master.kind !== 'exception' || kind !== 'exception' ||\n                            !master.dead) {\n                        token.warn('already_defined', name);\n                    }\n                } else if (master.function !== global_funct) {\n                    if (kind === 'var') {\n                        token.warn('redefinition_a_b', name, master.line);\n                    }\n                }\n            }\n            scope[name] = token;\n            if (kind === 'var') {\n                block_var.push(name);\n            }\n        }\n    }\n\n    function peek(distance) {\n\n// Peek ahead to a future token. The distance is how far ahead to look. The\n// default is the next token.\n\n        var found, slot = 0;\n\n        distance = distance || 0;\n        while (slot <= distance) {\n            found = lookahead[slot];\n            if (!found) {\n                found = lookahead[slot] = lex.token();\n            }\n            slot += 1;\n        }\n        return found;\n    }\n\n\n    function advance(id, match) {\n\n// Produce the next token, also looking for programming errors.\n\n        if (indent) {\n\n// If indentation checking was requested, then inspect all of the line breakings.\n// The var statement is tricky because the names might be aligned or not. We\n// look at the first line break after the var to determine the programmer's\n// intention.\n\n            if (var_mode && next_token.line !== token.line) {\n                if ((var_mode !== indent || !next_token.edge) &&\n                        next_token.from === indent.at -\n                        (next_token.edge ? option.indent : 0)) {\n                    var dent = indent;\n                    for (;;) {\n                        dent.at -= option.indent;\n                        if (dent === var_mode) {\n                            break;\n                        }\n                        dent = dent.was;\n                    }\n                    dent.open = false;\n                }\n                var_mode = null;\n            }\n            if (next_token.id === '?' && indent.mode === ':' &&\n                    token.line !== next_token.line) {\n                indent.at -= option.indent;\n            }\n            if (indent.open) {\n\n// If the token is an edge.\n\n                if (next_token.edge) {\n                    if (next_token.edge === 'label') {\n                        expected_at(1);\n                    } else if (next_token.edge === 'case' || indent.mode === 'statement') {\n                        expected_at(indent.at - option.indent);\n                    } else if (indent.mode !== 'array' || next_token.line !== token.line) {\n                        expected_at(indent.at);\n                    }\n\n// If the token is not an edge, but is the first token on the line.\n\n                } else if (next_token.line !== token.line) {\n                    if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                    indent.wrap = true;\n                }\n            } else if (next_token.line !== token.line) {\n                if (next_token.edge) {\n                    expected_at(indent.at);\n                } else {\n                    indent.wrap = true;\n                    if (indent.mode === 'statement' || indent.mode === 'var') {\n                        expected_at(indent.at + option.indent);\n                    } else if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                }\n            }\n        }\n\n        switch (token.id) {\n        case '(number)':\n            if (next_token.id === '.') {\n                next_token.warn('trailing_decimal_a');\n            }\n            break;\n        case '-':\n            if (next_token.id === '-' || next_token.id === '--') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        case '+':\n            if (next_token.id === '+' || next_token.id === '++') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        }\n        if (token.id === '(string)' || token.identifier) {\n            anonname = token.string;\n        }\n\n        if (id && next_token.id !== id) {\n            if (match) {\n                next_token.warn('expected_a_b_from_c_d', id,\n                    match.id, match.line, artifact());\n            } else if (!next_token.identifier || next_token.string !== id) {\n                next_token.warn('expected_a_b', id, artifact());\n            }\n        }\n        prev_token = token;\n        token = next_token;\n        next_token = lookahead.shift() || lex.token();\n        next_token.function = funct;\n        tokens.push(next_token);\n    }\n\n\n    function do_globals() {\n        var name, writeable;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            writeable = false;\n            if (next_token.id === ':') {\n                advance(':');\n                switch (next_token.id) {\n                case 'true':\n                    writeable = predefined[name] !== false;\n                    advance('true');\n                    break;\n                case 'false':\n                    advance('false');\n                    break;\n                default:\n                    next_token.stop('unexpected_a');\n                }\n            }\n            predefined[name] = writeable;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    function do_jslint() {\n        var name, value;\n        while (next_token.id === '(string)' || next_token.identifier) {\n            name = next_token.string;\n            if (!allowed_option[name]) {\n                next_token.stop('unexpected_a');\n            }\n            advance();\n            if (next_token.id !== ':') {\n                next_token.stop('expected_a_b', ':', artifact());\n            }\n            advance(':');\n            if (typeof allowed_option[name] === 'number') {\n                value = next_token.number;\n                if (value > allowed_option[name] || value <= 0 ||\n                        Math.floor(value) !== value) {\n                    next_token.stop('expected_small_a');\n                }\n                option[name] = value;\n            } else {\n                if (next_token.id === 'true') {\n                    option[name] = true;\n                } else if (next_token.id === 'false') {\n                    option[name] = false;\n                } else {\n                    next_token.stop('unexpected_a');\n                }\n            }\n            advance();\n            if (next_token.id === ',') {\n                advance(',');\n            }\n        }\n        assume();\n    }\n\n\n    function do_properties() {\n        var name;\n        option.properties = true;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            if (next_token.id === ':') {\n                for (;;) {\n                    advance();\n                    if (next_token.id !== '(string)' && !next_token.identifier) {\n                        break;\n                    }\n                }\n            }\n            property[name] = 0;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    directive = function directive() {\n        var command = this.id,\n            old_comments_off = comments_off,\n            old_indent = indent;\n        comments_off = true;\n        indent = null;\n        if (next_token.line === token.line && next_token.from === token.thru) {\n            next_token.warn('missing_space_a_b', artifact(token), artifact());\n        }\n        if (lookahead.length > 0) {\n            this.warn('unexpected_a');\n        }\n        switch (command) {\n        case '/*properties':\n        case '/*property':\n        case '/*members':\n        case '/*member':\n            do_properties();\n            break;\n        case '/*jslint':\n            do_jslint();\n            break;\n        case '/*globals':\n        case '/*global':\n            do_globals();\n            break;\n        default:\n            this.stop('unexpected_a');\n        }\n        comments_off = old_comments_off;\n        advance('*/');\n        indent = old_indent;\n    };\n\n\n// Indentation intention\n\n    function edge(mode) {\n        next_token.edge = indent ? indent.open && (mode || 'edge') : '';\n    }\n\n\n    function step_in(mode) {\n        var open;\n        if (typeof mode === 'number') {\n            indent = {\n                at: +mode,\n                open: true,\n                was: indent\n            };\n        } else if (!indent) {\n            indent = {\n                at: 1,\n                mode: 'statement',\n                open: true\n            };\n        } else if (mode === 'statement') {\n            indent = {\n                at: indent.at,\n                open: true,\n                was: indent\n            };\n        } else {\n            open = mode === 'var' || next_token.line !== token.line;\n            indent = {\n                at: (open || mode === 'control'\n                    ? indent.at + option.indent\n                    : indent.at) + (indent.wrap ? option.indent : 0),\n                mode: mode,\n                open: open,\n                was: indent\n            };\n            if (mode === 'var' && open) {\n                var_mode = indent;\n            }\n        }\n    }\n\n    function step_out(id, symbol) {\n        if (id) {\n            if (indent && indent.open) {\n                indent.at -= option.indent;\n                edge();\n            }\n            advance(id, symbol);\n        }\n        if (indent) {\n            indent = indent.was;\n        }\n    }\n\n// Functions for conformance of whitespace.\n\n    function one_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && !option.white &&\n                (token.line !== right.line ||\n                token.thru + 1 !== right.from)) {\n            right.warn('expected_space_a_b', artifact(token), artifact(right));\n        }\n    }\n\n    function one_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru + 1 !== right.from))) {\n            right.warn('expected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if ((!option.white) &&\n                left.thru !== right.from && left.line === right.line) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru !== right.from))) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function spaces(left, right) {\n        if (!option.white) {\n            left = left || token;\n            right = right || next_token;\n            if (left.thru === right.from && left.line === right.line) {\n                right.warn('missing_space_a_b', artifact(left), artifact(right));\n            }\n        }\n    }\n\n    function comma() {\n        if (next_token.id !== ',') {\n            warn('expected_a_b', token.line, token.thru, ',', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(',');\n            spaces();\n        }\n    }\n\n\n    function semicolon() {\n        if (next_token.id !== ';') {\n            warn('expected_a_b', token.line, token.thru, ';', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(';');\n            if (semicolon_coda[next_token.id] !== true) {\n                spaces();\n            }\n        }\n    }\n\n    function use_strict() {\n        if (next_token.string === 'use strict') {\n            if (strict_mode) {\n                next_token.warn('unnecessary_use');\n            }\n            edge();\n            advance();\n            semicolon();\n            strict_mode = true;\n            return true;\n        }\n        return false;\n    }\n\n\n    function are_similar(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (Array.isArray(a)) {\n            if (Array.isArray(b) && a.length === b.length) {\n                var i;\n                for (i = 0; i < a.length; i += 1) {\n                    if (!are_similar(a[i], b[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n        if (Array.isArray(b)) {\n            return false;\n        }\n        if (a.id === '(number)' && b.id === '(number)') {\n            return a.number === b.number;\n        }\n        if (a.arity === b.arity && a.string === b.string) {\n            switch (a.arity) {\n            case undefined:\n                return a.string === b.string;\n            case 'prefix':\n            case 'suffix':\n                return a.id === b.id && are_similar(a.first, b.first) &&\n                    a.id !== '{' && a.id !== '[';\n            case 'infix':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second);\n            case 'ternary':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second) &&\n                    are_similar(a.third, b.third);\n            case 'function':\n            case 'regexp':\n                return false;\n            default:\n                return true;\n            }\n        }\n        if (a.id === '.' && b.id === '[' && b.arity === 'infix') {\n            return a.second.string === b.second.string && b.second.id === '(string)';\n        }\n        if (a.id === '[' && a.arity === 'infix' && b.id === '.') {\n            return a.second.string === b.second.string && a.second.id === '(string)';\n        }\n        return false;\n    }\n\n\n// This is the heart of JSLINT, the Pratt parser. In addition to parsing, it\n// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is\n// like .nud except that it is only used on the first token of a statement.\n// Having .fud makes it much easier to define statement-oriented languages like\n// JavaScript. I retained Pratt's nomenclature.\n\n// .nud     Null denotation\n// .fud     First null denotation\n// .led     Left denotation\n//  lbp     Left binding power\n//  rbp     Right binding power\n\n// They are elements of the parsing method called Top Down Operator Precedence.\n\n    function expression(rbp, initial) {\n\n// rbp is the right binding power.\n// initial indicates that this is the first expression of a statement.\n\n        var left;\n        if (next_token.id === '(end)') {\n            token.stop('unexpected_a', next_token.id);\n        }\n        advance();\n        if (initial) {\n            anonname = 'anonymous';\n        }\n        if (initial === true && token.fud) {\n            left = token.fud();\n        } else {\n            if (token.nud) {\n                left = token.nud();\n            } else {\n                if (next_token.id === '(number)' && token.id === '.') {\n                    token.warn('leading_decimal_a', artifact());\n                    advance();\n                    return token;\n                }\n                token.stop('expected_identifier_a', artifact(token));\n            }\n            while (rbp < next_token.lbp) {\n                advance();\n                left = token.led(left);\n            }\n        }\n        if (left && left.assign && !initial) {\n            if (!option.ass) {\n                left.warn('assignment_expression');\n            }\n            if (left.id !== '=' && left.first.master) {\n                left.first.master.used = true;\n            }\n        }\n        return left;\n    }\n\n    protosymbol = {\n        nud: function () {\n            this.stop('unexpected_a');\n        },\n        led: function () {\n            this.stop('expected_operator_a');\n        },\n        warn: function (code, a, b, c, d) {\n            if (!this.warning) {\n                this.warning = warn(code, this.line || 0, this.from || 0,\n                    a || artifact(this), b, c, d);\n            }\n        },\n        stop: function (code, a, b, c, d) {\n            this.warning = undefined;\n            this.warn(code, a, b, c, d);\n            return quit('stopping', this.line, this.character);\n        },\n        lbp: 0\n    };\n\n// Functional constructors for making the symbols that will be inherited by\n// tokens.\n\n    function symbol(s, bp) {\n        var x = syntax[s];\n        if (!x) {\n            x = Object.create(protosymbol);\n            x.id = x.string = s;\n            x.lbp = bp || 0;\n            syntax[s] = x;\n        }\n        return x;\n    }\n\n    function postscript(x) {\n        x.postscript = true;\n        return x;\n    }\n\n    function ultimate(s) {\n        var x = symbol(s, 0);\n        x.from = 1;\n        x.thru = 1;\n        x.line = 0;\n        x.edge = 'edge';\n        x.string = s;\n        return postscript(x);\n    }\n\n    function reserve_name(x) {\n        var c = x.id.charAt(0);\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            x.identifier = x.reserved = true;\n        }\n        return x;\n    }\n\n    function stmt(s, f) {\n        var x = symbol(s);\n        x.fud = f;\n        return reserve_name(x);\n    }\n\n    function disrupt_stmt(s, f) {\n        var x = stmt(s, f);\n        x.disrupt = true;\n    }\n\n    function labeled_stmt(s, f) {\n        var x = stmt(s, function labeled() {\n            var the_statement;\n            if (funct.breakage) {\n                funct.breakage.push(this);\n            } else {\n                funct.breakage = [this];\n            }\n            the_statement = f.apply(this);\n            if (funct.breakage.length > 1) {\n                funct.breakage.pop();\n            } else {\n                delete funct.breakage;\n            }\n            return the_statement;\n        });\n        x.labeled = true;\n    }\n\n    function prefix(s, f) {\n        var x = symbol(s, 150);\n        reserve_name(x);\n        x.nud = function () {\n            var that = this;\n            that.arity = 'prefix';\n            if (typeof f === 'function') {\n                that = f(that);\n                if (that.arity !== 'prefix') {\n                    return that;\n                }\n            } else {\n                if (s === 'typeof') {\n                    one_space();\n                } else {\n                    no_space_only();\n                }\n                that.first = expression(150);\n            }\n            switch (that.id) {\n            case '++':\n            case '--':\n                if (!option.plusplus) {\n                    that.warn('unexpected_a');\n                } else if ((!that.first.identifier || that.first.reserved) &&\n                        that.first.id !== '.' && that.first.id !== '[') {\n                    that.warn('bad_operand');\n                }\n                break;\n            default:\n                if (that.first.arity === 'prefix' ||\n                        that.first.arity === 'function') {\n                    that.warn('unexpected_a');\n                }\n            }\n            return that;\n        };\n        return x;\n    }\n\n\n    function type(s, t, nud) {\n        var x = symbol(s);\n        x.arity = t;\n        if (nud) {\n            x.nud = nud;\n        }\n        return x;\n    }\n\n\n    function reserve(s, f) {\n        var x = symbol(s);\n        x.identifier = x.reserved = true;\n        if (typeof f === 'function') {\n            x.nud = f;\n        }\n        return x;\n    }\n\n\n    function constant(name) {\n        var x = reserve(name);\n        x.string = name;\n        x.nud = return_this;\n        return x;\n    }\n\n\n    function reservevar(s, v) {\n        return reserve(s, function () {\n            if (typeof v === 'function') {\n                v(this);\n            }\n            return this;\n        });\n    }\n\n\n    function infix(s, p, f, w) {\n        var x = symbol(s, p);\n        reserve_name(x);\n        x.led = function (left) {\n            this.arity = 'infix';\n            if (!w) {\n                spaces(prev_token, token);\n                spaces();\n            }\n            if (!option.bitwise && this.bitwise) {\n                this.warn('unexpected_a');\n            }\n            if (typeof f === 'function') {\n                return f(left, this);\n            }\n            this.first = left;\n            this.second = expression(p);\n            return this;\n        };\n        return x;\n    }\n\n    function expected_relation(node, message) {\n        if (node.assign) {\n            node.warn(message || 'conditional_assignment');\n        }\n        return node;\n    }\n\n    function expected_condition(node, message) {\n        switch (node.id) {\n        case '[':\n        case '-':\n            if (node.arity !== 'infix') {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        case 'false':\n        case 'function':\n        case 'Infinity':\n        case 'NaN':\n        case 'null':\n        case 'true':\n        case 'undefined':\n        case 'void':\n        case '(number)':\n        case '(regexp)':\n        case '(string)':\n        case '{':\n        case '?':\n        case '~':\n            node.warn(message || 'weird_condition');\n            break;\n        case '(':\n            if (node.first.id === 'new' ||\n                    (node.first.string === 'Boolean') ||\n                    (node.first.id === '.' &&\n                        numbery[node.first.second.string] === true)) {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        }\n        return node;\n    }\n\n    function check_relation(node) {\n        switch (node.arity) {\n        case 'prefix':\n            switch (node.id) {\n            case '{':\n            case '[':\n                node.warn('unexpected_a');\n                break;\n            case '!':\n                node.warn('confusing_a');\n                break;\n            }\n            break;\n        case 'function':\n        case 'regexp':\n            node.warn('unexpected_a');\n            break;\n        default:\n            if (node.id  === 'NaN') {\n                node.warn('isNaN');\n            } else if (node.relation) {\n                node.warn('weird_relation');\n            }\n        }\n        return node;\n    }\n\n\n    function relation(s, eqeq) {\n        var x = infix(s, 100, function (left, that) {\n            check_relation(left);\n            if (eqeq && !option.eqeq) {\n                that.warn('expected_a_b', eqeq, that.id);\n            }\n            var right = expression(100);\n            if (are_similar(left, right) ||\n                    ((left.id === '(string)' || left.id === '(number)') &&\n                    (right.id === '(string)' || right.id === '(number)'))) {\n                that.warn('weird_relation');\n            } else if (left.id === 'typeof') {\n                if (right.id !== '(string)') {\n                    right.warn(\"expected_string_a\", artifact(right));\n                } else if (right.string === 'undefined' ||\n                        right.string === 'null') {\n                    left.warn(\"unexpected_typeof_a\", right.string);\n                }\n            } else if (right.id === 'typeof') {\n                if (left.id !== '(string)') {\n                    left.warn(\"expected_string_a\", artifact(left));\n                } else if (left.string === 'undefined' ||\n                        left.string === 'null') {\n                    right.warn(\"unexpected_typeof_a\", left.string);\n                }\n            }\n            that.first = left;\n            that.second = check_relation(right);\n            return that;\n        });\n        x.relation = true;\n        return x;\n    }\n\n    function lvalue(that, s) {\n        var master;\n        if (that.identifier) {\n            master = scope[that.string];\n            if (master) {\n                if (scope[that.string].writeable !== true) {\n                    that.warn('read_only');\n                }\n                master.used -= 1;\n                if (s === '=') {\n                    master.init = true;\n                }\n            }\n        } else if (that.id === '.' || that.id === '[') {\n            if (!that.first || that.first.string === 'arguments') {\n                that.warn('bad_assignment');\n            }\n        } else {\n            that.warn('bad_assignment');\n        }\n    }\n\n\n    function assignop(s, op) {\n        var x = infix(s, 20, function (left, that) {\n            var next;\n            that.first = left;\n            lvalue(left, s);\n            that.second = expression(20);\n            if (that.id === '=' && are_similar(that.first, that.second)) {\n                that.warn('weird_assignment');\n            }\n            next = that;\n            while (next_token.id === '=') {\n                lvalue(next.second, '=');\n                next_token.first = next.second;\n                next.second = next_token;\n                next = next_token;\n                advance('=');\n                next.second = expression(20);\n            }\n            return that;\n        });\n        x.assign = true;\n        if (op) {\n            if (syntax[op].bitwise) {\n                x.bitwise = true;\n            }\n        }\n        return x;\n    }\n\n\n    function bitwise(s, p) {\n        var x = infix(s, p, 'number');\n        x.bitwise = true;\n        return x;\n    }\n\n\n    function suffix(s) {\n        var x = symbol(s, 150);\n        x.led = function (left) {\n            no_space_only(prev_token, token);\n            if (!option.plusplus) {\n                this.warn('unexpected_a');\n            } else if ((!left.identifier || left.reserved) &&\n                    left.id !== '.' && left.id !== '[') {\n                this.warn('bad_operand');\n            }\n            this.first = left;\n            this.arity = 'suffix';\n            return this;\n        };\n        return x;\n    }\n\n\n    function optional_identifier(variable) {\n        if (next_token.identifier) {\n            advance();\n            if (token.reserved && variable) {\n                token.warn('expected_identifier_a_reserved');\n            }\n            return token.string;\n        }\n    }\n\n\n    function identifier(variable) {\n        var i = optional_identifier(variable);\n        if (!i) {\n            next_token.stop(token.id === 'function' && next_token.id === '('\n                ? 'name_function'\n                : 'expected_identifier_a');\n        }\n        return i;\n    }\n\n\n    function statement() {\n\n        var label, preamble, the_statement;\n\n// We don't like the empty statement.\n\n        if (next_token.id === ';') {\n            next_token.warn('unexpected_a');\n            semicolon();\n            return;\n        }\n\n// Is this a labeled statement?\n\n        if (next_token.identifier && !next_token.reserved && peek().id === ':') {\n            edge('label');\n            label = next_token;\n            advance();\n            advance(':');\n            define('label', label);\n            if (next_token.labeled !== true || funct === global_funct) {\n                label.stop('unexpected_label_a');\n            } else if (jx.test(label.string + ':')) {\n                label.warn('url');\n            }\n            next_token.label = label;\n            label.init = true;\n            label.statement = next_token;\n        }\n\n// Parse the statement.\n\n        preamble = next_token;\n        if (token.id !== 'else') {\n            edge();\n        }\n        step_in('statement');\n        the_statement = expression(0, true);\n        if (the_statement) {\n\n// Look for the final semicolon.\n\n            if (the_statement.arity === 'statement') {\n                if (the_statement.id === 'switch' ||\n                        (the_statement.block && the_statement.id !== 'do')) {\n                    spaces();\n                } else {\n                    semicolon();\n                }\n            } else {\n\n// If this is an expression statement, determine if it is acceptable.\n// We do not like\n//      new Blah;\n// statements. If it is to be used at all, new should only be used to make\n// objects, not side effects. The expression statements we do like do\n// assignment or invocation or delete.\n\n                if (the_statement.id === '(') {\n                    if (the_statement.first.id === 'new') {\n                        next_token.warn('bad_new');\n                    }\n                } else if (the_statement.id === '++' ||\n                        the_statement.id === '--') {\n                    lvalue(the_statement.first);\n                } else if (!the_statement.assign &&\n                        the_statement.id !== 'delete') {\n                    if (!option.closure || !preamble.comments) {\n                        preamble.warn('assignment_function_expression');\n                    }\n                }\n                semicolon();\n            }\n        }\n        step_out();\n        if (label) {\n            label.dead = true;\n        }\n        return the_statement;\n    }\n\n\n    function statements() {\n        var array = [], disruptor, the_statement;\n\n// A disrupt statement may not be followed by any other statement.\n// If the last statement is disrupt, then the sequence is disrupt.\n\n        while (next_token.postscript !== true) {\n            if (next_token.id === ';') {\n                next_token.warn('unexpected_a');\n                semicolon();\n            } else {\n                if (next_token.string === 'use strict') {\n                    if ((!node_js) || funct !== global_funct || array.length > 0) {\n                        next_token.warn('function_strict');\n                    }\n                    use_strict();\n                }\n                if (disruptor) {\n                    next_token.warn('unreachable_a_b', next_token.string,\n                        disruptor.string);\n                    disruptor = null;\n                }\n                the_statement = statement();\n                if (the_statement) {\n                    array.push(the_statement);\n                    if (the_statement.disrupt) {\n                        disruptor = the_statement;\n                        array.disrupt = true;\n                    }\n                }\n            }\n        }\n        return array;\n    }\n\n\n    function block(kind) {\n\n// A block is a sequence of statements wrapped in braces.\n\n        var array,\n            curly = next_token,\n            old_block_var = block_var,\n            old_in_block = in_block,\n            old_strict_mode = strict_mode;\n\n        in_block = kind !== 'function' && kind !== 'try' && kind !== 'catch';\n        block_var = [];\n        if (curly.id === '{') {\n            spaces();\n            advance('{');\n            step_in();\n            if (kind === 'function' && !use_strict() && !old_strict_mode &&\n                    !option.sloppy && funct.level === 1) {\n                next_token.warn('missing_use_strict');\n            }\n            array = statements();\n            strict_mode = old_strict_mode;\n            step_out('}', curly);\n        } else if (in_block) {\n            curly.stop('expected_a_b', '{', artifact());\n        } else {\n            curly.warn('expected_a_b', '{', artifact());\n            array = [statement()];\n            array.disrupt = array[0].disrupt;\n        }\n        if (kind !== 'catch' && array.length === 0 && !option.debug) {\n            curly.warn('empty_block');\n        }\n        block_var.forEach(function (name) {\n            scope[name].dead = true;\n        });\n        block_var = old_block_var;\n        in_block = old_in_block;\n        return array;\n    }\n\n\n    function tally_property(name) {\n        if (option.properties && typeof property[name] !== 'number') {\n            token.warn('unexpected_property_a', name);\n        }\n        if (property[name]) {\n            property[name] += 1;\n        } else {\n            property[name] = 1;\n        }\n    }\n\n\n// ECMAScript parser\n\n    (function () {\n        var x = symbol('(identifier)');\n        x.nud = function () {\n            var name = this.string,\n                master = scope[name],\n                writeable;\n\n// If the master is not in scope, then we may have an undeclared variable.\n// Check the predefined list. If it was predefined, create the global\n// variable.\n\n            if (!master) {\n                writeable = predefined[name];\n                if (typeof writeable === 'boolean') {\n                    global_scope[name] = master = {\n                        dead: false,\n                        function: global_funct,\n                        kind: 'var',\n                        string: name,\n                        writeable: writeable\n                    };\n\n// But if the variable is not in scope, and is not predefined, and if we are not\n// in the global scope, then we have an undefined variable error.\n\n                } else {\n                    token.warn('used_before_a');\n                }\n            } else {\n                this.master = master;\n            }\n\n// Annotate uses that cross scope boundaries.\n\n            if (master) {\n                if (master.kind === 'label') {\n                    this.warn('a_label');\n                } else {\n                    if (master.dead === true || master.dead === funct) {\n                        this.warn('a_scope');\n                    }\n                    master.used += 1;\n                    if (master.function !== funct) {\n                        if (master.function === global_funct) {\n                            funct.global.push(name);\n                        } else {\n                            master.function.closure.push(name);\n                            funct.outer.push(name);\n                        }\n                    }\n                }\n            }\n            return this;\n        };\n        x.identifier = true;\n    }());\n\n\n// Build the syntax table by declaring the syntactic elements.\n\n    type('(array)', 'array');\n    type('(function)', 'function');\n    type('(number)', 'number', return_this);\n    type('(object)', 'object');\n    type('(string)', 'string', return_this);\n    type('(boolean)', 'boolean', return_this);\n    type('(regexp)', 'regexp', return_this);\n\n    ultimate('(begin)');\n    ultimate('(end)');\n    ultimate('(error)');\n    postscript(symbol('}'));\n    symbol(')');\n    symbol(']');\n    postscript(symbol('\"'));\n    postscript(symbol('\\''));\n    symbol(';');\n    symbol(':');\n    symbol(',');\n    symbol('#');\n    symbol('@');\n    symbol('*/');\n    postscript(reserve('case'));\n    reserve('catch');\n    postscript(reserve('default'));\n    reserve('else');\n    reserve('finally');\n\n    reservevar('arguments', function (x) {\n        if (strict_mode && funct === global_funct) {\n            x.warn('strict');\n        }\n        funct.arguments = true;\n    });\n    reservevar('eval');\n    constant('false', 'boolean');\n    constant('Infinity', 'number');\n    constant('NaN', 'number');\n    constant('null', '');\n    reservevar('this', function (x) {\n        if (strict_mode && funct.statement && funct.name.charAt(0) > 'Z') {\n            x.warn('strict');\n        }\n    });\n    constant('true', 'boolean');\n    constant('undefined', '');\n\n    infix('?', 30, function (left, that) {\n        step_in('?');\n        that.first = expected_condition(expected_relation(left));\n        that.second = expression(0);\n        spaces();\n        step_out();\n        var colon = next_token;\n        advance(':');\n        step_in(':');\n        spaces();\n        that.third = expression(10);\n        that.arity = 'ternary';\n        if (are_similar(that.second, that.third)) {\n            colon.warn('weird_ternary');\n        } else if (are_similar(that.first, that.second)) {\n            that.warn('use_or');\n        }\n        step_out();\n        return that;\n    });\n\n    infix('||', 40, function (left, that) {\n        function paren_check(that) {\n            if (that.id === '&&' && !that.paren) {\n                that.warn('and');\n            }\n            return that;\n        }\n\n        that.first = paren_check(expected_condition(expected_relation(left)));\n        that.second = paren_check(expected_relation(expression(40)));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    infix('&&', 50, function (left, that) {\n        that.first = expected_condition(expected_relation(left));\n        that.second = expected_relation(expression(50));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    prefix('void', function (that) {\n        that.first = expression(0);\n        that.warn('expected_a_b', 'undefined', 'void');\n        return that;\n    });\n\n    bitwise('|', 70);\n    bitwise('^', 80);\n    bitwise('&', 90);\n\n    relation('==', '===');\n    relation('===');\n    relation('!=', '!==');\n    relation('!==');\n    relation('<');\n    relation('>');\n    relation('<=');\n    relation('>=');\n\n    bitwise('<<', 120);\n    bitwise('>>', 120);\n    bitwise('>>>', 120);\n\n    infix('in', 120, function (left, that) {\n        that.warn('infix_in');\n        that.left = left;\n        that.right = expression(130);\n        return that;\n    });\n    infix('instanceof', 120);\n    infix('+', 130, function (left, that) {\n        if (left.id === '(number)') {\n            if (left.number === 0) {\n                left.warn('unexpected_a', '0');\n            }\n        } else if (left.id === '(string)') {\n            if (left.string === '') {\n                left.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        var right = expression(130);\n        if (right.id === '(number)') {\n            if (right.number === 0) {\n                right.warn('unexpected_a', '0');\n            }\n        } else if (right.id === '(string)') {\n            if (right.string === '') {\n                right.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        if (left.id === right.id) {\n            if (left.id === '(string)' || left.id === '(number)') {\n                if (left.id === '(string)') {\n                    left.string += right.string;\n                    if (jx.test(left.string)) {\n                        left.warn('url');\n                    }\n                } else {\n                    left.number += right.number;\n                }\n                left.thru = right.thru;\n                return left;\n            }\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('+');\n    prefix('+++', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('+++', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('-', 130, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(130);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number -= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('-');\n    prefix('---', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('---', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('*', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number *= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('/', 140, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number /= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('%', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number %= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n\n    suffix('++');\n    prefix('++');\n\n    suffix('--');\n    prefix('--');\n    prefix('delete', function (that) {\n        one_space();\n        var p = expression(0);\n        if (!p || (p.id !== '.' && p.id !== '[')) {\n            next_token.warn('deleted');\n        }\n        that.first = p;\n        return that;\n    });\n\n\n    prefix('~', function (that) {\n        no_space_only();\n        if (!option.bitwise) {\n            that.warn('unexpected_a');\n        }\n        that.first = expression(150);\n        return that;\n    });\n    function banger(that) {\n        no_space_only();\n        that.first = expected_condition(expression(150));\n        if (bang[that.first.id] === that || that.first.assign) {\n            that.warn('confusing_a');\n        }\n        return that;\n    }\n    prefix('!', banger);\n    prefix('!!', banger);\n    prefix('typeof');\n    prefix('new', function (that) {\n        one_space();\n        var c = expression(160), n, p, v;\n        that.first = c;\n        if (c.id !== 'function') {\n            if (c.identifier) {\n                switch (c.string) {\n                case 'Object':\n                    token.warn('use_object');\n                    break;\n                case 'Array':\n                    if (next_token.id === '(') {\n                        p = next_token;\n                        p.first = this;\n                        advance('(');\n                        if (next_token.id !== ')') {\n                            n = expression(0);\n                            p.second = [n];\n                            if (n.id === '(string)' || next_token.id === ',') {\n                                p.warn('use_array');\n                            }\n                            while (next_token.id === ',') {\n                                advance(',');\n                                p.second.push(expression(0));\n                            }\n                        } else {\n                            token.warn('use_array');\n                        }\n                        advance(')', p);\n                        return p;\n                    }\n                    token.warn('use_array');\n                    break;\n                case 'Number':\n                case 'String':\n                case 'Boolean':\n                case 'Math':\n                case 'JSON':\n                    c.warn('not_a_constructor');\n                    break;\n                case 'Function':\n                    if (!option.evil) {\n                        next_token.warn('function_eval');\n                    }\n                    break;\n                case 'Date':\n                case 'RegExp':\n                case 'this':\n                    break;\n                default:\n                    if (c.id !== 'function') {\n                        v = c.string.charAt(0);\n                        if (!option.newcap && (v < 'A' || v > 'Z')) {\n                            token.warn('constructor_name_a');\n                        }\n                    }\n                }\n            } else {\n                if (c.id !== '.' && c.id !== '[' && c.id !== '(') {\n                    token.warn('bad_constructor');\n                }\n            }\n        } else {\n            that.warn('weird_new');\n        }\n        if (next_token.id !== '(') {\n            next_token.warn('missing_a', '()');\n        }\n        return that;\n    });\n\n    infix('(', 160, function (left, that) {\n        var e, p;\n        if (indent && indent.mode === 'expression') {\n            no_space(prev_token, token);\n        } else {\n            no_space_only(prev_token, token);\n        }\n        if (!left.immed && left.id === 'function') {\n            next_token.warn('wrap_immediate');\n        }\n        p = [];\n        if (left.identifier) {\n            if (left.string.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {\n                if (left.string !== 'Number' && left.string !== 'String' &&\n                        left.string !== 'Boolean' && left.string !== 'Date') {\n                    if (left.string === 'Math') {\n                        left.warn('not_a_function');\n                    } else if (left.string === 'Object') {\n                        token.warn('use_object');\n                    } else if (left.string === 'Array' || !option.newcap) {\n                        left.warn('missing_a', 'new');\n                    }\n                }\n            } else if (left.string === 'JSON') {\n                left.warn('not_a_function');\n            }\n        } else if (left.id === '.') {\n            if (left.second.string === 'split' &&\n                    left.first.id === '(string)') {\n                left.second.warn('use_array');\n            }\n        }\n        step_in();\n        if (next_token.id !== ')') {\n            no_space();\n            for (;;) {\n                edge();\n                e = expression(10);\n                if (left.string === 'Boolean' && (e.id === '!' || e.id === '~')) {\n                    e.warn('weird_condition');\n                }\n                p.push(e);\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', that);\n        if (typeof left === 'object') {\n            if (left.string === 'parseInt' && p.length === 1) {\n                left.warn('radix');\n            } else if (left.string === 'String' && p.length >= 1 && p[0].id === '(string)') {\n                left.warn('unexpected_a');\n            }\n            if (!option.evil) {\n                if (left.string === 'eval' || left.string === 'Function' ||\n                        left.string === 'execScript') {\n                    left.warn('evil');\n                } else if (p[0] && p[0].id === '(string)' &&\n                        (left.string === 'setTimeout' ||\n                        left.string === 'setInterval')) {\n                    left.warn('implied_evil');\n                }\n            }\n            if (!left.identifier && left.id !== '.' && left.id !== '[' &&\n                    left.id !== '(' && left.id !== '&&' && left.id !== '||' &&\n                    left.id !== '?') {\n                left.warn('bad_invocation');\n            }\n            if (left.id === '.') {\n                if (p.length > 0 &&\n                        left.first && left.first.first &&\n                        are_similar(p[0], left.first.first)) {\n                    if (left.second.string === 'call' ||\n                            (left.second.string === 'apply' && (p.length === 1 ||\n                            (p[1].arity === 'prefix' && p[1].id === '[')))) {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n                if (left.second.string === 'toString') {\n                    if (left.first.id === '(string)' || left.first.id === '(number)') {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n            }\n        }\n        that.first = left;\n        that.second = p;\n        return that;\n    }, true);\n\n    prefix('(', function (that) {\n        step_in('expression');\n        no_space();\n        edge();\n        if (next_token.id === 'function') {\n            next_token.immed = true;\n        }\n        var value = expression(0);\n        value.paren = true;\n        no_space();\n        step_out(')', that);\n        if (value.id === 'function') {\n            switch (next_token.id) {\n            case '(':\n                next_token.warn('move_invocation');\n                break;\n            case '.':\n            case '[':\n                next_token.warn('unexpected_a');\n                break;\n            default:\n                that.warn('bad_wrap');\n            }\n        } else if (!value.arity) {\n            if (!option.closure || !that.comments) {\n                that.warn('unexpected_a');\n            }\n        }\n        return value;\n    });\n\n    infix('.', 170, function (left, that) {\n        no_space(prev_token, token);\n        no_space();\n        var name = identifier();\n        if (typeof name === 'string') {\n            tally_property(name);\n        }\n        that.first = left;\n        that.second = token;\n        if (left && left.string === 'arguments' &&\n                (name === 'callee' || name === 'caller')) {\n            left.warn('avoid_a', 'arguments.' + name);\n        } else if (!option.evil && left && left.string === 'document' &&\n                (name === 'write' || name === 'writeln')) {\n            left.warn('write_is_wrong');\n        } else if (!option.stupid && syx.test(name)) {\n            token.warn('sync_a');\n        }\n        if (!option.evil && (name === 'eval' || name === 'execScript')) {\n            next_token.warn('evil');\n        }\n        return that;\n    }, true);\n\n    infix('[', 170, function (left, that) {\n        var e, s;\n        no_space_only(prev_token, token);\n        no_space();\n        step_in();\n        edge();\n        e = expression(0);\n        switch (e.id) {\n        case '(number)':\n            if (e.id === '(number)' && left.id === 'arguments') {\n                left.warn('use_param');\n            }\n            break;\n        case '(string)':\n            if (!option.evil &&\n                    (e.string === 'eval' || e.string === 'execScript')) {\n                e.warn('evil');\n            } else if (!option.sub && ix.test(e.string)) {\n                s = syntax[e.string];\n                if (!s || !s.reserved) {\n                    e.warn('subscript');\n                }\n            }\n            tally_property(e.string);\n            break;\n        }\n        step_out(']', that);\n        no_space(prev_token, token);\n        that.first = left;\n        that.second = e;\n        return that;\n    }, true);\n\n    prefix('[', function (that) {\n        that.first = [];\n        step_in('array');\n        while (next_token.id !== '(end)') {\n            while (next_token.id === ',') {\n                next_token.warn('unexpected_a');\n                advance(',');\n            }\n            if (next_token.id === ']') {\n                break;\n            }\n            indent.wrap = false;\n            edge();\n            that.first.push(expression(10));\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id === ']') {\n                    token.warn('unexpected_a');\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        step_out(']', that);\n        return that;\n    }, 170);\n\n\n    function property_name() {\n        var id = optional_identifier();\n        if (!id) {\n            if (next_token.id === '(string)') {\n                id = next_token.string;\n                advance();\n            } else if (next_token.id === '(number)') {\n                id = next_token.number.toString();\n                advance();\n            }\n        }\n        return id;\n    }\n\n\n\n    assignop('=');\n    assignop('+=', '+');\n    assignop('-=', '-');\n    assignop('*=', '*');\n    assignop('/=', '/').nud = function () {\n        next_token.stop('slash_equal');\n    };\n    assignop('%=', '%');\n    assignop('&=', '&');\n    assignop('|=', '|');\n    assignop('^=', '^');\n    assignop('<<=', '<<');\n    assignop('>>=', '>>');\n    assignop('>>>=', '>>>');\n\n    function function_parameters() {\n        var id, parameters = [], paren = next_token;\n        advance('(');\n        token.function = funct;\n        step_in();\n        no_space();\n        if (next_token.id !== ')') {\n            for (;;) {\n                edge();\n                id = identifier();\n                define('parameter', token);\n                parameters.push(id);\n                token.init = true;\n                token.writeable = true;\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', paren);\n        return parameters;\n    }\n\n    function do_function(func, name) {\n        var old_funct = funct,\n            old_option = option,\n            old_scope = scope;\n        scope = Object.create(old_scope);\n        funct = {\n            closure: [],\n            global: [],\n            level: old_funct.level + 1,\n            line: next_token.line,\n            loopage: 0,\n            name: name || '\\'' + (anonname || '').replace(nx, sanitize) + '\\'',\n            outer: [],\n            scope: scope\n        };\n        funct.parameter = function_parameters();\n        func.function = funct;\n        option = Object.create(old_option);\n        functions.push(funct);\n        if (name) {\n            func.name = name;\n            func.string = name;\n            define('function', func);\n            func.init = true;\n            func.used += 1;\n        }\n        func.writeable = false;\n        one_space();\n        func.block = block('function');\n        Object.keys(scope).forEach(function (name) {\n            var master = scope[name];\n            if (!master.used && master.kind !== 'exception' &&\n                    (master.kind !== 'parameter' || !option.unparam)) {\n                master.warn('unused_a');\n            } else if (!master.init) {\n                master.warn('uninitialized_a');\n            }\n        });\n        funct = old_funct;\n        option = old_option;\n        scope = old_scope;\n    }\n\n    prefix('{', function (that) {\n        var get, i, j, name, set, seen = Object.create(null);\n        that.first = [];\n        step_in();\n        while (next_token.id !== '}') {\n            indent.wrap = false;\n\n// JSLint recognizes the ES5 extension for get/set in object literals,\n// but requires that they be used in pairs.\n\n            edge();\n            if (next_token.string === 'get' && peek().id !== ':') {\n                get = next_token;\n                advance('get');\n                one_space_only();\n                name = next_token;\n                i = property_name();\n                if (!i) {\n                    next_token.stop('missing_property');\n                }\n                get.string = '';\n                do_function(get);\n                if (funct.loopage) {\n                    get.warn('function_loop');\n                }\n                if (get.function.parameter.length) {\n                    get.warn('parameter_a_get_b', get.function.parameter[0], i);\n                }\n                comma();\n                set = next_token;\n                spaces();\n                edge();\n                advance('set');\n                set.string = '';\n                one_space_only();\n                j = property_name();\n                if (i !== j) {\n                    token.stop('expected_a_b', i, j || next_token.string);\n                }\n                do_function(set);\n                if (set.block.length === 0) {\n                    token.warn('missing_a', 'throw');\n                }\n                if (set.function.parameter.length === 0) {\n                    set.stop('parameter_set_a', 'value');\n                } else if (set.function.parameter[0] !== 'value') {\n                    set.stop('expected_a_b', 'value',\n                        set.function.parameter[0]);\n                }\n                name.first = [get, set];\n            } else {\n                name = next_token;\n                i = property_name();\n                if (typeof i !== 'string') {\n                    next_token.stop('missing_property');\n                }\n                advance(':');\n                spaces();\n                name.first = expression(10);\n            }\n            that.first.push(name);\n            if (seen[i] === true) {\n                next_token.warn('duplicate_a', i);\n            }\n            seen[i] = true;\n            tally_property(i);\n            if (next_token.id !== ',') {\n                break;\n            }\n            for (;;) {\n                comma();\n                if (next_token.id !== ',') {\n                    break;\n                }\n                next_token.warn('unexpected_a');\n            }\n            if (next_token.id === '}') {\n                token.warn('unexpected_a');\n            }\n        }\n        step_out('}', that);\n        return that;\n    });\n\n    stmt('{', function () {\n        next_token.warn('statement_block');\n        this.arity = 'statement';\n        this.block = statements();\n        this.disrupt = this.block.disrupt;\n        advance('}', this);\n        return this;\n    });\n\n    stmt('/*global', directive);\n    stmt('/*globals', directive);\n    stmt('/*jslint', directive);\n    stmt('/*member', directive);\n    stmt('/*members', directive);\n    stmt('/*property', directive);\n    stmt('/*properties', directive);\n\n    stmt('var', function () {\n\n// JavaScript does not have block scope. It only has function scope. So,\n// declaring a variable in a block can have unexpected consequences.\n\n// var.first will contain an array, the array containing name tokens\n// and assignment tokens.\n\n        var assign, id, name;\n\n        if (funct.loopage) {\n            next_token.warn('var_loop');\n        } else if (funct.varstatement && !option.vars) {\n            next_token.warn('combine_var');\n        }\n        if (funct !== global_funct) {\n            funct.varstatement = true;\n        }\n        this.arity = 'statement';\n        this.first = [];\n        step_in('var');\n        for (;;) {\n            name = next_token;\n            id = identifier(true);\n            define('var', name);\n            name.dead = funct;\n            if (next_token.id === '=') {\n                if (funct === global_funct && !name.writeable) {\n                    name.warn('read_only');\n                }\n                assign = next_token;\n                assign.first = name;\n                spaces();\n                advance('=');\n                spaces();\n                if (next_token.id === 'undefined') {\n                    token.warn('unnecessary_initialize', id);\n                }\n                if (peek(0).id === '=' && next_token.identifier) {\n                    next_token.stop('var_a_not');\n                }\n                assign.second = expression(0);\n                assign.arity = 'infix';\n                name.init = true;\n                this.first.push(assign);\n            } else {\n                this.first.push(name);\n            }\n            name.dead = false;\n            name.writeable = true;\n            if (next_token.id !== ',') {\n                break;\n            }\n            comma();\n            indent.wrap = false;\n            if (var_mode && next_token.line === token.line &&\n                    this.first.length === 1) {\n                var_mode = null;\n                indent.open = false;\n                indent.at -= option.indent;\n            }\n            spaces();\n            edge();\n        }\n        var_mode = null;\n        step_out();\n        return this;\n    });\n\n    stmt('function', function () {\n        one_space();\n        if (in_block) {\n            token.warn('function_block');\n        }\n        var name = next_token,\n            id = identifier(true);\n        define('var', name);\n        if (!name.writeable) {\n            name.warn('read_only');\n        }\n        name.init = true;\n        name.statement = true;\n        no_space();\n        this.arity = 'statement';\n        do_function(this, id);\n        if (next_token.id === '(' && next_token.line === token.line) {\n            next_token.stop('function_statement');\n        }\n        return this;\n    });\n\n    prefix('function', function (that) {\n        var id = optional_identifier(true), name;\n        if (id) {\n            name = token;\n            no_space();\n        } else {\n            id = '';\n            one_space();\n        }\n        do_function(that, id);\n        if (name) {\n            name.function = that.function;\n        }\n        if (funct.loopage) {\n            that.warn('function_loop');\n        }\n        switch (next_token.id) {\n        case ';':\n        case '(':\n        case ')':\n        case ',':\n        case ']':\n        case '}':\n        case ':':\n        case '(end)':\n            break;\n        case '.':\n            if (peek().string !== 'bind' || peek(1).id !== '(') {\n                next_token.warn('unexpected_a');\n            }\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n        that.arity = 'function';\n        return that;\n    });\n\n    stmt('if', function () {\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('if');\n        if (next_token.id === 'else') {\n            if (this.block.disrupt) {\n                next_token.warn(this.elif ? 'use_nested_if' : 'unnecessary_else');\n            }\n            one_space();\n            advance('else');\n            one_space();\n            if (next_token.id === 'if') {\n                next_token.elif = true;\n                this.else = statement(true);\n            } else {\n                this.else = block('else');\n            }\n            if (this.else.disrupt && this.block.disrupt) {\n                this.disrupt = true;\n            }\n        }\n        return this;\n    });\n\n    stmt('try', function () {\n\n// try.first    The catch variable\n// try.second   The catch clause\n// try.third    The finally clause\n// try.block    The try block\n\n        var exception_variable, paren;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('try');\n        if (next_token.id === 'catch') {\n            one_space();\n            advance('catch');\n            one_space();\n            paren = next_token;\n            advance('(');\n            step_in('control');\n            no_space();\n            edge();\n            exception_variable = next_token;\n            this.first = identifier();\n            define('exception', exception_variable);\n            exception_variable.init = true;\n            no_space();\n            step_out(')', paren);\n            one_space();\n            this.second = block('catch');\n            if (this.second.length) {\n                if (this.first === 'ignore') {\n                    exception_variable.warn('unexpected_a');\n                }\n            } else {\n                if (this.first !== 'ignore') {\n                    exception_variable.warn('expected_a_b', 'ignore',\n                        exception_variable.string);\n                }\n            }\n            exception_variable.dead = true;\n        }\n        if (next_token.id === 'finally') {\n            one_space();\n            advance('finally');\n            one_space();\n            this.third = block('finally');\n        } else if (!this.second) {\n            next_token.stop('expected_a_b', 'catch', artifact());\n        }\n        return this;\n    });\n\n    labeled_stmt('while', function () {\n        one_space();\n        var paren = next_token;\n        funct.loopage += 1;\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_relation(expression(0));\n        if (this.first.id !== 'true') {\n            expected_condition(this.first, 'unexpected_a');\n        }\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('while');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        funct.loopage -= 1;\n        return this;\n    });\n\n    reserve('with');\n\n    labeled_stmt('switch', function () {\n\n// switch.first         the switch expression\n// switch.second        the array of cases. A case is 'case' or 'default' token:\n//    case.first        the array of case expressions\n//    case.second       the array of statements\n// If all of the arrays of statements are disrupt, then the switch is disrupt.\n\n        var cases = [],\n            old_in_block = in_block,\n            particular,\n            that = token,\n            the_case = next_token;\n\n        function find_duplicate_case(value) {\n            if (are_similar(particular, value)) {\n                value.warn('duplicate_a');\n            }\n        }\n\n        one_space();\n        advance('(');\n        no_space();\n        step_in();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', the_case);\n        one_space();\n        advance('{');\n        step_in();\n        in_block = true;\n        this.second = [];\n        if (that.from !== next_token.from && !option.white) {\n            next_token.warn('expected_a_at_b_c', next_token.string, that.from, next_token.from);\n        }\n        while (next_token.id === 'case') {\n            the_case = next_token;\n            the_case.first = [];\n            the_case.arity = 'case';\n            for (;;) {\n                spaces();\n                edge('case');\n                advance('case');\n                one_space();\n                particular = expression(0);\n                cases.forEach(find_duplicate_case);\n                cases.push(particular);\n                the_case.first.push(particular);\n                if (particular.id === 'NaN') {\n                    particular.warn('unexpected_a');\n                }\n                no_space_only();\n                advance(':');\n                if (next_token.id !== 'case') {\n                    break;\n                }\n            }\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                if (!the_case.second[the_case.second.length - 1].disrupt) {\n                    next_token.warn('missing_a_after_b', 'break', 'case');\n                }\n            } else {\n                next_token.warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.second.length === 0) {\n            next_token.warn('missing_a', 'case');\n        }\n        if (next_token.id === 'default') {\n            spaces();\n            the_case = next_token;\n            the_case.arity = 'case';\n            edge('case');\n            advance('default');\n            no_space_only();\n            advance(':');\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                this.disrupt = the_case.second[the_case.second.length - 1].disrupt;\n            } else {\n                the_case.warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.break) {\n            this.disrupt = false;\n        }\n        spaces();\n        step_out('}', this);\n        in_block = old_in_block;\n        return this;\n    });\n\n    stmt('debugger', function () {\n        if (!option.debug) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        return this;\n    });\n\n    labeled_stmt('do', function () {\n        funct.loopage += 1;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('do');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        one_space();\n        advance('while');\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in();\n        no_space();\n        edge();\n        this.first = expected_condition(expected_relation(expression(0)), 'unexpected_a');\n        no_space();\n        step_out(')', paren);\n        funct.loopage -= 1;\n        return this;\n    });\n\n    labeled_stmt('for', function () {\n\n        var blok, filter, master, ok = false, paren = next_token, value;\n        this.arity = 'statement';\n        funct.loopage += 1;\n        advance('(');\n        if (next_token.id === ';') {\n            no_space();\n            advance(';');\n            no_space();\n            advance(';');\n            no_space();\n            advance(')');\n            blok = block('for');\n        } else {\n            step_in('control');\n            spaces(this, paren);\n            no_space();\n            if (next_token.id === 'var') {\n                next_token.stop('move_var');\n            }\n            edge();\n            if (peek(0).id === 'in') {\n                this.forin = true;\n                value = expression(1000);\n                master = value.master;\n                if (!master) {\n                    value.stop('bad_in_a');\n                }\n                if (master.kind !== 'var' || master.function !== funct ||\n                        !master.writeable || master.dead) {\n                    value.warn('bad_in_a');\n                }\n                master.init = true;\n                master.used -= 1;\n                this.first = value;\n                advance('in');\n                this.second = expression(20);\n                step_out(')', paren);\n                blok = block('for');\n                if (!option.forin) {\n                    if (blok.length === 1 && typeof blok[0] === 'object') {\n                        if (blok[0].id === 'if' && !blok[0].else) {\n                            filter = blok[0].first;\n                            while (filter.id === '&&') {\n                                filter = filter.first;\n                            }\n                            switch (filter.id) {\n                            case '===':\n                            case '!==':\n                                ok = filter.first.id === '['\n                                    ? are_similar(filter.first.first, this.second) &&\n                                        are_similar(filter.first.second, this.first)\n                                    : filter.first.id === 'typeof' &&\n                                        filter.first.first.id === '[' &&\n                                        are_similar(filter.first.first.first, this.second) &&\n                                        are_similar(filter.first.first.second, this.first);\n                                break;\n                            case '(':\n                                ok = filter.first.id === '.' && ((\n                                    are_similar(filter.first.first, this.second) &&\n                                    filter.first.second.string === 'hasOwnProperty' &&\n                                    are_similar(filter.second[0], this.first)\n                                ) || (\n                                    filter.first.first.id === '.' &&\n                                    filter.first.first.first.first &&\n                                    filter.first.first.first.first.string === 'Object' &&\n                                    filter.first.first.first.id === '.' &&\n                                    filter.first.first.first.second.string === 'prototype' &&\n                                    filter.first.first.second.string === 'hasOwnProperty' &&\n                                    filter.first.second.string === 'call' &&\n                                    are_similar(filter.second[0], this.second) &&\n                                    are_similar(filter.second[1], this.first)\n                                ));\n                                break;\n                            }\n                        } else if (blok[0].id === 'switch') {\n                            ok = blok[0].id === 'switch' &&\n                                blok[0].first.id === 'typeof' &&\n                                blok[0].first.first.id === '[' &&\n                                are_similar(blok[0].first.first.first, this.second) &&\n                                are_similar(blok[0].first.first.second, this.first);\n                        }\n                    }\n                    if (!ok) {\n                        this.warn('for_if');\n                    }\n                }\n            } else {\n                edge();\n                this.first = [];\n                for (;;) {\n                    this.first.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                semicolon();\n                edge();\n                this.second = expected_relation(expression(0));\n                if (this.second.id !== 'true') {\n                    expected_condition(this.second, 'unexpected_a');\n                }\n                semicolon(token);\n                if (next_token.id === ';') {\n                    next_token.stop('expected_a_b', ')', ';');\n                }\n                this.third = [];\n                edge();\n                for (;;) {\n                    this.third.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                no_space();\n                step_out(')', paren);\n                one_space();\n                blok = block('for');\n            }\n        }\n        if (blok.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        this.block = blok;\n        funct.loopage -= 1;\n        return this;\n    });\n\n    function optional_label(that) {\n        var label = next_token.string,\n            master;\n        that.arity = 'statement';\n        if (!funct.breakage || (!option.continue && that.id === 'continue')) {\n            that.warn('unexpected_a');\n        } else if (next_token.identifier && token.line === next_token.line) {\n            one_space_only();\n            master = scope[label];\n            if (!master || master.kind !== 'label') {\n                next_token.warn('not_a_label');\n            } else if (master.dead || master.function !== funct) {\n                next_token.warn('not_a_scope');\n            } else {\n                master.used += 1;\n                if (that.id === 'break') {\n                    master.statement.break = true;\n                }\n                if (funct.breakage[funct.breakage.length - 1] === master.statement) {\n                    next_token.warn('unexpected_a');\n                }\n            }\n            that.first = next_token;\n            advance();\n        } else {\n            if (that.id === 'break') {\n                funct.breakage[funct.breakage.length - 1].break = true;\n            }\n        }\n        return that;\n\n    }\n\n    disrupt_stmt('break', function () {\n        return optional_label(this);\n    });\n\n    disrupt_stmt('continue', function () {\n        return optional_label(this);\n    });\n\n    disrupt_stmt('return', function () {\n        if (funct === global_funct) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        if (next_token.id !== ';' && next_token.line === token.line) {\n            if (option.closure) {\n                spaces();\n            } else {\n                one_space_only();\n            }\n            if (next_token.id === '/' || next_token.id === '(regexp)') {\n                next_token.warn('wrap_regexp');\n            }\n            this.first = expression(0);\n            if (this.first.assign) {\n                this.first.warn('unexpected_a');\n            }\n        }\n        return this;\n    });\n\n    disrupt_stmt('throw', function () {\n        this.arity = 'statement';\n        one_space_only();\n        this.first = expression(20);\n        return this;\n    });\n\n\n//  Superfluous reserved words\n\n    reserve('class');\n    reserve('const');\n    reserve('enum');\n    reserve('export');\n    reserve('extends');\n    reserve('import');\n    reserve('super');\n\n// Harmony reserved words\n\n    reserve('implements');\n    reserve('interface');\n    reserve('let');\n    reserve('package');\n    reserve('private');\n    reserve('protected');\n    reserve('public');\n    reserve('static');\n    reserve('yield');\n\n\n// Parse JSON\n\n    function json_value() {\n\n        function json_object() {\n            var brace = next_token, object = Object.create(null);\n            advance('{');\n            if (next_token.id !== '}') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    if (next_token.id !== '(string)') {\n                        next_token.warn('expected_string_a');\n                    }\n                    if (object[next_token.string] === true) {\n                        next_token.warn('duplicate_a');\n                    } else if (next_token.string === '__proto__') {\n                        next_token.warn('dangling_a');\n                    } else {\n                        object[next_token.string] = true;\n                    }\n                    advance();\n                    advance(':');\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === '}') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance('}', brace);\n        }\n\n        function json_array() {\n            var bracket = next_token;\n            advance('[');\n            if (next_token.id !== ']') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === ']') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance(']', bracket);\n        }\n\n        switch (next_token.id) {\n        case '{':\n            json_object();\n            break;\n        case '[':\n            json_array();\n            break;\n        case 'true':\n        case 'false':\n        case 'null':\n        case '(number)':\n        case '(string)':\n            advance();\n            break;\n        case '-':\n            advance('-');\n            no_space_only();\n            advance('(number)');\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n    }\n\n\n// The actual JSLINT function itself.\n\n    itself = function JSLint(the_source, the_option) {\n\n        var i, predef, tree;\n        itself.errors = [];\n        itself.tree = '';\n        itself.properties = '';\n        begin = prev_token = token = next_token =\n            Object.create(syntax['(begin)']);\n        tokens = [];\n        predefined = Object.create(null);\n        add_to_predefined(standard);\n        property = Object.create(null);\n        if (the_option) {\n            option = Object.create(the_option);\n            predef = option.predef;\n            if (predef) {\n                if (Array.isArray(predef)) {\n                    for (i = 0; i < predef.length; i += 1) {\n                        predefined[predef[i]] = true;\n                    }\n                } else if (typeof predef === 'object') {\n                    add_to_predefined(predef);\n                }\n            }\n        } else {\n            option = Object.create(null);\n        }\n        option.indent = +option.indent || 4;\n        option.maxerr = +option.maxerr || 50;\n        global_scope = scope = Object.create(null);\n        global_funct = funct = {\n            scope: scope,\n            loopage: 0,\n            level: 0\n        };\n        functions = [funct];\n        block_var = [];\n\n        comments = [];\n        comments_off = false;\n        in_block = false;\n        indent = null;\n        json_mode = false;\n        lookahead = [];\n        node_js = false;\n        prereg = true;\n        strict_mode = false;\n        var_mode = null;\n        warnings = 0;\n        lex.init(the_source);\n\n        assume();\n\n        try {\n            advance();\n            if (next_token.id === '(number)') {\n                next_token.stop('unexpected_a');\n            } else {\n                switch (next_token.id) {\n                case '{':\n                case '[':\n                    comments_off = true;\n                    json_mode = true;\n                    json_value();\n                    break;\n                default:\n\n// If the first token is a semicolon, ignore it. This is sometimes used when\n// files are intended to be appended to files that may be sloppy. A sloppy\n// file may be depending on semicolon insertion on its last line.\n\n                    step_in(1);\n                    if (next_token.id === ';' && !node_js) {\n                        next_token.edge = true;\n                        advance(';');\n                    }\n                    tree = statements();\n                    begin.first = tree;\n                    itself.tree = begin;\n                    if (tree.disrupt) {\n                        prev_token.warn('weird_program');\n                    }\n                }\n            }\n            indent = null;\n            advance('(end)');\n            itself.property = property;\n        } catch (e) {\n            if (e) {        // ~~\n                itself.errors.push({\n                    reason    : e.message,\n                    line      : e.line || next_token.line,\n                    character : e.character || next_token.from\n                }, null);\n            }\n        }\n        return itself.errors.length === 0;\n    };\n\n    function unique(array) {\n        array = array.sort();\n        var i, length = 0, previous, value;\n        for (i = 0; i < array.length; i += 1) {\n            value = array[i];\n            if (value !== previous) {\n                array[length] = value;\n                previous = value;\n                length += 1;\n            }\n        }\n        array.length = length;\n        return array;\n    }\n\n// Data summary.\n\n    itself.data = function () {\n        var data = {functions: []},\n            function_data,\n            i,\n            the_function,\n            the_scope;\n        data.errors = itself.errors;\n        data.json = json_mode;\n        data.global = unique(Object.keys(global_scope));\n\n        function selects(name) {\n            var kind = the_scope[name].kind;\n            switch (kind) {\n            case 'var':\n            case 'exception':\n            case 'label':\n                function_data[kind].push(name);\n                break;\n            }\n        }\n\n        for (i = 1; i < functions.length; i += 1) {\n            the_function = functions[i];\n            function_data = {\n                name: the_function.name,\n                line: the_function.line,\n                level: the_function.level,\n                parameter: the_function.parameter,\n                var: [],\n                exception: [],\n                closure: unique(the_function.closure),\n                outer: unique(the_function.outer),\n                global: unique(the_function.global),\n                label: []\n            };\n            the_scope = the_function.scope;\n            Object.keys(the_scope).forEach(selects);\n            function_data.var.sort();\n            function_data.exception.sort();\n            function_data.label.sort();\n            data.functions.push(function_data);\n        }\n        data.tokens = tokens;\n        return data;\n    };\n\n    itself.error_report = function (data) {\n        var evidence, i, output = [], warning;\n        if (data.errors.length) {\n            if (data.json) {\n                output.push('<cite>JSON: bad.</cite><br>');\n            }\n            for (i = 0; i < data.errors.length; i += 1) {\n                warning = data.errors[i];\n                if (warning) {\n                    evidence = warning.evidence || '';\n                    output.push('<cite>');\n                    if (isFinite(warning.line)) {\n                        output.push('<address>line ' +\n                            String(warning.line) +\n                            ' character ' + String(warning.character) +\n                            '</address>');\n                    }\n                    output.push(warning.reason.entityify() + '</cite>');\n                    if (evidence) {\n                        output.push('<pre>' + evidence.entityify() + '</pre>');\n                    }\n                }\n            }\n        }\n        return output.join('');\n    };\n\n\n    itself.report = function (data) {\n        var dl, i, j, names, output = [], the_function;\n\n        function detail(h, array) {\n            var comma_needed = false;\n            if (array.length) {\n                output.push(\"<dt>\" + h + \"</dt><dd>\");\n                array.forEach(function (item) {\n                    output.push((comma_needed ? ', ' : '') + item);\n                    comma_needed = true;\n                });\n                output.push(\"</dd>\");\n            }\n        }\n\n        output.push('<dl class=level0>');\n        if (data.global.length) {\n            detail('global', data.global);\n            dl = true;\n        } else if (data.json) {\n            if (!data.errors.length) {\n                output.push(\"<dt>JSON: good.</dt>\");\n            }\n        } else {\n            output.push(\"<dt><i>No new global variables introduced.</i></dt>\");\n        }\n        if (dl) {\n            output.push(\"</dl>\");\n        } else {\n            output[0] = '';\n        }\n\n        if (data.functions) {\n            for (i = 0; i < data.functions.length; i += 1) {\n                the_function = data.functions[i];\n                names = [];\n                if (the_function.params) {\n                    for (j = 0; j < the_function.params.length; j += 1) {\n                        names[j] = the_function.params[j].string;\n                    }\n                }\n                output.push('<dl class=level' + the_function.level +\n                    '><address>line ' + String(the_function.line) +\n                    '</address>' + the_function.name.entityify());\n                detail('parameter', the_function.parameter);\n                detail('variable', the_function.var);\n                detail('exception', the_function.exception);\n                detail('closure', the_function.closure);\n                detail('outer', the_function.outer);\n                detail('global', the_function.global);\n                detail('label', the_function.label);\n                output.push('</dl>');\n            }\n        }\n        return output.join('');\n    };\n\n    itself.properties_report = function (property) {\n        if (!property) {\n            return '';\n        }\n        var i,\n            key,\n            keys = Object.keys(property).sort(),\n            mem = '   ',\n            name,\n            not_first = false,\n            output = ['/*properties'];\n        for (i = 0; i < keys.length; i += 1) {\n            key = keys[i];\n            if (property[key] > 0) {\n                if (not_first) {\n                    mem += ',';\n                }\n                name = ix.test(key)\n                    ? key\n                    : '\\'' + key.replace(nx, sanitize) + '\\'';\n                if (mem.length + name.length >= 80) {\n                    output.push(mem);\n                    mem = '    ';\n                } else {\n                    mem += ' ';\n                }\n                mem += name;\n                not_first = true;\n            }\n        }\n        output.push(mem, '*/\\n');\n        return output.join('\\n');\n    };\n\n    itself.color = function (data) {\n        var from,\n            i = 1,\n            level,\n            line,\n            result = [],\n            thru,\n            data_token = data.tokens[0];\n        while (data_token && data_token.id !== '(end)') {\n            from = data_token.from;\n            line = data_token.line;\n            thru = data_token.thru;\n            level = data_token.function.level;\n            do {\n                thru = data_token.thru;\n                data_token = data.tokens[i];\n                i += 1;\n            } while (data_token && data_token.line === line &&\n                    data_token.from - thru < 5 &&\n                    level === data_token.function.level);\n            result.push({\n                line: line,\n                level: level,\n                from: from,\n                thru: thru\n            });\n        }\n        return result;\n    };\n\n    itself.jslint = itself;\n\n    itself.edition = '2014-04-08';\n\n    return itself;\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jslint-2014-07-08.js":"// jslint.js\n// 2014-07-08\n\n// Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// The Software shall be used for Good, not Evil.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// WARNING: JSLint will hurt your feelings.\n\n// JSLINT is a global function. It takes two parameters.\n\n//     var myResult = JSLINT(source, option);\n\n// The first parameter is either a string or an array of strings. If it is a\n// string, it will be split on '\\n' or '\\r'. If it is an array of strings, it\n// is assumed that each string represents one line. The source can be a\n// JavaScript text or a JSON text.\n\n// The second parameter is an optional object of options that control the\n// operation of JSLINT. Most of the options are booleans: They are all\n// optional and have a default value of false. One of the options, predef,\n// can be an array of names, which will be used to declare global variables,\n// or an object whose keys are used as global names, with a boolean value\n// that determines if they are assignable.\n\n// If it checks out, JSLINT returns true. Otherwise, it returns false.\n\n// If false, you can inspect JSLINT.errors to find out the problems.\n// JSLINT.errors is an array of objects containing these properties:\n\n//  {\n//      line      : The line (relative to 0) at which the lint was found\n//      character : The character (relative to 0) at which the lint was found\n//      reason    : The problem\n//      evidence  : The text line in which the problem occurred\n//      raw       : The raw message before the details were inserted\n//      a         : The first detail\n//      b         : The second detail\n//      c         : The third detail\n//      d         : The fourth detail\n//  }\n\n// If a stopping error was found, a null will be the last element of the\n// JSLINT.errors array. A stopping error means that JSLint was not confident\n// enough to continue. It does not necessarily mean that the error was\n// especially heinous.\n\n// You can request a data structure that contains JSLint's results.\n\n//     var myData = JSLINT.data();\n\n// It returns a structure with this form:\n\n//     {\n//         errors: [\n//             {\n//                 line: NUMBER,\n//                 character: NUMBER,\n//                 reason: STRING,\n//                 evidence: STRING\n//             }\n//         ],\n//         functions: [\n//             {\n//                 name: STRING,\n//                 line: NUMBER,\n//                 level: NUMBER,\n//                 parameter: [\n//                     STRING\n//                 ],\n//                 var: [\n//                     STRING\n//                 ],\n//                 exception: [\n//                     STRING\n//                 ],\n//                 closure: [\n//                     STRING\n//                 ],\n//                 outer: [\n//                     STRING\n//                 ],\n//                 global: [\n//                     STRING\n//                 ],\n//                 label: [\n//                     STRING\n//                 ]\n//             }\n//         ],\n//         global: [\n//             STRING\n//         ],\n//         member: {\n//             STRING: NUMBER\n//         },\n//         json: BOOLEAN\n//     }\n\n// You can request a Function Report, which shows all of the functions\n// and the parameters and vars that they use. This can be used to find\n// implied global variables and other problems. The report is in HTML and\n// can be inserted into an HTML <body>. It should be given the result of the\n// JSLINT.data function.\n\n//     var myReport = JSLINT.report(data);\n\n// You can request an HTML error report.\n\n//     var myErrorReport = JSLINT.error_report(data);\n\n// You can obtain an object containing all of the properties found in the\n// file. JSLINT.property contains an object containing a key for each\n// property used in the program, the value being the number of times that\n// property name was used in the file.\n\n// You can request a properties report, which produces a list of the program's\n// properties in the form of a /*properties*/ declaration.\n\n//      var myPropertyReport = JSLINT.properties_report(JSLINT.property);\n\n// You can obtain the parse tree that JSLint constructed while parsing. The\n// latest tree is kept in JSLINT.tree. A nice stringification can be produced\n// with\n\n//     JSON.stringify(JSLINT.tree, [\n//         'string',  'arity', 'name',  'first',\n//         'second', 'third', 'block', 'else'\n//     ], 4));\n\n// You can request a context coloring table. It contains information that can be\n// applied to the file that was analyzed. Context coloring colors functions\n// based on their nesting level, and variables on the color of the functions\n// in which they are defined.\n\n//      var myColorization = JSLINT.color(data);\n\n// It returns an array containing objects of this form:\n\n//      {\n//          from: COLUMN,\n//          thru: COLUMN,\n//          line: ROW,\n//          level: 0 or higher\n//      }\n\n// JSLint provides three inline directives. They look like slashstar comments,\n// and allow for setting options, declaring global variables, and establishing a\n// set of allowed property names.\n\n// These directives respect function scope.\n\n// The jslint directive is a special comment that can set one or more options.\n// For example:\n\n/*jslint\n    evil: true, nomen: true, regexp: true, todo: true\n*/\n\n// The current option set is\n\n//     ass        true, if assignment expressions should be allowed\n//     bitwise    true, if bitwise operators should be allowed\n//     browser    true, if the standard browser globals should be predefined\n//     closure    true, if Google Closure idioms should be tolerated\n//     continue   true, if the continuation statement should be tolerated\n//     debug      true, if debugger statements should be allowed\n//     devel      true, if logging should be allowed (console, alert, etc.)\n//     eqeq       true, if == should be allowed\n//     evil       true, if eval should be allowed\n//     forin      true, if for in statements need not filter\n//     indent     the indentation factor\n//     maxerr     the maximum number of errors to allow\n//     maxlen     the maximum length of a source line\n//     newcap     true, if constructor names capitalization is ignored\n//     node       true, if Node.js globals should be predefined\n//     nomen      true, if names may have dangling _\n//     passfail   true, if the scan should stop on first error\n//     plusplus   true, if increment/decrement should be allowed\n//     properties true, if all property names must be declared with /*properties*/\n//     regexp     true, if the . should be allowed in regexp literals\n//     rhino      true, if the Rhino environment globals should be predefined\n//     unparam    true, if unused parameters should be tolerated\n//     sloppy     true, if the 'use strict'; pragma is optional\n//     stupid     true, if really stupid practices are tolerated\n//     sub        true, if all forms of subscript notation are tolerated\n//     todo       true, if TODO comments are tolerated\n//     vars       true, if multiple var statements per function should be allowed\n//     white      true, if sloppy whitespace is tolerated\n\n// The properties directive declares an exclusive list of property names.\n// Any properties named in the program that are not in the list will\n// produce a warning.\n\n// For example:\n\n/*properties\n    '\\b', '\\t', '\\n', '\\f', '\\r', '!', '!=', '!==', '\"', '%', '\\'', '(begin)',\n    '(error)', '*', '+', '-', '/', '<', '<=', '==', '===', '>', '>=', '\\\\', a,\n    a_label, a_scope, already_defined, and, apply, arguments, arity, ass,\n    assign, assignment_expression, assignment_function_expression, at, avoid_a,\n    b, bad_assignment, bad_constructor, bad_in_a, bad_invocation, bad_new,\n    bad_number, bad_operand, bad_wrap, bitwise, block, break, breakage, browser,\n    c, call, charAt, charCodeAt, character, closure, code, color, combine_var,\n    comments, conditional_assignment, confusing_a, confusing_regexp,\n    constructor_name_a, continue, control_a, couch, create, d, dangling_a, data,\n    dead, debug, deleted, devel, disrupt, duplicate_a, edge, edition, elif,\n    else, empty_block, empty_case, empty_class, entityify, eqeq, error_report,\n    errors, evidence, evil, exception, exec, expected_a_at_b_c, expected_a_b,\n    expected_a_b_from_c_d, expected_id_a, expected_identifier_a,\n    expected_identifier_a_reserved, expected_number_a, expected_operator_a,\n    expected_positive_a, expected_small_a, expected_space_a_b,\n    expected_string_a, f, first, flag, floor, forEach, for_if, forin, from,\n    fromCharCode, fud, function, function_block, function_eval, function_loop,\n    function_statement, function_strict, functions, global, hasOwnProperty, id,\n    identifier, identifier_function, immed, implied_evil, indent, indexOf,\n    infix_in, init, insecure_a, isAlpha, isArray, isDigit, isNaN, join, jslint,\n    json, keys, kind, label, labeled, lbp, leading_decimal_a, led, left, length,\n    level, line, loopage, master, match, maxerr, maxlen, message, missing_a,\n    missing_a_after_b, missing_property, missing_space_a_b, missing_use_strict,\n    mode, move_invocation, move_var, n, name, name_function, nested_comment,\n    newcap, node, nomen, not, not_a_constructor, not_a_defined, not_a_function,\n    not_a_label, not_a_scope, not_greater, nud, number, octal_a, open, outer,\n    parameter, parameter_a_get_b, parameter_arguments_a, parameter_set_a,\n    params, paren, passfail, plusplus, pop, postscript, predef, properties,\n    properties_report, property, prototype, push, quote, r, radix, raw,\n    read_only, reason, redefinition_a_b, regexp, relation, replace, report,\n    reserved, reserved_a, rhino, right, scanned_a_b, scope, search, second,\n    shift, slash_equal, slice, sloppy, sort, split, statement, statement_block,\n    stop, stopping, strange_loop, strict, string, stupid, sub, subscript,\n    substr, supplant, sync_a, t, tag_a_in_b, test, third, thru, toString, todo,\n    todo_comment, token, tokens, too_long, too_many, trailing_decimal_a, tree,\n    unclosed, unclosed_comment, unclosed_regexp, unescaped_a, unexpected_a,\n    unexpected_char_a, unexpected_comment, unexpected_label_a,\n    unexpected_property_a, unexpected_space_a_b, unexpected_typeof_a,\n    uninitialized_a, unnecessary_else, unnecessary_initialize, unnecessary_use,\n    unparam, unreachable_a_b, unsafe, unused_a, url, use_array, use_braces,\n    use_nested_if, use_object, use_or, use_param, use_spaces, used,\n    used_before_a, var, var_a_not, var_loop, vars, varstatement, warn, warning,\n    was, weird_assignment, weird_condition, weird_new, weird_program,\n    weird_relation, weird_ternary, white, wrap, wrap_immediate, wrap_regexp,\n    write_is_wrong, writeable\n*/\n\n// The global directive is used to declare global variables that can\n// be accessed by the program. If a declaration is true, then the variable\n// is writeable. Otherwise, it is read-only.\n\n// We build the application inside a function so that we produce only a single\n// global variable. That function will be invoked immediately, and its return\n// value is the JSLINT function itself. That function is also an object that\n// can contain data and other functions.\n\nvar JSLINT = (function () {\n    'use strict';\n\n    function array_to_object(array, value) {\n\n// Make an object from an array of keys and a common value.\n\n        var i, length = array.length, object = Object.create(null);\n        for (i = 0; i < length; i += 1) {\n            object[array[i]] = value;\n        }\n        return object;\n    }\n\n\n    var allowed_option = {\n            ass       : true,\n            bitwise   : true,\n            browser   : true,\n            closure   : true,\n            continue  : true,\n            couch     : true,\n            debug     : true,\n            devel     : true,\n            eqeq      : true,\n            evil      : true,\n            forin     : true,\n            indent    :   10,\n            maxerr    : 1000,\n            maxlen    :  256,\n            newcap    : true,\n            node      : true,\n            nomen     : true,\n            passfail  : true,\n            plusplus  : true,\n            properties: true,\n            regexp    : true,\n            rhino     : true,\n            unparam   : true,\n            sloppy    : true,\n            stupid    : true,\n            sub       : true,\n            todo      : true,\n            vars      : true,\n            white     : true\n        },\n        anonname,       // The guessed name for anonymous functions.\n\n// These are operators that should not be used with the ! operator.\n\n        bang = {\n            '<'  : true,\n            '<=' : true,\n            '==' : true,\n            '===': true,\n            '!==': true,\n            '!=' : true,\n            '>'  : true,\n            '>=' : true,\n            '+'  : true,\n            '-'  : true,\n            '*'  : true,\n            '/'  : true,\n            '%'  : true\n        },\n        begin,          // The root token\n        block_var,     // vars defined in the current block\n\n// browser contains a set of global names that are commonly provided by a\n// web browser environment.\n\n        browser = array_to_object([\n            'clearInterval', 'clearTimeout', 'document', 'event', 'FormData',\n            'frames', 'history', 'Image', 'localStorage', 'location', 'name',\n            'navigator', 'Option', 'parent', 'screen', 'sessionStorage',\n            'setInterval', 'setTimeout', 'Storage', 'window', 'XMLHttpRequest'\n        ], false),\n\n// bundle contains the text messages.\n\n        bundle = {\n            a_label: \"'{a}' is a statement label.\",\n            a_scope: \"'{a}' used out of scope.\",\n            already_defined: \"'{a}' is already defined.\",\n            and: \"The '&&' subexpression should be wrapped in parens.\",\n            assignment_expression: \"Unexpected assignment expression.\",\n            assignment_function_expression: \"Expected an assignment or \" +\n                \"function call and instead saw an expression.\",\n            avoid_a: \"Avoid '{a}'.\",\n            bad_assignment: \"Bad assignment.\",\n            bad_constructor: \"Bad constructor.\",\n            bad_in_a: \"Bad for in variable '{a}'.\",\n            bad_invocation: \"Bad invocation.\",\n            bad_new: \"Do not use 'new' for side effects.\",\n            bad_number: \"Bad number '{a}'.\",\n            bad_operand: \"Bad operand.\",\n            bad_wrap: \"Do not wrap function literals in parens unless they \" +\n                \"are to be immediately invoked.\",\n            combine_var: \"Combine this with the previous 'var' statement.\",\n            conditional_assignment: \"Expected a conditional expression and \" +\n                \"instead saw an assignment.\",\n            confusing_a: \"Confusing use of '{a}'.\",\n            confusing_regexp: \"Confusing regular expression.\",\n            constructor_name_a: \"A constructor name '{a}' should start with \" +\n                \"an uppercase letter.\",\n            control_a: \"Unexpected control character '{a}'.\",\n            dangling_a: \"Unexpected dangling '_' in '{a}'.\",\n            deleted: \"Only properties should be deleted.\",\n            duplicate_a: \"Duplicate '{a}'.\",\n            empty_block: \"Empty block.\",\n            empty_case: \"Empty case.\",\n            empty_class: \"Empty class.\",\n            evil: \"eval is evil.\",\n            expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n            expected_a_b_from_c_d: \"Expected '{a}' to match '{b}' from line \" +\n                \"{c} and instead saw '{d}'.\",\n            expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n            expected_id_a: \"Expected an id, and instead saw #{a}.\",\n            expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n            expected_identifier_a_reserved: \"Expected an identifier and \" +\n                \"instead saw '{a}' (a reserved word).\",\n            expected_number_a: \"Expected a number and instead saw '{a}'.\",\n            expected_operator_a: \"Expected an operator and instead saw '{a}'.\",\n            expected_positive_a: \"Expected a positive number and instead saw '{a}'\",\n            expected_small_a: \"Expected a small positive integer and instead saw '{a}'\",\n            expected_space_a_b: \"Expected exactly one space between '{a}' and '{b}'.\",\n            expected_string_a: \"Expected a string and instead saw '{a}'.\",\n            for_if: \"The body of a for in should be wrapped in an if \" +\n                \"statement to filter unwanted properties from the prototype.\",\n            function_block: \"Function statements should not be placed in blocks.\" +\n                \"Use a function expression or move the statement to the top of \" +\n                \"the outer function.\",\n            function_eval: \"The Function constructor is eval.\",\n            function_loop: \"Don't make functions within a loop.\",\n            function_statement: \"Function statements are not invocable. \" +\n                \"Wrap the whole function invocation in parens.\",\n            function_strict: \"Use the function form of 'use strict'.\",\n            identifier_function: \"Expected an identifier in an assignment \" +\n                \"and instead saw a function invocation.\",\n            implied_evil: \"Implied eval is evil. Pass a function instead of a string.\",\n            infix_in: \"Unexpected 'in'. Compare with undefined, or use the \" +\n                \"hasOwnProperty method instead.\",\n            insecure_a: \"Insecure '{a}'.\",\n            isNaN: \"Use the isNaN function to compare with NaN.\",\n            leading_decimal_a: \"A leading decimal point can be confused with a dot: '.{a}'.\",\n            missing_a: \"Missing '{a}'.\",\n            missing_a_after_b: \"Missing '{a}' after '{b}'.\",\n            missing_property: \"Missing property name.\",\n            missing_space_a_b: \"Missing space between '{a}' and '{b}'.\",\n            missing_use_strict: \"Missing 'use strict' statement.\",\n            move_invocation: \"Move the invocation into the parens that \" +\n                \"contain the function.\",\n            move_var: \"Move 'var' declarations to the top of the function.\",\n            name_function: \"Missing name in function statement.\",\n            nested_comment: \"Nested comment.\",\n            not: \"Nested not.\",\n            not_a_constructor: \"Do not use {a} as a constructor.\",\n            not_a_defined: \"'{a}' has not been fully defined yet.\",\n            not_a_function: \"'{a}' is not a function.\",\n            not_a_label: \"'{a}' is not a label.\",\n            not_a_scope: \"'{a}' is out of scope.\",\n            not_greater: \"'{a}' should not be greater than '{b}'.\",\n            octal_a: \"Don't use octal: '{a}'. Use '\\\\u....' instead.\",\n            parameter_arguments_a: \"Do not mutate parameter '{a}' when using 'arguments'.\",\n            parameter_a_get_b: \"Unexpected parameter '{a}' in get {b} function.\",\n            parameter_set_a: \"Expected parameter (value) in set {a} function.\",\n            radix: \"Missing radix parameter.\",\n            read_only: \"Read only.\",\n            redefinition_a_b: \"Redefinition of '{a}' from line {b}.\",\n            reserved_a: \"Reserved name '{a}'.\",\n            scanned_a_b: \"{a} ({b}% scanned).\",\n            slash_equal: \"A regular expression literal can be confused with '/='.\",\n            statement_block: \"Expected to see a statement and instead saw a block.\",\n            stopping: \"Stopping.\",\n            strange_loop: \"Strange loop.\",\n            strict: \"Strict violation.\",\n            subscript: \"['{a}'] is better written in dot notation.\",\n            sync_a: \"Unexpected sync method: '{a}'.\",\n            tag_a_in_b: \"A '<{a}>' must be within '<{b}>'.\",\n            todo_comment: \"Unexpected TODO comment.\",\n            too_long: \"Line too long.\",\n            too_many: \"Too many errors.\",\n            trailing_decimal_a: \"A trailing decimal point can be confused \" +\n                \"with a dot: '.{a}'.\",\n            unclosed: \"Unclosed string.\",\n            unclosed_comment: \"Unclosed comment.\",\n            unclosed_regexp: \"Unclosed regular expression.\",\n            unescaped_a: \"Unescaped '{a}'.\",\n            unexpected_a: \"Unexpected '{a}'.\",\n            unexpected_char_a: \"Unexpected character '{a}'.\",\n            unexpected_comment: \"Unexpected comment.\",\n            unexpected_label_a: \"Unexpected label '{a}'.\",\n            unexpected_property_a: \"Unexpected /*property*/ '{a}'.\",\n            unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n            unexpected_typeof_a: \"Unexpected 'typeof'. \" +\n                \"Use '===' to compare directly with {a}.\",\n            uninitialized_a: \"Uninitialized '{a}'.\",\n            unnecessary_else: \"Unnecessary 'else' after disruption.\",\n            unnecessary_initialize: \"It is not necessary to initialize '{a}' \" +\n                \"to 'undefined'.\",\n            unnecessary_use: \"Unnecessary 'use strict'.\",\n            unreachable_a_b: \"Unreachable '{a}' after '{b}'.\",\n            unsafe: \"Unsafe character.\",\n            unused_a: \"Unused '{a}'.\",\n            url: \"JavaScript URL.\",\n            use_array: \"Use the array literal notation [].\",\n            use_braces: \"Spaces are hard to count. Use {{a}}.\",\n            use_nested_if: \"Expected 'else { if' and instead saw 'else if'.\",\n            use_object: \"Use the object literal notation {} or Object.create(null).\",\n            use_or: \"Use the || operator.\",\n            use_param: \"Use a named parameter.\",\n            use_spaces: \"Use spaces, not tabs.\",\n            used_before_a: \"'{a}' was used before it was defined.\",\n            var_a_not: \"Variable {a} was not declared correctly.\",\n            var_loop: \"Don't declare variables in a loop.\",\n            weird_assignment: \"Weird assignment.\",\n            weird_condition: \"Weird condition.\",\n            weird_new: \"Weird construction. Delete 'new'.\",\n            weird_program: \"Weird program.\",\n            weird_relation: \"Weird relation.\",\n            weird_ternary: \"Weird ternary.\",\n            wrap_immediate: \"Wrap an immediate function invocation in \" +\n                \"parentheses to assist the reader in understanding that the \" +\n                \"expression is the result of a function, and not the \" +\n                \"function itself.\",\n            wrap_regexp: \"Wrap the /regexp/ literal in parens to \" +\n                \"disambiguate the slash operator.\",\n            write_is_wrong: \"document.write can be a form of eval.\"\n        },\n        closure = array_to_object([\n            'goog'\n        ], false),\n        comments,\n        comments_off,\n        couch = array_to_object([\n            'emit', 'getRow', 'isArray', 'log', 'provides', 'registerType',\n            'require', 'send', 'start', 'sum', 'toJSON'\n        ], false),\n\n        descapes = {\n            'b': '\\b',\n            't': '\\t',\n            'n': '\\n',\n            'f': '\\f',\n            'r': '\\r',\n            '\"': '\"',\n            '/': '/',\n            '\\\\': '\\\\',\n            '!': '!'\n        },\n\n        devel = array_to_object([\n            'alert', 'confirm', 'console', 'Debug', 'opera', 'prompt', 'WSH'\n        ], false),\n        directive,\n        escapes = {\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\\'': '\\\\\\'',\n            '\"' : '\\\\\"',\n            '/' : '\\\\/',\n            '\\\\': '\\\\\\\\'\n        },\n\n        funct,          // The current function\n\n        functions,      // All of the functions\n        global_funct,   // The global body\n        global_scope,   // The global scope\n        in_block,       // Where function statements are not allowed\n        indent,\n        itself,         // JSLINT itself\n        json_mode,\n        lex,            // the tokenizer\n        lines,\n        lookahead,\n        node = array_to_object([\n            'Buffer', 'clearImmediate', 'clearInterval', 'clearTimeout',\n            'console', 'exports', 'global', 'module', 'process',\n            'require', 'setImmediate', 'setInterval', 'setTimeout',\n            '__dirname', '__filename'\n        ], false),\n        node_js,\n        numbery = array_to_object(['indexOf', 'lastIndexOf', 'search'], true),\n        next_token,\n        option,\n        predefined,     // Global variables defined by option\n        prereg,\n        prev_token,\n        property,\n        protosymbol,\n        regexp_flag = array_to_object(['g', 'i', 'm'], true),\n        return_this = function return_this() {\n            return this;\n        },\n        rhino = array_to_object([\n            'defineClass', 'deserialize', 'gc', 'help', 'load', 'loadClass',\n            'print', 'quit', 'readFile', 'readUrl', 'runCommand', 'seal',\n            'serialize', 'spawn', 'sync', 'toint32', 'version'\n        ], false),\n\n        scope,      // An object containing an object for each variable in scope\n        semicolon_coda = array_to_object([';', '\"', '\\'', ')'], true),\n\n// standard contains the global names that are provided by the\n// ECMAScript standard.\n\n        standard = array_to_object([\n            'Array', 'Boolean', 'Date', 'decodeURI', 'decodeURIComponent',\n            'encodeURI', 'encodeURIComponent', 'Error', 'eval', 'EvalError',\n            'Function', 'isFinite', 'isNaN', 'JSON', 'Map', 'Math', 'Number',\n            'Object', 'parseInt', 'parseFloat', 'Promise', 'Proxy',\n            'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set',\n            'String', 'Symbol', 'SyntaxError', 'System', 'TypeError',\n            'URIError', 'WeakMap', 'WeakSet'\n        ], false),\n\n        strict_mode,\n        syntax = Object.create(null),\n        token,\n        tokens,\n        var_mode,\n        warnings,\n\n// Regular expressions. Some of these are stupidly long.\n\n// carriage return, carriage return linefeed, or linefeed\n        crlfx = /\\r\\n?|\\n/,\n// unsafe characters that are silently deleted by one or more browsers\n        cx = /[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n// identifier\n        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,\n// javascript url\n        jx = /^(?:javascript|jscript|ecmascript|vbscript)\\s*:/i,\n// star slash\n        lx = /\\*\\/|\\/\\*/,\n// characters in strings that need escapement\n        nx = /[\\u0000-\\u001f'\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n// sync\n        syx = /Sync$/,\n// comment todo\n        tox = /^\\W*to\\s*do(?:\\W|$)/i,\n// token\n        tx = /^\\s*([(){}\\[\\]\\?.,:;'\"~#@`]|={1,3}|\\/(\\*(jslint|properties|property|members?|globals?)?|=|\\/)?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|[\\^%]=?|&[&=]?|\\|[|=]?|>{1,3}=?|<(?:[\\/=!]|\\!(\\[|--)?|<=?)?|\\!(\\!|==?)?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+(?:[xX][0-9a-fA-F]+|\\.[0-9]*)?(?:[eE][+\\-]?[0-9]+)?)/;\n\n\n    if (typeof String.prototype.entityify !== 'function') {\n        String.prototype.entityify = function () {\n            return this\n                .replace(/&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;');\n        };\n    }\n\n    if (typeof String.prototype.isAlpha !== 'function') {\n        String.prototype.isAlpha = function () {\n            return (this >= 'a' && this <= 'z\\uffff') ||\n                (this >= 'A' && this <= 'Z\\uffff');\n        };\n    }\n\n    if (typeof String.prototype.isDigit !== 'function') {\n        String.prototype.isDigit = function () {\n            return (this >= '0' && this <= '9');\n        };\n    }\n\n    if (typeof String.prototype.supplant !== 'function') {\n        String.prototype.supplant = function (o) {\n            return this.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n                var replacement = o[b];\n                return typeof replacement === 'string' ||\n                    typeof replacement === 'number' ? replacement : a;\n            });\n        };\n    }\n\n\n    function sanitize(a) {\n\n//  Escapify a troublesome character.\n\n        return escapes[a] ||\n            '\\\\u' + ('0000' + a.charCodeAt().toString(16)).slice(-4);\n    }\n\n\n    function add_to_predefined(group) {\n        Object.keys(group).forEach(function (name) {\n            predefined[name] = group[name];\n        });\n    }\n\n\n    function assume() {\n        if (option.browser) {\n            add_to_predefined(browser);\n            option.browser = false;\n        }\n        if (option.closure) {\n            add_to_predefined(closure);\n        }\n        if (option.couch) {\n            add_to_predefined(couch);\n            option.couch = false;\n        }\n        if (option.devel) {\n            add_to_predefined(devel);\n            option.devel = false;\n        }\n        if (option.node) {\n            add_to_predefined(node);\n            option.node = false;\n            node_js = true;\n        }\n        if (option.rhino) {\n            add_to_predefined(rhino);\n            option.rhino = false;\n        }\n    }\n\n\n// Produce an error warning.\n\n    function artifact(tok) {\n        if (!tok) {\n            tok = next_token;\n        }\n        return tok.id === '(number)' ? tok.number : tok.string;\n    }\n\n    function quit(message, line, character) {\n        throw {\n            name: 'JSLintError',\n            line: line,\n            character: character,\n            message: bundle.scanned_a_b.supplant({\n                a: bundle[message] || message,\n                b: Math.floor((line / lines.length) * 100)\n            })\n        };\n    }\n\n    function warn(code, line, character, a, b, c, d) {\n        var warning = {         // ~~\n            id: '(error)',\n            raw: bundle[code] || code,\n            code: code,\n            evidence: lines[line - 1] || '',\n            line: line,\n            character: character,\n            a: a || artifact(this),\n            b: b,\n            c: c,\n            d: d\n        };\n        warning.reason = warning.raw.supplant(warning);\n        itself.errors.push(warning);\n        if (option.passfail) {\n            quit('stopping', line, character);\n        }\n        warnings += 1;\n        if (warnings >= option.maxerr) {\n            quit('too_many', line, character);\n        }\n        return warning;\n    }\n\n    function stop(code, line, character, a, b, c, d) {\n        var warning = warn(code, line, character, a, b, c, d);\n        quit('stopping', warning.line, warning.character);\n    }\n\n    function expected_at(at) {\n        if (!option.white && next_token.from !== at) {\n            next_token.warn('expected_a_at_b_c', '', at, next_token.from);\n        }\n    }\n\n// lexical analysis and token construction\n\n    lex = (function lex() {\n        var character, c, from, length, line, pos, source_row;\n\n// Private lex methods\n\n        function next_line() {\n            var at;\n            character = 1;\n            source_row = lines[line];\n            line += 1;\n            if (source_row === undefined) {\n                return false;\n            }\n            at = source_row.search(/\\t/);\n            if (at >= 0) {\n                if (option.white) {\n                    source_row = source_row.replace(/\\t/g, ' ');\n                } else {\n                    warn('use_spaces', line, at + 1);\n                }\n            }\n            at = source_row.search(cx);\n            if (at >= 0) {\n                warn('unsafe', line, at);\n            }\n            if (option.maxlen && option.maxlen < source_row.length) {\n                warn('too_long', line, source_row.length);\n            }\n            return true;\n        }\n\n// Produce a token object.  The token inherits from a syntax symbol.\n\n        function it(type, value) {\n            var id, the_token;\n            if (type === '(string)') {\n                if (jx.test(value)) {\n                    warn('url', line, from);\n                }\n            }\n            the_token = Object.create(syntax[(\n                type === '(punctuator)' || (type === '(identifier)' &&\n                        Object.prototype.hasOwnProperty.call(syntax, value))\n                    ? value\n                    : type\n            )] || syntax['(error)']);\n            if (type === '(identifier)') {\n                the_token.identifier = true;\n                if (value === '__iterator__' || value === '__proto__') {\n                    stop('reserved_a', line, from, value);\n                } else if (!option.nomen &&\n                        (value.charAt(0) === '_' ||\n                        value.charAt(value.length - 1) === '_')) {\n                    warn('dangling_a', line, from, value);\n                }\n            }\n            if (type === '(number)') {\n                the_token.number = +value;\n            } else if (value !== undefined) {\n                the_token.string = String(value);\n            }\n            the_token.line = line;\n            the_token.from = from;\n            the_token.thru = character;\n            if (comments.length) {\n                the_token.comments = comments;\n                comments = [];\n            }\n            id = the_token.id;\n            prereg = id && (\n                ('(,=:[!&|?{};~+-*%^<>'.indexOf(id.charAt(id.length - 1)) >= 0) ||\n                id === 'return' || id === 'case'\n            );\n            return the_token;\n        }\n\n        function match(x) {\n            var exec = x.exec(source_row), first;\n            if (exec) {\n                length = exec[0].length;\n                first = exec[1];\n                c = first.charAt(0);\n                source_row = source_row.slice(length);\n                from = character + length - first.length;\n                character += length;\n                return first;\n            }\n            for (;;) {\n                if (!source_row) {\n                    if (!option.white) {\n                        warn('unexpected_char_a', line, character - 1, '(space)');\n                    }\n                    return;\n                }\n                c = source_row.charAt(0);\n                if (c !== ' ') {\n                    break;\n                }\n                source_row = source_row.slice(1);\n                character += 1;\n            }\n            stop('unexpected_char_a', line, character, c);\n\n        }\n\n        function string(x) {\n            var ch, at = 0, r = '', result;\n\n            function hex(n) {\n                var i = parseInt(source_row.substr(at + 1, n), 16);\n                at += n;\n                if (i >= 32 && i <= 126 &&\n                        i !== 34 && i !== 92 && i !== 39) {\n                    warn('unexpected_a', line, character, '\\\\');\n                }\n                character += n;\n                ch = String.fromCharCode(i);\n            }\n\n            if (json_mode && x !== '\"') {\n                warn('expected_a_b', line, character, '\"', x);\n            }\n\n            for (;;) {\n                while (at >= source_row.length) {\n                    at = 0;\n                    if (!next_line()) {\n                        stop('unclosed', line - 1, from);\n                    }\n                }\n                ch = source_row.charAt(at);\n                if (ch === x) {\n                    character += 1;\n                    source_row = source_row.slice(at + 1);\n                    result = it('(string)', r);\n                    result.quote = x;\n                    return result;\n                }\n                if (ch < ' ') {\n                    if (ch === '\\n' || ch === '\\r') {\n                        break;\n                    }\n                    warn('control_a', line, character + at,\n                        source_row.slice(0, at));\n                } else if (ch === '\\\\') {\n                    at += 1;\n                    character += 1;\n                    ch = source_row.charAt(at);\n                    switch (ch) {\n                    case '':\n                        warn('unexpected_a', line, character, '\\\\');\n                        next_line();\n                        at = -1;\n                        break;\n                    case '\\'':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\\\'');\n                        }\n                        break;\n                    case 'u':\n                        hex(4);\n                        break;\n                    case 'v':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\v');\n                        }\n                        ch = '\\v';\n                        break;\n                    case 'x':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\x');\n                        }\n                        hex(2);\n                        break;\n                    default:\n                        if (typeof descapes[ch] !== 'string') {\n                            warn(ch >= '0' && ch <= '7' ? 'octal_a' : 'unexpected_a',\n                                line, character, '\\\\' + ch);\n                        } else {\n                            ch = descapes[ch];\n                        }\n                    }\n                }\n                r += ch;\n                character += 1;\n                at += 1;\n            }\n        }\n\n        function number(snippet) {\n            var digit;\n            if (source_row.charAt(0).isAlpha()) {\n                warn('expected_space_a_b',\n                    line, character, c, source_row.charAt(0));\n            }\n            if (c === '0') {\n                digit = snippet.charAt(1);\n                if (digit.isDigit()) {\n                    if (token.id !== '.') {\n                        warn('unexpected_a', line, character, snippet);\n                    }\n                } else if (json_mode && (digit === 'x' || digit === 'X')) {\n                    warn('unexpected_a', line, character, '0x');\n                }\n            }\n            if (snippet.slice(snippet.length - 1) === '.') {\n                warn('trailing_decimal_a', line, character, snippet);\n            }\n            digit = +snippet;\n            if (!isFinite(digit)) {\n                warn('bad_number', line, character, snippet);\n            }\n            snippet = digit;\n            return it('(number)', snippet);\n        }\n\n        function comment(snippet, type) {\n            if (comments_off) {\n                warn('unexpected_comment', line, character);\n            } else if (!option.todo && tox.test(snippet)) {\n                warn('todo_comment', line, character);\n            }\n            comments.push({\n                id: type,\n                from: from,\n                thru: character,\n                line: line,\n                string: snippet\n            });\n        }\n\n        function regexp() {\n            var at = 0,\n                b,\n                bit,\n                depth = 0,\n                flag = '',\n                high,\n                letter,\n                low,\n                potential,\n                quote,\n                result;\n            for (;;) {\n                b = true;\n                c = source_row.charAt(at);\n                at += 1;\n                switch (c) {\n                case '':\n                    stop('unclosed_regexp', line, from);\n                    return;\n                case '/':\n                    if (depth > 0) {\n                        warn('unescaped_a', line, from + at, '/');\n                    }\n                    c = source_row.slice(0, at - 1);\n                    potential = Object.create(regexp_flag);\n                    for (;;) {\n                        letter = source_row.charAt(at);\n                        if (potential[letter] !== true) {\n                            break;\n                        }\n                        potential[letter] = false;\n                        at += 1;\n                        flag += letter;\n                    }\n                    if (source_row.charAt(at).isAlpha()) {\n                        stop('unexpected_a', line, from, source_row.charAt(at));\n                    }\n                    character += at;\n                    source_row = source_row.slice(at);\n                    quote = source_row.charAt(0);\n                    if (quote === '/' || quote === '*') {\n                        stop('confusing_regexp', line, from);\n                    }\n                    result = it('(regexp)', c);\n                    result.flag = flag;\n                    return result;\n                case '\\\\':\n                    c = source_row.charAt(at);\n                    if (c < ' ') {\n                        warn('control_a', line, from + at, String(c));\n                    } else if (c === '<') {\n                        warn('unexpected_a', line, from + at, '\\\\');\n                    }\n                    at += 1;\n                    break;\n                case '(':\n                    depth += 1;\n                    b = false;\n                    if (source_row.charAt(at) === '?') {\n                        at += 1;\n                        switch (source_row.charAt(at)) {\n                        case ':':\n                        case '=':\n                        case '!':\n                            at += 1;\n                            break;\n                        default:\n                            warn('expected_a_b', line, from + at,\n                                ':', source_row.charAt(at));\n                        }\n                    }\n                    break;\n                case '|':\n                    b = false;\n                    break;\n                case ')':\n                    if (depth === 0) {\n                        warn('unescaped_a', line, from + at, ')');\n                    } else {\n                        depth -= 1;\n                    }\n                    break;\n                case ' ':\n                    pos = 1;\n                    while (source_row.charAt(at) === ' ') {\n                        at += 1;\n                        pos += 1;\n                    }\n                    if (pos > 1) {\n                        warn('use_braces', line, from + at, pos);\n                    }\n                    break;\n                case '[':\n                    c = source_row.charAt(at);\n                    if (c === '^') {\n                        at += 1;\n                        if (!option.regexp) {\n                            warn('insecure_a', line, from + at, c);\n                        } else if (source_row.charAt(at) === ']') {\n                            stop('unescaped_a', line, from + at, '^');\n                        }\n                    }\n                    bit = false;\n                    if (c === ']') {\n                        warn('empty_class', line, from + at - 1);\n                        bit = true;\n                    }\nklass:              do {\n                        c = source_row.charAt(at);\n                        at += 1;\n                        switch (c) {\n                        case '[':\n                        case '^':\n                            warn('unescaped_a', line, from + at, c);\n                            bit = true;\n                            break;\n                        case '-':\n                            if (bit) {\n                                bit = false;\n                            } else {\n                                warn('unescaped_a', line, from + at, '-');\n                                bit = true;\n                            }\n                            break;\n                        case ']':\n                            if (!bit) {\n                                warn('unescaped_a', line, from + at - 1, '-');\n                            }\n                            break klass;\n                        case '\\\\':\n                            c = source_row.charAt(at);\n                            if (c < ' ') {\n                                warn('control_a', line, from + at, String(c));\n                            } else if (c === '<') {\n                                warn('unexpected_a', line, from + at, '\\\\');\n                            }\n                            at += 1;\n                            bit = true;\n                            break;\n                        case '/':\n                            warn('unescaped_a', line, from + at - 1, '/');\n                            bit = true;\n                            break;\n                        default:\n                            bit = true;\n                        }\n                    } while (c);\n                    break;\n                case '.':\n                    if (!option.regexp) {\n                        warn('insecure_a', line, from + at, c);\n                    }\n                    break;\n                case ']':\n                case '?':\n                case '{':\n                case '}':\n                case '+':\n                case '*':\n                    warn('unescaped_a', line, from + at, c);\n                    break;\n                }\n                if (b) {\n                    switch (source_row.charAt(at)) {\n                    case '?':\n                    case '+':\n                    case '*':\n                        at += 1;\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        break;\n                    case '{':\n                        at += 1;\n                        c = source_row.charAt(at);\n                        if (c < '0' || c > '9') {\n                            warn('expected_number_a', line,\n                                from + at, c);\n                        }\n                        at += 1;\n                        low = +c;\n                        for (;;) {\n                            c = source_row.charAt(at);\n                            if (c < '0' || c > '9') {\n                                break;\n                            }\n                            at += 1;\n                            low = +c + (low * 10);\n                        }\n                        high = low;\n                        if (c === ',') {\n                            at += 1;\n                            high = Infinity;\n                            c = source_row.charAt(at);\n                            if (c >= '0' && c <= '9') {\n                                at += 1;\n                                high = +c;\n                                for (;;) {\n                                    c = source_row.charAt(at);\n                                    if (c < '0' || c > '9') {\n                                        break;\n                                    }\n                                    at += 1;\n                                    high = +c + (high * 10);\n                                }\n                            }\n                        }\n                        if (source_row.charAt(at) !== '}') {\n                            warn('expected_a_b', line, from + at,\n                                '}', c);\n                        } else {\n                            at += 1;\n                        }\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        if (low > high) {\n                            warn('not_greater', line, from + at,\n                                low, high);\n                        }\n                        break;\n                    }\n                }\n            }\n            c = source_row.slice(0, at - 1);\n            character += at;\n            source_row = source_row.slice(at);\n            return it('(regexp)', c);\n        }\n\n// Public lex methods\n\n        return {\n            init: function (source) {\n                if (typeof source === 'string') {\n                    lines = source.split(crlfx);\n                } else {\n                    lines = source;\n                }\n                line = 0;\n                next_line();\n                from = 1;\n            },\n\n// token -- this is called by advance to get the next token.\n\n            token: function () {\n                var first, i, snippet;\n\n                for (;;) {\n                    while (!source_row) {\n                        if (!next_line()) {\n                            return it('(end)');\n                        }\n                    }\n                    snippet = match(tx);\n                    if (snippet) {\n\n//      identifier\n\n                        first = snippet.charAt(0);\n                        if (first.isAlpha() || first === '_' || first === '$') {\n                            return it('(identifier)', snippet);\n                        }\n\n//      number\n\n                        if (first.isDigit()) {\n                            return number(snippet);\n                        }\n                        switch (snippet) {\n\n//      string\n\n                        case '\"':\n                        case \"'\":\n                            return string(snippet);\n\n//      // comment\n\n                        case '//':\n                            comment(source_row, '//');\n                            source_row = '';\n                            break;\n\n//      /* comment\n\n                        case '/*':\n                            for (;;) {\n                                i = source_row.search(lx);\n                                if (i >= 0) {\n                                    break;\n                                }\n                                character = source_row.length;\n                                comment(source_row);\n                                from = 0;\n                                if (!next_line()) {\n                                    stop('unclosed_comment', line, character);\n                                }\n                            }\n                            comment(source_row.slice(0, i), '/*');\n                            character += i + 2;\n                            if (source_row.charAt(i) === '/') {\n                                stop('nested_comment', line, character);\n                            }\n                            source_row = source_row.slice(i + 2);\n                            break;\n\n                        case '':\n                            break;\n//      /\n                        case '/':\n                            if (token.id === '/=') {\n                                stop('slash_equal', line, from);\n                            }\n                            return prereg\n                                ? regexp()\n                                : it('(punctuator)', snippet);\n\n//      punctuator\n                        default:\n                            return it('(punctuator)', snippet);\n                        }\n                    }\n                }\n            }\n        };\n    }());\n\n    function define(kind, token) {\n\n// Define a name.\n\n        var name = token.string,\n            master = scope[name];       // The current definition of the name\n\n// vars are created with a deadzone, so that the expression that initializes\n// the var cannot access the var. Functions are not writeable.\n\n        token.dead = false;\n        token.init = false;\n        token.kind = kind;\n        token.master = master;\n        token.used = 0;\n        token.writeable = true;\n\n// Global variables are a little weird. They can be defined multiple times.\n// Some predefined global vars are (or should) not be writeable.\n\n        if (kind === 'var' && funct === global_funct) {\n            if (!master) {\n                if (predefined[name] === false) {\n                    token.writeable = false;\n                }\n                global_scope[name] = token;\n            }\n        } else {\n\n// It is an error if the name has already been defined in this scope, except\n// when reusing an exception variable name.\n\n            if (master) {\n                if (master.function === funct) {\n                    if (master.kind !== 'exception' || kind !== 'exception' ||\n                            !master.dead) {\n                        token.warn('already_defined', name);\n                    }\n                } else if (master.function !== global_funct) {\n                    if (kind === 'var') {\n                        token.warn('redefinition_a_b', name, master.line);\n                    }\n                }\n            }\n            scope[name] = token;\n            if (kind === 'var') {\n                block_var.push(name);\n            }\n        }\n    }\n\n    function peek(distance) {\n\n// Peek ahead to a future token. The distance is how far ahead to look. The\n// default is the next token.\n\n        var found, slot = 0;\n\n        distance = distance || 0;\n        while (slot <= distance) {\n            found = lookahead[slot];\n            if (!found) {\n                found = lookahead[slot] = lex.token();\n            }\n            slot += 1;\n        }\n        return found;\n    }\n\n\n    function advance(id, match) {\n\n// Produce the next token, also looking for programming errors.\n\n        if (indent) {\n\n// If indentation checking was requested, then inspect all of the line breakings.\n// The var statement is tricky because the names might be aligned or not. We\n// look at the first line break after the var to determine the programmer's\n// intention.\n\n            if (var_mode && next_token.line !== token.line) {\n                if ((var_mode !== indent || !next_token.edge) &&\n                        next_token.from === indent.at -\n                        (next_token.edge ? option.indent : 0)) {\n                    var dent = indent;\n                    for (;;) {\n                        dent.at -= option.indent;\n                        if (dent === var_mode) {\n                            break;\n                        }\n                        dent = dent.was;\n                    }\n                    dent.open = false;\n                }\n                var_mode = null;\n            }\n            if (next_token.id === '?' && indent.mode === ':' &&\n                    token.line !== next_token.line) {\n                indent.at -= option.indent;\n            }\n            if (indent.open) {\n\n// If the token is an edge.\n\n                if (next_token.edge) {\n                    if (next_token.edge === 'label') {\n                        expected_at(1);\n                    } else if (next_token.edge === 'case' || indent.mode === 'statement') {\n                        expected_at(indent.at - option.indent);\n                    } else if (indent.mode !== 'array' || next_token.line !== token.line) {\n                        expected_at(indent.at);\n                    }\n\n// If the token is not an edge, but is the first token on the line.\n\n                } else if (next_token.line !== token.line) {\n                    if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                    indent.wrap = true;\n                }\n            } else if (next_token.line !== token.line) {\n                if (next_token.edge) {\n                    expected_at(indent.at);\n                } else {\n                    indent.wrap = true;\n                    if (indent.mode === 'statement' || indent.mode === 'var') {\n                        expected_at(indent.at + option.indent);\n                    } else if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                }\n            }\n        }\n\n        switch (token.id) {\n        case '(number)':\n            if (next_token.id === '.') {\n                next_token.warn('trailing_decimal_a');\n            }\n            break;\n        case '-':\n            if (next_token.id === '-' || next_token.id === '--') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        case '+':\n            if (next_token.id === '+' || next_token.id === '++') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        }\n        if (token.id === '(string)' || token.identifier) {\n            anonname = token.string;\n        }\n\n        if (id && next_token.id !== id) {\n            if (match) {\n                next_token.warn('expected_a_b_from_c_d', id,\n                    match.id, match.line, artifact());\n            } else if (!next_token.identifier || next_token.string !== id) {\n                next_token.warn('expected_a_b', id, artifact());\n            }\n        }\n        prev_token = token;\n        token = next_token;\n        next_token = lookahead.shift() || lex.token();\n        next_token.function = funct;\n        tokens.push(next_token);\n    }\n\n\n    function do_globals() {\n        var name, writeable;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            writeable = false;\n            if (next_token.id === ':') {\n                advance(':');\n                switch (next_token.id) {\n                case 'true':\n                    writeable = predefined[name] !== false;\n                    advance('true');\n                    break;\n                case 'false':\n                    advance('false');\n                    break;\n                default:\n                    next_token.stop('unexpected_a');\n                }\n            }\n            predefined[name] = writeable;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    function do_jslint() {\n        var name, value;\n        while (next_token.id === '(string)' || next_token.identifier) {\n            name = next_token.string;\n            if (!allowed_option[name]) {\n                next_token.stop('unexpected_a');\n            }\n            advance();\n            if (next_token.id !== ':') {\n                next_token.stop('expected_a_b', ':', artifact());\n            }\n            advance(':');\n            if (typeof allowed_option[name] === 'number') {\n                value = next_token.number;\n                if (value > allowed_option[name] || value <= 0 ||\n                        Math.floor(value) !== value) {\n                    next_token.stop('expected_small_a');\n                }\n                option[name] = value;\n            } else {\n                if (next_token.id === 'true') {\n                    option[name] = true;\n                } else if (next_token.id === 'false') {\n                    option[name] = false;\n                } else {\n                    next_token.stop('unexpected_a');\n                }\n            }\n            advance();\n            if (next_token.id === ',') {\n                advance(',');\n            }\n        }\n        assume();\n    }\n\n\n    function do_properties() {\n        var name;\n        option.properties = true;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            if (next_token.id === ':') {\n                for (;;) {\n                    advance();\n                    if (next_token.id !== '(string)' && !next_token.identifier) {\n                        break;\n                    }\n                }\n            }\n            property[name] = 0;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    directive = function directive() {\n        var command = this.id,\n            old_comments_off = comments_off,\n            old_indent = indent;\n        comments_off = true;\n        indent = null;\n        if (next_token.line === token.line && next_token.from === token.thru) {\n            next_token.warn('missing_space_a_b', artifact(token), artifact());\n        }\n        if (lookahead.length > 0) {\n            this.warn('unexpected_a');\n        }\n        switch (command) {\n        case '/*properties':\n        case '/*property':\n        case '/*members':\n        case '/*member':\n            do_properties();\n            break;\n        case '/*jslint':\n            do_jslint();\n            break;\n        case '/*globals':\n        case '/*global':\n            do_globals();\n            break;\n        default:\n            this.stop('unexpected_a');\n        }\n        comments_off = old_comments_off;\n        advance('*/');\n        indent = old_indent;\n    };\n\n\n// Indentation intention\n\n    function edge(mode) {\n        next_token.edge = indent ? indent.open && (mode || 'edge') : '';\n    }\n\n\n    function step_in(mode) {\n        var open;\n        if (typeof mode === 'number') {\n            indent = {\n                at: +mode,\n                open: true,\n                was: indent\n            };\n        } else if (!indent) {\n            indent = {\n                at: 1,\n                mode: 'statement',\n                open: true\n            };\n        } else if (mode === 'statement') {\n            indent = {\n                at: indent.at,\n                open: true,\n                was: indent\n            };\n        } else {\n            open = mode === 'var' || next_token.line !== token.line;\n            indent = {\n                at: (open || mode === 'control'\n                    ? indent.at + option.indent\n                    : indent.at) + (indent.wrap ? option.indent : 0),\n                mode: mode,\n                open: open,\n                was: indent\n            };\n            if (mode === 'var' && open) {\n                var_mode = indent;\n            }\n        }\n    }\n\n    function step_out(id, symbol) {\n        if (id) {\n            if (indent && indent.open) {\n                indent.at -= option.indent;\n                edge();\n            }\n            advance(id, symbol);\n        }\n        if (indent) {\n            indent = indent.was;\n        }\n    }\n\n// Functions for conformance of whitespace.\n\n    function one_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && !option.white &&\n                (token.line !== right.line ||\n                token.thru + 1 !== right.from)) {\n            right.warn('expected_space_a_b', artifact(token), artifact(right));\n        }\n    }\n\n    function one_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru + 1 !== right.from))) {\n            right.warn('expected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if ((!option.white) &&\n                left.thru !== right.from && left.line === right.line) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru !== right.from))) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function spaces(left, right) {\n        if (!option.white) {\n            left = left || token;\n            right = right || next_token;\n            if (left.thru === right.from && left.line === right.line) {\n                right.warn('missing_space_a_b', artifact(left), artifact(right));\n            }\n        }\n    }\n\n    function comma() {\n        if (next_token.id !== ',') {\n            warn('expected_a_b', token.line, token.thru, ',', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(',');\n            spaces();\n        }\n    }\n\n\n    function semicolon() {\n        if (next_token.id !== ';') {\n            warn('expected_a_b', token.line, token.thru, ';', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(';');\n            if (semicolon_coda[next_token.id] !== true) {\n                spaces();\n            }\n        }\n    }\n\n    function use_strict() {\n        if (next_token.string === 'use strict') {\n            if (strict_mode) {\n                next_token.warn('unnecessary_use');\n            }\n            edge();\n            advance();\n            semicolon();\n            strict_mode = true;\n            return true;\n        }\n        return false;\n    }\n\n\n    function are_similar(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (Array.isArray(a)) {\n            if (Array.isArray(b) && a.length === b.length) {\n                var i;\n                for (i = 0; i < a.length; i += 1) {\n                    if (!are_similar(a[i], b[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n        if (Array.isArray(b)) {\n            return false;\n        }\n        if (a.id === '(number)' && b.id === '(number)') {\n            return a.number === b.number;\n        }\n        if (a.arity === b.arity && a.string === b.string) {\n            switch (a.arity) {\n            case undefined:\n                return a.string === b.string;\n            case 'prefix':\n            case 'suffix':\n                return a.id === b.id && are_similar(a.first, b.first) &&\n                    a.id !== '{' && a.id !== '[';\n            case 'infix':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second);\n            case 'ternary':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second) &&\n                    are_similar(a.third, b.third);\n            case 'function':\n            case 'regexp':\n                return false;\n            default:\n                return true;\n            }\n        }\n        if (a.id === '.' && b.id === '[' && b.arity === 'infix') {\n            return a.second.string === b.second.string && b.second.id === '(string)';\n        }\n        if (a.id === '[' && a.arity === 'infix' && b.id === '.') {\n            return a.second.string === b.second.string && a.second.id === '(string)';\n        }\n        return false;\n    }\n\n\n// This is the heart of JSLINT, the Pratt parser. In addition to parsing, it\n// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is\n// like .nud except that it is only used on the first token of a statement.\n// Having .fud makes it much easier to define statement-oriented languages like\n// JavaScript. I retained Pratt's nomenclature.\n\n// .nud     Null denotation\n// .fud     First null denotation\n// .led     Left denotation\n//  lbp     Left binding power\n//  rbp     Right binding power\n\n// They are elements of the parsing method called Top Down Operator Precedence.\n\n    function expression(rbp, initial) {\n\n// rbp is the right binding power.\n// initial indicates that this is the first expression of a statement.\n\n        var left;\n        if (next_token.id === '(end)') {\n            token.stop('unexpected_a', next_token.id);\n        }\n        advance();\n        if (initial) {\n            anonname = 'anonymous';\n        }\n        if (initial === true && token.fud) {\n            left = token.fud();\n        } else {\n            if (token.nud) {\n                left = token.nud();\n            } else {\n                if (next_token.id === '(number)' && token.id === '.') {\n                    token.warn('leading_decimal_a', artifact());\n                    advance();\n                    return token;\n                }\n                token.stop('expected_identifier_a', artifact(token));\n            }\n            while (rbp < next_token.lbp) {\n                advance();\n                left = token.led(left);\n            }\n        }\n        if (left && left.assign && !initial) {\n            if (!option.ass) {\n                left.warn('assignment_expression');\n            }\n            if (left.id !== '=' && left.first.master) {\n                left.first.master.used = true;\n            }\n        }\n        return left;\n    }\n\n    protosymbol = {\n        nud: function () {\n            this.stop('unexpected_a');\n        },\n        led: function () {\n            this.stop('expected_operator_a');\n        },\n        warn: function (code, a, b, c, d) {\n            if (!this.warning) {\n                this.warning = warn(code, this.line || 0, this.from || 0,\n                    a || artifact(this), b, c, d);\n            }\n        },\n        stop: function (code, a, b, c, d) {\n            this.warning = undefined;\n            this.warn(code, a, b, c, d);\n            return quit('stopping', this.line, this.character);\n        },\n        lbp: 0\n    };\n\n// Functional constructors for making the symbols that will be inherited by\n// tokens.\n\n    function symbol(s, bp) {\n        var x = syntax[s];\n        if (!x) {\n            x = Object.create(protosymbol);\n            x.id = x.string = s;\n            x.lbp = bp || 0;\n            syntax[s] = x;\n        }\n        return x;\n    }\n\n    function postscript(x) {\n        x.postscript = true;\n        return x;\n    }\n\n    function ultimate(s) {\n        var x = symbol(s, 0);\n        x.from = 1;\n        x.thru = 1;\n        x.line = 0;\n        x.edge = 'edge';\n        x.string = s;\n        return postscript(x);\n    }\n\n    function reserve_name(x) {\n        var c = x.id.charAt(0);\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            x.identifier = x.reserved = true;\n        }\n        return x;\n    }\n\n    function stmt(s, f) {\n        var x = symbol(s);\n        x.fud = f;\n        return reserve_name(x);\n    }\n\n    function disrupt_stmt(s, f) {\n        var x = stmt(s, f);\n        x.disrupt = true;\n    }\n\n    function labeled_stmt(s, f) {\n        var x = stmt(s, function labeled() {\n            var the_statement;\n            if (funct.breakage) {\n                funct.breakage.push(this);\n            } else {\n                funct.breakage = [this];\n            }\n            the_statement = f.apply(this);\n            if (funct.breakage.length > 1) {\n                funct.breakage.pop();\n            } else {\n                delete funct.breakage;\n            }\n            return the_statement;\n        });\n        x.labeled = true;\n    }\n\n    function prefix(s, f) {\n        var x = symbol(s, 150);\n        reserve_name(x);\n        x.nud = function () {\n            var that = this;\n            that.arity = 'prefix';\n            if (typeof f === 'function') {\n                that = f(that);\n                if (that.arity !== 'prefix') {\n                    return that;\n                }\n            } else {\n                if (s === 'typeof') {\n                    one_space();\n                } else {\n                    no_space_only();\n                }\n                that.first = expression(150);\n            }\n            switch (that.id) {\n            case '++':\n            case '--':\n                if (!option.plusplus) {\n                    that.warn('unexpected_a');\n                } else if ((!that.first.identifier || that.first.reserved) &&\n                        that.first.id !== '.' && that.first.id !== '[') {\n                    that.warn('bad_operand');\n                }\n                break;\n            default:\n                if (that.first.arity === 'prefix' ||\n                        that.first.arity === 'function') {\n                    that.warn('unexpected_a');\n                }\n            }\n            return that;\n        };\n        return x;\n    }\n\n\n    function type(s, t, nud) {\n        var x = symbol(s);\n        x.arity = t;\n        if (nud) {\n            x.nud = nud;\n        }\n        return x;\n    }\n\n\n    function reserve(s, f) {\n        var x = symbol(s);\n        x.identifier = x.reserved = true;\n        if (typeof f === 'function') {\n            x.nud = f;\n        }\n        return x;\n    }\n\n\n    function constant(name) {\n        var x = reserve(name);\n        x.string = name;\n        x.nud = return_this;\n        return x;\n    }\n\n\n    function reservevar(s, v) {\n        return reserve(s, function () {\n            if (typeof v === 'function') {\n                v(this);\n            }\n            return this;\n        });\n    }\n\n\n    function infix(s, p, f, w) {\n        var x = symbol(s, p);\n        reserve_name(x);\n        x.led = function (left) {\n            this.arity = 'infix';\n            if (!w) {\n                spaces(prev_token, token);\n                spaces();\n            }\n            if (!option.bitwise && this.bitwise) {\n                this.warn('unexpected_a');\n            }\n            if (typeof f === 'function') {\n                return f(left, this);\n            }\n            this.first = left;\n            this.second = expression(p);\n            return this;\n        };\n        return x;\n    }\n\n    function expected_relation(node, message) {\n        if (node.assign) {\n            node.warn(message || 'conditional_assignment');\n        }\n        return node;\n    }\n\n    function expected_condition(node, message) {\n        switch (node.id) {\n        case '[':\n        case '-':\n            if (node.arity !== 'infix') {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        case 'false':\n        case 'function':\n        case 'Infinity':\n        case 'NaN':\n        case 'null':\n        case 'true':\n        case 'undefined':\n        case 'void':\n        case '(number)':\n        case '(regexp)':\n        case '(string)':\n        case '{':\n        case '?':\n        case '~':\n            node.warn(message || 'weird_condition');\n            break;\n        case '(':\n            if (node.first.id === 'new' ||\n                    (node.first.string === 'Boolean') ||\n                    (node.first.id === '.' &&\n                        numbery[node.first.second.string] === true)) {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        }\n        return node;\n    }\n\n    function check_relation(node) {\n        switch (node.arity) {\n        case 'prefix':\n            switch (node.id) {\n            case '{':\n            case '[':\n                node.warn('unexpected_a');\n                break;\n            case '!':\n                node.warn('confusing_a');\n                break;\n            }\n            break;\n        case 'function':\n        case 'regexp':\n            node.warn('unexpected_a');\n            break;\n        default:\n            if (node.id  === 'NaN') {\n                node.warn('isNaN');\n            } else if (node.relation) {\n                node.warn('weird_relation');\n            }\n        }\n        return node;\n    }\n\n\n    function relation(s, eqeq) {\n        var x = infix(s, 100, function (left, that) {\n            check_relation(left);\n            if (eqeq && !option.eqeq) {\n                that.warn('expected_a_b', eqeq, that.id);\n            }\n            var right = expression(100);\n            if (are_similar(left, right) ||\n                    ((left.id === '(string)' || left.id === '(number)') &&\n                    (right.id === '(string)' || right.id === '(number)'))) {\n                that.warn('weird_relation');\n            } else if (left.id === 'typeof') {\n                if (right.id !== '(string)') {\n                    right.warn(\"expected_string_a\", artifact(right));\n                } else if (right.string === 'undefined' ||\n                        right.string === 'null') {\n                    left.warn(\"unexpected_typeof_a\", right.string);\n                }\n            } else if (right.id === 'typeof') {\n                if (left.id !== '(string)') {\n                    left.warn(\"expected_string_a\", artifact(left));\n                } else if (left.string === 'undefined' ||\n                        left.string === 'null') {\n                    right.warn(\"unexpected_typeof_a\", left.string);\n                }\n            }\n            that.first = left;\n            that.second = check_relation(right);\n            return that;\n        });\n        x.relation = true;\n        return x;\n    }\n\n    function lvalue(that, s) {\n        var master;\n        if (that.identifier) {\n            master = scope[that.string];\n            if (master) {\n                if (scope[that.string].writeable !== true) {\n                    that.warn('read_only');\n                }\n                master.used -= 1;\n                if (s === '=') {\n                    master.init = true;\n                }\n            } else if (that.reserved) {\n                that.warn('expected_identifier_a_reserved');\n            }\n        } else if (that.id === '.' || that.id === '[') {\n            if (!that.first || that.first.string === 'arguments') {\n                that.warn('bad_assignment');\n            }\n        } else {\n            that.warn('bad_assignment');\n        }\n    }\n\n\n    function assignop(s, op) {\n        var x = infix(s, 20, function (left, that) {\n            var next;\n            that.first = left;\n            lvalue(left, s);\n            that.second = expression(20);\n            if (that.id === '=' && are_similar(that.first, that.second)) {\n                that.warn('weird_assignment');\n            }\n            next = that;\n            while (next_token.id === '=') {\n                lvalue(next.second, '=');\n                next_token.first = next.second;\n                next.second = next_token;\n                next = next_token;\n                advance('=');\n                next.second = expression(20);\n            }\n            return that;\n        });\n        x.assign = true;\n        if (op) {\n            if (syntax[op].bitwise) {\n                x.bitwise = true;\n            }\n        }\n        return x;\n    }\n\n\n    function bitwise(s, p) {\n        var x = infix(s, p, 'number');\n        x.bitwise = true;\n        return x;\n    }\n\n\n    function suffix(s) {\n        var x = symbol(s, 150);\n        x.led = function (left) {\n            no_space_only(prev_token, token);\n            if (!option.plusplus) {\n                this.warn('unexpected_a');\n            } else if ((!left.identifier || left.reserved) &&\n                    left.id !== '.' && left.id !== '[') {\n                this.warn('bad_operand');\n            }\n            this.first = left;\n            this.arity = 'suffix';\n            return this;\n        };\n        return x;\n    }\n\n\n    function optional_identifier(variable) {\n        if (next_token.identifier) {\n            advance();\n            if (token.reserved && variable) {\n                token.warn('expected_identifier_a_reserved');\n            }\n            return token.string;\n        }\n    }\n\n\n    function identifier(variable) {\n        var i = optional_identifier(variable);\n        if (!i) {\n            next_token.stop(token.id === 'function' && next_token.id === '('\n                ? 'name_function'\n                : 'expected_identifier_a');\n        }\n        return i;\n    }\n\n\n    function statement() {\n\n        var label, preamble, the_statement;\n\n// We don't like the empty statement.\n\n        if (next_token.id === ';') {\n            next_token.warn('unexpected_a');\n            semicolon();\n            return;\n        }\n\n// Is this a labeled statement?\n\n        if (next_token.identifier && !next_token.reserved && peek().id === ':') {\n            edge('label');\n            label = next_token;\n            advance();\n            advance(':');\n            define('label', label);\n            if (next_token.labeled !== true || funct === global_funct) {\n                label.stop('unexpected_label_a');\n            } else if (jx.test(label.string + ':')) {\n                label.warn('url');\n            }\n            next_token.label = label;\n            label.init = true;\n            label.statement = next_token;\n        }\n\n// Parse the statement.\n\n        preamble = next_token;\n        if (token.id !== 'else') {\n            edge();\n        }\n        step_in('statement');\n        the_statement = expression(0, true);\n        if (the_statement) {\n\n// Look for the final semicolon.\n\n            if (the_statement.arity === 'statement') {\n                if (the_statement.id === 'switch' ||\n                        (the_statement.block && the_statement.id !== 'do')) {\n                    spaces();\n                } else {\n                    semicolon();\n                }\n            } else {\n\n// If this is an expression statement, determine if it is acceptable.\n// We do not like\n//      new Blah;\n// statements. If it is to be used at all, new should only be used to make\n// objects, not side effects. The expression statements we do like do\n// assignment or invocation or delete.\n\n                if (the_statement.id === '(') {\n                    if (the_statement.first.id === 'new') {\n                        next_token.warn('bad_new');\n                    }\n                } else if (the_statement.id === '++' ||\n                        the_statement.id === '--') {\n                    lvalue(the_statement.first);\n                } else if (!the_statement.assign &&\n                        the_statement.id !== 'delete') {\n                    if (!option.closure || !preamble.comments) {\n                        preamble.warn('assignment_function_expression');\n                    }\n                }\n                semicolon();\n            }\n        }\n        step_out();\n        if (label) {\n            label.dead = true;\n        }\n        return the_statement;\n    }\n\n\n    function statements() {\n        var array = [], disruptor, the_statement;\n\n// A disrupt statement may not be followed by any other statement.\n// If the last statement is disrupt, then the sequence is disrupt.\n\n        while (next_token.postscript !== true) {\n            if (next_token.id === ';') {\n                next_token.warn('unexpected_a');\n                semicolon();\n            } else {\n                if (next_token.string === 'use strict') {\n                    if ((!node_js) || funct !== global_funct || array.length > 0) {\n                        next_token.warn('function_strict');\n                    }\n                    use_strict();\n                }\n                if (disruptor) {\n                    next_token.warn('unreachable_a_b', next_token.string,\n                        disruptor.string);\n                    disruptor = null;\n                }\n                the_statement = statement();\n                if (the_statement) {\n                    array.push(the_statement);\n                    if (the_statement.disrupt) {\n                        disruptor = the_statement;\n                        array.disrupt = true;\n                    }\n                }\n            }\n        }\n        return array;\n    }\n\n\n    function block(kind) {\n\n// A block is a sequence of statements wrapped in braces.\n\n        var array,\n            curly = next_token,\n            old_block_var = block_var,\n            old_in_block = in_block,\n            old_strict_mode = strict_mode;\n\n        in_block = kind !== 'function' && kind !== 'try' && kind !== 'catch';\n        block_var = [];\n        if (curly.id === '{') {\n            spaces();\n            advance('{');\n            step_in();\n            if (kind === 'function' && !use_strict() && !old_strict_mode &&\n                    !option.sloppy && funct.level === 1) {\n                next_token.warn('missing_use_strict');\n            }\n            array = statements();\n            strict_mode = old_strict_mode;\n            step_out('}', curly);\n        } else if (in_block) {\n            curly.stop('expected_a_b', '{', artifact());\n        } else {\n            curly.warn('expected_a_b', '{', artifact());\n            array = [statement()];\n            array.disrupt = array[0].disrupt;\n        }\n        if (kind !== 'catch' && array.length === 0 && !option.debug) {\n            curly.warn('empty_block');\n        }\n        block_var.forEach(function (name) {\n            scope[name].dead = true;\n        });\n        block_var = old_block_var;\n        in_block = old_in_block;\n        return array;\n    }\n\n\n    function tally_property(name) {\n        if (option.properties && typeof property[name] !== 'number') {\n            token.warn('unexpected_property_a', name);\n        }\n        if (property[name]) {\n            property[name] += 1;\n        } else {\n            property[name] = 1;\n        }\n    }\n\n\n// ECMAScript parser\n\n    (function () {\n        var x = symbol('(identifier)');\n        x.nud = function () {\n            var name = this.string,\n                master = scope[name],\n                writeable;\n\n// If the master is not in scope, then we may have an undeclared variable.\n// Check the predefined list. If it was predefined, create the global\n// variable.\n\n            if (!master) {\n                writeable = predefined[name];\n                if (typeof writeable === 'boolean') {\n                    global_scope[name] = master = {\n                        dead: false,\n                        function: global_funct,\n                        kind: 'var',\n                        string: name,\n                        writeable: writeable\n                    };\n\n// But if the variable is not in scope, and is not predefined, and if we are not\n// in the global scope, then we have an undefined variable error.\n\n                } else {\n                    token.warn('used_before_a');\n                }\n            } else {\n                this.master = master;\n            }\n\n// Annotate uses that cross scope boundaries.\n\n            if (master) {\n                if (master.kind === 'label') {\n                    this.warn('a_label');\n                } else {\n                    if (master.dead === true || master.dead === funct) {\n                        this.warn('a_scope');\n                    }\n                    master.used += 1;\n                    if (master.function !== funct) {\n                        if (master.function === global_funct) {\n                            funct.global.push(name);\n                        } else {\n                            master.function.closure.push(name);\n                            funct.outer.push(name);\n                        }\n                    }\n                }\n            }\n            return this;\n        };\n        x.identifier = true;\n    }());\n\n\n// Build the syntax table by declaring the syntactic elements.\n\n    type('(array)', 'array');\n    type('(function)', 'function');\n    type('(number)', 'number', return_this);\n    type('(object)', 'object');\n    type('(string)', 'string', return_this);\n    type('(boolean)', 'boolean', return_this);\n    type('(regexp)', 'regexp', return_this);\n\n    ultimate('(begin)');\n    ultimate('(end)');\n    ultimate('(error)');\n    postscript(symbol('}'));\n    symbol(')');\n    symbol(']');\n    postscript(symbol('\"'));\n    postscript(symbol('\\''));\n    symbol(';');\n    symbol(':');\n    symbol(',');\n    symbol('#');\n    symbol('@');\n    symbol('*/');\n    postscript(reserve('case'));\n    reserve('catch');\n    postscript(reserve('default'));\n    reserve('else');\n    reserve('finally');\n\n    reservevar('arguments', function (x) {\n        if (strict_mode && funct === global_funct) {\n            x.warn('strict');\n        }\n        funct.arguments = true;\n    });\n    reservevar('eval');\n    constant('false', 'boolean');\n    constant('Infinity', 'number');\n    constant('NaN', 'number');\n    constant('null', '');\n    reservevar('this', function (x) {\n        if (strict_mode && funct.statement && funct.name.charAt(0) > 'Z') {\n            x.warn('strict');\n        }\n    });\n    constant('true', 'boolean');\n    constant('undefined', '');\n\n    infix('?', 30, function (left, that) {\n        step_in('?');\n        that.first = expected_condition(expected_relation(left));\n        that.second = expression(0);\n        spaces();\n        step_out();\n        var colon = next_token;\n        advance(':');\n        step_in(':');\n        spaces();\n        that.third = expression(10);\n        that.arity = 'ternary';\n        if (are_similar(that.second, that.third)) {\n            colon.warn('weird_ternary');\n        } else if (are_similar(that.first, that.second)) {\n            that.warn('use_or');\n        }\n        step_out();\n        return that;\n    });\n\n    infix('||', 40, function (left, that) {\n        function paren_check(that) {\n            if (that.id === '&&' && !that.paren) {\n                that.warn('and');\n            }\n            return that;\n        }\n\n        that.first = paren_check(expected_condition(expected_relation(left)));\n        that.second = paren_check(expected_relation(expression(40)));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    infix('&&', 50, function (left, that) {\n        that.first = expected_condition(expected_relation(left));\n        that.second = expected_relation(expression(50));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    prefix('void', function (that) {\n        that.first = expression(0);\n        that.warn('expected_a_b', 'undefined', 'void');\n        return that;\n    });\n\n    bitwise('|', 70);\n    bitwise('^', 80);\n    bitwise('&', 90);\n\n    relation('==', '===');\n    relation('===');\n    relation('!=', '!==');\n    relation('!==');\n    relation('<');\n    relation('>');\n    relation('<=');\n    relation('>=');\n\n    bitwise('<<', 120);\n    bitwise('>>', 120);\n    bitwise('>>>', 120);\n\n    infix('in', 120, function (left, that) {\n        that.warn('infix_in');\n        that.left = left;\n        that.right = expression(130);\n        return that;\n    });\n    infix('instanceof', 120);\n    infix('+', 130, function (left, that) {\n        if (left.id === '(number)') {\n            if (left.number === 0) {\n                left.warn('unexpected_a', '0');\n            }\n        } else if (left.id === '(string)') {\n            if (left.string === '') {\n                left.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        var right = expression(130);\n        if (right.id === '(number)') {\n            if (right.number === 0) {\n                right.warn('unexpected_a', '0');\n            }\n        } else if (right.id === '(string)') {\n            if (right.string === '') {\n                right.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        if (left.id === right.id) {\n            if (left.id === '(string)' || left.id === '(number)') {\n                if (left.id === '(string)') {\n                    left.string += right.string;\n                    if (jx.test(left.string)) {\n                        left.warn('url');\n                    }\n                } else {\n                    left.number += right.number;\n                }\n                left.thru = right.thru;\n                return left;\n            }\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('+');\n    prefix('+++', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('+++', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('-', 130, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(130);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number -= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('-');\n    prefix('---', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('---', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('*', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number *= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('/', 140, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number /= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('%', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number %= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n\n    suffix('++');\n    prefix('++');\n\n    suffix('--');\n    prefix('--');\n    prefix('delete', function (that) {\n        one_space();\n        var p = expression(0);\n        if (!p || (p.id !== '.' && p.id !== '[')) {\n            next_token.warn('deleted');\n        }\n        that.first = p;\n        return that;\n    });\n\n\n    prefix('~', function (that) {\n        no_space_only();\n        if (!option.bitwise) {\n            that.warn('unexpected_a');\n        }\n        that.first = expression(150);\n        return that;\n    });\n    function banger(that) {\n        no_space_only();\n        that.first = expected_condition(expression(150));\n        if (bang[that.first.id] === that || that.first.assign) {\n            that.warn('confusing_a');\n        }\n        return that;\n    }\n    prefix('!', banger);\n    prefix('!!', banger);\n    prefix('typeof');\n    prefix('new', function (that) {\n        one_space();\n        var c = expression(160), n, p, v;\n        that.first = c;\n        if (c.id !== 'function') {\n            if (c.identifier) {\n                switch (c.string) {\n                case 'Object':\n                    token.warn('use_object');\n                    break;\n                case 'Array':\n                    if (next_token.id === '(') {\n                        p = next_token;\n                        p.first = this;\n                        advance('(');\n                        if (next_token.id !== ')') {\n                            n = expression(0);\n                            p.second = [n];\n                            if (n.id === '(string)' || next_token.id === ',') {\n                                p.warn('use_array');\n                            }\n                            while (next_token.id === ',') {\n                                advance(',');\n                                p.second.push(expression(0));\n                            }\n                        } else {\n                            token.warn('use_array');\n                        }\n                        advance(')', p);\n                        return p;\n                    }\n                    token.warn('use_array');\n                    break;\n                case 'Number':\n                case 'String':\n                case 'Boolean':\n                case 'Math':\n                case 'JSON':\n                    c.warn('not_a_constructor');\n                    break;\n                case 'Function':\n                    if (!option.evil) {\n                        next_token.warn('function_eval');\n                    }\n                    break;\n                case 'Date':\n                case 'RegExp':\n                case 'this':\n                    break;\n                default:\n                    if (c.id !== 'function') {\n                        v = c.string.charAt(0);\n                        if (!option.newcap && (v < 'A' || v > 'Z')) {\n                            token.warn('constructor_name_a');\n                        }\n                    }\n                }\n            } else {\n                if (c.id !== '.' && c.id !== '[' && c.id !== '(') {\n                    token.warn('bad_constructor');\n                }\n            }\n        } else {\n            that.warn('weird_new');\n        }\n        if (next_token.id !== '(') {\n            next_token.warn('missing_a', '()');\n        }\n        return that;\n    });\n\n    infix('(', 160, function (left, that) {\n        var e, p;\n        if (indent && indent.mode === 'expression') {\n            no_space(prev_token, token);\n        } else {\n            no_space_only(prev_token, token);\n        }\n        if (!left.immed && left.id === 'function') {\n            next_token.warn('wrap_immediate');\n        }\n        p = [];\n        if (left.identifier) {\n            if (left.string.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {\n                if (left.string !== 'Number' && left.string !== 'String' &&\n                        left.string !== 'Boolean' && left.string !== 'Date') {\n                    if (left.string === 'Math') {\n                        left.warn('not_a_function');\n                    } else if (left.string === 'Object') {\n                        token.warn('use_object');\n                    } else if (left.string === 'Array' || !option.newcap) {\n                        left.warn('missing_a', 'new');\n                    }\n                }\n            } else if (left.string === 'JSON') {\n                left.warn('not_a_function');\n            }\n        } else if (left.id === '.') {\n            if (left.second.string === 'split' &&\n                    left.first.id === '(string)') {\n                left.second.warn('use_array');\n            }\n        }\n        step_in();\n        if (next_token.id !== ')') {\n            no_space();\n            for (;;) {\n                edge();\n                e = expression(10);\n                if (left.string === 'Boolean' && (e.id === '!' || e.id === '~')) {\n                    e.warn('weird_condition');\n                }\n                p.push(e);\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', that);\n        if (typeof left === 'object') {\n            if (left.string === 'parseInt' && p.length === 1) {\n                left.warn('radix');\n            } else if (left.string === 'String' && p.length >= 1 && p[0].id === '(string)') {\n                left.warn('unexpected_a');\n            }\n            if (!option.evil) {\n                if (left.string === 'eval' || left.string === 'Function' ||\n                        left.string === 'execScript') {\n                    left.warn('evil');\n                } else if (p[0] && p[0].id === '(string)' &&\n                        (left.string === 'setTimeout' ||\n                        left.string === 'setInterval')) {\n                    left.warn('implied_evil');\n                }\n            }\n            if (!left.identifier && left.id !== '.' && left.id !== '[' &&\n                    left.id !== '(' && left.id !== '&&' && left.id !== '||' &&\n                    left.id !== '?') {\n                left.warn('bad_invocation');\n            }\n            if (left.id === '.') {\n                if (p.length > 0 &&\n                        left.first && left.first.first &&\n                        are_similar(p[0], left.first.first)) {\n                    if (left.second.string === 'call' ||\n                            (left.second.string === 'apply' && (p.length === 1 ||\n                            (p[1].arity === 'prefix' && p[1].id === '[')))) {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n                if (left.second.string === 'toString') {\n                    if (left.first.id === '(string)' || left.first.id === '(number)') {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n            }\n        }\n        that.first = left;\n        that.second = p;\n        return that;\n    }, true);\n\n    prefix('(', function (that) {\n        step_in('expression');\n        no_space();\n        edge();\n        if (next_token.id === 'function') {\n            next_token.immed = true;\n        }\n        var value = expression(0);\n        value.paren = true;\n        no_space();\n        step_out(')', that);\n        if (value.id === 'function') {\n            switch (next_token.id) {\n            case '(':\n                next_token.warn('move_invocation');\n                break;\n            case '.':\n            case '[':\n                next_token.warn('unexpected_a');\n                break;\n            default:\n                that.warn('bad_wrap');\n            }\n        } else if (!value.arity) {\n            if (!option.closure || !that.comments) {\n                that.warn('unexpected_a');\n            }\n        }\n        return value;\n    });\n\n    infix('.', 170, function (left, that) {\n        no_space(prev_token, token);\n        no_space();\n        var name = identifier();\n        if (typeof name === 'string') {\n            tally_property(name);\n        }\n        that.first = left;\n        that.second = token;\n        if (left && left.string === 'arguments' &&\n                (name === 'callee' || name === 'caller')) {\n            left.warn('avoid_a', 'arguments.' + name);\n        } else if (!option.evil && left && left.string === 'document' &&\n                (name === 'write' || name === 'writeln')) {\n            left.warn('write_is_wrong');\n        } else if (!option.stupid && syx.test(name)) {\n            token.warn('sync_a');\n        } else if (left && left.id === '{') {\n            that.warn('unexpected_a');\n        }\n        if (!option.evil && (name === 'eval' || name === 'execScript')) {\n            next_token.warn('evil');\n        }\n        return that;\n    }, true);\n\n    infix('[', 170, function (left, that) {\n        var e, s;\n        no_space_only(prev_token, token);\n        no_space();\n        step_in();\n        edge();\n        e = expression(0);\n        switch (e.id) {\n        case '(number)':\n            if (e.id === '(number)' && left.id === 'arguments') {\n                left.warn('use_param');\n            }\n            break;\n        case '(string)':\n            if (!option.evil &&\n                    (e.string === 'eval' || e.string === 'execScript')) {\n                e.warn('evil');\n            } else if (!option.sub && ix.test(e.string)) {\n                s = syntax[e.string];\n                if (!s || !s.reserved) {\n                    e.warn('subscript');\n                }\n            }\n            tally_property(e.string);\n            break;\n        }\n        if (left && (left.id === '{' || (left.id === '[' && left.arity === 'prefix'))) {\n            that.warn('unexpected_a');\n        }\n        step_out(']', that);\n        no_space(prev_token, token);\n        that.first = left;\n        that.second = e;\n        return that;\n    }, true);\n\n    prefix('[', function (that) {\n        that.first = [];\n        step_in('array');\n        while (next_token.id !== '(end)') {\n            while (next_token.id === ',') {\n                next_token.warn('unexpected_a');\n                advance(',');\n            }\n            if (next_token.id === ']') {\n                break;\n            }\n            indent.wrap = false;\n            edge();\n            that.first.push(expression(10));\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id === ']') {\n                    token.warn('unexpected_a');\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        step_out(']', that);\n        return that;\n    }, 170);\n\n\n    function property_name() {\n        var id = optional_identifier();\n        if (!id) {\n            if (next_token.id === '(string)') {\n                id = next_token.string;\n                advance();\n            } else if (next_token.id === '(number)') {\n                id = next_token.number.toString();\n                advance();\n            }\n        }\n        return id;\n    }\n\n\n\n    assignop('=');\n    assignop('+=', '+');\n    assignop('-=', '-');\n    assignop('*=', '*');\n    assignop('/=', '/').nud = function () {\n        next_token.stop('slash_equal');\n    };\n    assignop('%=', '%');\n    assignop('&=', '&');\n    assignop('|=', '|');\n    assignop('^=', '^');\n    assignop('<<=', '<<');\n    assignop('>>=', '>>');\n    assignop('>>>=', '>>>');\n\n    function function_parameters() {\n        var id, parameters = [], paren = next_token;\n        advance('(');\n        token.function = funct;\n        step_in();\n        no_space();\n        if (next_token.id !== ')') {\n            for (;;) {\n                edge();\n                id = identifier();\n                if (token.reserved) {\n                    token.warn('expected_identifier_a_reserved');\n                }\n                define('parameter', token);\n                parameters.push(id);\n                token.init = true;\n                token.writeable = true;\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', paren);\n        return parameters;\n    }\n\n    function do_function(func, name) {\n        var old_funct = funct,\n            old_option = option,\n            old_scope = scope;\n        scope = Object.create(old_scope);\n        funct = {\n            closure: [],\n            global: [],\n            level: old_funct.level + 1,\n            line: next_token.line,\n            loopage: 0,\n            name: name || '\\'' + (anonname || '').replace(nx, sanitize) + '\\'',\n            outer: [],\n            scope: scope\n        };\n        funct.parameter = function_parameters();\n        func.function = funct;\n        option = Object.create(old_option);\n        functions.push(funct);\n        if (name) {\n            func.name = name;\n            func.string = name;\n            define('function', func);\n            func.init = true;\n            func.used += 1;\n        }\n        func.writeable = false;\n        one_space();\n        func.block = block('function');\n        Object.keys(scope).forEach(function (name) {\n            var master = scope[name];\n            if (!master.used && master.kind !== 'exception' &&\n                    (master.kind !== 'parameter' || !option.unparam)) {\n                master.warn('unused_a');\n            } else if (!master.init) {\n                master.warn('uninitialized_a');\n            }\n        });\n        funct = old_funct;\n        option = old_option;\n        scope = old_scope;\n    }\n\n    prefix('{', function (that) {\n        var get, i, j, name, set, seen = Object.create(null);\n        that.first = [];\n        step_in();\n        while (next_token.id !== '}') {\n            indent.wrap = false;\n\n// JSLint recognizes the ES5 extension for get/set in object literals,\n// but requires that they be used in pairs.\n\n            edge();\n            if (next_token.string === 'get' && peek().id !== ':') {\n                get = next_token;\n                advance('get');\n                one_space_only();\n                name = next_token;\n                i = property_name();\n                if (!i) {\n                    next_token.stop('missing_property');\n                }\n                get.string = '';\n                do_function(get);\n                if (funct.loopage) {\n                    get.warn('function_loop');\n                }\n                if (get.function.parameter.length) {\n                    get.warn('parameter_a_get_b', get.function.parameter[0], i);\n                }\n                comma();\n                set = next_token;\n                spaces();\n                edge();\n                advance('set');\n                set.string = '';\n                one_space_only();\n                j = property_name();\n                if (i !== j) {\n                    token.stop('expected_a_b', i, j || next_token.string);\n                }\n                do_function(set);\n                if (set.block.length === 0) {\n                    token.warn('missing_a', 'throw');\n                }\n                if (set.function.parameter.length === 0) {\n                    set.stop('parameter_set_a', 'value');\n                } else if (set.function.parameter[0] !== 'value') {\n                    set.stop('expected_a_b', 'value',\n                        set.function.parameter[0]);\n                }\n                name.first = [get, set];\n            } else {\n                name = next_token;\n                i = property_name();\n                if (typeof i !== 'string') {\n                    next_token.stop('missing_property');\n                }\n                advance(':');\n                spaces();\n                name.first = expression(10);\n            }\n            that.first.push(name);\n            if (seen[i] === true) {\n                next_token.warn('duplicate_a', i);\n            }\n            seen[i] = true;\n            tally_property(i);\n            if (next_token.id !== ',') {\n                break;\n            }\n            for (;;) {\n                comma();\n                if (next_token.id !== ',') {\n                    break;\n                }\n                next_token.warn('unexpected_a');\n            }\n            if (next_token.id === '}') {\n                token.warn('unexpected_a');\n            }\n        }\n        step_out('}', that);\n        return that;\n    });\n\n    stmt('{', function () {\n        next_token.warn('statement_block');\n        this.arity = 'statement';\n        this.block = statements();\n        this.disrupt = this.block.disrupt;\n        advance('}', this);\n        return this;\n    });\n\n    stmt('/*global', directive);\n    stmt('/*globals', directive);\n    stmt('/*jslint', directive);\n    stmt('/*member', directive);\n    stmt('/*members', directive);\n    stmt('/*property', directive);\n    stmt('/*properties', directive);\n\n    stmt('var', function () {\n\n// JavaScript does not have block scope. It only has function scope. So,\n// declaring a variable in a block can have unexpected consequences.\n\n// var.first will contain an array, the array containing name tokens\n// and assignment tokens.\n\n        var assign, id, name;\n\n        if (funct.loopage) {\n            next_token.warn('var_loop');\n        } else if (funct.varstatement && !option.vars) {\n            next_token.warn('combine_var');\n        }\n        if (funct !== global_funct) {\n            funct.varstatement = true;\n        }\n        this.arity = 'statement';\n        this.first = [];\n        step_in('var');\n        for (;;) {\n            name = next_token;\n            id = identifier(true);\n            define('var', name);\n            name.dead = funct;\n            if (next_token.id === '=') {\n                if (funct === global_funct && !name.writeable) {\n                    name.warn('read_only');\n                }\n                assign = next_token;\n                assign.first = name;\n                spaces();\n                advance('=');\n                spaces();\n                if (next_token.id === 'undefined') {\n                    token.warn('unnecessary_initialize', id);\n                }\n                if (peek(0).id === '=' && next_token.identifier) {\n                    next_token.stop('var_a_not');\n                }\n                assign.second = expression(0);\n                assign.arity = 'infix';\n                name.init = true;\n                this.first.push(assign);\n            } else {\n                this.first.push(name);\n            }\n            name.dead = false;\n            name.writeable = true;\n            if (next_token.id !== ',') {\n                break;\n            }\n            comma();\n            indent.wrap = false;\n            if (var_mode && next_token.line === token.line &&\n                    this.first.length === 1) {\n                var_mode = null;\n                indent.open = false;\n                indent.at -= option.indent;\n            }\n            spaces();\n            edge();\n        }\n        var_mode = null;\n        step_out();\n        return this;\n    });\n\n    stmt('function', function () {\n        one_space();\n        if (in_block) {\n            token.warn('function_block');\n        }\n        var name = next_token,\n            id = identifier(true);\n        define('var', name);\n        if (!name.writeable) {\n            name.warn('read_only');\n        }\n        name.init = true;\n        name.statement = true;\n        no_space();\n        this.arity = 'statement';\n        do_function(this, id);\n        if (next_token.id === '(' && next_token.line === token.line) {\n            next_token.stop('function_statement');\n        }\n        return this;\n    });\n\n    prefix('function', function (that) {\n        var id = optional_identifier(true), name;\n        if (id) {\n            name = token;\n            no_space();\n        } else {\n            id = '';\n            one_space();\n        }\n        do_function(that, id);\n        if (name) {\n            name.function = that.function;\n        }\n        if (funct.loopage) {\n            that.warn('function_loop');\n        }\n        switch (next_token.id) {\n        case ';':\n        case '(':\n        case ')':\n        case ',':\n        case ']':\n        case '}':\n        case ':':\n        case '(end)':\n            break;\n        case '.':\n            if (peek().string !== 'bind' || peek(1).id !== '(') {\n                next_token.warn('unexpected_a');\n            }\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n        that.arity = 'function';\n        return that;\n    });\n\n    stmt('if', function () {\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('if');\n        if (next_token.id === 'else') {\n            if (this.block.disrupt) {\n                next_token.warn(this.elif ? 'use_nested_if' : 'unnecessary_else');\n            }\n            one_space();\n            advance('else');\n            one_space();\n            if (next_token.id === 'if') {\n                next_token.elif = true;\n                this.else = statement(true);\n            } else {\n                this.else = block('else');\n            }\n            if (this.else.disrupt && this.block.disrupt) {\n                this.disrupt = true;\n            }\n        }\n        return this;\n    });\n\n    stmt('try', function () {\n\n// try.first    The catch variable\n// try.second   The catch clause\n// try.third    The finally clause\n// try.block    The try block\n\n        var exception_variable, paren;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('try');\n        if (next_token.id === 'catch') {\n            one_space();\n            advance('catch');\n            one_space();\n            paren = next_token;\n            advance('(');\n            step_in('control');\n            no_space();\n            edge();\n            exception_variable = next_token;\n            this.first = identifier();\n            define('exception', exception_variable);\n            exception_variable.init = true;\n            no_space();\n            step_out(')', paren);\n            one_space();\n            this.second = block('catch');\n            if (this.second.length) {\n                if (this.first === 'ignore') {\n                    exception_variable.warn('unexpected_a');\n                }\n            } else {\n                if (this.first !== 'ignore') {\n                    exception_variable.warn('expected_a_b', 'ignore',\n                        exception_variable.string);\n                }\n            }\n            exception_variable.dead = true;\n        }\n        if (next_token.id === 'finally') {\n            one_space();\n            advance('finally');\n            one_space();\n            this.third = block('finally');\n        } else if (!this.second) {\n            next_token.stop('expected_a_b', 'catch', artifact());\n        }\n        return this;\n    });\n\n    labeled_stmt('while', function () {\n        one_space();\n        var paren = next_token;\n        funct.loopage += 1;\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_relation(expression(0));\n        if (this.first.id !== 'true') {\n            expected_condition(this.first, 'unexpected_a');\n        }\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('while');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        funct.loopage -= 1;\n        return this;\n    });\n\n    reserve('with');\n\n    labeled_stmt('switch', function () {\n\n// switch.first         the switch expression\n// switch.second        the array of cases. A case is 'case' or 'default' token:\n//    case.first        the array of case expressions\n//    case.second       the array of statements\n// If all of the arrays of statements are disrupt, then the switch is disrupt.\n\n        var cases = [],\n            old_in_block = in_block,\n            particular,\n            that = token,\n            the_case = next_token;\n\n        function find_duplicate_case(value) {\n            if (are_similar(particular, value)) {\n                value.warn('duplicate_a');\n            }\n        }\n\n        one_space();\n        advance('(');\n        no_space();\n        step_in();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', the_case);\n        one_space();\n        advance('{');\n        step_in();\n        in_block = true;\n        this.second = [];\n        if (that.from !== next_token.from && !option.white) {\n            next_token.warn('expected_a_at_b_c', next_token.string, that.from, next_token.from);\n        }\n        while (next_token.id === 'case') {\n            the_case = next_token;\n            the_case.first = [];\n            the_case.arity = 'case';\n            for (;;) {\n                spaces();\n                edge('case');\n                advance('case');\n                one_space();\n                particular = expression(0);\n                cases.forEach(find_duplicate_case);\n                cases.push(particular);\n                the_case.first.push(particular);\n                if (particular.id === 'NaN') {\n                    particular.warn('unexpected_a');\n                }\n                no_space_only();\n                advance(':');\n                if (next_token.id !== 'case') {\n                    break;\n                }\n            }\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                if (!the_case.second[the_case.second.length - 1].disrupt) {\n                    next_token.warn('missing_a_after_b', 'break', 'case');\n                }\n            } else {\n                next_token.warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.second.length === 0) {\n            next_token.warn('missing_a', 'case');\n        }\n        if (next_token.id === 'default') {\n            spaces();\n            the_case = next_token;\n            the_case.arity = 'case';\n            edge('case');\n            advance('default');\n            no_space_only();\n            advance(':');\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                this.disrupt = the_case.second[the_case.second.length - 1].disrupt;\n            } else {\n                the_case.warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.break) {\n            this.disrupt = false;\n        }\n        spaces();\n        step_out('}', this);\n        in_block = old_in_block;\n        return this;\n    });\n\n    stmt('debugger', function () {\n        if (!option.debug) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        return this;\n    });\n\n    labeled_stmt('do', function () {\n        funct.loopage += 1;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('do');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        one_space();\n        advance('while');\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in();\n        no_space();\n        edge();\n        this.first = expected_condition(expected_relation(expression(0)), 'unexpected_a');\n        no_space();\n        step_out(')', paren);\n        funct.loopage -= 1;\n        return this;\n    });\n\n    labeled_stmt('for', function () {\n\n        var blok, filter, master, ok = false, paren = next_token, value;\n        this.arity = 'statement';\n        funct.loopage += 1;\n        advance('(');\n        if (next_token.id === ';') {\n            no_space();\n            advance(';');\n            no_space();\n            advance(';');\n            no_space();\n            advance(')');\n            blok = block('for');\n        } else {\n            step_in('control');\n            spaces(this, paren);\n            no_space();\n            if (next_token.id === 'var') {\n                next_token.stop('move_var');\n            }\n            edge();\n            if (peek(0).id === 'in') {\n                this.forin = true;\n                value = expression(1000);\n                master = value.master;\n                if (!master) {\n                    value.stop('bad_in_a');\n                }\n                if (master.kind !== 'var' || master.function !== funct ||\n                        !master.writeable || master.dead) {\n                    value.warn('bad_in_a');\n                }\n                master.init = true;\n                master.used -= 1;\n                this.first = value;\n                advance('in');\n                this.second = expression(20);\n                step_out(')', paren);\n                blok = block('for');\n                if (!option.forin) {\n                    if (blok.length === 1 && typeof blok[0] === 'object') {\n                        if (blok[0].id === 'if' && !blok[0].else) {\n                            filter = blok[0].first;\n                            while (filter.id === '&&') {\n                                filter = filter.first;\n                            }\n                            switch (filter.id) {\n                            case '===':\n                            case '!==':\n                                ok = filter.first.id === '['\n                                    ? are_similar(filter.first.first, this.second) &&\n                                        are_similar(filter.first.second, this.first)\n                                    : filter.first.id === 'typeof' &&\n                                        filter.first.first.id === '[' &&\n                                        are_similar(filter.first.first.first, this.second) &&\n                                        are_similar(filter.first.first.second, this.first);\n                                break;\n                            case '(':\n                                ok = filter.first.id === '.' && ((\n                                    are_similar(filter.first.first, this.second) &&\n                                    filter.first.second.string === 'hasOwnProperty' &&\n                                    are_similar(filter.second[0], this.first)\n                                ) || (\n                                    filter.first.first.id === '.' &&\n                                    filter.first.first.first.first &&\n                                    filter.first.first.first.first.string === 'Object' &&\n                                    filter.first.first.first.id === '.' &&\n                                    filter.first.first.first.second.string === 'prototype' &&\n                                    filter.first.first.second.string === 'hasOwnProperty' &&\n                                    filter.first.second.string === 'call' &&\n                                    are_similar(filter.second[0], this.second) &&\n                                    are_similar(filter.second[1], this.first)\n                                ));\n                                break;\n                            }\n                        } else if (blok[0].id === 'switch') {\n                            ok = blok[0].id === 'switch' &&\n                                blok[0].first.id === 'typeof' &&\n                                blok[0].first.first.id === '[' &&\n                                are_similar(blok[0].first.first.first, this.second) &&\n                                are_similar(blok[0].first.first.second, this.first);\n                        }\n                    }\n                    if (!ok) {\n                        this.warn('for_if');\n                    }\n                }\n            } else {\n                edge();\n                this.first = [];\n                for (;;) {\n                    this.first.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                semicolon();\n                edge();\n                this.second = expected_relation(expression(0));\n                if (this.second.id !== 'true') {\n                    expected_condition(this.second, 'unexpected_a');\n                }\n                semicolon(token);\n                if (next_token.id === ';') {\n                    next_token.stop('expected_a_b', ')', ';');\n                }\n                this.third = [];\n                edge();\n                for (;;) {\n                    this.third.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                no_space();\n                step_out(')', paren);\n                one_space();\n                blok = block('for');\n            }\n        }\n        if (blok.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        this.block = blok;\n        funct.loopage -= 1;\n        return this;\n    });\n\n    function optional_label(that) {\n        var label = next_token.string,\n            master;\n        that.arity = 'statement';\n        if (!funct.breakage || (!option.continue && that.id === 'continue')) {\n            that.warn('unexpected_a');\n        } else if (next_token.identifier && token.line === next_token.line) {\n            one_space_only();\n            master = scope[label];\n            if (!master || master.kind !== 'label') {\n                next_token.warn('not_a_label');\n            } else if (master.dead || master.function !== funct) {\n                next_token.warn('not_a_scope');\n            } else {\n                master.used += 1;\n                if (that.id === 'break') {\n                    master.statement.break = true;\n                }\n                if (funct.breakage[funct.breakage.length - 1] === master.statement) {\n                    next_token.warn('unexpected_a');\n                }\n            }\n            that.first = next_token;\n            advance();\n        } else {\n            if (that.id === 'break') {\n                funct.breakage[funct.breakage.length - 1].break = true;\n            }\n        }\n        return that;\n\n    }\n\n    disrupt_stmt('break', function () {\n        return optional_label(this);\n    });\n\n    disrupt_stmt('continue', function () {\n        return optional_label(this);\n    });\n\n    disrupt_stmt('return', function () {\n        if (funct === global_funct) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        if (next_token.id !== ';' && next_token.line === token.line) {\n            if (option.closure) {\n                spaces();\n            } else {\n                one_space_only();\n            }\n            if (next_token.id === '/' || next_token.id === '(regexp)') {\n                next_token.warn('wrap_regexp');\n            }\n            this.first = expression(0);\n            if (this.first.assign) {\n                this.first.warn('unexpected_a');\n            }\n        }\n        return this;\n    });\n\n    disrupt_stmt('throw', function () {\n        this.arity = 'statement';\n        one_space_only();\n        this.first = expression(20);\n        return this;\n    });\n\n\n//  Superfluous reserved words\n\n    reserve('class');\n    reserve('const');\n    reserve('enum');\n    reserve('export');\n    reserve('extends');\n    reserve('import');\n    reserve('super');\n\n// Harmony reserved words\n\n    reserve('implements');\n    reserve('interface');\n    reserve('let');\n    reserve('package');\n    reserve('private');\n    reserve('protected');\n    reserve('public');\n    reserve('static');\n    reserve('yield');\n\n\n// Parse JSON\n\n    function json_value() {\n\n        function json_object() {\n            var brace = next_token, object = Object.create(null);\n            advance('{');\n            if (next_token.id !== '}') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    if (next_token.id !== '(string)') {\n                        next_token.warn('expected_string_a');\n                    }\n                    if (object[next_token.string] === true) {\n                        next_token.warn('duplicate_a');\n                    } else if (next_token.string === '__proto__') {\n                        next_token.warn('dangling_a');\n                    } else {\n                        object[next_token.string] = true;\n                    }\n                    advance();\n                    advance(':');\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === '}') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance('}', brace);\n        }\n\n        function json_array() {\n            var bracket = next_token;\n            advance('[');\n            if (next_token.id !== ']') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === ']') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance(']', bracket);\n        }\n\n        switch (next_token.id) {\n        case '{':\n            json_object();\n            break;\n        case '[':\n            json_array();\n            break;\n        case 'true':\n        case 'false':\n        case 'null':\n        case '(number)':\n        case '(string)':\n            advance();\n            break;\n        case '-':\n            advance('-');\n            no_space_only();\n            advance('(number)');\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n    }\n\n\n// The actual JSLINT function itself.\n\n    itself = function JSLint(the_source, the_option) {\n\n        var i, predef, tree;\n        itself.errors = [];\n        itself.tree = '';\n        itself.properties = '';\n        begin = prev_token = token = next_token =\n            Object.create(syntax['(begin)']);\n        tokens = [];\n        predefined = Object.create(null);\n        add_to_predefined(standard);\n        property = Object.create(null);\n        if (the_option) {\n            option = Object.create(the_option);\n            predef = option.predef;\n            if (predef) {\n                if (Array.isArray(predef)) {\n                    for (i = 0; i < predef.length; i += 1) {\n                        predefined[predef[i]] = true;\n                    }\n                } else if (typeof predef === 'object') {\n                    add_to_predefined(predef);\n                }\n            }\n        } else {\n            option = Object.create(null);\n        }\n        option.indent = +option.indent || 4;\n        option.maxerr = +option.maxerr || 50;\n        global_scope = scope = Object.create(null);\n        global_funct = funct = {\n            scope: scope,\n            loopage: 0,\n            level: 0\n        };\n        functions = [funct];\n        block_var = [];\n\n        comments = [];\n        comments_off = false;\n        in_block = false;\n        indent = null;\n        json_mode = false;\n        lookahead = [];\n        node_js = false;\n        prereg = true;\n        strict_mode = false;\n        var_mode = null;\n        warnings = 0;\n        lex.init(the_source);\n\n        assume();\n\n        try {\n            advance();\n            if (next_token.id === '(number)') {\n                next_token.stop('unexpected_a');\n            } else {\n                switch (next_token.id) {\n                case '{':\n                case '[':\n                    comments_off = true;\n                    json_mode = true;\n                    json_value();\n                    break;\n                default:\n\n// If the first token is a semicolon, ignore it. This is sometimes used when\n// files are intended to be appended to files that may be sloppy. A sloppy\n// file may be depending on semicolon insertion on its last line.\n\n                    step_in(1);\n                    if (next_token.id === ';' && !node_js) {\n                        next_token.edge = true;\n                        advance(';');\n                    }\n                    tree = statements();\n                    begin.first = tree;\n                    itself.tree = begin;\n                    if (tree.disrupt) {\n                        prev_token.warn('weird_program');\n                    }\n                }\n            }\n            indent = null;\n            advance('(end)');\n            itself.property = property;\n        } catch (e) {\n            if (e) {        // ~~\n                itself.errors.push({\n                    reason    : e.message,\n                    line      : e.line || next_token.line,\n                    character : e.character || next_token.from\n                }, null);\n            }\n        }\n        return itself.errors.length === 0;\n    };\n\n    function unique(array) {\n        array = array.sort();\n        var i, length = 0, previous, value;\n        for (i = 0; i < array.length; i += 1) {\n            value = array[i];\n            if (value !== previous) {\n                array[length] = value;\n                previous = value;\n                length += 1;\n            }\n        }\n        array.length = length;\n        return array;\n    }\n\n// Data summary.\n\n    itself.data = function () {\n        var data = {functions: []},\n            function_data,\n            i,\n            the_function,\n            the_scope;\n        data.errors = itself.errors;\n        data.json = json_mode;\n        data.global = unique(Object.keys(global_scope));\n\n        function selects(name) {\n            var kind = the_scope[name].kind;\n            switch (kind) {\n            case 'var':\n            case 'exception':\n            case 'label':\n                function_data[kind].push(name);\n                break;\n            }\n        }\n\n        for (i = 1; i < functions.length; i += 1) {\n            the_function = functions[i];\n            function_data = {\n                name: the_function.name,\n                line: the_function.line,\n                level: the_function.level,\n                parameter: the_function.parameter,\n                var: [],\n                exception: [],\n                closure: unique(the_function.closure),\n                outer: unique(the_function.outer),\n                global: unique(the_function.global),\n                label: []\n            };\n            the_scope = the_function.scope;\n            Object.keys(the_scope).forEach(selects);\n            function_data.var.sort();\n            function_data.exception.sort();\n            function_data.label.sort();\n            data.functions.push(function_data);\n        }\n        data.tokens = tokens;\n        return data;\n    };\n\n    itself.error_report = function (data) {\n        var evidence, i, output = [], warning;\n        if (data.errors.length) {\n            if (data.json) {\n                output.push('<cite>JSON: bad.</cite><br>');\n            }\n            for (i = 0; i < data.errors.length; i += 1) {\n                warning = data.errors[i];\n                if (warning) {\n                    evidence = warning.evidence || '';\n                    output.push('<cite>');\n                    if (isFinite(warning.line)) {\n                        output.push('<address>line ' +\n                            String(warning.line) +\n                            ' character ' + String(warning.character) +\n                            '</address>');\n                    }\n                    output.push(warning.reason.entityify() + '</cite>');\n                    if (evidence) {\n                        output.push('<pre>' + evidence.entityify() + '</pre>');\n                    }\n                }\n            }\n        }\n        return output.join('');\n    };\n\n\n    itself.report = function (data) {\n        var dl, i, j, names, output = [], the_function;\n\n        function detail(h, array) {\n            var comma_needed = false;\n            if (array.length) {\n                output.push(\"<dt>\" + h + \"</dt><dd>\");\n                array.forEach(function (item) {\n                    output.push((comma_needed ? ', ' : '') + item);\n                    comma_needed = true;\n                });\n                output.push(\"</dd>\");\n            }\n        }\n\n        output.push('<dl class=level0>');\n        if (data.global.length) {\n            detail('global', data.global);\n            dl = true;\n        } else if (data.json) {\n            if (!data.errors.length) {\n                output.push(\"<dt>JSON: good.</dt>\");\n            }\n        } else {\n            output.push(\"<dt><i>No new global variables introduced.</i></dt>\");\n        }\n        if (dl) {\n            output.push(\"</dl>\");\n        } else {\n            output[0] = '';\n        }\n\n        if (data.functions) {\n            for (i = 0; i < data.functions.length; i += 1) {\n                the_function = data.functions[i];\n                names = [];\n                if (the_function.params) {\n                    for (j = 0; j < the_function.params.length; j += 1) {\n                        names[j] = the_function.params[j].string;\n                    }\n                }\n                output.push('<dl class=level' + the_function.level +\n                    '><address>line ' + String(the_function.line) +\n                    '</address>' + the_function.name.entityify());\n                detail('parameter', the_function.parameter);\n                detail('variable', the_function.var);\n                detail('exception', the_function.exception);\n                detail('closure', the_function.closure);\n                detail('outer', the_function.outer);\n                detail('global', the_function.global);\n                detail('label', the_function.label);\n                output.push('</dl>');\n            }\n        }\n        return output.join('');\n    };\n\n    itself.properties_report = function (property) {\n        if (!property) {\n            return '';\n        }\n        var i,\n            key,\n            keys = Object.keys(property).sort(),\n            mem = '   ',\n            name,\n            not_first = false,\n            output = ['/*properties'];\n        for (i = 0; i < keys.length; i += 1) {\n            key = keys[i];\n            if (property[key] > 0) {\n                if (not_first) {\n                    mem += ',';\n                }\n                name = ix.test(key)\n                    ? key\n                    : '\\'' + key.replace(nx, sanitize) + '\\'';\n                if (mem.length + name.length >= 80) {\n                    output.push(mem);\n                    mem = '    ';\n                } else {\n                    mem += ' ';\n                }\n                mem += name;\n                not_first = true;\n            }\n        }\n        output.push(mem, '*/\\n');\n        return output.join('\\n');\n    };\n\n    itself.color = function (data) {\n        var from,\n            i = 1,\n            level,\n            line,\n            result = [],\n            thru,\n            data_token = data.tokens[0];\n        while (data_token && data_token.id !== '(end)') {\n            from = data_token.from;\n            line = data_token.line;\n            thru = data_token.thru;\n            level = data_token.function.level;\n            do {\n                thru = data_token.thru;\n                data_token = data.tokens[i];\n                i += 1;\n            } while (data_token && data_token.line === line &&\n                    data_token.from - thru < 5 &&\n                    level === data_token.function.level);\n            result.push({\n                line: line,\n                level: level,\n                from: from,\n                thru: thru\n            });\n        }\n        return result;\n    };\n\n    itself.jslint = itself;\n\n    itself.edition = '2014-07-08';\n\n    return itself;\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jslint-2015-05-08.js":"// jslint.js\n// 2015-05-08\n// Copyright (c) 2015 Douglas Crockford  (www.JSLint.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// The Software shall be used for Good, not Evil.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// jslint is a function that takes 3 arguments:\n\n//      source          A text to analyze, a string or an array of strings.\n//      option_object   An object whose keys correspond to option names.\n//      global_array    An array of strings containing global variables that\n//                      the file is allowed readonly access.\n\n// jslint returns an object containing its results. The object contains a lot\n// of valuable information. It can be used to generate reports. The object\n// contains:\n\n//      edition: the version of JSLint that did the analysis.\n//      functions: an array of objects that represent all of the functions\n//              declared in the file.\n//      global: an object representing the global object. Its .context property\n//              is an object containing a property for each global variable.\n//      id: \"(JSLint)\"\n//      imports: an array of strings representing each of the imports.\n//      json: true if the file is a JSON text.\n//      lines: an array of strings, the source.\n//      module: true if an import or export statement was used.\n//      ok: true if no warnings were generated. This is what you want.\n//      option: the option argument.\n//      property: a property object.\n//      stop: true if JSLint was unable to finish. You don't want this.\n//      tokens: an array of objects representing the tokens in the file.\n//      tree: the token objects arranged in a tree.\n//      warnings: an array of warning objects. A warning object can contain:\n//          name: 'JSLintError'\n//          column: A column number in the file.\n//          line: A line number in the file.\n//          code: A warning code string.\n//          message: The warning message string.\n//          a: Exhibit A.\n//          b: Exhibit B.\n//          c: Exhibit C.\n//          d: Exhibit D.\n\n// jslint works in several phases. In any of these phases, errors might be\n// found. Sometimes JSLint is able to recover from an error and continue\n// parsing. In some cases, it cannot and will stop early. If that should happen,\n// repair your code and try again.\n\n// Phases:\n\n//      1. If the source is a single string, split it into an array of strings.\n//      2. Turn the source into an array of tokens.\n//      3. Furcate the tokens into a parse tree.\n//      4. Walk the tree, traversing all of the nodes of the tree. It is a\n//          recursive traversal. Each node may be processed on the way down\n//          (preaction) and on the way up (postaction).\n//      5. Check the whitespace between the tokens.\n\n// jslint can also examine JSON text. It decides that a file is JSON text if\n// the first token is '[' or '{'. Processing of JSON text is much simpler than\n// the processing of JavaScript programs. Only the first three phases are\n// required.\n\n// WARNING: JSLint will hurt your feelings.\n\n/*property\n    a, and, arity, b, bad_assignment_a, bad_character_number_a, bad_get,\n    bad_module_name_a, bad_option_a, bad_property_a, bad_set, bitwise, block,\n    body, browser, c, calls, catch, charAt, charCodeAt, closer, closure, code,\n    column, concat, constant, context, couch, create, d, dead, devel,\n    directive, disrupt, dot, duplicate_a, edition, ellipsis, else, empty_block,\n    es6, eval, every, expected_a_at_b_c, expected_a_b, expected_a_b_from_c_d,\n    expected_a_before_b, expected_digits_after_a, expected_four_digits,\n    expected_identifier_a, expected_line_break_a_b, expected_regexp_factor_a,\n    expected_space_a_b, expected_string_a, expected_type_string_a, expression,\n    extra, flag, for, forEach, free, from, fud, fudge, function,\n    function_in_loop, functions, g, global, i, id, identifier, import, imports,\n    inc, indexOf, infix_in, init, initial, isArray, isNaN, join, json, keys,\n    label, label_a, lbp, led, length, level, line, lines, live, loop, m,\n    margin, match, maxerr, maxlen, message, misplaced_a, misplaced_directive_a,\n    module, naked_block, name, names, nested_comment, new, node, not_label_a,\n    nud, ok, open, option, out_of_scope_a, parameters, pop, property, push,\n    qmark, quote, redefinition_a_b, replace, reserved_a, role, search,\n    signature, slash_equal, slice, sort, split, statement, stop, stopping,\n    strict, subscript_a, switch, test, this, thru, toString, todo_comment,\n    tokens, too_long, too_many, tree, type, u, unclosed_comment, unclosed_mega,\n    unclosed_string, undeclared_a, unexpected_a, unexpected_a_after_b,\n    unexpected_at_top_level_a, unexpected_char_a, unexpected_comment,\n    unexpected_directive_a, unexpected_expression_a, unexpected_label_a,\n    unexpected_parens, unexpected_space_a_b, unexpected_statement_a,\n    unexpected_typeof_a, uninitialized_a, unreachable_a,\n    unregistered_property_a, unsafe, unused_a, use_spaces, used, value,\n    var_loop, var_switch, variable, warning, warnings, weird_condition_a,\n    weird_expression_a, weird_loop, weird_relation_a, white, wrap_immediate,\n    wrap_regexp, wrapped, writable, y\n*/\n\nvar jslint = (function JSLint() {\n    'use strict';\n\n    function empty() {\n\n// The empty function produces a new empty object that inherits nothing. This is\n// much better than {} because confusions around accidental method names like\n// 'constructor' are completely avoided.\n\n        return Object.create(null);\n    }\n\n    function populate(object, array, value) {\n\n// Augment an object by taking property names from an array of strings.\n\n        array.forEach(function (name) {\n            object[name] = value;\n        });\n    }\n\n    var allowed_option = {\n\n// These are the options that are recognized in the option object or that may\n// appear in a /*jslint*/ directive. Most options will have a boolean value,\n// usually true. Some options will also predefine some number of global\n// variables.\n\n        bitwise: true,\n        browser: [\n            'Audio', 'clearInterval', 'clearTimeout', 'document', 'event',\n            'FormData', 'frames', 'history', 'Image', 'localStorage',\n            'location', 'name', 'navigator', 'Option', 'parent', 'screen',\n            'sessionStorage', 'setInterval', 'setTimeout', 'Storage',\n            'XMLHttpRequest'\n        ],\n        couch: [\n            'emit', 'getRow', 'isArray', 'log', 'provides', 'registerType',\n            'require', 'send', 'start', 'sum', 'toJSON'\n        ],\n        devel: [\n            'alert', 'confirm', 'console', 'Debug', 'opera', 'prompt', 'WSH'\n        ],\n        es6: [\n            'ArrayBuffer', 'DataView', 'Float32Array', 'Float64Array',\n            'Generator', 'GeneratorFunction', 'Int8Array', 'Int16Array',\n            'Int32Array', 'Intl', 'Map', 'Promise', 'Proxy', 'Reflect',\n            'Set', 'Symbol', 'System', 'Uint8Array', 'Uint8ClampedArray',\n            'Uint16Array', 'Uint32Array', 'WeakMap', 'WeakSet'\n        ],\n        eval: true,\n        for: true,\n        fudge: true,\n        maxerr: 1000,\n        maxlen: 256,\n        node: [\n            'Buffer', 'clearImmediate', 'clearInterval', 'clearTimeout',\n            'console', 'exports', 'global', 'module', 'process',\n            'require', 'setImmediate', 'setInterval', 'setTimeout',\n            '__dirname', '__filename'\n        ],\n        this: true,\n        white: true\n    };\n\n    var spaceop = {\n\n// This is the set of infix operators that require a space on each side.\n\n        '!=': true,\n        '!==': true,\n        '%': true,\n        '%=': true,\n        '^': true,\n        '^=': true,\n        '&': true,\n        '&=': true,\n        '&&': true,\n        '*': true,\n        '*=': true,\n        '-=': true,\n        '+=': true,\n        '=': true,\n        '=>': true,\n        '==': true,\n        '===': true,\n        '|': true,\n        '|=': true,\n        '||': true,\n        '<': true,\n        '<=': true,\n        '<<': true,\n        '<<=': true,\n        '>': true,\n        '>=': true,\n        '>>': true,\n        '>>=': true,\n        '>>>': true,\n        '>>>=': true\n    };\n\n    var bitwiseop = {\n\n// These are the bitwise operators.\n\n        '~': true,\n        '^': true,\n        '^=': true,\n        '&': true,\n        '&=': true,\n        '|': true,\n        '|=': true,\n        '<<': true,\n        '<<=': true,\n        '>>': true,\n        '>>=': true,\n        '>>>': true,\n        '>>>=': true\n    };\n\n    var opener = {\n\n// The open and close pairs.\n\n        '(': ')',       // paren\n        '[': ']',       // bracket\n        '{': '}',       // brace\n        '${': '}'       // mega\n    };\n\n    var relationop = {\n\n// The relational operators.\n\n        '!=': true,\n        '!==': true,\n        '==': true,\n        '===': true,\n        '<': true,\n        '<=': true,\n        '>': true,\n        '>=': true\n    };\n\n    var standard = [\n\n// These are the globals that are provided by the ES5 language standard.\n\n        'Array', 'Boolean', 'Date', 'decodeURI', 'decodeURIComponent',\n        'encodeURI', 'encodeURIComponent', 'Error', 'EvalError', 'Function',\n        'isFinite', 'isNaN', 'JSON', 'Math', 'Number', 'Object', 'parseInt',\n        'parseFloat', 'RangeError', 'ReferenceError', 'RegExp', 'String',\n        'SyntaxError', 'TypeError', 'URIError'\n    ];\n\n    var bundle = {\n\n// The bundle contains the raw text messages that are generated by jslint. It\n// seems that they are all error messages and warnings. There are no \"Atta\n// boy!\" or \"You are so awesome!\" messages. There is no positive reinforcement\n// or encouragement. This relentless negativity can undermine self-esteem and\n// wound the inner child. But if you accept it as sound advice rather than as\n// personal criticism, it can make your programs better.\n\n        and: \"The '&&' subexpression should be wrapped in parens.\",\n        bad_assignment_a: \"Bad assignment to '{a}'.\",\n        bad_character_number_a: \"Bad character code: '{a}'\",\n        bad_get: \"A get function takes no parameters.\",\n        bad_module_name_a: \"Bad module name '{a}'.\",\n        bad_option_a: \"Bad option '{a}'.\",\n        bad_property_a: \"Bad property name '{a}'.\",\n        bad_set: \"A set function takes one parameter.\",\n        duplicate_a: \"Duplicate '{a}'.\",\n        empty_block: \"Empty block.\",\n        es6: \"Unexpected ES6 feature.\",\n        expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n        expected_a_before_b: \"Expected '{a}' before '{b}'.\",\n        expected_a_b_from_c_d: \"Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.\",\n        expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n        expected_digits_after_a: \"Expected digits after '{a}'.\",\n        expected_four_digits: \"Expected four digits after '\\\\u'.\",\n        expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n        expected_line_break_a_b: \"Expected a line break between '{a}' and '{b}'.\",\n        expected_regexp_factor_a: \"Expected a regexp factor and instead saw '{a}'.\",\n        expected_space_a_b: \"Expected one space between '{a}' and '{b}'.\",\n        expected_string_a: \"Expected a string and instead saw '{a}'.\",\n        expected_type_string_a: \"Expected a type string and instead saw '{a}'.\",\n        function_in_loop: \"Don't make functions within a loop.\",\n        infix_in: \"Unexpected 'in'. Compare with undefined, or use the hasOwnProperty method instead.\",\n        isNaN: \"Use the isNaN function to compare with NaN.\",\n        label_a: \"'{a}' is a statement label.\",\n        misplaced_a: \"Place '{a}' at the outermost level.\",\n        misplaced_directive_a: \"Place the '/*{a}*/' directive before the first statement.\",\n        naked_block: \"Naked block.\",\n        nested_comment: \"Nested comment.\",\n        not_label_a: \"'{a}' is not a label.\",\n        out_of_scope_a: \"'{a}' is out of scope.\",\n        redefinition_a_b: \"Redefinition of '{a}' from line {b}.\",\n        reserved_a: \"Reserved name '{a}'.\",\n        slash_equal: \"A regular expression literal can be confused with '/='.\",\n        stopping: \"Stopping.\",\n        subscript_a: \"['{a}'] is better written in dot notation.\",\n        todo_comment: \"Unexpected TODO comment.\",\n        too_long: \"Line too long.\",\n        too_many: \"Too many warnings.\",\n        unclosed_comment: \"Unclosed comment.\",\n        unclosed_mega: \"Unclosed mega literal.\",\n        unclosed_string: \"Unclosed string.\",\n        undeclared_a: \"Undeclared '{a}'.\",\n        unexpected_a: \"Unexpected '{a}'.\",\n        unexpected_a_after_b: \"Unexpected '{a}' after '{b}'.\",\n        unexpected_at_top_level_a: \"Unexpected '{a}' at top level.\",\n        unexpected_char_a: \"Unexpected character '{a}'.\",\n        unexpected_comment: \"Unexpected comment.\",\n        unexpected_directive_a: \"When using modules, don't use directive '/*{a}'.\",\n        unexpected_expression_a: \"Unexpected expression '{a}' in statement position.\",\n\n        unexpected_statement_a: \"Unexpected statement '{a}' in expression position.\",\n        unexpected_label_a: \"Unexpected label '{a}'.\",\n        unexpected_parens: \"Don't wrap function literals in parens.\",\n        unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n        unexpected_typeof_a: \"Unexpected 'typeof'. Use '===' to compare directly with {a}.\",\n        uninitialized_a: \"Uninitialized '{a}'.\",\n        unreachable_a: \"Unreachable '{a}'.\",\n        unregistered_property_a: \"Unregistered property name '{a}'.\",\n        unsafe: \"Unsafe character '{a}'.\",\n        unused_a: \"Unused '{a}'.\",\n        use_spaces: \"Use spaces, not tabs.\",\n        var_loop: \"Don't declare variables in a loop.\",\n        var_switch: \"Don't declare variables in a switch.\",\n        wrap_regexp: \"Wrap this regexp in parens to avoid confusion.\",\n        weird_loop: \"Weird loop.\",\n        weird_condition_a: \"Weird condition '{a}'.\",\n        weird_expression_a: \"Weird expression '{a}'.\",\n        weird_relation_a: \"Weird relation '{a}'.\",\n        wrap_immediate: \"Wrap an immediate function invocation in \" +\n                \"parentheses to assist the reader in understanding that the \" +\n                \"expression is the result of a function, and not the \" +\n                \"function itself.\"\n    };\n\n// Regular expression literals:\n\n// supplant {variables}\n    var rx_supplant = /\\{([^{}]*)\\}/g,\n// carriage return, carriage return linefeed, or linefeed\n        rx_crlf = /\\n|\\r\\n?/,\n// unsafe characters that are silently deleted by one or more browsers\n        rx_unsafe = /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n// identifier\n        rx_identifier = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,\n        rx_bad_property = /^_|\\$|Sync$|_$/,\n// star slash\n        rx_star_slash = /\\*\\//,\n// slash star\n        rx_slash_star = /\\/\\*/,\n// slash star or ending slash\n        rx_slash_star_or_slash = /\\/\\*|\\/$/,\n// uncompleted work comment\n        rx_todo = /\\b(?:todo|TO\\s?DO|HACK)\\b/,\n// tab\n        rx_tab = /\\t/g,\n// directive\n        rx_directive = /^(jslint|property|global)\\s*(.*)$/,\n        rx_directive_part = /^([a-zA-Z$_][a-zA-Z0-9$_]*)\\s*(?::\\s*(true|false|[0-9]+)\\s*)?(?:,\\s*)?(.*)$/,\n// token (sorry it is so long)\n        rx_token = /^((\\s+)|([a-zA-Z_$][a-zA-Z0-9_$]*)|[(){}\\[\\]\\?,:;'\"~`]|=(?:==?|>)?|\\.+|\\/[*\\/]?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|[\\^%]=?|&[&=]?|\\|[|=]?|>{1,3}=?|<<?=?|!={0,2}|(0|[1-9][0-9]*))(.*)$/,\n        rx_digits = /^([0-9]+)(.*)$/,\n        rx_hexs = /^([0-9a-fA-F]+)(.*)$/,\n        rx_octals = /^([0-7]+)(.*)$/,\n        rx_bits = /^([01]+)(.*)$/,\n// mega\n        rx_mega = /`|\\$\\{/,\n// indentation\n        rx_colons = /^(.*)\\?([:.]*)$/,\n        rx_dot = /\\.$/,\n// JSON number\n        rx_JSON_number = /^-?\\d+(?:\\.\\d*)?(?:e[\\-+]?\\d+)?$/i;\n\n    function is_letter(string) {\n        return (string >= 'a' && string <= 'z\\uffff') ||\n                (string >= 'A' && string <= 'Z\\uffff');\n    }\n\n    function supplant(string, object) {\n        return string.replace(rx_supplant, function (found, filling) {\n            var replacement = object[filling];\n            return replacement !== undefined\n                ? replacement\n                : found;\n        });\n    }\n\n    var anon = \"anonymous\", // The guessed name for anonymous functions.\n        blockage,           // The current block.\n        block_stack,        // The stack of blocks.\n        declared_globals,   // The object containing the global declarations.\n        directive_mode,     // true if directives are still allowed.\n        early_stop,         // true if JSLint cannot finish.\n        export_mode,        // true if an export statement was seen.\n        fudge,              // true if the natural numbers start with 1.\n        functionage,        // The current function.\n        functions,          // The array containing all of the functions.\n        global,             // The global object, the outermost context.\n        imports,            // The array collecting all import-from strings.\n        json_mode,          // true if parsing JSON.\n        lines,              // The array containing source lines.\n        module_mode,        // true if import or export was used.\n        next_token,         // The next token to be examined in the parse.\n        option,             // The options parameter.\n        property,           // The object containing the tallied property names.\n        mega_mode,          // true if currently parsing a megastring literal.\n        stack,              // The stack of functions.\n        syntax,             // The object containing the parser.\n        token,              // The current token being examined in the parse.\n        token_nr,           // The number of the next token.\n        tokens,             // The array of tokens.\n        tenure,             // The predefined property registry.\n        tree,               // The abstract parse tree.\n        var_mode,           // true if using var, false if using let.\n        warnings;           // The array collecting all generated warnings.\n\n// Error reportage functions:\n\n    function artifact(the_token) {\n\n// Return a string representing an artifact.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        return the_token.id === '(string)' || the_token.id === '(number)'\n            ? String(the_token.value)\n            : the_token.id;\n    }\n\n    function artifact_line(the_token) {\n\n// Return the fudged line number of an artifact.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        return the_token.line + fudge;\n    }\n\n    function artifact_column(the_token) {\n\n// Return the fudged column number of an artifact.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        return the_token.from + fudge;\n    }\n\n    function warn_at(code, line, column, a, b, c, d) {\n\n// Report an error at some line and column of the program. The warning object\n// resembles an exception.\n\n        var warning = {         // ~~\n            name: 'JSLintError',\n            column: column,\n            line: line,\n            code: code\n        };\n        if (a !== undefined) {\n            warning.a = a;\n        }\n        if (b !== undefined) {\n            warning.b = b;\n        }\n        if (c !== undefined) {\n            warning.c = c;\n        }\n        if (d !== undefined) {\n            warning.d = d;\n        }\n        warning.message = supplant(bundle[code] || code, warning);\n        warnings.push(warning);\n        return warnings.length === option.maxerr\n            ? stop_at('too_many', line, column)\n            : warning;\n    }\n\n    function stop_at(code, line, column, a, b, c, d) {\n\n// Same as warn_at, except that it stops the analysis.\n\n        warn_at(code, line, column, a, b, c, d);\n        throw warn_at('stopping', line, column);\n    }\n\n    function warn(code, the_token, a, b, c, d) {\n\n// Same as warn_at, except the warning will be associated with a specific token.\n// If there is already a warning on this token, suppress the new one. It is\n// likely that the first warning will be the most meaningful.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        if (the_token.warning === undefined) {\n            the_token.warning = warn_at(\n                code,\n                the_token.line,\n                the_token.from,\n                a || artifact(the_token),\n                b,\n                c,\n                d\n            );\n            return the_token.warning;\n        }\n    }\n\n    function stop(code, the_token, a, b, c, d) {\n\n// Similar to warn and stop_at. If the token already had a warning, that\n// warning will be replaced with this new one. It is likely that the stopping\n// warning will be the most meaningful.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        the_token.warning = undefined;\n        warn(code, the_token, a, b, c, d);\n        the_token.warning = undefined;\n        throw warn('stopping', the_token, a, b, c, d);\n    }\n\n// Tokenize:\n\n    function tokenize(source) {\n\n// tokenize takes a source and produces from it an array of token objects.\n// JavaScript is notoriously difficult to tokenize because of the horrible\n// interactions between automatic semicolon insertion, regular expression\n// literals, and now megastring literals. JSLint benefits from eliminating\n// automatic semicolon insertion and nested megastring literals, which allows\n// full tokenization to precede parsing.\n\n// If the source is not an array, then it is split into lines at the\n// carriage return/linefeed.\n\n        lines = Array.isArray(source)\n            ? source\n            : source.split(rx_crlf);\n        tokens = [];\n\n        var char,                   // a popular character\n            column = 0,             // the column number of the next character\n            from,                   // the starting column number of the token\n            line = -1,              // the line number of the next character\n            previous = global,      // the previous token including comments\n            prior = global,         // the previous token excluding comments\n            mega_from,              // the starting column of megastring\n            mega_line,              // the starting line of megastring\n            snippet,                // a piece of string\n            source_line;            // the current line source string\n\n        function next_line() {\n\n// Put the next line of source in source_line. If the line contains tabs,\n// replace them with spaces and give a warning. Also warn if the line contains\n// unsafe characters or is too damn long.\n\n            var at;\n            column = 0;\n            line += 1;\n            source_line = lines[line];\n            if (source_line !== undefined) {\n                at = source_line.search(rx_tab);\n                if (at >= 0) {\n                    if (!option.white) {\n                        warn_at('use_spaces', line, at + 1);\n                    }\n                    source_line = source_line.replace(rx_tab, ' ');\n                }\n                at = source_line.search(rx_unsafe);\n                if (at >= 0) {\n                    warn_at(\n                        'unsafe',\n                        line,\n                        column + at,\n                        'U+' + source_line.charCodeAt(at).toString(16)\n                    );\n                }\n                if (option.maxlen && option.maxlen < source_line.length) {\n                    warn_at('too_long', line, source_line.length);\n                }\n            }\n            return source_line;\n        }\n\n// Most tokens, including the identifiers, operators, and punctuators, can be\n// found with a regular expression. Regular expressions cannot correctly match\n// regular expression literals, so we will match those the hard way. String\n// literals and number literals can be matched by regular expressions, but they\n// don't provide good warnings. The functions snip, next_char, prev_char,\n// some_digits, and escape help in the parsing of literals.\n\n        function snip() {\n\n// Remove the last character from snippet.\n\n            snippet = snippet.slice(0, -1);\n        }\n\n        function next_char(match) {\n\n// Get the next character from the source line. Remove it from the source_line,\n// and append it to the snippet. Optionally check that the previous character\n// matched an expected value.\n\n            if (match !== undefined && char !== match) {\n                return stop_at('expected_a_b', line, column, match, char);\n            }\n            if (source_line) {\n                char = source_line.charAt(0);\n                source_line = source_line.slice(1);\n                snippet += char;\n            } else {\n                char = '';\n                snippet += ' ';\n            }\n            column += 1;\n            return char;\n        }\n\n        function back_char() {\n\n// Back up one character by moving a character from the end of the snippet to\n// the front of the source_line.\n\n            if (snippet) {\n                char = snippet.slice(-1);\n                source_line = char + source_line;\n                column -= 1;\n                snip();\n            } else {\n                char = '';\n            }\n            return char;\n        }\n\n        function some_digits(rx, quiet) {\n            var result = source_line.match(rx);\n            if (result) {\n                char = result[1];\n                column += char.length;\n                source_line = result[2];\n                snippet += char;\n            } else {\n                char = '';\n                if (!quiet) {\n                    warn_at(\n                        'expected_digits_after_a',\n                        line,\n                        column,\n                        snippet\n                    );\n                }\n            }\n            return char.length;\n        }\n\n        function escape(extra) {\n            switch (next_char('\\\\')) {\n            case '\\\\':\n            case '\\'':\n            case '\"':\n            case '/':\n            case ':':\n            case 'b':\n            case 'f':\n            case 'n':\n            case 'r':\n            case 't':\n            case ' ':\n                break;\n            case 'u':\n                if (next_char('u') === '{') {\n                    if (some_digits(rx_hexs) > 5) {\n                        warn_at('too_many_digits', line, column - 1);\n                    }\n                    if (!option.es6) {\n                        warn_at('es6', line, column);\n                    }\n                    if (next_char() !== '}') {\n                        stop_at('expected_a_before_b', line, column, '}', char);\n                    }\n                    return;\n                }\n                back_char();\n                if (some_digits(rx_hexs, true) !== 4) {\n                    warn_at('expected_four_digits', line, column - 1);\n                }\n                break;\n            case '':\n                return stop_at('unclosed_string', line, column);\n            default:\n                if (extra && extra.indexOf(char) < 0) {\n                    warn_at('unexpected_a_after_b', line, column, char, '\\\\');\n                }\n            }\n            next_char();\n        }\n\n        function make(id, value, identifier) {\n\n// Make the token object and append it to the tokens list.\n\n            var the_token = {\n                id: id,\n                identifier: !!identifier,\n                from: from,\n                thru: column,\n                line: line\n            };\n            tokens.push(the_token);\n\n// Directives must appear before the first statement.\n\n            if (id !== '(comment)') {\n                directive_mode = false;\n            }\n\n// If the token is to have a value, give it one.\n\n            if (value !== undefined) {\n                the_token.value = value;\n            }\n\n// If this token is an identifier that touches a preceding number, or\n// a '/', comment, or regular expression literal that touches a preceding\n// comment or regular expression literal, then give a missing space warning.\n// This warning is not suppressed by option.white.\n\n            if (\n                previous.line === line &&\n                previous.thru === from &&\n                (\n                    (id === '(comment)' || id === '(regexp)' || id === '/') &&\n                    (\n                        previous.id === '(comment)' ||\n                        previous.id === '(regexp)'\n                    )\n                )\n            ) {\n                warn(\n                    'expected_space_a_b',\n                    the_token,\n                    artifact(previous),\n                    artifact(the_token)\n                );\n            }\n            if (previous.id === '.' && id === '(number)') {\n                warn('expected_a_before_b', previous, '0', '.');\n            }\n            if (prior.id === '.' && the_token.identifier) {\n                the_token.dot = true;\n            }\n\n// The previous token is used to detect adjacency problems.\n\n            previous = the_token;\n\n// The prior token is a previous token that was not a comment. The prior token\n// is used to disambiguate '/', which can mean division or regular expression\n// literal.\n\n            if (previous.id !== '(comment)') {\n                prior = previous;\n            }\n            return the_token;\n        }\n\n        function directive(the_comment, body) {\n\n// JSLint recognizes three directives that can be encoded in comments. This\n// function processes one item, and calls itself recursively to process the\n// next one.\n\n            var result = body.match(rx_directive_part);\n            if (result) {\n                var allowed,\n                    name = result[1],\n                    value = result[2];\n                switch (the_comment.directive) {\n                case 'jslint':\n                    allowed = allowed_option[name];\n                    switch (typeof allowed) {\n                    case 'boolean':\n                        switch (value) {\n                        case 'true':\n                        case '':\n                        case undefined:\n                            option[name] = true;\n                            break;\n                        case 'false':\n                            option[name] = false;\n                            break;\n                        default:\n                            warn('bad_option_a', the_comment, name + ':' + value);\n                        }\n                        break;\n                    case 'number':\n                        if (isFinite(+value)) {\n                            option[name] = +value;\n                        } else {\n                            warn('bad_option_a', the_comment, name + ':' + value);\n                        }\n                        break;\n                    case 'object':\n                        option[name] = true;\n                        populate(declared_globals, allowed, false);\n                        break;\n                    default:\n                        warn('bad_option_a', the_comment, name);\n                    }\n                    break;\n                case 'property':\n                    if (tenure === undefined) {\n                        tenure = empty();\n                    }\n                    tenure[name] = true;\n                    break;\n                case 'global':\n                    if (value) {\n                        warn('bad_option_a', the_comment, name + ':' + value);\n                    }\n                    declared_globals[name] = false;\n                    module_mode = the_comment;\n                    break;\n                }\n                return directive(the_comment, result[3]);\n            }\n            if (body) {\n                return stop('bad_directive_a', the_comment, body);\n            }\n        }\n\n        function comment(snippet) {\n\n// Make a comment object. Comments are not allowed in JSON text. Comments can\n// include directives and notices of incompletion.\n\n            var the_comment = make('(comment)', snippet);\n            if (json_mode) {\n                warn('unexpected_comment', the_comment);\n            }\n            if (Array.isArray(snippet)) {\n                snippet = snippet.join(' ');\n            }\n            if (!option.devel && rx_todo.test(snippet)) {\n                warn('todo_comment', the_comment);\n            }\n            var result = snippet.match(rx_directive);\n            if (result) {\n                if (!directive_mode) {\n                    warn_at('misplaced_directive_a', line, from, result[1]);\n                } else {\n                    the_comment.directive = result[1];\n                    directive(the_comment, result[2]);\n                }\n            }\n            return the_comment;\n        }\n\n        function regexp() {\n\n// Parse a regular expression literal.\n\n            var result,\n                u_mode = false,\n                value;\n\n            function quantifier() {\n\n// Match an optional quantifier.\n\n                switch (char) {\n                case '?':\n                case '*':\n                case '+':\n                    next_char();\n                    break;\n                case '{':\n                    if (some_digits(rx_digits, true) === 0) {\n                        warn_at('expected_a', line, column, '0');\n                    }\n                    if (next_char() === ',') {\n                        some_digits(rx_digits, true);\n                        next_char();\n                    }\n                    next_char('}');\n                    break;\n                default:\n                    return;\n                }\n                if (char === '?') {\n                    next_char('?');\n                }\n            }\n\n            function subklass() {\n\n// Match a character in a character class.\n\n                switch (char) {\n                case '\\\\':\n                    escape();\n                    return true;\n                case '[':\n                case ']':\n                case '/':\n                case '^':\n                case '-':\n                case '':\n                    return false;\n                case '`':\n                    if (mega_mode) {\n                        warn_at('unexpected_a', line, column, '`');\n                    }\n                    next_char();\n                    return true;\n                case ' ':\n                    warn_at('expected_a_b', line, column, '\\\\s', ' ');\n                    next_char();\n                    return true;\n                default:\n                    next_char();\n                    return true;\n                }\n            }\n\n            function range() {\n\n// Match a range of subclasses.\n\n                if (subklass()) {\n                    if (char === '-') {\n                        next_char('-');\n                        if (!subklass()) {\n                            return stop_at('unexpected_a', line, column - 1, '-');\n                        }\n                    }\n                    return range();\n                }\n            }\n\n            function klass() {\n\n// Match a class.\n\n                next_char('[');\n                if (char === '^') {\n                    next_char('^');\n                }\n                range();\n                next_char(']');\n            }\n\n            function choice() {\n\n                function group() {\n\n// Match a group that starts with left paren.\n\n                    next_char('(');\n                    if (char === '?') {\n                        next_char('?');\n                        switch (char) {\n                        case ':':\n                        case '=':\n                        case '!':\n                            next_char();\n                            break;\n                        default:\n                            next_char(':');\n                        }\n                    } else if (char === ':') {\n                        warn_at('expected_a_before_b', line, column, '?', ':');\n                    }\n                    choice();\n                    next_char(')');\n                }\n\n                function factor() {\n                    switch (char) {\n                    case '[':\n                        klass();\n                        return true;\n                    case '\\\\':\n                        escape('BbDdSsWw^${}[]().|*+?');\n                        return true;\n                    case '(':\n                        group();\n                        return true;\n                    case '/':\n                    case '|':\n                    case ']':\n                    case ')':\n                    case '}':\n                    case '{':\n                    case '?':\n                    case '+':\n                    case '*':\n                    case '':\n                        return false;\n                    case '`':\n                        if (mega_mode) {\n                            warn_at('unexpected_a', line, column, '`');\n                        }\n                        break;\n                    case ' ':\n                        warn_at('expected_a_b', line, column, '\\\\s', ' ');\n                        break;\n                    }\n                    next_char();\n                    return true;\n                }\n\n                function sequence(follow) {\n                    if (factor()) {\n                        quantifier();\n                        return sequence(true);\n                    }\n                    if (!follow) {\n                        warn_at('expected_regexp_factor_a', line, column, char);\n                    }\n                }\n\n// Match a choice (a sequence that can be followed by | and another choice).\n\n                sequence();\n                if (char === '|') {\n                    next_char('|');\n                    return choice();\n                }\n            }\n\n// Scan the regexp literal. Give a warning if the first character is = because\n// /= looks like a division assignment operator.\n\n            snippet = '';\n            next_char();\n            if (char === '=') {\n                warn_at('expected_a_before_b', line, column, '\\\\', '=');\n            }\n            choice();\n\n// Make sure there is a closing slash.\n\n            snip();\n            value = snippet;\n            next_char('/');\n\n// Process dangling flag letters.\n\n            var allowed = {\n                    g: true,\n                    i: true,\n                    m: true,\n                    u: u_mode,\n                    y: option.es6\n                },\n                flag = empty();\n            (function make_flag() {\n                if (is_letter(char)) {\n                    if (allowed[char] !== true) {\n                        warn_at('unexpected_a', line, column, char);\n                    }\n                    allowed[char] = false;\n                    flag[char] = true;\n                    next_char();\n                    return make_flag();\n                }\n            }());\n            if (u_mode && !flag.u) {\n                warn_at('expected_a_before_b', line, column, 'u', char);\n            }\n            back_char();\n            if (char === '/' || char === '*') {\n                return stop_at('unexpected_a', line, from, char);\n            }\n            result = make('(regexp)', char);\n            result.flag = flag;\n            result.value = value;\n            return result;\n        }\n\n        function string(quote) {\n\n// Make a string token.\n\n            var the_token;\n            snippet = '';\n            next_char();\n\n            return (function next() {\n                switch (char) {\n                case quote:\n                    snip();\n                    the_token = make('(string)', snippet);\n                    the_token.quote = quote;\n                    return the_token;\n                case '\\\\':\n                    escape();\n                    break;\n                case '':\n                    return stop_at('unclosed_string', line, column);\n                case '`':\n                    if (mega_mode) {\n                        warn_at('unexpected_a', line, column, '`');\n                    }\n                    next_char('`');\n                    break;\n                default:\n                    next_char();\n                }\n                return next();\n            }());\n        }\n\n        function frack() {\n            if (char === '.') {\n                some_digits(rx_digits);\n                next_char();\n            }\n            if (char === 'E' || char === 'e') {\n                next_char();\n                if (char !== '+' && char !== '-') {\n                    back_char();\n                }\n                some_digits(rx_digits);\n                next_char();\n            }\n        }\n\n        function number() {\n            if (snippet === '0') {\n                switch (next_char()) {\n                case '.':\n                    frack();\n                    break;\n                case 'b':\n                    some_digits(rx_bits);\n                    next_char();\n                    break;\n                case 'o':\n                    some_digits(rx_octals);\n                    next_char();\n                    break;\n                case 'x':\n                    some_digits(rx_hexs);\n                    next_char();\n                    break;\n                }\n            } else {\n                next_char();\n                frack();\n            }\n\n// If the next character after a number is a digit or letter, then something\n// unexpected is going on.\n\n            if (\n                (char >= '0' && char <= '9') ||\n                (char >= 'a' && char <= 'z') ||\n                (char >= 'A' && char <= 'Z')\n            ) {\n                return stop_at(\n                    'unexpected_a_after_b',\n                    line,\n                    column - 1,\n                    snippet.slice(-1),\n                    snippet.slice(0, -1)\n                );\n            }\n            back_char();\n            return make('(number)', snippet);\n        }\n\n        function lex() {\n            var array,\n                i,\n                j,\n                last,\n                result,\n                the_token;\n            if (!source_line) {\n                source_line = next_line();\n                from = 0;\n                return source_line === undefined\n                    ? mega_mode\n                        ? stop_at('unclosed_mega', mega_line, mega_from)\n                        : make('(end)')\n                    : lex();\n            }\n            from = column;\n            result = source_line.match(rx_token);\n\n// result[1] token\n// result[2] whitespace\n// result[3] identifier\n// result[4] number\n// result[5] rest\n\n            if (!result) {\n                return stop_at('unexpected_char_a', line, column, source_line.charAt(0));\n            }\n\n            snippet = result[1];\n            column += snippet.length;\n            source_line = result[5];\n\n// Whitespace was matched. Call lex again to get more.\n\n            if (result[2]) {\n                return lex();\n            }\n\n// The token is an identifier.\n\n            if (result[3]) {\n                return make(snippet, undefined, true);\n            }\n\n// The token is a number.\n\n            if (result[4]) {\n                return number(snippet);\n            }\n\n// The token is something miscellaneous.\n\n            switch (snippet) {\n\n// The token is a single quote string.\n\n            case '\\'':\n                if (json_mode) {\n                    warn_at('unexpected_a', line, column, '\\'');\n                }\n                return string('\\'');\n\n// The token is a double quote string.\n\n            case '\"':\n                return string('\"');\n\n// The token is a megastring. We don't allow any kind if mega nesting.\n\n            case '`':\n                if (mega_mode) {\n                    return stop_at('expected_a_b', line, column, '}', '`');\n                }\n                snippet = '';\n                mega_from = from;\n                mega_line = line;\n                mega_mode = true;\n\n// Parsing a mega literal is tricky. First make a ` token.\n\n                make('`');\n                from += 1;\n\n// Then loop, building up a string, possibly from many lines, until seeing\n// the end of file, a closing `, or a ${ indicting an expression within the\n// string.\n\n                (function part() {\n                    var at = source_line.search(rx_mega);\n\n// If neither ` nor ${ is seen, then the whole line joins the snippet.\n\n                    if (at < 0) {\n                        snippet += source_line + '\\n';\n                        return next_line() === undefined\n                            ? stop_at('unclosed_mega', mega_line, mega_from)\n                            : part();\n                    }\n\n// if either ` or ${ was found, then the preceding joins the snippet to become\n// a string token.\n\n                    snippet += source_line.slice(0, at);\n                    column += at;\n                    source_line = source_line.slice(at);\n                    make('(string)', snippet).quote = '`';\n                    snippet = '';\n\n// If ${, then make tokens that will become part of an expression until\n// a } token is made.\n\n                    if (source_line.charAt(0) === '$') {\n                        column += 2;\n                        make('${');\n                        source_line = source_line.slice(2);\n                        (function expr() {\n                            var id = lex().id;\n                            if (id === '{') {\n                                return stop_at(\n                                    'expected_a_b',\n                                    line,\n                                    column,\n                                    '}',\n                                    '{'\n                                );\n                            }\n                            if (id !== '}') {\n                                return expr();\n                            }\n                        }());\n                        return part();\n                    }\n                }());\n                source_line = source_line.slice(1);\n                column += 1;\n                mega_mode = false;\n                return make('`');\n\n// The token is a // comment.\n\n            case '//':\n                snippet = source_line;\n                source_line = '';\n                the_token = comment(snippet);\n                if (mega_mode) {\n                    warn('unexpected_comment', the_token, '`');\n                }\n                return the_token;\n\n// The token is a /* comment.\n\n            case '/*':\n                array = [];\n                if (source_line.charAt(0) === '/') {\n                    warn_at('unexpected_a', line, column + i, '/');\n                }\n                (function next() {\n                    if (source_line > '') {\n                        i = source_line.search(rx_star_slash);\n                        if (i >= 0) {\n                            return;\n                        }\n                        j = source_line.search(rx_slash_star);\n                        if (j >= 0) {\n                            warn_at('nested_comment', line, column + j);\n                        }\n                    }\n                    array.push(source_line);\n                    source_line = next_line();\n                    if (source_line === undefined) {\n                        return stop_at('unclosed_comment', line, column);\n                    }\n                    return next();\n                }());\n                snippet = source_line.slice(0, i);\n                j = snippet.search(rx_slash_star_or_slash);\n                if (j >= 0) {\n                    warn_at('nested_comment', line, column + j);\n                }\n                array.push(snippet);\n                column += i + 2;\n                source_line = source_line.slice(i + 2);\n                return comment(array);\n\n// The token is a slash.\n\n            case '/':\n\n// The / can be a division operator or the beginning of a regular expression\n// literal. It is not possible to know which without doing a complete parse.\n// We want to complete the tokenization before we begin to parse, so we will\n// estimate. This estimator can fail in some cases. For example, it cannot\n// know if '}' is ending a block or ending an object literal, so it can\n// behave incorrectly in that case; it is not meaningful to divide an\n// object, so it is likely that we can get away with it. We avoided the worst\n// cases by eliminating automatic semicolon insertion.\n\n                if (prior.identifier) {\n                    if (!prior.dot) {\n                        switch (prior.id) {\n                        case 'return':\n                            return regexp();\n                        case '(begin)':\n                        case 'case':\n                        case 'delete':\n                        case 'in':\n                        case 'instanceof':\n                        case 'new':\n                        case 'typeof':\n                        case 'void':\n                        case 'yield':\n                            the_token = regexp();\n                            return stop('unexpected_a', the_token);\n                        }\n                    }\n                } else {\n                    last = prior.id.charAt(prior.id.length - 1);\n                    if ('(,=:?['.indexOf(last) >= 0) {\n                        return regexp();\n                    }\n                    if ('!&|{};~+-*%/^<>'.indexOf(last) >= 0) {\n                        the_token = regexp();\n                        warn('wrap_regexp', the_token);\n                        return the_token;\n                    }\n                }\n                if (source_line.charAt(0) === '/') {\n                    column += 1;\n                    source_line = source_line.slice(1);\n                    snippet = '/=';\n                    warn_at('unexpected_a', line, column, '/=');\n                }\n                break;\n            }\n            return make(snippet);\n        }\n\n// This is the only loop in JSLint. It will turn into a recursive call to lex\n// when ES6 has been finished and widely deployed and adopted.\n\n        while (true) {\n            if (lex().id === '(end)') {\n                break;\n            }\n        }\n    }\n\n// Parsing:\n\n// Parsing weaves the tokens into an abstract syntax tree. During that process,\n// a token may be given any of these properties:\n\n//      arity       string\n//      label       identifier\n//      name        identifier\n//      expression  expressions\n//      block       statements\n//      else        statements (else, default, catch)\n\n// Specialized tokens may have additional properties.\n\n    function survey(name) {\n        var id = name.id;\n\n// Tally the property name. If it is a string, only tally strings that conform\n// to the identifier rules.\n\n        if (id === '(string)') {\n            id = name.value;\n            if (!rx_identifier.test(id)) {\n                return id;\n            }\n        } else if (!name.identifier) {\n            return stop('expected_identifier_a', name);\n        }\n\n// If we have seen this name before, increment its count.\n\n        if (typeof property[id] === 'number') {\n            property[id] += 1;\n\n// If this is the first time seeing this property name, and if there is a\n// tenure list, then it must be on the list. Otherwise, it must conform to\n// the rules for good property names.\n\n        } else {\n            if (tenure !== undefined) {\n                if (tenure[id] !== true) {\n                    warn('unregistered_property_a', name);\n                }\n            } else {\n                if (rx_bad_property.test(id)) {\n                    warn('bad_property_a', name);\n                }\n            }\n            property[id] = 1;\n        }\n        return id;\n    }\n\n    function dispense() {\n\n// Deliver the next token, skipping the comments.\n\n        var cadet = tokens[token_nr];\n        token_nr += 1;\n        return cadet.id === '(comment)'\n            ? dispense()\n            : cadet;\n    }\n\n    function lookahead() {\n\n// Look ahead one token without advancing.\n\n        var old_token_nr = token_nr,\n            cadet = dispense(true);\n        token_nr = old_token_nr;\n        return cadet;\n    }\n\n    function advance(id, match) {\n\n// Produce the next token.\n\n// Attempt to give helpful names to anonymous functions.\n\n        if (token.identifier && token.id !== 'function') {\n            anon = token.id;\n        } else if (token.id === '(string)' && rx_identifier.test(token.value)) {\n            anon = token.value;\n        }\n\n// Attempt to match next_token with an expected id.\n\n        if (id !== undefined && next_token.id !== id) {\n            return match === undefined\n                ? stop('expected_a_b', next_token, id, artifact())\n                : stop(\n                    'expected_a_b_from_c_d',\n                    next_token,\n                    id,\n                    artifact(match),\n                    artifact_line(match),\n                    artifact(next_token)\n                );\n        }\n\n// Promote the tokens, skipping comments.\n\n        token = next_token;\n        next_token = dispense();\n        if (next_token.id === '(end)') {\n            token_nr -= 1;\n        }\n    }\n\n// Parsing of JSON is simple:\n\n    function json_value() {\n\n        function json_object() {\n            var brace = next_token,\n                object = empty();\n            advance('{');\n            if (next_token.id !== '}') {\n                (function next() {\n                    advance('(string)');\n                    if (object[token.value] !== undefined) {\n                        warn('duplicate_a', token);\n                    } else if (token.value === '__proto__') {\n                        warn('bad_property_name_a', token);\n                    } else {\n                        object[token.value] = token;\n                    }\n                    advance(':');\n                    json_value();\n                    if (next_token.id === ',') {\n                        advance(',');\n                        return next();\n                    }\n                }());\n            }\n            advance('}', brace);\n        }\n\n        function json_array() {\n            var bracket = next_token;\n            advance('[');\n            if (next_token.id !== ']') {\n                (function next() {\n                    json_value();\n                    if (next_token.id === ',') {\n                        advance(',');\n                        return next();\n                    }\n                }());\n            }\n            advance(']', bracket);\n        }\n\n        switch (next_token.id) {\n        case '{':\n            json_object();\n            break;\n        case '[':\n            json_array();\n            break;\n        case 'true':\n        case 'false':\n        case 'null':\n            advance();\n            break;\n        case '(number)':\n            if (!rx_JSON_number.test(next_token.value)) {\n                warn('unexpected_a');\n            }\n            advance();\n            break;\n        case '(string)':\n            advance();\n            break;\n        case '-':\n            advance('-');\n            advance('(number)');\n            break;\n        default:\n            stop('unexpected_a');\n        }\n    }\n\n// Now we parse JavaScript.\n\n    function enroll(name, role, readonly) {\n\n// Enroll a name into the current function context. The role can be exception,\n// label, parameter, or variable. We look for variable redefinition because it\n// causes confusion.\n\n        var id = name.id;\n\n// Reserved words may not be enrolled.\n\n        if (syntax[id] !== undefined && id !== 'ignore') {\n            warn('reserved_a', name);\n        } else {\n\n// Has the name been enrolled in this context?\n\n            var earlier = functionage.context[id];\n            if (earlier) {\n                warn(\n                    'redefinition_a_b',\n                    name,\n                    name.id,\n                    earlier.line + fudge\n                );\n\n// Has the name been enrolled in an outer context?\n\n            } else {\n                stack.forEach(function (value) {\n                    var item = value.context[id];\n                    if (item !== undefined) {\n                        earlier = item;\n                    }\n                });\n                if (earlier) {\n                    if (id === 'ignore') {\n                        if (earlier.role === 'variable') {\n                            warn('unexpected_a', name);\n                        }\n                    } else {\n                        if (\n                            (role !== 'exception' || earlier.role !== 'exception') &&\n                            role !== 'parameter' &&\n                            role !== 'function'\n                        ) {\n                            warn(\n                                'redefinition_a_b',\n                                name,\n                                name.id,\n                                earlier.line + fudge\n                            );\n                        }\n                    }\n                }\n\n// Enroll it.\n\n                functionage.context[id] = name;\n                name.dead = true;\n                name.function = functionage;\n                name.init = false;\n                name.role = role;\n                name.used = 0;\n                name.writable = !readonly;\n            }\n        }\n    }\n\n    function expression(rbp, initial) {\n\n// This is the heart of the Pratt parser. I retained Pratt's nomenclature.\n// They are elements of the parsing method called Top Down Operator Precedence.\n\n// nud     Null denotation\n// led     Left denotation\n// lbp     Left binding power\n// rbp     Right binding power\n\n// It processes a nud (variable, constant, prefix operator). It will then\n// process leds (infix operators) until the bind powers cause it to stop. It\n// returns the expression's parse tree.\n\n        var left, the_symbol;\n\n// Statements will have already advanced, so advance now only if the token is\n// not the first of a statement,\n\n        if (!initial) {\n            advance();\n        }\n        the_symbol = syntax[token.id];\n        if (the_symbol !== undefined && the_symbol.nud !== undefined) {\n            left = the_symbol.nud();\n        } else if (token.identifier) {\n            left = token;\n            left.arity = 'variable';\n        } else {\n            return stop('unexpected_a', token);\n        }\n        (function right() {\n            the_symbol = syntax[next_token.id];\n            if (\n                the_symbol !== undefined &&\n                the_symbol.led !== undefined &&\n                rbp < the_symbol.lbp\n            ) {\n                advance();\n                left = the_symbol.led(left);\n                return right();\n            }\n        }());\n        return left;\n    }\n\n    function condition() {\n\n// Parse the condition part of a do, if, while.\n\n        var the_paren = next_token,\n            the_value;\n        the_paren.free = true;\n        advance('(');\n        the_value = expression(0);\n        advance(')');\n        if (the_value.wrapped === true) {\n            warn('unexpected_a', the_paren);\n        }\n        switch (the_value.id) {\n        case '~':\n        case '&':\n        case '|':\n        case '^':\n        case '<<':\n        case '>>':\n        case '>>>':\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n        case '%':\n        case 'typeof':\n        case '(number)':\n        case '(string)':\n            warn('unexpected_a', the_value);\n            break;\n        }\n        return the_value;\n    }\n\n    function semicolon() {\n\n// Try to match a semicolon.\n\n        if (next_token.id === ';') {\n            advance(';');\n        } else {\n            warn_at(\n                'expected_a_b',\n                token.line,\n                token.thru,\n                ';',\n                artifact(next_token)\n            );\n        }\n        anon = 'anonymous';\n    }\n\n    function statement() {\n\n// Parse a statement. Any statement may have a label, but only four statements\n// have use for one. A statement can be one of the standard statements, or\n// an assignment expression, or an invocation expression.\n\n        var first,\n            the_label,\n            the_statement,\n            the_symbol;\n        advance();\n        if (token.identifier && next_token.id === ':') {\n            the_label = token;\n            if (the_label.id === 'ignore') {\n                warn('unexpected_a', the_label);\n            }\n            advance(':');\n            switch (next_token.id) {\n            case 'do':\n            case 'for':\n            case 'switch':\n            case 'while':\n                enroll(the_label, 'label', true);\n                the_label.init = true;\n                the_statement = statement();\n                the_statement.label = the_label;\n                the_statement.statement = true;\n                return the_statement;\n            default:\n                advance();\n                warn('unexpected_label_a', the_label);\n            }\n        }\n\n// Parse the statement.\n\n        first = token;\n        first.statement = true;\n        the_symbol = syntax[first.id];\n        if (the_symbol !== undefined && the_symbol.fud !== undefined) {\n            the_symbol.disrupt = false;\n            the_symbol.statement = true;\n            return the_symbol.fud();\n        }\n\n// It is an expression statement.\n\n        the_statement = expression(0, true);\n        if (\n            the_statement.wrapped &&\n            (\n                the_statement.id !== '(' ||\n                the_statement.expression[0].id !== 'function'\n            )\n        ) {\n            warn('unexpected_a', first);\n        }\n        semicolon();\n        return the_statement;\n    }\n\n    function statements() {\n\n// Parse a list of statements. Give a warning if an unreachable statement\n// follows a disruptive statement.\n\n        var array = [];\n        (function next(disrupt) {\n            var a_statement;\n            switch (next_token.id) {\n            case '}':\n            case 'case':\n            case 'default':\n            case 'else':\n            case '(end)':\n                break;\n            default:\n                a_statement = statement();\n                array.push(a_statement);\n                if (disrupt) {\n                    warn('unreachable_a', a_statement);\n                }\n                return next(a_statement.disrupt);\n            }\n        }(false));\n        return array;\n    }\n\n    function not_top_level(thing) {\n\n// Some features should not be at the outermost level.\n\n        if (functionage === global) {\n            warn('unexpected_at_top_level_a', thing);\n        }\n    }\n\n    function top_level_only(the_thing) {\n\n// Some features must be at the most outermost level.\n\n        if (blockage !== global) {\n            warn('misplaced_a', the_thing);\n        }\n    }\n\n    function block(special) {\n\n// Parse a block, a sequence of statements wrapped in braces.\n//  special 'body'      The block is a function body.\n//          'ignore'    No warning on an empty block.\n//          'naked'     No advance.\n//          undefined   Not special.\n\n        var stmts, the_block;\n        if (special !== 'naked') {\n            advance('{');\n        }\n        the_block = token;\n        the_block.arity = 'statement';\n        the_block.body = special === 'body';\n\n// All top level function bodies should include the 'use strict' pragma unless\n// the whole file is strict.\n\n        if (the_block.body && stack.length <= 1 && !global.strict) {\n            if (\n                next_token.id === '(string)' ||\n                next_token.value === 'use strict'\n            ) {\n                next_token.statement = true;\n                functionage.strict = true;\n                advance('(string)');\n                advance(';');\n            } else {\n                warn(\n                    'expected_a_before_b',\n                    next_token,\n                    next_token.id === '`'\n                        ? '\\''\n                        : 'use strict',\n                    artifact(next_token)\n                );\n            }\n        }\n        stmts = statements();\n        the_block.block = stmts;\n        if (stmts.length === 0) {\n            if (!option.devel && special !== 'ignore') {\n                warn('empty_block', the_block);\n            }\n            the_block.disrupt = false;\n        } else {\n            the_block.disrupt = stmts[stmts.length - 1].disrupt;\n        }\n        advance('}');\n        return the_block;\n    }\n\n    function mutation_check(the_thing) {\n\n// The only expressions that may be assigned to are\n//      e.b\n//      e[b]\n//      v\n\n        if (\n            the_thing.id !== '.' &&\n            (the_thing.id !== '[' || the_thing.arity !== 'binary') &&\n            the_thing.arity !== 'variable'\n        ) {\n            warn('bad_assignment_a', the_thing);\n            return false;\n        }\n        return true;\n    }\n\n    function left_check(left, right) {\n\n// Warn if the left is not one of these:\n//      e.b\n//      e[b]\n//      e()\n//      identifier\n\n        var id = left.id;\n        if (\n            !left.identifier &&\n            (\n                left.arity !== 'binary' ||\n                (id !== '.' && id !== '(' && id !== '[')\n            )\n        ) {\n            warn('unexpected_a', right);\n            return false;\n        }\n        return true;\n    }\n\n// These functions are used to specify the grammar of our language:\n\n    function symbol(id, bp) {\n\n// Make a symbol if it does not already exist in the language's syntax.\n\n        var the_symbol = syntax[id];\n        if (the_symbol === undefined) {\n            the_symbol = empty();\n            the_symbol.id = id;\n            the_symbol.lbp = bp || 0;\n            syntax[id] = the_symbol;\n        }\n        return the_symbol;\n    }\n\n    function assignment(id) {\n\n// Make an assignment operator. The one true assignment is different because\n// its left side, when it is a variable, is not treated as an expression.\n// That case is special because that is when a variable gets initialized. The\n// other assignment operators can modify, but they cannot initialize.\n\n        var the_symbol = symbol(id, 20);\n        the_symbol.led = function (left) {\n            var the_token = token,\n                right;\n            the_token.arity = 'assignment';\n            right = expression(20 - 1);\n            if (id === '=' && left.arity === 'variable') {\n                the_token.names = left;\n                the_token.expression = right;\n            } else {\n                the_token.expression = [left, right];\n            }\n            switch (right.arity) {\n            case 'assignment':\n            case 'pre':\n            case 'post':\n                warn('unexpected_a', right);\n                break;\n            }\n            if (\n                option.es6 &&\n                left.arity === 'unary' &&\n                (left.id === '[' || left.id === '{')\n            ) {\n                warn('expected_a_before_b', left, 'const', left.id);\n            } else {\n                mutation_check(left);\n            }\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function constant(id, type, value) {\n\n// Make a constant symbol.\n\n        var the_symbol = symbol(id);\n        the_symbol.nud = typeof value === 'function'\n            ? value\n            : function () {\n                token.constant = true;\n                if (value !== undefined) {\n                    token.value = value;\n                }\n                return token;\n            };\n        the_symbol.type = type;\n        the_symbol.value = value;\n        return the_symbol;\n    }\n\n    function infix(id, bp, f) {\n\n// Make an infix operator.\n\n        var the_symbol = symbol(id, bp);\n        the_symbol.led = function (left) {\n            var the_token = token;\n            the_token.arity = 'binary';\n            if (f !== undefined) {\n                return f(left);\n            }\n            the_token.expression = [left, expression(bp)];\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function post(id) {\n\n// Make one of the post operators.\n\n        var the_symbol = symbol(id, 150);\n        the_symbol.led = function (left) {\n            token.expression = left;\n            token.arity = 'post';\n            mutation_check(token.expression);\n            return token;\n        };\n        return the_symbol;\n    }\n\n    function pre(id) {\n\n// Make one of the pre operators.\n\n        var the_symbol = symbol(id);\n        the_symbol.nud = function () {\n            var the_token = token;\n            the_token.arity = 'pre';\n            the_token.expression = expression(150);\n            mutation_check(the_token.expression);\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function prefix(id, f) {\n\n// Make a prefix operator.\n\n        var the_symbol = symbol(id);\n        the_symbol.nud = function () {\n            var the_token = token;\n            the_token.arity = 'unary';\n            if (typeof f === 'function') {\n                return f();\n            }\n            the_token.expression = expression(150);\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function stmt(id, f) {\n\n// Make a statement.\n\n        var the_symbol = symbol(id);\n        the_symbol.fud = function () {\n            token.arity = 'statement';\n            return f();\n        };\n        return the_symbol;\n    }\n\n    function ternary(id1, id2) {\n\n// Make a ternary operator.\n\n        var the_symbol = symbol(id1, 30);\n        the_symbol.led = function (left) {\n            var the_token = token,\n                second = expression(20);\n            advance(id2);\n            token.arity = 'ternary';\n            the_token.arity = 'ternary';\n            the_token.expression = [left, second, expression(10)];\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n// Begin defining the language.\n\n    syntax = empty();\n\n    symbol('}');\n    symbol(')');\n    symbol(']');\n    symbol(',');\n    symbol(';');\n    symbol(':');\n    symbol('*/');\n    symbol('await');\n    symbol('case');\n    symbol('catch');\n    symbol('class');\n    symbol('default');\n    symbol('else');\n    symbol('enum');\n    symbol('finally');\n    symbol('implements');\n    symbol('interface');\n    symbol('package');\n    symbol('private');\n    symbol('protected');\n    symbol('public');\n    symbol('static');\n    symbol('super');\n    symbol('void');\n    symbol('with');\n    symbol('yield');\n\n    constant('(number)', 'number');\n    constant('(regexp)', 'regexp');\n    constant('(string)', 'string');\n    constant('arguments', 'object', function () {\n        warn('unexpected_a', token);\n        return token;\n    });\n    constant('eval', 'function', function () {\n        if (!option.eval) {\n            warn('unexpected_a', token);\n        } else if (next_token.id !== '(') {\n            warn('expected_a_before_b', next_token, '(', artifact());\n        }\n        return token;\n    });\n    constant('false', 'boolean', false);\n    constant('ignore', 'undefined', function () {\n        warn('unexpected_a', token);\n        return token;\n    });\n    constant('Infinity', 'number', Infinity);\n    constant('NaN', 'number', NaN);\n    constant('null', 'null', null);\n    constant('this', 'object', function () {\n        if (!option.this) {\n            warn('unexpected_a', token);\n        }\n        return token;\n    });\n    constant('true', 'boolean', true);\n    constant('undefined', 'undefined');\n\n    assignment('=');\n    assignment('+=');\n    assignment('-=');\n    assignment('*=');\n    assignment('/=');\n    assignment('%=');\n    assignment('&=');\n    assignment('|=');\n    assignment('^=');\n    assignment('<<=');\n    assignment('>>=');\n    assignment('>>>=');\n\n    infix('||', 40);\n    infix('&&', 50);\n    infix('|', 70);\n    infix('^', 80);\n    infix('&', 90);\n    infix('==', 100);\n    infix('===', 100);\n    infix('!=', 100);\n    infix('!==', 100);\n    infix('<', 110);\n    infix('>', 110);\n    infix('<=', 110);\n    infix('>=', 110);\n    infix('in', 110);\n    infix('instanceof', 110);\n    infix('<<', 120);\n    infix('>>', 120);\n    infix('>>>', 120);\n    infix('+', 130);\n    infix('-', 130);\n    infix('*', 140);\n    infix('/', 140);\n    infix('%', 140);\n    infix('(', 160, function (left) {\n        var the_paren = token,\n            the_argument;\n        if (left.id !== 'function') {\n            left_check(left, the_paren);\n        }\n        the_paren.free = false;\n        the_paren.expression = [left];\n        if (left.identifier) {\n            if (left.new) {\n                if (\n                    left.id.charAt(0) > 'Z' ||\n                    left.id === 'Boolean' ||\n                    left.id === 'Number' ||\n                    left.id === 'String' ||\n                    (left.id === 'Symbol' && option.es6)\n                ) {\n                    warn('unexpected_a', left, 'new');\n                } else if (left.id === 'Function') {\n                    if (!option.eval) {\n                        warn('unexpected_a', left, 'new Function');\n                    }\n                } else if (left.id === 'Array') {\n                    warn('expected_a_b', left, '[]', 'new Array');\n                } else if (left.id === 'Object') {\n                    warn(\n                        'expected_a_b',\n                        left,\n                        'Object.create(null)',\n                        'new Object'\n                    );\n                }\n            } else {\n                if (\n                    left.id.charAt(0) >= 'A' &&\n                    left.id.charAt(0) <= 'Z' &&\n                    left.id !== 'Boolean' &&\n                    left.id !== 'Number' &&\n                    left.id !== 'String' &&\n                    left.id !== 'Symbol'\n                ) {\n                    warn(\n                        'expected_a_before_b',\n                        left,\n                        'new',\n                        artifact(left)\n                    );\n                }\n                if (functionage.arity === 'statement') {\n                    functionage.name.calls[left.id] = left;\n                }\n            }\n        }\n        if (next_token.id !== ')') {\n            (function next() {\n                the_argument = expression(10);\n                the_paren.expression.push(the_argument);\n                if (next_token.id === ',') {\n                    advance(',');\n                    return next();\n                }\n            }());\n        }\n        advance(')', the_paren);\n        if (the_paren.expression.length === 2) {\n            if (the_argument.wrapped === true) {\n                warn('unexpected_a', the_paren);\n            }\n            if (the_argument.id === '(') {\n                the_argument.wrapped = true;\n            }\n        }\n        return the_paren;\n    });\n    infix('.', 170, function (left) {\n        var the_token = token,\n            name = next_token;\n        if (\n            (left.id !== '(string)' || name.id !== 'indexOf') &&\n            (left.id !== '[' || (\n                name.id !== 'concat' && name.id !== 'forEach'\n            )) &&\n            (left.id !== '+' || name.id !== 'slice') &&\n            (left.id !== '(regexp)' || (\n                name.id !== 'exec' && name.id !== 'test'\n            ))\n        ) {\n            left_check(left, the_token);\n        }\n        if (!name.identifier) {\n            stop('expected_identifier_a');\n        }\n        advance();\n        survey(name);\n\n// The property name is not an expression.\n\n        the_token.name = name;\n        the_token.expression = left;\n        return the_token;\n    });\n    infix('[', 170, function (left) {\n        var the_token = token,\n            the_subscript = expression(0);\n        if (\n            the_subscript.id === '(string)' &&\n            rx_identifier.test(the_subscript.value)\n        ) {\n            warn('subscript_a', the_subscript);\n            survey(the_subscript);\n        } else if (the_subscript.id === '`') {\n            warn('unexpected_a', the_subscript);\n        }\n        left_check(left, the_token);\n        the_token.expression = [left, the_subscript];\n        advance(']');\n        return the_token;\n    });\n    infix('=>', 170, function (left) {\n        return stop('expected_a_before_b', left, '(', artifact(left));\n    });\n\n    function do_tick() {\n        var the_tick = token;\n        if (!option.es6) {\n            warn('es6', the_tick);\n        }\n        the_tick.value = [];\n        the_tick.expression = [];\n        if (next_token.id !== '`') {\n            (function part() {\n                advance('(string)');\n                the_tick.value.push(token);\n                if (next_token.id === '${') {\n                    advance('${');\n                    the_tick.expression.push(expression(0));\n                    advance('}');\n                    return part();\n                }\n            }());\n        }\n        advance('`');\n        return the_tick;\n    }\n\n    infix('`', 160, function (left) {\n        var the_tick = do_tick();\n        left_check(left, the_tick);\n        the_tick.expression = [left].concat(the_tick.expression);\n        return the_tick;\n    });\n\n    post('++');\n    post('--');\n    pre('++');\n    pre('--');\n\n    prefix('+');\n    prefix('-');\n    prefix('~');\n    prefix('!');\n    prefix('!!');\n    prefix('[', function () {\n        var the_token = token;\n        the_token.expression = [];\n        if (next_token.id !== ']') {\n            (function next() {\n                the_token.expression.push(expression(10));\n                if (next_token.id === ',') {\n                    advance(',');\n                    return next();\n                }\n            }());\n        }\n        advance(']');\n        return the_token;\n    });\n    prefix('=>', function () {\n        return stop('expected_a_before_b', token, '()', '=>');\n    });\n    prefix('new', function () {\n        var the_new = token;\n        next_token.new = true;\n        the_new.expression = expression(150);\n        if (the_new.expression.id !== '(') {\n            warn('expected_a_before_b', next_token, '()', artifact(next_token));\n        }\n        return the_new;\n    });\n    prefix('typeof');\n    prefix('void', function () {\n        var the_void = token;\n        warn('unexpected_a', the_void);\n        the_void.expression = expression(0);\n        return the_void;\n    });\n\n    function parameter(list, signature) {\n        var ellipsis = false,\n            param;\n        if (next_token.id === '{') {\n            if (!option.es6) {\n                warn('es6');\n            }\n            param = next_token;\n            param.names = [];\n            advance('{');\n            signature.push('{');\n            (function subparameter() {\n                var subparam = next_token;\n                if (!subparam.identifier) {\n                    return stop('expected_identifier_a');\n                }\n                survey(subparam);\n                advance();\n                signature.push(subparam.id);\n                if (next_token.id === ':') {\n                    advance(':');\n                    advance();\n                    token.label = subparam;\n                    subparam = token;\n                    if (!subparam.identifier) {\n                        return stop('expected_identifier_a');\n                    }\n                }\n                param.names.push(subparam);\n                if (next_token.id === ',') {\n                    advance(',');\n                    signature.push(\", \");\n                    return subparameter();\n                }\n            }());\n            list.push(param);\n            advance('}');\n            signature.push('}');\n            if (next_token.id === ',') {\n                advance(',');\n                signature.push(\", \");\n                return parameter(list, signature);\n            }\n        } else if (next_token.id === '[') {\n            if (!option.es6) {\n                warn('es6');\n            }\n            param = next_token;\n            param.names = [];\n            advance('[');\n            signature.push(\"[]\");\n            (function subparameter() {\n                var subparam = next_token;\n                if (!subparam.identifier) {\n                    return stop('expected_identifier_a');\n                }\n                advance();\n                param.names.push(subparam);\n                if (next_token.id === ',') {\n                    advance(',');\n                    return subparameter();\n                }\n            }());\n            list.push(param);\n            advance(']');\n            if (next_token.id === ',') {\n                advance(',');\n                signature.push(\", \");\n                return parameter(list, signature);\n            }\n        } else {\n            if (next_token.id === '...') {\n                if (!option.es6) {\n                    warn('es6');\n                }\n                ellipsis = true;\n                signature.push(\"...\");\n                advance('...');\n            }\n            if (!next_token.identifier) {\n                return stop('expected_identifier_a');\n            }\n            param = next_token;\n            list.push(param);\n            advance();\n            signature.push(param.id);\n            if (ellipsis) {\n                param.ellipsis = true;\n            } else {\n                if (next_token.id === '=') {\n                    if (!option.es6) {\n                        warn('es6');\n                    }\n                    advance('=');\n                    param.expression = expression(0);\n                }\n                if (next_token.id === ',') {\n                    advance(',');\n                    signature.push(\", \");\n                    return parameter(list, signature);\n                }\n            }\n        }\n    }\n\n    function parameter_list() {\n        var list = [], signature = ['('];\n        if (next_token.id !== ')' && next_token.id !== '(end)') {\n            parameter(list, signature);\n        }\n        advance(')');\n        signature.push(')');\n        return [list, signature.join('')];\n    }\n\n    function do_function(the_function) {\n        var name;\n        if (the_function === undefined) {\n            the_function = token;\n\n// A function statement must have a name that will be in the parent's scope.\n\n            if (the_function.arity === 'statement') {\n                if (!next_token.identifier) {\n                    return stop('expected_identifier_a', next_token);\n                }\n                name = next_token;\n                enroll(name, 'variable', true);\n                the_function.name = name;\n                name.init = true;\n                name.calls = empty();\n                advance();\n            } else if (name === undefined) {\n\n// A function expression may have an optional name.\n\n                if (next_token.identifier) {\n                    name = next_token;\n                    the_function.name = name;\n                    advance();\n                } else {\n                    the_function.name = anon;\n                }\n            }\n        } else {\n            name = the_function.name;\n        }\n        the_function.level = functionage.level + 1;\n        if (mega_mode) {\n            warn('unexpected_a', the_function);\n        }\n\n// Don't make functions in loops. It is inefficient, and it can lead to scoping\n// errors.\n\n        if (functionage.loop > 0) {\n            warn('function_in_loop', the_function);\n        }\n\n// Give the function properties for storing its names and for observing the\n// depth of loops and switches.\n\n        the_function.context = empty();\n        the_function.loop = 0;\n        the_function.switch = 0;\n\n// Push the current function context and establish a new one.\n\n        stack.push(functionage);\n        functions.push(the_function);\n        functionage = the_function;\n        if (the_function.arity !== 'statement' && name) {\n            enroll(name, 'function', true);\n            name.dead = false;\n            name.init = true;\n            name.used = 1;\n        }\n\n// Parse the parameter list.\n\n        advance('(');\n        token.free = false;\n        var pl = parameter_list();\n        functionage.parameters = pl[0];\n        functionage.signature = pl[1];\n        functionage.parameters.forEach(function enroll_parameter(name) {\n            if (name.identifier) {\n                enroll(name, 'parameter', false);\n            } else {\n                name.names.forEach(enroll_parameter);\n            }\n        });\n\n// The function's body is a block.\n\n        the_function.block = block('body');\n        if (the_function.arity === 'statement' && next_token.line === token.line) {\n            return stop('unexpected_a', next_token);\n        }\n        if (next_token.id === '.' || next_token.id === '[') {\n            warn('unexpected_a');\n        }\n\n// Restore the previous context.\n\n        functionage = stack.pop();\n        return the_function;\n    }\n\n    prefix('function', do_function);\n\n    function fart(pl) {\n        advance('=>');\n        var the_arrow = token;\n        the_arrow.arity = 'binary';\n        the_arrow.name = \"=>\";\n        the_arrow.level = functionage.level + 1;\n        functions.push(the_arrow);\n        if (functionage.loop > 0) {\n            warn('function_in_loop', the_arrow);\n        }\n\n// Give the function properties storing its names and for observing the depth\n// of loops and switches.\n\n        the_arrow.context = empty();\n        the_arrow.loop = 0;\n        the_arrow.switch = 0;\n\n// Push the current function context and establish a new one.\n\n        stack.push(functionage);\n        functionage = the_arrow;\n        the_arrow.parameters = pl[0];\n        the_arrow.signature = pl[1];\n        the_arrow.parameters.forEach(function (name) {\n            enroll(name, 'parameter', true);\n        });\n        if (!option.es6) {\n            warn('es6', the_arrow);\n        }\n        if (next_token.id === '{') {\n            warn('expected_a_b', the_arrow, \"function\", \"=>\");\n            the_arrow.block = block('body');\n        } else {\n            the_arrow.expression = expression(0);\n        }\n        functionage = stack.pop();\n        return the_arrow;\n    }\n\n    prefix('(', function () {\n        var the_paren = token,\n            the_value,\n            cadet = lookahead().id;\n\n// We can distinguish between a parameter list for => and a wrapped expression\n// with one token of lookahead.\n\n        if (\n            next_token.id === ')' ||\n            next_token.id === '...' ||\n            (next_token.identifier && (cadet === ',' || cadet === '='))\n        ) {\n            the_paren.free = false;\n            return fart(parameter_list());\n        }\n        the_paren.free = true;\n        the_value = expression(0);\n        if (the_value.wrapped === true) {\n            warn('unexpected_a', the_paren);\n        }\n        the_value.wrapped = true;\n        advance(')', the_paren);\n        if (next_token.id === \"=>\") {\n            if (the_value.arity !== 'variable') {\n                return stop('expected_identifier_a', the_value);\n            }\n            the_paren.expression = [the_value];\n            return fart([the_paren.expression, \"(\" + the_value.id + \")\"]);\n        }\n        return the_value;\n    });\n    prefix('`', do_tick);\n    prefix('{', function () {\n        var the_brace = token,\n            seen = empty();\n        the_brace.expression = [];\n        if (next_token.id !== '}') {\n            (function member() {\n                var extra = true,\n                    id,\n                    name = next_token,\n                    value;\n                advance();\n                if (\n                    (name.id === 'get' || name.id === 'set') &&\n                    next_token.identifier\n                ) {\n                    extra = name.id;\n                    name = next_token;\n                    advance();\n                }\n                id = survey(name);\n                if (seen[id] === true) {\n                    warn('duplicate_a', name);\n                } else if (seen[id] === 'get' && extra !== 'set') {\n                    warn('expected_a_before_b', name, 'set', artifact(name));\n                }\n                seen[id] = extra === 'get'\n                    ? 'get'\n                    : true;\n                if (name.identifier) {\n                    switch (next_token.id) {\n                    case '}':\n                    case ',':\n                        if (!option.es6) {\n                            warn('es6');\n                        } else if (extra !== true) {\n                            advance(':');\n                        }\n                        name.arity = 'variable';\n                        value = name;\n                        break;\n                    case '(':\n                        if (!option.es6) {\n                            warn('es6');\n                        }\n                        value = do_function({\n                            arity: 'unary',\n                            from: name.from,\n                            id: 'function',\n                            line: name.line,\n                            name: name,\n                            thru: name.from\n                        }, name);\n                        break;\n                    default:\n                        advance(':');\n                        value = expression(0);\n                    }\n                    value.label = name;\n                    if (typeof extra === 'string') {\n                        value.extra = extra;\n                    }\n                    the_brace.expression.push(value);\n                } else {\n                    advance(':');\n                    value = expression(0);\n                    value.label = name;\n                    the_brace.expression.push(value);\n                }\n                if (next_token.id === ',') {\n                    advance(',');\n                    return member();\n                }\n            }());\n        }\n        advance('}');\n        return the_brace;\n    });\n\n    stmt(';', function () {\n        warn('unexpected_a', token);\n        return token;\n    });\n    stmt('{', function () {\n        warn('naked_block', token);\n        return block('naked');\n    });\n    stmt('break', function () {\n        var the_break = token,\n            the_label;\n        if (functionage.loop < 1 && functionage.switch < 1) {\n            warn('unexpected_a', the_break);\n        }\n        the_break.disrupt = true;\n        if (next_token.identifier && token.line === next_token.line) {\n            the_label = functionage.context[next_token.id];\n            if (\n                the_label === undefined ||\n                the_label.role !== 'label' ||\n                the_label.dead\n            ) {\n                warn(the_label !== undefined && the_label.dead\n                    ? 'out_of_scope_a'\n                    : 'not_label_a');\n            } else {\n                the_label.used += 1;\n            }\n            the_break.label = next_token;\n            advance();\n        }\n        advance(';');\n        return the_break;\n    });\n\n    function do_var() {\n        var the_statement = token,\n            is_const = the_statement.id === 'const';\n        the_statement.names = [];\n\n// A program may use var or let, but not both, and let and const require\n// option.es6.\n\n        if (is_const) {\n            if (!option.es6) {\n                warn('es6', the_statement);\n            }\n        } else if (var_mode === undefined) {\n            var_mode = the_statement.id;\n            if (!option.es6 && var_mode !== 'var') {\n                warn('es6', the_statement);\n            }\n        } else if (the_statement.id !== var_mode) {\n            warn(\n                'expected_a_b',\n                the_statement,\n                var_mode,\n                the_statement.id\n            );\n        }\n\n// We don't expect to see variables created in switch statements.\n\n        if (functionage.switch > 0) {\n            warn('var_switch', the_statement);\n        }\n        if (functionage.loop > 0 && the_statement.id === 'var') {\n            warn('var_loop', the_statement);\n        }\n        (function next() {\n            if (next_token.id === '{' && the_statement.id !== 'var') {\n                var the_brace = next_token;\n                the_brace.names = [];\n                advance('{');\n                (function pair() {\n                    if (!next_token.identifier) {\n                        return stop('expected_identifier_a', next_token);\n                    }\n                    var name = next_token;\n                    survey(name);\n                    advance();\n                    if (next_token.id === ':') {\n                        advance(':');\n                        if (!next_token.identifier) {\n                            return stop('expected_identifier_a', next_token);\n                        }\n                        next_token.label = name;\n                        the_brace.names.push(next_token);\n                        enroll(next_token, 'variable', is_const);\n                        advance();\n                    } else {\n                        the_brace.names.push(name);\n                        enroll(name, 'variable', is_const);\n                    }\n                    if (next_token.id === ',') {\n                        advance(',');\n                        return pair();\n                    }\n                }());\n                advance('}');\n                advance('=');\n                the_brace.expression = expression(0);\n                the_statement.names.push(the_brace);\n            } else if (next_token.id === '[' && the_statement.id !== 'var') {\n                var the_bracket = next_token;\n                the_bracket.names = [];\n                advance('[');\n                (function element() {\n                    var ellipsis;\n                    if (next_token.id === '...') {\n                        ellipsis = true;\n                        advance('...');\n                    }\n                    if (!next_token.identifier) {\n                        return stop('expected_identifier_a', next_token);\n                    }\n                    var name = next_token;\n                    advance();\n                    the_bracket.names.push(name);\n                    enroll(name, 'variable', the_statement.id === 'const');\n                    if (ellipsis) {\n                        name.ellipsis = true;\n                    } else if (next_token.id === ',') {\n                        advance(',');\n                        return element();\n                    }\n                }());\n                advance(']');\n                advance('=');\n                the_bracket.expression = expression(0);\n                the_statement.names.push(the_bracket);\n            } else if (next_token.identifier) {\n                var name = next_token;\n                advance();\n                if (name.id === 'ignore') {\n                    warn('unexpected_a', name);\n                }\n                enroll(name, 'variable', is_const);\n                if (next_token.id === '=' || is_const) {\n                    advance('=');\n                    name.expression = expression(0);\n                    name.init = true;\n                }\n                the_statement.names.push(name);\n            } else {\n                return stop('expected_identifier_a', next_token);\n            }\n            if (next_token.id === ',') {\n                advance(',');\n                return next();\n            }\n        }());\n        the_statement.open =\n                the_statement.names.length > 1 &&\n                the_statement.line !== the_statement.names[1].line;\n        semicolon();\n        return the_statement;\n    }\n\n    stmt('const', do_var);\n    stmt('continue', function () {\n        var the_continue = token;\n        if (functionage.loop < 1) {\n            warn('unexpected_a', the_continue);\n        }\n        not_top_level(the_continue);\n        the_continue.disrupt = true;\n        warn('unexpected_a', the_continue);\n        advance(';');\n        return the_continue;\n    });\n    stmt('debugger', function () {\n        var the_debug = token;\n        if (!option.devel) {\n            warn('unexpected_a', the_debug);\n        }\n        semicolon();\n        return the_debug;\n    });\n    stmt('delete', function () {\n        var the_token = token,\n            the_value = expression(0);\n        if (\n            (the_value.id !== '.' && the_value.id !== '[') ||\n            the_value.arity !== 'binary'\n        ) {\n            stop('expected_a_b', the_value, '.', artifact(the_value));\n        }\n        the_token.expression = the_value;\n        semicolon();\n        return the_token;\n    });\n    stmt('do', function () {\n        var the_do = token;\n        not_top_level(the_do);\n        functionage.loop += 1;\n        the_do.block = block();\n        advance('while');\n        the_do.expression = condition();\n        semicolon();\n        if (the_do.block.disrupt === true) {\n            warn('weird_loop', the_do);\n        }\n        functionage.loop -= 1;\n        return the_do;\n    });\n    stmt('export', function () {\n        var the_export = token;\n        if (export_mode) {\n            warn('es6', the_export);\n        }\n        if (!option.es6) {\n            warn('es6', the_export);\n        }\n        if (typeof module_mode === 'object') {\n            warn('unexpected_directive_a', module_mode, module_mode.directive);\n        }\n        module_mode = true;\n        advance('default');\n        the_export.expression = expression(0);\n        semicolon();\n        return the_export;\n    });\n    stmt('for', function () {\n        var first,\n            the_for = token;\n        if (!option.for) {\n            warn('unexpected_a', the_for);\n        }\n        not_top_level(the_for);\n        functionage.loop += 1;\n        advance('(');\n        token.free = true;\n        if (next_token.id === ';') {\n            return stop('expected_a_b', the_for, 'while (', 'for (;');\n        }\n        first = expression(0);\n        if (first.id === 'in') {\n            if (first.expression[0].arity !== 'variable') {\n                warn('bad_assignment_a', first.expression[0]);\n            }\n            the_for.name = first.expression[0];\n            the_for.expression = first.expression[1];\n            warn('expected_a_b', the_for, 'Object.keys', 'for in');\n        } else {\n            the_for.initial = first;\n            advance(';');\n            the_for.expression = expression(0);\n            advance(';');\n            the_for.inc = expression(0);\n            if (the_for.inc.id === '++') {\n                warn('expected_a_b', the_for.inc, '+= 1', '++');\n            }\n        }\n        advance(')');\n        the_for.block = block();\n        if (the_for.block.disrupt === true) {\n            warn('weird_loop', the_for);\n        }\n        functionage.loop -= 1;\n        return the_for;\n    });\n    stmt('function', do_function);\n    stmt('if', function () {\n        var the_else,\n            the_if = token;\n        the_if.expression = condition();\n        the_if.block = block();\n        if (next_token.id === 'else') {\n            advance('else');\n            the_else = token;\n            the_if.else = next_token.id === 'if'\n                ? statement()\n                : block();\n            if (the_if.block.disrupt === true) {\n                if (the_if.else.disrupt === true) {\n                    the_if.disrupt = true;\n                } else {\n                    warn('unexpected_a', the_else);\n                }\n            }\n        }\n        return the_if;\n    });\n    stmt('import', function () {\n        var the_import = token;\n        if (!option.es6) {\n            warn('es6', the_import);\n        } else if (typeof module_mode === 'object') {\n            warn('unexpected_directive_a', module_mode, module_mode.directive);\n        }\n        module_mode = true;\n        if (!next_token.identifier) {\n            return stop('expected_identifier_a');\n        }\n        var name = next_token;\n        advance();\n        if (name.id === 'ignore') {\n            warn('unexpected_a', name);\n        }\n        enroll(name, 'variable', true);\n        advance('from');\n        advance('(string)');\n        the_import.import = token;\n        the_import.name = name;\n        if (!rx_identifier.test(token.value)) {\n            warn('bad_module_name_a', token);\n        }\n        imports.push(token.value);\n        semicolon();\n        return the_import;\n    });\n    stmt('let', do_var);\n    stmt('return', function () {\n        var the_return = token;\n        not_top_level(the_return);\n        the_return.disrupt = true;\n        if (next_token.id !== ';' && the_return.line === next_token.line) {\n            the_return.expression = expression(10);\n        }\n        advance(';');\n        return the_return;\n    });\n    stmt('switch', function () {\n        var stmts,\n            the_cases = [],\n            the_switch = token;\n        not_top_level(the_switch);\n        functionage.switch += 1;\n        advance('(');\n        token.free = true;\n        the_switch.expression = expression(0);\n        the_switch.block = the_cases;\n        advance(')');\n        advance('{');\n        (function major() {\n            var the_case = next_token;\n            the_case.arity = 'statement';\n            the_case.expression = [];\n            (function minor() {\n                advance('case');\n                token.switch = true;\n                the_case.expression.push(expression(0));\n                advance(':');\n                if (next_token.id === 'case') {\n                    return minor();\n                }\n            }());\n            stmts = statements();\n            the_case.block = stmts;\n            the_cases.push(the_case);\n            if (!stmts[stmts.length - 1].disrupt) {\n                warn(\n                    'expected_a_before_b',\n                    next_token,\n                    'break;',\n                    artifact(next_token)\n                );\n            }\n            if (next_token.id === 'case') {\n                return major();\n            }\n        }());\n        if (next_token.id === 'default') {\n            advance('default');\n            token.switch = true;\n            advance(':');\n            the_switch.else = statements();\n        }\n        advance('}', the_switch);\n        functionage.switch -= 1;\n        return the_switch;\n    });\n    stmt('throw', function () {\n        var the_throw = token;\n        the_throw.disrupt = true;\n        the_throw.expression = expression(10);\n        semicolon();\n        return the_throw;\n    });\n    stmt('try', function () {\n        var the_try = token,\n            the_catch;\n        the_try.block = block();\n        if (next_token.id === 'catch') {\n            var ignored = 'ignore';\n            the_catch = next_token;\n            the_try.catch = the_catch;\n            advance('catch');\n            advance('(');\n            if (!next_token.identifier) {\n                return stop('expected_identifier_a', next_token);\n            }\n            if (next_token.id !== 'ignore') {\n                ignored = undefined;\n                the_catch.name = next_token;\n                enroll(next_token, 'exception', true);\n            }\n            advance();\n            advance(')');\n            the_catch.block = block(ignored);\n        }\n        if (next_token.id === 'finally') {\n            advance('finally');\n            the_try.else = block();\n        }\n        return the_try;\n    });\n    stmt('var', do_var);\n    stmt('while', function () {\n        var the_while = token;\n        not_top_level(the_while);\n        functionage.loop += 1;\n        the_while.expression = condition();\n        the_while.block = block();\n        if (the_while.block.disrupt === true) {\n            warn('weird_loop', the_while);\n        }\n        functionage.loop -= 1;\n        return the_while;\n    });\n\n    ternary('?', ':');\n\n// Ambulation of the parse tree.\n\n    function action(when) {\n\n// Produce a function that will register task functions that will be called as\n// the tree is traversed.\n\n        return function (arity, id, task) {\n            var a_set = when[arity],\n                i_set;\n\n// The id parameter is optional. If excluded, the task will be applied to all\n// ids.\n\n            if (typeof id !== 'string') {\n                task = id;\n                id = '(all)';\n            }\n\n// If this arity has no registrations yet, then create a set object to hold\n// them.\n\n            if (a_set === undefined) {\n                a_set = empty();\n                when[arity] = a_set;\n            }\n\n// If this id has no registrations yet, then create a set array to hold them.\n\n            i_set = a_set[id];\n            if (i_set === undefined) {\n                i_set = [];\n                a_set[id] = i_set;\n            }\n\n// Register the task with the arity and the id.\n\n            i_set.push(task);\n        };\n    }\n\n    function amble(when) {\n\n// Produce a function that will act on the tasks registered by an action\n// function while walking the tree.\n\n        return function (the_token) {\n\n// Given a task set that was built by an action function, run all of the\n// relevant tasks on the token.\n\n            var a_set = when[the_token.arity],\n                i_set;\n\n// If there are tasks associated with the token's arity...\n\n            if (a_set !== undefined) {\n\n// If there are tasks associated with the token's id...\n\n                i_set = a_set[the_token.id];\n                if (i_set !== undefined) {\n                    i_set.forEach(function (task) {\n                        return task(the_token);\n                    });\n                }\n\n// If there are tasks for all ids.\n\n                i_set = a_set['(all)'];\n                if (i_set !== undefined) {\n                    i_set.forEach(function (task) {\n                        return task(the_token);\n                    });\n                }\n            }\n        };\n    }\n\n    var posts = empty(),\n        pres = empty(),\n        preaction = action(pres),\n        postaction = action(posts),\n        preamble = amble(pres),\n        postamble = amble(posts);\n\n    function walk_expression(thing) {\n        if (thing) {\n            if (Array.isArray(thing)) {\n                thing.forEach(walk_expression);\n            } else {\n                preamble(thing);\n                walk_expression(thing.expression);\n                if (thing.id === 'function') {\n                    walk_statement(thing.block);\n                }\n                switch (thing.arity) {\n                case 'post':\n                case 'pre':\n                    warn('unexpected_a', thing);\n                    break;\n                case 'statement':\n                case 'assignment':\n                    warn('unexpected_statement_a', thing);\n                    break;\n                }\n                postamble(thing);\n            }\n        }\n    }\n\n    function walk_statement(thing) {\n        if (thing) {\n            if (Array.isArray(thing)) {\n                thing.forEach(walk_statement);\n            } else {\n                preamble(thing);\n                walk_expression(thing.expression);\n                switch (thing.arity) {\n                case 'statement':\n                case 'assignment':\n                    break;\n                case 'binary':\n                    if (thing.id !== '(') {\n                        warn('unexpected_expression_a', thing);\n                    }\n                    break;\n                default:\n                    warn('unexpected_expression_a', thing);\n                }\n                walk_statement(thing.block);\n                walk_statement(thing.else);\n                postamble(thing);\n            }\n        }\n    }\n\n    function lookup(thing) {\n        if (thing.arity === 'variable') {\n\n// Look up the variable in the current context.\n\n            var the_variable = functionage.context[thing.id];\n\n// If it isn't local, search all the other contexts. If there are name\n// collisions, take the most recent.\n\n            if (the_variable === undefined) {\n                stack.forEach(function (outer) {\n                    var a_variable = outer.context[thing.id];\n                    if (\n                        a_variable !== undefined &&\n                        a_variable.role !== 'label'\n                    ) {\n                        the_variable = a_variable;\n                    }\n                });\n\n// If it isn't in any of those either, perhaps it is a predefined global.\n// If so, add it to the global context.\n\n                if (the_variable === undefined) {\n                    if (declared_globals[thing.id] === undefined) {\n                        warn('undeclared_a', thing);\n                        return;\n                    }\n                    the_variable = {\n                        dead: false,\n                        function: global,\n                        id: thing.id,\n                        init: true,\n                        role: 'variable',\n                        used: 0,\n                        writable: false\n                    };\n                    global.context[thing.id] = the_variable;\n                }\n                the_variable.closure = true;\n                functionage.context[thing.id] = the_variable;\n            } else if (the_variable.role === 'label') {\n                warn('label_a', thing);\n            }\n            if (the_variable.dead && the_variable.function === functionage) {\n                warn('out_of_scope_a', thing);\n            }\n            return the_variable;\n        }\n    }\n\n    function preaction_function(thing) {\n        if (thing.arity === 'statement' && blockage.body !== true) {\n            warn('unexpected_a', thing);\n        }\n        stack.push(functionage);\n        block_stack.push(blockage);\n        functionage = thing;\n        blockage = thing;\n        thing.live = [];\n        if (typeof thing.name === 'object') {\n            thing.name.dead = false;\n            thing.name.init = true;\n        }\n        switch (thing.extra) {\n        case 'get':\n            if (thing.parameters.length !== 0) {\n                warn('bad_get', thing);\n            }\n            break;\n        case 'set':\n            if (thing.parameters.length !== 1) {\n                warn('bad_set', thing);\n            }\n            break;\n        }\n        thing.parameters.forEach(function (name) {\n            walk_expression(name.expression);\n            if (name.id === '{' || name.id === '[') {\n                name.names.forEach(subactivate);\n            } else {\n                name.dead = false;\n                name.init = true;\n            }\n        });\n    }\n\n    function bitwise_check(thing) {\n        if (!option.bitwise && bitwiseop[thing.id] === true) {\n            warn('unexpected_a', thing);\n        }\n    }\n\n    function pop_block() {\n        blockage.live.forEach(function (name) {\n            name.dead = true;\n        });\n        delete blockage.live;\n        blockage = block_stack.pop();\n    }\n\n    function subactivate(name) {\n        name.init = true;\n        name.dead = false;\n        blockage.live.push(name);\n    }\n\n    function activate(name) {\n        if (name.expression !== undefined) {\n            walk_expression(name.expression);\n            if (name.id === '{' || name.id === '[') {\n                name.names.forEach(subactivate);\n            } else {\n                name.init = true;\n            }\n        }\n        name.dead = false;\n        blockage.live.push(name);\n    }\n\n    function action_var(thing) {\n        thing.names.forEach(activate);\n    }\n\n    preaction('assignment', bitwise_check);\n    preaction('binary', bitwise_check);\n    preaction('binary', function (thing) {\n        if (relationop[thing.id] === true) {\n            if (\n                thing.expression[0].id === 'NaN' ||\n                thing.expression[1].id === 'NaN'\n            ) {\n                warn('isNaN', thing);\n            } else if (thing.expression[0].id === 'typeof') {\n                if (thing.expression[1].id !== '(string)') {\n                    if (thing.expression[1].id !== 'typeof') {\n                        warn('expected_string_a', expression[1]);\n                    }\n                } else {\n                    var value = thing.expression[1].value;\n                    if (value === 'symbol') {\n                        if (!option.es6) {\n                            warn('es6', thing.expression[1], value);\n                        }\n                    } else if (value === 'null' || value === 'undefined') {\n                        warn('unexpected_typeof_a', thing.expression[1], value);\n                    } else if (\n                        value !== 'boolean' &&\n                        value !== 'function' &&\n                        value !== 'number' &&\n                        value !== 'object' &&\n                        value !== 'string'\n                    ) {\n                        warn('expected_type_string_a', expression[1], value);\n                    }\n                }\n            }\n        }\n    });\n    preaction('binary', '==', function (thing) {\n        warn('expected_a_b', thing, '===', '==');\n    });\n    preaction('binary', '!=', function (thing) {\n        warn('expected_a_b', thing, '!==', '!=');\n    });\n    preaction('binary', '=>', preaction_function);\n    preaction('binary', '||', function (thing) {\n        thing.expression.forEach(function (thang) {\n            if (thang.id === '&&' && !thang.wrapped) {\n                warn('and', thang);\n            }\n        });\n    });\n    preaction('binary', '(', function (thing) {\n        var left = thing.expression[0];\n        if (\n            left.identifier &&\n            functionage.context[left.id] === undefined &&\n            typeof functionage.name === 'object'\n        ) {\n            var parent = functionage.name.function;\n            if (parent) {\n                var left_variable = parent.context[left.id];\n                if (\n                    left_variable !== undefined &&\n                    left_variable.dead &&\n                    left_variable.function === parent &&\n                    left_variable.calls !== undefined &&\n                    left_variable.calls[functionage.name.id] !== undefined\n                ) {\n                    left_variable.dead = false;\n                }\n            }\n        }\n    });\n    preaction('binary', 'in', function (thing) {\n        warn('infix_in', thing);\n    });\n    preaction('statement', '{', function (thing) {\n        block_stack.push(blockage);\n        blockage = thing;\n        thing.live = [];\n    });\n    preaction('statement', 'for', function (thing) {\n        if (thing.name !== undefined) {\n            var the_variable = lookup(thing.name);\n            if (the_variable !== undefined) {\n                the_variable.init = true;\n                if (!the_variable.writable) {\n                    warn('bad_assignment_a', thing.name);\n                }\n            }\n        }\n        walk_statement(thing.initial);\n    });\n    preaction('statement', 'function', preaction_function);\n    preaction('unary', '~', bitwise_check);\n    preaction('unary', 'function', preaction_function);\n    preaction('variable', function (thing) {\n        var the_variable = lookup(thing);\n        if (the_variable !== undefined) {\n            thing.variable = the_variable;\n            the_variable.used += 1;\n        }\n    });\n\n    function init_variable(name) {\n        var the_variable = lookup(name);\n        if (the_variable !== undefined) {\n            if (the_variable.writable) {\n                the_variable.init = true;\n                return;\n            }\n        }\n        warn('bad_assignment_a', name);\n    }\n\n    postaction('assignment', function (thing) {\n\n// Assignment using = sets the init property of a variable. No other assignment\n// operator can do this. A = token keeps that variable (or array of variables\n// in case of destructuring) in its name property.\n\n        if (thing.id === '=') {\n            if (thing.names !== undefined) {\n                if (Array.isArray(thing.names)) {\n                    thing.names.forEach(init_variable);\n                } else {\n                    init_variable(thing.names);\n                }\n            }\n        } else {\n            var lvalue = thing.expression[0];\n            if (lvalue.arity === 'variable') {\n                if (lvalue.variable.writable !== true) {\n                    warn('bad_assignment_a', lvalue);\n                }\n            }\n        }\n    });\n\n    function postaction_function(thing) {\n        delete functionage.loop;\n        delete functionage.switch;\n        functionage = stack.pop();\n        if (thing.wrapped) {\n            warn('unexpected_parens', thing);\n        }\n        return pop_block();\n    }\n\n    function is_weird(thing) {\n        return (\n            thing.id === '(regexp)' ||\n            thing.id === '{' ||\n            thing.id === '=>' ||\n            thing.id === 'function' ||\n            (thing.id === '[' && thing.arity === 'unary')\n        );\n    }\n\n    function are_similar(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (Array.isArray(a)) {\n            return (\n                Array.isArray(b) &&\n                a.length === b.length &&\n                a.every(function (value, index) {\n                    return are_similar(value, b[index]);\n                })\n            );\n        }\n        if (Array.isArray(b)) {\n            return false;\n        }\n        if (a.id === '(number)' && b.id === '(number)') {\n            return a.value === b.value;\n        }\n        var a_string, b_string;\n        if (a.id === '(string)') {\n            a_string = a.value;\n        } else if (a.id === '`' && a.constant) {\n            a_string = a.value[0];\n        }\n        if (b.id === '(string)') {\n            b_string = b.value;\n        } else if (b.id === '`' && b.constant) {\n            b_string = b.value[0];\n        }\n        if (typeof a_string === 'string') {\n            return a_string === b_string;\n        }\n        if (is_weird(a) || is_weird(b)) {\n            return false;\n        }\n        if (a.arity === b.arity && a.id === b.id) {\n            if (a.id === '.') {\n                return are_similar(a.expression, b.expression) &&\n                        are_similar(a.name, b.name);\n            }\n            switch (a.arity) {\n            case 'unary':\n                return are_similar(a.expression, b.expression);\n            case 'binary':\n                return are_similar(a.expression[0], b.expression[0]) &&\n                        are_similar(a.expression[1], b.expression[1]);\n            case 'ternary':\n                return are_similar(a.expression[0], b.expression[0]) &&\n                        are_similar(a.expression[1], b.expression[1]) &&\n                        are_similar(a.expression[2], b.expression[2]);\n            case 'function':\n            case 'regexp':\n                return false;\n            default:\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    postaction('binary', function (thing) {\n        if (relationop[thing.id]) {\n            if (\n                is_weird(thing.expression[0]) ||\n                is_weird(thing.expression[1]) ||\n                are_similar(thing.expression[0], thing.expression[1]) ||\n                (\n                    thing.expression[0].constant === true &&\n                    thing.expression[1].constant === true\n                )\n            ) {\n                warn('weird_relation_a', thing);\n            }\n        }\n        switch (thing.id) {\n        case '=>':\n        case '(':\n        case '.':\n            break;\n        default:\n            if (\n                thing.expression[0].constant === true &&\n                thing.expression[1].constant === true\n            ) {\n                thing.constant = true;\n            }\n        }\n    });\n    postaction('binary', '&&', function (thing) {\n        if (\n            is_weird(thing.expression[0]) ||\n            are_similar(thing.expression[0], thing.expression[1]) ||\n            thing.expression[0].constant === true ||\n            thing.expression[1].constant === true\n        ) {\n            warn('weird_condition_a', thing);\n        }\n    });\n    postaction('binary', '||', function (thing) {\n        if (\n            is_weird(thing.expression[0]) ||\n            are_similar(thing.expression[0], thing.expression[1]) ||\n            thing.expression[0].constant === true\n        ) {\n            warn('weird_condition_a', thing);\n        }\n    });\n    postaction('binary', '=>', postaction_function);\n    postaction('binary', '(', function (thing) {\n        if (!thing.wrapped && thing.expression[0].id === 'function') {\n            warn('wrap_immediate', thing);\n        }\n    });\n    postaction('binary', '[', function (thing) {\n        if (is_weird(thing.expression[1])) {\n            warn('weird_expression_a', thing.expression[1]);\n        }\n    });\n    postaction('statement', '{', pop_block);\n    postaction('statement', 'const', action_var);\n    postaction('statement', 'export', top_level_only);\n    postaction('statement', 'for', function (thing) {\n        walk_statement(thing.inc);\n    });\n    postaction('statement', 'function', postaction_function);\n    postaction('statement', 'import', function (the_thing) {\n        var name = the_thing.name;\n        name.init = true;\n        name.dead = false;\n        blockage.live.push(name);\n        return top_level_only(the_thing);\n    });\n    postaction('statement', 'let', action_var);\n    postaction('statement', 'try', function (thing) {\n        if (thing.catch !== undefined) {\n            var the_name = thing.catch.name;\n            if (the_name !== undefined) {\n                var the_variable = functionage.context[the_name.id];\n                the_variable.dead = false;\n                the_variable.init = true;\n            }\n            walk_statement(thing.catch.block);\n        }\n    });\n    postaction('statement', 'var', action_var);\n    postaction('ternary', function (thing) {\n        if (\n            is_weird(thing.expression[0]) ||\n            thing.expression[0].constant === true ||\n            are_similar(thing.expression[1], thing.expression[2])\n        ) {\n            warn('unexpected_a', thing);\n        } else if (are_similar(thing.expression[0], thing.expression[1])) {\n            warn('expected_a_b', thing, '||', '?');\n        } else if (are_similar(thing.expression[0], thing.expression[2])) {\n            warn('expected_a_b', thing, '&&', '?');\n        } else if (\n            thing.expression[1].id === 'true' &&\n            thing.expression[2].id === 'false'\n        ) {\n            warn('expected_a_b', thing, '!!', '?');\n        } else if (\n            thing.expression[1].id === 'false' &&\n            thing.expression[2].id === 'true'\n        ) {\n            warn('expected_a_b', thing, '!', '?');\n        }\n    });\n    postaction('unary', function (thing) {\n        switch (thing.id) {\n        case '[':\n        case '{':\n        case 'function':\n        case 'new':\n            break;\n        case '`':\n            if (thing.expression.every(function (thing) {\n                return thing.constant;\n            })) {\n                thing.constant = true;\n            }\n            break;\n        default:\n            if (thing.expression.constant === true) {\n                thing.constant = true;\n            }\n        }\n    });\n    postaction('unary', 'function', postaction_function);\n\n    function delve(the_function) {\n        Object.keys(the_function.context).forEach(function (id) {\n            if (id !== 'ignore') {\n                var name = the_function.context[id];\n                if (name.function === the_function) {\n                    if (name.used === 0) {\n                        warn('unused_a', name);\n                    } else if (!name.init) {\n                        warn('uninitialized_a', name);\n                    }\n                }\n            }\n        });\n    }\n\n    function uninitialized_and_unused() {\n\n// Delve into the functions looking for variables that were not initialized\n// or used. If the file imports or exports, then its global object is also\n// delved.\n\n        if (module_mode === true || option.node) {\n            delve(global);\n        }\n        functions.forEach(delve);\n    }\n\n// Go through the token list, looking at usage of whitespace.\n\n    function whitage() {\n        var closer = '(end)',\n            free = false,\n            left = global,\n            margin = 0,\n            nr_comments_skipped = 0,\n            open = true,\n            qmark = '',\n            result,\n            right;\n\n        function at_margin(fit) {\n            if (right.from !== margin + fit) {\n                warn(\n                    'expected_a_at_b_c',\n                    right,\n                    artifact(right),\n                    margin + fit,\n                    artifact_column(right)\n                );\n            }\n        }\n\n        function expected_at(at) {\n            warn(\n                'expected_a_at_b_c',\n                right,\n                artifact(right),\n                at,\n                artifact_column(right)\n            );\n        }\n\n        function no_space_only() {\n            if (left.line !== right.line || left.thru !== right.from) {\n                warn(\n                    'unexpected_space_a_b',\n                    right,\n                    artifact(left),\n                    artifact(right)\n                );\n            }\n        }\n\n        function no_space() {\n            if (left.line === right.line) {\n                if (left.thru !== right.from && nr_comments_skipped === 0) {\n                    warn(\n                        'unexpected_space_a_b',\n                        right,\n                        artifact(left),\n                        artifact(right)\n                    );\n                }\n            } else {\n                if (open) {\n                    var at = free\n                        ? margin\n                        : margin + 8;\n                    if (right.from < at) {\n                        expected_at(at);\n                    }\n                } else {\n                    if (right.from !== margin + 8) {\n                        expected_at(margin + 8);\n                    }\n                }\n            }\n        }\n\n        function one_space_only() {\n            if (left.line !== right.line || left.thru + 1 !== right.from) {\n                warn(\n                    'expected_space_a_b',\n                    right,\n                    artifact(left),\n                    artifact(right)\n                );\n            }\n        }\n\n        function one_space() {\n            if (left.line === right.line) {\n                if (left.thru + 1 !== right.from && nr_comments_skipped === 0) {\n                    warn(\n                        'expected_space_a_b',\n                        right,\n                        artifact(left),\n                        artifact(right)\n                    );\n                }\n            } else {\n                if (open) {\n                    var at = free\n                        ? margin\n                        : margin + 8;\n                    if (right.from < at) {\n                        expected_at(at);\n                    }\n                } else {\n                    if (right.from !== margin + 8) {\n                        expected_at(margin + 8);\n                    }\n                }\n            }\n        }\n\n        function unqmark() {\n\n// Undo the effects of dangling nested ternary operators.\n\n            var level = qmark.length;\n            if (level > 0) {\n                margin -= level * 4;\n            }\n            qmark = '';\n        }\n\n        stack = [];\n        tokens.forEach(function (the_token) {\n            right = the_token;\n            if (right.id === '(comment)' || right.id === '(end)') {\n                nr_comments_skipped += 1;\n            } else {\n\n// If left is an opener and right is not the closer, then push the previous\n// state. If the token following the opener is on the next line, then this is\n// an open form. If the tokens are on different lines, then it is a closed for.\n// Open form is more readable, with each item (statement, argument, parameter,\n// etc) starting on its own line. Closed form is more compact. Statement blocks\n// are always in open form.\n\n                var new_closer = opener[left.id];\n                if (typeof new_closer === 'string') {\n                    if (new_closer !== right.id) {\n                        stack.push({\n                            closer: closer,\n                            free: free,\n                            margin: margin,\n                            open: open,\n                            qmark: qmark\n                        });\n                        qmark = '';\n                        closer = new_closer;\n                        if (left.line !== right.line) {\n                            free = (closer === ')' && left.free) || closer === ']';\n                            open = true;\n                            margin += 4;\n                            if (right.role === 'label') {\n                                if (right.from !== 0) {\n                                    expected_at(0);\n                                }\n                            } else if (right.switch) {\n                                unqmark();\n                                at_margin(-4);\n                            } else {\n                                at_margin(0);\n                            }\n                        } else {\n                            if (right.statement || right.role === 'label') {\n                                warn(\n                                    'expected_line_break_a_b',\n                                    right,\n                                    artifact(left),\n                                    artifact(right)\n                                );\n                            }\n                            free = false;\n                            open = false;\n                            no_space_only();\n                        }\n                    } else {\n\n// If left and right are opener and closer, then the placement of right depends\n// on the openness. Illegal pairs (like {]) have already been detected.\n\n                        if (left.line === right.line) {\n                            no_space();\n                        } else {\n                            at_margin(0);\n                        }\n                    }\n                } else {\n\n// If right is a closer, then pop the previous state,\n\n                    if (right.id === closer) {\n                        var previous = stack.pop();\n                        margin = previous.margin;\n                        if (open && right.id !== ';') {\n                            at_margin(0);\n                        } else {\n                            no_space_only();\n                        }\n                        closer = previous.closer;\n                        free = previous.free;\n                        open = previous.open;\n                        qmark = previous.qmark;\n                    } else {\n\n// Left is not an opener, and right is not a closer. The nature of left and\n// right will determine the space between them.\n\n// If left is , or ; or right is a statement then if open, right must go at the\n// margin, or if closed, a space before.\n\n\n                        if (right.switch) {\n                            unqmark();\n                            at_margin(-4);\n                        } else if (right.role === 'label') {\n                            if (right.from !== 0) {\n                                expected_at(0);\n                            }\n                        } else if (left.id === ',') {\n                            unqmark();\n                            if (!open || (free && left.line === right.line)) {\n                                one_space();\n                            } else {\n                                at_margin(0);\n                            }\n\n// If right is a ternary operator, line it up on the margin. Use qmark to\n// deal with nested ternary operators.\n\n                        } else if (right.arity === 'ternary') {\n                            if (right.id === '?') {\n                                margin += 4;\n                                qmark += '?';\n                            } else {\n                                result = qmark.match(rx_colons);\n                                qmark = result[1] + ':';\n                                margin -= 4 * result[2].length;\n                            }\n                            at_margin(0);\n                        } else if (\n                            left.id === '...' ||\n                            right.id === ',' ||\n                            right.id === ';' ||\n                            right.id === ':' ||\n                            (right.arity === 'binary' && (\n                                right.id === '(' ||\n                                right.id === '['\n                            ))\n                        ) {\n                            no_space_only();\n                        } else if (left.id === '.') {\n                            no_space();\n                        } else if (right.id === '.') {\n                            if (left.line === right.line) {\n                                no_space();\n                            } else {\n                                if (!rx_dot.test(qmark)) {\n                                    qmark += '.';\n                                    margin += 4;\n                                }\n                                at_margin(0);\n                            }\n                        } else if (left.id === ';') {\n                            unqmark();\n                            if (open) {\n                                at_margin(0);\n                            } else {\n                                one_space();\n                            }\n                        } else if (\n                            left.arity === 'ternary' ||\n                            left.id === 'case' ||\n                            left.id === 'catch' ||\n                            left.id === 'else' ||\n                            left.id === 'finally' ||\n                            left.id === 'while' ||\n                            right.id === 'catch' ||\n                            right.id === 'else' ||\n                            right.id === 'finally' ||\n                            (right.id === 'while' && !right.statement) ||\n                            (left.id === ')' && right.id === '{')\n                        ) {\n                            one_space_only();\n                        } else if (right.statement === true) {\n                            if (open) {\n                                at_margin(0);\n                            } else {\n                                one_space();\n                            }\n                        } else if (\n                            left.id === 'var' ||\n                            left.id === 'const' ||\n                            left.id === 'let'\n                        ) {\n                            stack.push({\n                                closer: closer,\n                                free: free,\n                                margin: margin,\n                                open: open,\n                                qmark: qmark\n                            });\n                            closer = ';';\n                            free = false;\n                            open = left.open;\n                            qmark = '';\n                            if (open) {\n                                margin = margin + 4;\n                                at_margin(0);\n                            } else {\n                                one_space_only();\n                            }\n                        } else if (\n\n// There is a space between left and right.\n\n                            spaceop[left.id] === true ||\n                            spaceop[right.id] === true ||\n                            (\n                                left.arity === 'binary' &&\n                                (left.id === '+' || left.id === '-')\n                            ) ||\n                            (\n                                right.arity === 'binary' &&\n                                (right.id === '+' || right.id === '-')\n                            ) ||\n                            left.id === 'function' ||\n                            left.id === ':' ||\n                            (\n                                (\n                                    left.identifier ||\n                                    left.id === '(string)' ||\n                                    left.id === '(number)'\n                                ) &&\n                                (\n                                    right.identifier ||\n                                    right.id === '(string)' ||\n                                    right.id === '(number)'\n                                )\n                            ) ||\n                            (left.arity === 'statement' && right.id !== ';')\n                        ) {\n                            one_space();\n                        } else if (left.arity === 'unary') {\n                            no_space_only();\n                        }\n                    }\n                }\n                nr_comments_skipped = 0;\n                delete left.calls;\n                delete left.dead;\n                delete left.free;\n                delete left.init;\n                delete left.open;\n                delete left.used;\n                left = right;\n            }\n        });\n    }\n\n// The jslint function itself.\n\n    return function jslint(source, option_object, global_array) {\n        try {\n            warnings = [];\n            option = option_object || empty();\n            block_stack = [];\n            declared_globals = empty();\n            directive_mode = true;\n            early_stop = true;\n            export_mode = true;\n            fudge = option.fudge\n                ? 1\n                : 0;\n            functions = [];\n            global = {\n                id: '(global)',\n                body: true,\n                context: empty(),\n                from: 0,\n                level: 0,\n                line: 0,\n                live: [],\n                loop: 0,\n                switch: 0,\n                thru: 0\n            };\n            blockage = global;\n            functionage = global;\n            imports = [];\n            json_mode = false;\n            mega_mode = false;\n            module_mode = false;\n            next_token = global;\n            property = empty();\n            stack = [];\n            tenure = undefined;\n            token = global;\n            token_nr = 0;\n            var_mode = undefined;\n            populate(declared_globals, standard, false);\n            if (global_array !== undefined) {\n                populate(declared_globals, global_array, false);\n            }\n            Object.keys(option).forEach(function (name) {\n                if (option[name] === true) {\n                    var allowed = allowed_option[name];\n                    if (Array.isArray(allowed)) {\n                        populate(declared_globals, allowed, false);\n                    }\n                }\n            });\n            tokenize(source);\n            advance();\n            if (tokens[0].id === '{' || tokens[0].id === '[') {\n                json_mode = true;\n                tree = json_value();\n                advance('(end)');\n            } else {\n\n// Because browsers encourage combining of script files, the first token might\n// be a semicolon to defend against a missing semicolon in the preceding file.\n\n                if (option.browser) {\n                    if (next_token.id === ';') {\n                        advance(';');\n                    }\n                } else {\n\n// If we are not in a browser, then the file form of strict pragma may be used.\n\n                    if (\n                        next_token.id === '(string)' &&\n                        next_token.value === 'use strict'\n                    ) {\n                        advance('(string)');\n                        advance(';');\n                        global.strict = true;\n                    }\n                }\n                tree = statements();\n                advance('(end)');\n                functionage = global;\n                walk_statement(tree);\n                uninitialized_and_unused();\n                if (!option.white) {\n                    whitage();\n                }\n            }\n            early_stop = false;\n        } catch (e) {\n            if (e.name !== 'JSLintError') {\n                warnings.push(e);\n            }\n        }\n        return {\n            functions: functions,\n            global: global,\n            id: \"(JSLint)\",\n            imports: imports,\n            json: json_mode,\n            lines: lines,\n            module: module_mode === true,\n            ok: warnings.length === 0 && !early_stop,\n            option: option,\n            property: property,\n            stop: early_stop,\n            tokens: tokens,\n            tree: tree,\n            warnings: warnings.sort(function (a, b) {\n                return a.line - b.line || a.column - b.column;\n            }),\n            edition: \"2015-05-08 BETA\"\n        };\n    };\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jslint-2016-05-13.js":"// jslint.js\n// 2016-05-13\n// Copyright (c) 2015 Douglas Crockford  (www.JSLint.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// The Software shall be used for Good, not Evil.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// jslint is a function that takes 3 arguments:\n\n//      source          A text to analyze, a string or an array of strings.\n//      option_object   An object whose keys correspond to option names.\n//      global_array    An array of strings containing global variables that\n//                      the file is allowed readonly access.\n\n// jslint returns an object containing its results. The object contains a lot\n// of valuable information. It can be used to generate reports. The object\n// contains:\n\n//      edition: the version of JSLint that did the analysis.\n//      functions: an array of objects that represent all of the functions\n//              declared in the file.\n//      global: an object representing the global object. Its .context property\n//              is an object containing a property for each global variable.\n//      id: \"(JSLint)\"\n//      imports: an array of strings representing each of the imports.\n//      json: true if the file is a JSON text.\n//      lines: an array of strings, the source.\n//      module: true if an import or export statement was used.\n//      ok: true if no warnings were generated. This is what you want.\n//      option: the option argument.\n//      property: a property object.\n//      stop: true if JSLint was unable to finish. You don't want this.\n//      tokens: an array of objects representing the tokens in the file.\n//      tree: the token objects arranged in a tree.\n//      warnings: an array of warning objects. A warning object can contain:\n//          name: \"JSLintError\"\n//          column: A column number in the file.\n//          line: A line number in the file.\n//          code: A warning code string.\n//          message: The warning message string.\n//          a: Exhibit A.\n//          b: Exhibit B.\n//          c: Exhibit C.\n//          d: Exhibit D.\n\n// jslint works in several phases. In any of these phases, errors might be\n// found. Sometimes JSLint is able to recover from an error and continue\n// parsing. In some cases, it cannot and will stop early. If that should happen,\n// repair your code and try again.\n\n// Phases:\n\n//      1. If the source is a single string, split it into an array of strings.\n//      2. Turn the source into an array of tokens.\n//      3. Furcate the tokens into a parse tree.\n//      4. Walk the tree, traversing all of the nodes of the tree. It is a\n//          recursive traversal. Each node may be processed on the way down\n//          (preaction) and on the way up (postaction).\n//      5. Check the whitespace between the tokens.\n\n// jslint can also examine JSON text. It decides that a file is JSON text if\n// the first token is \"[\" or \"{\". Processing of JSON text is much simpler than\n// the processing of JavaScript programs. Only the first three phases are\n// required.\n\n// WARNING: JSLint will hurt your feelings.\n\n/*property\n    a, and, arity, b, bad_assignment_a, bad_directive_a, bad_get,\n    bad_module_name_a, bad_option_a, bad_property_a, bad_set, bitwise, block,\n    body, browser, c, calls, catch, charAt, charCodeAt, closer, closure, code,\n    column, concat, constant, context, couch, create, d, dead, devel,\n    directive, directives, disrupt, dot, duplicate_a, edition, ellipsis, else,\n    empty_block, es6, eval, every, expected_a_at_b_c, expected_a_b,\n    expected_a_b_from_c_d, expected_a_before_b, expected_digits_after_a,\n    expected_four_digits, expected_identifier_a, expected_line_break_a_b,\n    expected_regexp_factor_a, expected_space_a_b, expected_statements_a,\n    expected_string_a, expected_type_string_a, expression, extra, flag, for,\n    forEach, free, from, fud, fudge, function, function_in_loop, functions, g,\n    global, i, id, identifier, import, imports, inc, indexOf, infix_in, init,\n    initial, isArray, isNaN, join, json, keys, label, label_a, lbp, led,\n    length, level, line, lines, live, loop, m, margin, match, maxerr, maxlen,\n    message, misplaced_a, misplaced_directive_a, missing_browser, module,\n    multivar, naked_block, name, names, nested_comment, new, node, not_label_a,\n    nud, ok, open, option, out_of_scope_a, parameters, pop, property, push,\n    qmark, quote, redefinition_a_b, replace, reserved_a, role, search,\n    signature, slice, some, sort, split, statement, stop, strict, subscript_a,\n    switch, test, this, thru, toString, todo_comment, tokens, too_long,\n    too_many, too_many_digits, tree, type, u, unclosed_comment, unclosed_mega,\n    unclosed_string, undeclared_a, unexpected_a, unexpected_a_after_b,\n    unexpected_at_top_level_a, unexpected_char_a, unexpected_comment,\n    unexpected_directive_a, unexpected_expression_a, unexpected_label_a,\n    unexpected_parens, unexpected_space_a_b, unexpected_statement_a,\n    unexpected_trailing_space, unexpected_typeof_a, uninitialized_a,\n    unreachable_a, unregistered_property_a, unsafe, unused_a, use_spaces, used,\n    value, var_loop, var_switch, variable, warning, warnings,\n    weird_condition_a, weird_expression_a, weird_loop, weird_relation_a, white,\n    wrap_assignment, wrap_condition, wrap_immediate, wrap_regexp, wrap_unary,\n    wrapped, writable, y\n*/\n\nvar jslint = (function JSLint() {\n    \"use strict\";\n\n    function empty() {\n\n// The empty function produces a new empty object that inherits nothing. This is\n// much better than {} because confusions around accidental method names like\n// \"constructor\" are completely avoided.\n\n        return Object.create(null);\n    }\n\n    function populate(object, array, value) {\n\n// Augment an object by taking property names from an array of strings.\n\n        array.forEach(function (name) {\n            object[name] = value;\n        });\n    }\n\n    var allowed_option = {\n\n// These are the options that are recognized in the option object or that may\n// appear in a /*jslint*/ directive. Most options will have a boolean value,\n// usually true. Some options will also predefine some number of global\n// variables.\n\n        bitwise: true,\n        browser: [\n            \"Audio\", \"clearInterval\", \"clearTimeout\", \"document\", \"event\",\n            \"FormData\", \"history\", \"Image\", \"localStorage\", \"location\", \"name\",\n            \"navigator\", \"Option\", \"screen\", \"sessionStorage\", \"setInterval\",\n            \"setTimeout\", \"Storage\", \"XMLHttpRequest\"\n        ],\n        couch: [\n            \"emit\", \"getRow\", \"isArray\", \"log\", \"provides\", \"registerType\",\n            \"require\", \"send\", \"start\", \"sum\", \"toJSON\"\n        ],\n        devel: [\n            \"alert\", \"confirm\", \"console\", \"Debug\", \"opera\", \"prompt\", \"WSH\"\n        ],\n        es6: [\n            \"ArrayBuffer\", \"DataView\", \"Float32Array\", \"Float64Array\",\n            \"Generator\", \"GeneratorFunction\", \"Int8Array\", \"Int16Array\",\n            \"Int32Array\", \"Intl\", \"Map\", \"Promise\", \"Proxy\", \"Reflect\",\n            \"Set\", \"Symbol\", \"System\", \"Uint8Array\", \"Uint8ClampedArray\",\n            \"Uint16Array\", \"Uint32Array\", \"WeakMap\", \"WeakSet\"\n        ],\n        eval: true,\n        for: true,\n        fudge: true,\n        maxerr: 10000,\n        maxlen: 10000,\n        multivar: true,\n        node: [\n            \"Buffer\", \"clearImmediate\", \"clearInterval\", \"clearTimeout\",\n            \"console\", \"exports\", \"global\", \"module\", \"process\", \"querystring\",\n            \"require\", \"setImmediate\", \"setInterval\", \"setTimeout\",\n            \"__dirname\", \"__filename\"\n        ],\n        this: true,\n        white: true\n    };\n\n    var spaceop = {\n\n// This is the set of infix operators that require a space on each side.\n\n        \"!=\": true,\n        \"!==\": true,\n        \"%\": true,\n        \"%=\": true,\n        \"&\": true,\n        \"&=\": true,\n        \"&&\": true,\n        \"*\": true,\n        \"*=\": true,\n        \"+=\": true,\n        \"-=\": true,\n        \"/\": true,\n        \"/=\": true,\n        \"<\": true,\n        \"<=\": true,\n        \"<<\": true,\n        \"<<=\": true,\n        \"=\": true,\n        \"==\": true,\n        \"===\": true,\n        \"=>\": true,\n        \">\": true,\n        \">=\": true,\n        \">>\": true,\n        \">>=\": true,\n        \">>>\": true,\n        \">>>=\": true,\n        \"^\": true,\n        \"^=\": true,\n        \"|\": true,\n        \"|=\": true,\n        \"||\": true\n    };\n\n    var bitwiseop = {\n\n// These are the bitwise operators.\n\n        \"~\": true,\n        \"^\": true,\n        \"^=\": true,\n        \"&\": true,\n        \"&=\": true,\n        \"|\": true,\n        \"|=\": true,\n        \"<<\": true,\n        \"<<=\": true,\n        \">>\": true,\n        \">>=\": true,\n        \">>>\": true,\n        \">>>=\": true\n    };\n\n    var opener = {\n\n// The open and close pairs.\n\n        \"(\": \")\",       // paren\n        \"[\": \"]\",       // bracket\n        \"{\": \"}\",       // brace\n        \"${\": \"}\"       // mega\n    };\n\n    var relationop = {\n\n// The relational operators.\n\n        \"!=\": true,\n        \"!==\": true,\n        \"==\": true,\n        \"===\": true,\n        \"<\": true,\n        \"<=\": true,\n        \">\": true,\n        \">=\": true\n    };\n\n    var standard = [\n\n// These are the globals that are provided by the ES5 language standard.\n\n        \"Array\", \"Boolean\", \"Date\", \"decodeURI\", \"decodeURIComponent\",\n        \"encodeURI\", \"encodeURIComponent\", \"Error\", \"EvalError\", \"isFinite\",\n        \"isNaN\", \"JSON\", \"Math\", \"Number\", \"Object\", \"parseInt\", \"parseFloat\",\n        \"RangeError\", \"ReferenceError\", \"RegExp\", \"String\", \"SyntaxError\",\n        \"TypeError\", \"URIError\"\n    ];\n\n    var bundle = {\n\n// The bundle contains the raw text messages that are generated by jslint. It\n// seems that they are all error messages and warnings. There are no \"Atta\n// boy!\" or \"You are so awesome!\" messages. There is no positive reinforcement\n// or encouragement. This relentless negativity can undermine self-esteem and\n// wound the inner child. But if you accept it as sound advice rather than as\n// personal criticism, it can make your programs better.\n\n        and: \"The '&&' subexpression should be wrapped in parens.\",\n        bad_assignment_a: \"Bad assignment to '{a}'.\",\n        bad_directive_a: \"Bad directive '{a}'.\",\n        bad_get: \"A get function takes no parameters.\",\n        bad_module_name_a: \"Bad module name '{a}'.\",\n        bad_option_a: \"Bad option '{a}'.\",\n        bad_property_a: \"Bad property name '{a}'.\",\n        bad_set: \"A set function takes one parameter.\",\n        duplicate_a: \"Duplicate '{a}'.\",\n        empty_block: \"Empty block.\",\n        es6: \"Unexpected ES6 feature '{a}'.\",\n        expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n        expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n        expected_a_b_from_c_d: \"Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.\",\n        expected_a_before_b: \"Expected '{a}' before '{b}'.\",\n        expected_digits_after_a: \"Expected digits after '{a}'.\",\n        expected_four_digits: \"Expected four digits after '\\\\u'.\",\n        expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n        expected_line_break_a_b: \"Expected a line break between '{a}' and '{b}'.\",\n        expected_regexp_factor_a: \"Expected a regexp factor and instead saw '{a}'.\",\n        expected_space_a_b: \"Expected one space between '{a}' and '{b}'.\",\n        expected_statements_a: \"Expected statements before '{a}'.\",\n        expected_string_a: \"Expected a string and instead saw '{a}'.\",\n        expected_type_string_a: \"Expected a type string and instead saw '{a}'.\",\n        function_in_loop: \"Don't make functions within a loop.\",\n        infix_in: \"Unexpected 'in'. Compare with undefined, or use the hasOwnProperty method instead.\",\n        isNaN: \"Use the isNaN function to compare with NaN.\",\n        label_a: \"'{a}' is a statement label.\",\n        misplaced_a: \"Place '{a}' at the outermost level.\",\n        misplaced_directive_a: \"Place the '/*{a}*/' directive before the first statement.\",\n        missing_browser: \"/*global*/ requires the Assume a browser option.\",\n        naked_block: \"Naked block.\",\n        nested_comment: \"Nested comment.\",\n        not_label_a: \"'{a}' is not a label.\",\n        out_of_scope_a: \"'{a}' is out of scope.\",\n        redefinition_a_b: \"Redefinition of '{a}' from line {b}.\",\n        reserved_a: \"Reserved name '{a}'.\",\n        subscript_a: \"['{a}'] is better written in dot notation.\",\n        todo_comment: \"Unexpected TODO comment.\",\n        too_long: \"Line too long.\",\n        too_many: \"Too many warnings.\",\n        too_many_digits: \"Too many digits.\",\n        unclosed_comment: \"Unclosed comment.\",\n        unclosed_mega: \"Unclosed mega literal.\",\n        unclosed_string: \"Unclosed string.\",\n        undeclared_a: \"Undeclared '{a}'.\",\n        unexpected_a: \"Unexpected '{a}'.\",\n        unexpected_a_after_b: \"Unexpected '{a}' after '{b}'.\",\n        unexpected_at_top_level_a: \"Unexpected '{a}' at top level.\",\n        unexpected_char_a: \"Unexpected character '{a}'.\",\n        unexpected_comment: \"Unexpected comment.\",\n        unexpected_directive_a: \"When using modules, don't use directive '/*{a}'.\",\n        unexpected_expression_a: \"Unexpected expression '{a}' in statement position.\",\n        unexpected_label_a: \"Unexpected label '{a}'.\",\n        unexpected_parens: \"Don't wrap function literals in parens.\",\n        unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n        unexpected_statement_a: \"Unexpected statement '{a}' in expression position.\",\n        unexpected_trailing_space: \"Unexpected trailing space.\",\n        unexpected_typeof_a: \"Unexpected 'typeof'. Use '===' to compare directly with {a}.\",\n        uninitialized_a: \"Uninitialized '{a}'.\",\n        unreachable_a: \"Unreachable '{a}'.\",\n        unregistered_property_a: \"Unregistered property name '{a}'.\",\n        unsafe: \"Unsafe character '{a}'.\",\n        unused_a: \"Unused '{a}'.\",\n        use_spaces: \"Use spaces, not tabs.\",\n        var_loop: \"Don't declare variables in a loop.\",\n        var_switch: \"Don't declare variables in a switch.\",\n        weird_condition_a: \"Weird condition '{a}'.\",\n        weird_expression_a: \"Weird expression '{a}'.\",\n        weird_loop: \"Weird loop.\",\n        weird_relation_a: \"Weird relation '{a}'.\",\n        wrap_assignment: \"Don't wrap assignment statements in parens.\",\n        wrap_condition: \"Wrap the condition in parens.\",\n        wrap_immediate: \"Wrap an immediate function invocation in \" +\n                \"parentheses to assist the reader in understanding that the \" +\n                \"expression is the result of a function, and not the \" +\n                \"function itself.\",\n        wrap_regexp: \"Wrap this regexp in parens to avoid confusion.\",\n        wrap_unary: \"Wrap the unary expression in parens.\"\n    };\n\n// Regular expression literals:\n\n// supplant {variables}\n    var rx_supplant = /\\{([^{}]*)\\}/g;\n// carriage return, carriage return linefeed, or linefeed\n    var rx_crlf = /\\n|\\r\\n?/;\n// unsafe characters that are silently deleted by one or more browsers\n    var rx_unsafe = /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/;\n// identifier\n    var rx_identifier = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/;\n    var rx_bad_property = /^_|\\$|Sync$|_$/;\n// star slash\n    var rx_star_slash = /\\*\\//;\n// slash star\n    var rx_slash_star = /\\/\\*/;\n// slash star or ending slash\n    var rx_slash_star_or_slash = /\\/\\*|\\/$/;\n// uncompleted work comment\n    var rx_todo = /\\b(?:todo|TO\\s?DO|HACK)\\b/;\n// tab\n    var rx_tab = /\\t/g;\n// directive\n    var rx_directive = /^(jslint|property|global)\\s+(.*)$/;\n    var rx_directive_part = /^([a-zA-Z$_][a-zA-Z0-9$_]*)\\s*(?::\\s*(true|false|[0-9]+)\\s*)?(?:,\\s*)?(.*)$/;\n// token (sorry it is so long)\n    var rx_token = /^((\\s+)|([a-zA-Z_$][a-zA-Z0-9_$]*)|[(){}\\[\\]\\?,:;'\"~`]|=(?:==?|>)?|\\.+|\\/[=*\\/]?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|[\\^%]=?|&[&=]?|\\|[\\|=]?|>{1,3}=?|<<?=?|!={0,2}|(0|[1-9][0-9]*))(.*)$/;\n    var rx_digits = /^([0-9]+)(.*)$/;\n    var rx_hexs = /^([0-9a-fA-F]+)(.*)$/;\n    var rx_octals = /^([0-7]+)(.*)$/;\n    var rx_bits = /^([01]+)(.*)$/;\n// mega\n    var rx_mega = /`|\\$\\{/;\n// indentation\n    var rx_colons = /^(.*)\\?([:.]*)$/;\n    var rx_dot = /\\.$/;\n// JSON number\n    var rx_JSON_number = /^-?\\d+(?:\\.\\d*)?(?:e[\\-+]?\\d+)?$/i;\n// initial cap\n    var rx_cap = /^[A-Z]/;\n\n    function is_letter(string) {\n        return (string >= \"a\" && string <= \"z\\uffff\") ||\n                (string >= \"A\" && string <= \"Z\\uffff\");\n    }\n\n    function supplant(string, object) {\n        return string.replace(rx_supplant, function (found, filling) {\n            var replacement = object[filling];\n            return (replacement !== undefined)\n                ? replacement\n                : found;\n        });\n    }\n\n    var anon = \"anonymous\"; // The guessed name for anonymous functions.\n    var blockage;           // The current block.\n    var block_stack;        // The stack of blocks.\n    var declared_globals;   // The object containing the global declarations.\n    var directives;         // The directive comments.\n    var directive_mode;     // true if directives are still allowed.\n    var early_stop;         // true if JSLint cannot finish.\n    var export_mode;        // true if an export statement was seen.\n    var fudge;              // true if the natural numbers start with 1.\n    var functionage;        // The current function.\n    var functions;          // The array containing all of the functions.\n    var global;             // The global object; the outermost context.\n    var imports;            // The array collecting all import-from strings.\n    var json_mode;          // true if parsing JSON.\n    var lines;              // The array containing source lines.\n    var module_mode;        // true if import or export was used.\n    var next_token;         // The next token to be examined in the parse.\n    var option;             // The options parameter.\n    var property;           // The object containing the tallied property names.\n    var mega_mode;          // true if currently parsing a megastring literal.\n    var stack;              // The stack of functions.\n    var syntax;             // The object containing the parser.\n    var token;              // The current token being examined in the parse.\n    var token_nr;           // The number of the next token.\n    var tokens;             // The array of tokens.\n    var tenure;             // The predefined property registry.\n    var tree;               // The abstract parse tree.\n    var var_mode;           // true if using var; false if using let.\n    var warnings;           // The array collecting all generated warnings.\n\n// Error reportage functions:\n\n    function artifact(the_token) {\n\n// Return a string representing an artifact.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        return (the_token.id === \"(string)\" || the_token.id === \"(number)\")\n            ? String(the_token.value)\n            : the_token.id;\n    }\n\n    function artifact_line(the_token) {\n\n// Return the fudged line number of an artifact.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        return the_token.line + fudge;\n    }\n\n    function artifact_column(the_token) {\n\n// Return the fudged column number of an artifact.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        return the_token.from + fudge;\n    }\n\n    function warn_at(code, line, column, a, b, c, d) {\n\n// Report an error at some line and column of the program. The warning object\n// resembles an exception.\n\n        var warning = {         // ~~\n            name: \"JSLintError\",\n            column: column,\n            line: line,\n            code: code\n        };\n        if (a !== undefined) {\n            warning.a = a;\n        }\n        if (b !== undefined) {\n            warning.b = b;\n        }\n        if (c !== undefined) {\n            warning.c = c;\n        }\n        if (d !== undefined) {\n            warning.d = d;\n        }\n        warning.message = supplant(bundle[code] || code, warning);\n        warnings.push(warning);\n        return (\n            typeof option.maxerr === \"number\" &&\n            warnings.length === option.maxerr\n        )   ? stop_at(\"too_many\", line, column)\n            : warning;\n    }\n\n    function stop_at(code, line, column, a, b, c, d) {\n\n// Same as warn_at, except that it stops the analysis.\n\n        throw warn_at(code, line, column, a, b, c, d);\n    }\n\n    function warn(code, the_token, a, b, c, d) {\n\n// Same as warn_at, except the warning will be associated with a specific token.\n// If there is already a warning on this token, suppress the new one. It is\n// likely that the first warning will be the most meaningful.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        if (the_token.warning === undefined) {\n            the_token.warning = warn_at(\n                code,\n                the_token.line,\n                the_token.from,\n                a || artifact(the_token),\n                b,\n                c,\n                d\n            );\n            return the_token.warning;\n        }\n    }\n\n    function stop(code, the_token, a, b, c, d) {\n\n// Similar to warn and stop_at. If the token already had a warning, that\n// warning will be replaced with this new one. It is likely that the stopping\n// warning will be the most meaningful.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        delete the_token.warning;\n        throw warn(code, the_token, a, b, c, d);\n    }\n\n// Tokenize:\n\n    function tokenize(source) {\n\n// tokenize takes a source and produces from it an array of token objects.\n// JavaScript is notoriously difficult to tokenize because of the horrible\n// interactions between automatic semicolon insertion, regular expression\n// literals, and now megastring literals. JSLint benefits from eliminating\n// automatic semicolon insertion and nested megastring literals, which allows\n// full tokenization to precede parsing.\n\n// If the source is not an array, then it is split into lines at the\n// carriage return/linefeed.\n\n        lines = (Array.isArray(source))\n            ? source\n            : source.split(rx_crlf);\n        tokens = [];\n\n        var char;                   // a popular character\n        var column = 0;             // the column number of the next character\n        var from;                   // the starting column number of the token\n        var line = -1;              // the line number of the next character\n        var previous = global;      // the previous token including comments\n        var prior = global;         // the previous token excluding comments\n        var mega_from;              // the starting column of megastring\n        var mega_line;              // the starting line of megastring\n        var snippet;                // a piece of string\n        var source_line;            // the current line source string\n\n        function next_line() {\n\n// Put the next line of source in source_line. If the line contains tabs,\n// replace them with spaces and give a warning. Also warn if the line contains\n// unsafe characters or is too damn long.\n\n            var at;\n            column = 0;\n            line += 1;\n            source_line = lines[line];\n            if (source_line !== undefined) {\n                at = source_line.search(rx_tab);\n                if (at >= 0) {\n                    if (!option.white) {\n                        warn_at(\"use_spaces\", line, at + 1);\n                    }\n                    source_line = source_line.replace(rx_tab, \" \");\n                }\n                at = source_line.search(rx_unsafe);\n                if (at >= 0) {\n                    warn_at(\n                        \"unsafe\",\n                        line,\n                        column + at,\n                        \"U+\" + source_line.charCodeAt(at).toString(16)\n                    );\n                }\n                if (option.maxlen && option.maxlen < source_line.length) {\n                    warn_at(\"too_long\", line, source_line.length);\n                } else if (!option.white && source_line.slice(-1) === \" \") {\n                    warn_at(\n                        \"unexpected_trailing_space\",\n                        line,\n                        source_line.length - 1\n                    );\n                }\n            }\n            return source_line;\n        }\n\n// Most tokens, including the identifiers, operators, and punctuators, can be\n// found with a regular expression. Regular expressions cannot correctly match\n// regular expression literals, so we will match those the hard way. String\n// literals and number literals can be matched by regular expressions, but they\n// don't provide good warnings. The functions snip, next_char, prev_char,\n// some_digits, and escape help in the parsing of literals.\n\n        function snip() {\n\n// Remove the last character from snippet.\n\n            snippet = snippet.slice(0, -1);\n        }\n\n        function next_char(match) {\n\n// Get the next character from the source line. Remove it from the source_line,\n// and append it to the snippet. Optionally check that the previous character\n// matched an expected value.\n\n            if (match !== undefined && char !== match) {\n                return stop_at(\"expected_a_b\", line, column, match, char);\n            }\n            if (source_line) {\n                char = source_line.charAt(0);\n                source_line = source_line.slice(1);\n                snippet += char;\n            } else {\n                char = \"\";\n                snippet += \" \";\n            }\n            column += 1;\n            return char;\n        }\n\n        function back_char() {\n\n// Back up one character by moving a character from the end of the snippet to\n// the front of the source_line.\n\n            if (snippet) {\n                char = snippet.slice(-1);\n                source_line = char + source_line;\n                column -= 1;\n                snip();\n            } else {\n                char = \"\";\n            }\n            return char;\n        }\n\n        function some_digits(rx, quiet) {\n            var result = source_line.match(rx);\n            if (result) {\n                char = result[1];\n                column += char.length;\n                source_line = result[2];\n                snippet += char;\n            } else {\n                char = \"\";\n                if (!quiet) {\n                    warn_at(\n                        \"expected_digits_after_a\",\n                        line,\n                        column,\n                        snippet\n                    );\n                }\n            }\n            return char.length;\n        }\n\n        function escape(extra) {\n            switch (next_char(\"\\\\\")) {\n            case \"\\\\\":\n            case \"\\\"\":\n            case \"'\":\n            case \"/\":\n            case \":\":\n            case \"=\":\n            case \"|\":\n            case \"b\":\n            case \"f\":\n            case \"n\":\n            case \"r\":\n            case \"t\":\n            case \" \":\n                break;\n            case \"u\":\n                if (next_char(\"u\") === \"{\") {\n                    if (some_digits(rx_hexs) > 5) {\n                        warn_at(\"too_many_digits\", line, column - 1);\n                    }\n                    if (!option.es6) {\n                        warn_at(\"es6\", line, column, \"u{\");\n                    }\n                    if (next_char() !== \"}\") {\n                        stop_at(\"expected_a_before_b\", line, column, \"}\", char);\n                    }\n                    next_char();\n                    return;\n                }\n                back_char();\n                if (some_digits(rx_hexs, true) < 4) {\n                    warn_at(\"expected_four_digits\", line, column - 1);\n                }\n                break;\n            case \"\":\n                return stop_at(\"unclosed_string\", line, column);\n            default:\n                if (extra && extra.indexOf(char) < 0) {\n                    warn_at(\"unexpected_a_after_b\", line, column, char, \"\\\\\");\n                }\n            }\n            next_char();\n        }\n\n        function make(id, value, identifier) {\n\n// Make the token object and append it to the tokens list.\n\n            var the_token = {\n                id: id,\n                identifier: !!identifier,\n                from: from,\n                thru: column,\n                line: line\n            };\n            tokens.push(the_token);\n\n// Directives must appear before the first statement.\n\n            if (id !== \"(comment)\" && id !== \";\") {\n                directive_mode = false;\n            }\n\n// If the token is to have a value, give it one.\n\n            if (value !== undefined) {\n                the_token.value = value;\n            }\n\n// If this token is an identifier that touches a preceding number, or\n// a \"/\", comment, or regular expression literal that touches a preceding\n// comment or regular expression literal, then give a missing space warning.\n// This warning is not suppressed by option.white.\n\n            if (\n                previous.line === line &&\n                previous.thru === from &&\n                (\n                    (id === \"(comment)\" || id === \"(regexp)\" || id === \"/\") &&\n                    (\n                        previous.id === \"(comment)\" ||\n                        previous.id === \"(regexp)\"\n                    )\n                )\n            ) {\n                warn(\n                    \"expected_space_a_b\",\n                    the_token,\n                    artifact(previous),\n                    artifact(the_token)\n                );\n            }\n            if (previous.id === \".\" && id === \"(number)\") {\n                warn(\"expected_a_before_b\", previous, \"0\", \".\");\n            }\n            if (prior.id === \".\" && the_token.identifier) {\n                the_token.dot = true;\n            }\n\n// The previous token is used to detect adjacency problems.\n\n            previous = the_token;\n\n// The prior token is a previous token that was not a comment. The prior token\n// is used to disambiguate \"/\", which can mean division or regular expression\n// literal.\n\n            if (previous.id !== \"(comment)\") {\n                prior = previous;\n            }\n            return the_token;\n        }\n\n        function parse_directive(the_comment, body) {\n\n// JSLint recognizes three directives that can be encoded in comments. This\n// function processes one item, and calls itself recursively to process the\n// next one.\n\n            var result = body.match(rx_directive_part);\n            if (result) {\n                var allowed;\n                var name = result[1];\n                var value = result[2];\n                switch (the_comment.directive) {\n                case \"jslint\":\n                    allowed = allowed_option[name];\n                    switch (typeof allowed) {\n                    case \"boolean\":\n                    case \"object\":\n                        switch (value) {\n                        case \"true\":\n                        case \"\":\n                        case undefined:\n                            option[name] = true;\n                            if (Array.isArray(allowed)) {\n                                populate(declared_globals, allowed, false);\n                            }\n                            break;\n                        case \"false\":\n                            option[name] = false;\n                            break;\n                        default:\n                            warn(\n                                \"bad_option_a\",\n                                the_comment,\n                                name + \":\" + value\n                            );\n                        }\n                        break;\n                    case \"number\":\n                        if (isFinite(+value)) {\n                            option[name] = +value;\n                        } else {\n                            warn(\n                                \"bad_option_a\",\n                                the_comment,\n                                name + \":\" + value\n                            );\n                        }\n                        break;\n                    default:\n                        warn(\"bad_option_a\", the_comment, name);\n                    }\n                    break;\n                case \"property\":\n                    if (tenure === undefined) {\n                        tenure = empty();\n                    }\n                    tenure[name] = true;\n                    break;\n                case \"global\":\n                    if (value) {\n                        warn(\"bad_option_a\", the_comment, name + \":\" + value);\n                    }\n                    declared_globals[name] = false;\n                    module_mode = the_comment;\n                    break;\n                }\n                return parse_directive(the_comment, result[3]);\n            }\n            if (body) {\n                return stop(\"bad_directive_a\", the_comment, body);\n            }\n        }\n\n        function comment(snippet) {\n\n// Make a comment object. Comments are not allowed in JSON text. Comments can\n// include directives and notices of incompletion.\n\n            var the_comment = make(\"(comment)\", snippet);\n            if (Array.isArray(snippet)) {\n                snippet = snippet.join(\" \");\n            }\n            if (!option.devel && rx_todo.test(snippet)) {\n                warn(\"todo_comment\", the_comment);\n            }\n            var result = snippet.match(rx_directive);\n            if (result) {\n                if (!directive_mode) {\n                    warn_at(\"misplaced_directive_a\", line, from, result[1]);\n                } else {\n                    the_comment.directive = result[1];\n                    parse_directive(the_comment, result[2]);\n                }\n                directives.push(the_comment);\n            }\n            return the_comment;\n        }\n\n        function regexp() {\n\n// Parse a regular expression literal.\n\n            var result;\n            var value;\n\n            function quantifier() {\n\n// Match an optional quantifier.\n\n                switch (char) {\n                case \"?\":\n                case \"*\":\n                case \"+\":\n                    next_char();\n                    break;\n                case \"{\":\n                    if (some_digits(rx_digits, true) === 0) {\n                        warn_at(\"expected_a\", line, column, \"0\");\n                    }\n                    if (next_char() === \",\") {\n                        some_digits(rx_digits, true);\n                        next_char();\n                    }\n                    next_char(\"}\");\n                    break;\n                default:\n                    return;\n                }\n                if (char === \"?\") {\n                    next_char(\"?\");\n                }\n            }\n\n            function subklass() {\n\n// Match a character in a character class.\n\n                switch (char) {\n                case \"\\\\\":\n                    escape();\n                    return true;\n                case \"[\":\n                case \"]\":\n                case \"/\":\n                case \"^\":\n                case \"-\":\n                case \"|\":\n                case \"\":\n                    return false;\n                case \"`\":\n                    if (mega_mode) {\n                        warn_at(\"unexpected_a\", line, column, \"`\");\n                    }\n                    next_char();\n                    return true;\n                case \" \":\n                    warn_at(\"expected_a_before_b\", line, column, \"\\\\\", \" \");\n                    next_char();\n                    return true;\n                default:\n                    next_char();\n                    return true;\n                }\n            }\n\n            function range() {\n\n// Match a range of subclasses.\n\n                if (subklass()) {\n                    if (char === \"-\") {\n                        next_char(\"-\");\n                        if (!subklass()) {\n                            return stop_at(\n                                \"unexpected_a\",\n                                line,\n                                column - 1,\n                                \"-\"\n                            );\n                        }\n                    }\n                    return range();\n                }\n            }\n\n            function klass() {\n\n// Match a class.\n\n                next_char(\"[\");\n                if (char === \"^\") {\n                    next_char(\"^\");\n                }\n                range();\n                next_char(\"]\");\n            }\n\n            function choice() {\n\n                function group() {\n\n// Match a group that starts with left paren.\n\n                    next_char(\"(\");\n                    if (char === \"?\") {\n                        next_char(\"?\");\n                        switch (char) {\n                        case \":\":\n                        case \"=\":\n                        case \"!\":\n                            next_char();\n                            break;\n                        default:\n                            next_char(\":\");\n                        }\n                    } else if (char === \":\") {\n                        warn_at(\"expected_a_before_b\", line, column, \"?\", \":\");\n                    }\n                    choice();\n                    next_char(\")\");\n                }\n\n                function factor() {\n                    switch (char) {\n                    case \"[\":\n                        klass();\n                        return true;\n                    case \"\\\\\":\n                        escape(\"BbDdSsWw^${}[]().|*+?\");\n                        return true;\n                    case \"(\":\n                        group();\n                        return true;\n                    case \"/\":\n                    case \"|\":\n                    case \"]\":\n                    case \")\":\n                    case \"}\":\n                    case \"{\":\n                    case \"?\":\n                    case \"+\":\n                    case \"*\":\n                    case \"\":\n                        return false;\n                    case \"`\":\n                        if (mega_mode) {\n                            warn_at(\"unexpected_a\", line, column, \"`\");\n                        }\n                        break;\n                    case \" \":\n                        warn_at(\"expected_a_before_b\", line, column, \"\\\\\", \" \");\n                        break;\n                    }\n                    next_char();\n                    return true;\n                }\n\n                function sequence(follow) {\n                    if (factor()) {\n                        quantifier();\n                        return sequence(true);\n                    }\n                    if (!follow) {\n                        warn_at(\"expected_regexp_factor_a\", line, column, char);\n                    }\n                }\n\n// Match a choice (a sequence that can be followed by | and another choice).\n\n                sequence();\n                if (char === \"|\") {\n                    next_char(\"|\");\n                    return choice();\n                }\n            }\n\n// Scan the regexp literal. Give a warning if the first character is = because\n// /= looks like a division assignment operator.\n\n            snippet = \"\";\n            next_char();\n            if (char === \"=\") {\n                warn_at(\"expected_a_before_b\", line, column, \"\\\\\", \"=\");\n            }\n            choice();\n\n// Make sure there is a closing slash.\n\n            snip();\n            value = snippet;\n            next_char(\"/\");\n\n// Process dangling flag letters.\n\n            var allowed = {\n                g: true,\n                i: true,\n                m: true,\n                u: 6,\n                y: 6\n            };\n            var flag = empty();\n            (function make_flag() {\n                if (is_letter(char)) {\n                    switch (allowed[char]) {\n                    case true:\n                        break;\n                    case 6:\n                        if (!option.es6) {\n                            warn_at(\"es6\", line, column, char);\n                        }\n                        break;\n                    default:\n                        warn_at(\"unexpected_a\", line, column, char);\n                    }\n                    allowed[char] = false;\n                    flag[char] = true;\n                    next_char();\n                    return make_flag();\n                }\n            }());\n            back_char();\n            if (char === \"/\" || char === \"*\") {\n                return stop_at(\"unexpected_a\", line, from, char);\n            }\n            result = make(\"(regexp)\", char);\n            result.flag = flag;\n            result.value = value;\n            return result;\n        }\n\n        function string(quote) {\n\n// Make a string token.\n\n            var the_token;\n            snippet = \"\";\n            next_char();\n\n            return (function next() {\n                switch (char) {\n                case quote:\n                    snip();\n                    the_token = make(\"(string)\", snippet);\n                    the_token.quote = quote;\n                    return the_token;\n                case \"\\\\\":\n                    escape();\n                    break;\n                case \"\":\n                    return stop_at(\"unclosed_string\", line, column);\n                case \"`\":\n                    if (mega_mode) {\n                        warn_at(\"unexpected_a\", line, column, \"`\");\n                    }\n                    next_char(\"`\");\n                    break;\n                default:\n                    next_char();\n                }\n                return next();\n            }());\n        }\n\n        function frack() {\n            if (char === \".\") {\n                some_digits(rx_digits);\n                next_char();\n            }\n            if (char === \"E\" || char === \"e\") {\n                next_char();\n                if (char !== \"+\" && char !== \"-\") {\n                    back_char();\n                }\n                some_digits(rx_digits);\n                next_char();\n            }\n        }\n\n        function number() {\n            if (snippet === \"0\") {\n                switch (next_char()) {\n                case \".\":\n                    frack();\n                    break;\n                case \"b\":\n                    some_digits(rx_bits);\n                    next_char();\n                    break;\n                case \"o\":\n                    some_digits(rx_octals);\n                    next_char();\n                    break;\n                case \"x\":\n                    some_digits(rx_hexs);\n                    next_char();\n                    break;\n                }\n            } else {\n                next_char();\n                frack();\n            }\n\n// If the next character after a number is a digit or letter, then something\n// unexpected is going on.\n\n            if (\n                (char >= \"0\" && char <= \"9\") ||\n                (char >= \"a\" && char <= \"z\") ||\n                (char >= \"A\" && char <= \"Z\")\n            ) {\n                return stop_at(\n                    \"unexpected_a_after_b\",\n                    line,\n                    column - 1,\n                    snippet.slice(-1),\n                    snippet.slice(0, -1)\n                );\n            }\n            back_char();\n            return make(\"(number)\", snippet);\n        }\n\n        function lex() {\n            var array;\n            var i = 0;\n            var j = 0;\n            var last;\n            var result;\n            var the_token;\n            if (!source_line) {\n                source_line = next_line();\n                from = 0;\n                return (source_line === undefined)\n                    ? (mega_mode)\n                        ? stop_at(\"unclosed_mega\", mega_line, mega_from)\n                        : make(\"(end)\")\n                    : lex();\n            }\n            from = column;\n            result = source_line.match(rx_token);\n\n// result[1] token\n// result[2] whitespace\n// result[3] identifier\n// result[4] number\n// result[5] rest\n\n            if (!result) {\n                return stop_at(\n                    \"unexpected_char_a\",\n                    line,\n                    column,\n                    source_line.charAt(0)\n                );\n            }\n\n            snippet = result[1];\n            column += snippet.length;\n            source_line = result[5];\n\n// Whitespace was matched. Call lex again to get more.\n\n            if (result[2]) {\n                return lex();\n            }\n\n// The token is an identifier.\n\n            if (result[3]) {\n                return make(snippet, undefined, true);\n            }\n\n// The token is a number.\n\n            if (result[4]) {\n                return number(snippet);\n            }\n\n// The token is something miscellaneous.\n\n            switch (snippet) {\n\n// The token is a single or double quote string.\n\n            case \"\\\"\":\n            case \"'\":\n                return string(snippet);\n\n// The token is a megastring. We don't allow any kind of mega nesting.\n\n            case \"`\":\n                if (mega_mode) {\n                    return stop_at(\"expected_a_b\", line, column, \"}\", \"`\");\n                }\n                snippet = \"\";\n                mega_from = from;\n                mega_line = line;\n                mega_mode = true;\n\n// Parsing a mega literal is tricky. First make a ` token.\n\n                make(\"`\");\n                from += 1;\n\n// Then loop, building up a string, possibly from many lines, until seeing\n// the end of file, a closing `, or a ${ indicting an expression within the\n// string.\n\n                (function part() {\n                    var at = source_line.search(rx_mega);\n\n// If neither ` nor ${ is seen, then the whole line joins the snippet.\n\n                    if (at < 0) {\n                        snippet += source_line + \"\\n\";\n                        return (next_line() === undefined)\n                            ? stop_at(\"unclosed_mega\", mega_line, mega_from)\n                            : part();\n                    }\n\n// if either ` or ${ was found, then the preceding joins the snippet to become\n// a string token.\n\n                    snippet += source_line.slice(0, at);\n                    column += at;\n                    source_line = source_line.slice(at);\n                    make(\"(string)\", snippet).quote = \"`\";\n                    snippet = \"\";\n\n// If ${, then make tokens that will become part of an expression until\n// a } token is made.\n\n                    if (source_line.charAt(0) === \"$\") {\n                        column += 2;\n                        make(\"${\");\n                        source_line = source_line.slice(2);\n                        (function expr() {\n                            var id = lex().id;\n                            if (id === \"{\") {\n                                return stop_at(\n                                    \"expected_a_b\",\n                                    line,\n                                    column,\n                                    \"}\",\n                                    \"{\"\n                                );\n                            }\n                            if (id !== \"}\") {\n                                return expr();\n                            }\n                        }());\n                        return part();\n                    }\n                }());\n                source_line = source_line.slice(1);\n                column += 1;\n                mega_mode = false;\n                return make(\"`\");\n\n// The token is a // comment.\n\n            case \"//\":\n                snippet = source_line;\n                source_line = \"\";\n                the_token = comment(snippet);\n                if (mega_mode) {\n                    warn(\"unexpected_comment\", the_token, \"`\");\n                }\n                return the_token;\n\n// The token is a /* comment.\n\n            case \"/*\":\n                array = [];\n                if (source_line.charAt(0) === \"/\") {\n                    warn_at(\"unexpected_a\", line, column + i, \"/\");\n                }\n                (function next() {\n                    if (source_line > \"\") {\n                        i = source_line.search(rx_star_slash);\n                        if (i >= 0) {\n                            return;\n                        }\n                        j = source_line.search(rx_slash_star);\n                        if (j >= 0) {\n                            warn_at(\"nested_comment\", line, column + j);\n                        }\n                    }\n                    array.push(source_line);\n                    source_line = next_line();\n                    if (source_line === undefined) {\n                        return stop_at(\"unclosed_comment\", line, column);\n                    }\n                    return next();\n                }());\n                snippet = source_line.slice(0, i);\n                j = snippet.search(rx_slash_star_or_slash);\n                if (j >= 0) {\n                    warn_at(\"nested_comment\", line, column + j);\n                }\n                array.push(snippet);\n                column += i + 2;\n                source_line = source_line.slice(i + 2);\n                return comment(array);\n\n// The token is a slash.\n\n            case \"/\":\n\n// The / can be a division operator or the beginning of a regular expression\n// literal. It is not possible to know which without doing a complete parse.\n// We want to complete the tokenization before we begin to parse, so we will\n// estimate. This estimator can fail in some cases. For example, it cannot\n// know if \"}\" is ending a block or ending an object literal, so it can\n// behave incorrectly in that case; it is not meaningful to divide an\n// object, so it is likely that we can get away with it. We avoided the worst\n// cases by eliminating automatic semicolon insertion.\n\n                if (prior.identifier) {\n                    if (!prior.dot) {\n                        switch (prior.id) {\n                        case \"return\":\n                            return regexp();\n                        case \"(begin)\":\n                        case \"case\":\n                        case \"delete\":\n                        case \"in\":\n                        case \"instanceof\":\n                        case \"new\":\n                        case \"typeof\":\n                        case \"void\":\n                        case \"yield\":\n                            the_token = regexp();\n                            return stop(\"unexpected_a\", the_token);\n                        }\n                    }\n                } else {\n                    last = prior.id.charAt(prior.id.length - 1);\n                    if (\"(,=:?[\".indexOf(last) >= 0) {\n                        return regexp();\n                    }\n                    if (\"!&|{};~+-*%/^<>\".indexOf(last) >= 0) {\n                        the_token = regexp();\n                        warn(\"wrap_regexp\", the_token);\n                        return the_token;\n                    }\n                }\n                if (source_line.charAt(0) === \"/\") {\n                    column += 1;\n                    source_line = source_line.slice(1);\n                    snippet = \"/=\";\n                    warn_at(\"unexpected_a\", line, column, \"/=\");\n                }\n                break;\n            }\n            return make(snippet);\n        }\n\n// This is the only loop in JSLint. It will turn into a recursive call to lex\n// when ES6 has been finished and widely deployed and adopted.\n\n        while (true) {\n            if (lex().id === \"(end)\") {\n                break;\n            }\n        }\n    }\n\n// Parsing:\n\n// Parsing weaves the tokens into an abstract syntax tree. During that process,\n// a token may be given any of these properties:\n\n//      arity       string\n//      label       identifier\n//      name        identifier\n//      expression  expressions\n//      block       statements\n//      else        statements (else, default, catch)\n\n// Specialized tokens may have additional properties.\n\n    function survey(name) {\n        var id = name.id;\n\n// Tally the property name. If it is a string, only tally strings that conform\n// to the identifier rules.\n\n        if (id === \"(string)\") {\n            id = name.value;\n            if (!rx_identifier.test(id)) {\n                return id;\n            }\n        } else {\n            if (!name.identifier) {\n                return stop(\"expected_identifier_a\", name);\n            }\n        }\n\n// If we have seen this name before, increment its count.\n\n        if (typeof property[id] === \"number\") {\n            property[id] += 1;\n\n// If this is the first time seeing this property name, and if there is a\n// tenure list, then it must be on the list. Otherwise, it must conform to\n// the rules for good property names.\n\n        } else {\n            if (tenure !== undefined) {\n                if (tenure[id] !== true) {\n                    warn(\"unregistered_property_a\", name);\n                }\n            } else {\n                if (name.identifier && rx_bad_property.test(id)) {\n                    warn(\"bad_property_a\", name);\n                }\n            }\n            property[id] = 1;\n        }\n        return id;\n    }\n\n    function dispense() {\n\n// Deliver the next token, skipping the comments.\n\n        var cadet = tokens[token_nr];\n        token_nr += 1;\n        if (cadet.id === \"(comment)\") {\n            if (json_mode) {\n                warn(\"unexpected_a\", cadet);\n            }\n            return dispense();\n        } else {\n            return cadet;\n        }\n    }\n\n    function lookahead() {\n\n// Look ahead one token without advancing.\n\n        var old_token_nr = token_nr;\n        var cadet = dispense(true);\n        token_nr = old_token_nr;\n        return cadet;\n    }\n\n    function advance(id, match) {\n\n// Produce the next token.\n\n// Attempt to give helpful names to anonymous functions.\n\n        if (token.identifier && token.id !== \"function\") {\n            anon = token.id;\n        } else if (token.id === \"(string)\" && rx_identifier.test(token.value)) {\n            anon = token.value;\n        }\n\n// Attempt to match next_token with an expected id.\n\n        if (id !== undefined && next_token.id !== id) {\n            return (match === undefined)\n                ? stop(\"expected_a_b\", next_token, id, artifact())\n                : stop(\n                    \"expected_a_b_from_c_d\",\n                    next_token,\n                    id,\n                    artifact(match),\n                    artifact_line(match),\n                    artifact(next_token)\n                );\n        }\n\n// Promote the tokens, skipping comments.\n\n        token = next_token;\n        next_token = dispense();\n        if (next_token.id === \"(end)\") {\n            token_nr -= 1;\n        }\n    }\n\n// Parsing of JSON is simple:\n\n    function json_value() {\n\n        function json_object() {\n            var brace = next_token;\n            var object = empty();\n            advance(\"{\");\n            if (next_token.id !== \"}\") {\n                (function next() {\n                    if (next_token.quote !== \"\\\"\") {\n                        warn(\"unexpected_a\", next_token, next_token.quote);\n                    }\n                    advance(\"(string)\");\n                    if (object[token.value] !== undefined) {\n                        warn(\"duplicate_a\", token);\n                    } else if (token.value === \"__proto__\") {\n                        warn(\"bad_property_name_a\", token);\n                    } else {\n                        object[token.value] = token;\n                    }\n                    advance(\":\");\n                    json_value();\n                    if (next_token.id === \",\") {\n                        advance(\",\");\n                        return next();\n                    }\n                }());\n            }\n            advance(\"}\", brace);\n        }\n\n        function json_array() {\n            var bracket = next_token;\n            advance(\"[\");\n            if (next_token.id !== \"]\") {\n                (function next() {\n                    json_value();\n                    if (next_token.id === \",\") {\n                        advance(\",\");\n                        return next();\n                    }\n                }());\n            }\n            advance(\"]\", bracket);\n        }\n\n        switch (next_token.id) {\n        case \"{\":\n            json_object();\n            break;\n        case \"[\":\n            json_array();\n            break;\n        case \"true\":\n        case \"false\":\n        case \"null\":\n            advance();\n            break;\n        case \"(number)\":\n            if (!rx_JSON_number.test(next_token.value)) {\n                warn(\"unexpected_a\");\n            }\n            advance();\n            break;\n        case \"(string)\":\n            if (next_token.quote !== \"\\\"\") {\n                warn(\"unexpected_a\", next_token, next_token.quote);\n            }\n            advance();\n            break;\n        case \"-\":\n            advance(\"-\");\n            advance(\"(number)\");\n            break;\n        default:\n            stop(\"unexpected_a\");\n        }\n    }\n\n// Now we parse JavaScript.\n\n    function enroll(name, role, readonly) {\n\n// Enroll a name into the current function context. The role can be exception,\n// function, label, parameter, or variable. We look for variable redefinition\n// because it causes confusion.\n\n        var id = name.id;\n\n// Reserved words may not be enrolled.\n\n        if (syntax[id] !== undefined && id !== \"ignore\") {\n            warn(\"reserved_a\", name);\n        } else {\n\n// Has the name been enrolled in this context?\n\n            var earlier = functionage.context[id];\n            if (earlier) {\n                warn(\n                    \"redefinition_a_b\",\n                    name,\n                    name.id,\n                    earlier.line + fudge\n                );\n\n// Has the name been enrolled in an outer context?\n\n            } else {\n                stack.forEach(function (value) {\n                    var item = value.context[id];\n                    if (item !== undefined) {\n                        earlier = item;\n                    }\n                });\n                if (earlier) {\n                    if (id === \"ignore\") {\n                        if (earlier.role === \"variable\") {\n                            warn(\"unexpected_a\", name);\n                        }\n                    } else {\n                        if ((\n                            role !== \"exception\" ||\n                            earlier.role !== \"exception\"\n                        ) && role !== \"parameter\") {\n                            warn(\n                                \"redefinition_a_b\",\n                                name,\n                                name.id,\n                                earlier.line + fudge\n                            );\n                        }\n                    }\n                }\n\n// Enroll it.\n\n                functionage.context[id] = name;\n                name.dead = true;\n                name.function = functionage;\n                name.init = false;\n                name.role = role;\n                name.used = 0;\n                name.writable = !readonly;\n            }\n        }\n    }\n\n    function expression(rbp, initial) {\n\n// This is the heart of the Pratt parser. I retained Pratt's nomenclature.\n// They are elements of the parsing method called Top Down Operator Precedence.\n\n// nud     Null denotation\n// led     Left denotation\n// lbp     Left binding power\n// rbp     Right binding power\n\n// It processes a nud (variable, constant, prefix operator). It will then\n// process leds (infix operators) until the bind powers cause it to stop. It\n// returns the expression's parse tree.\n\n        var left;\n        var the_symbol;\n\n// Statements will have already advanced, so advance now only if the token is\n// not the first of a statement,\n\n        if (!initial) {\n            advance();\n        }\n        the_symbol = syntax[token.id];\n        if (the_symbol !== undefined && the_symbol.nud !== undefined) {\n            left = the_symbol.nud();\n        } else if (token.identifier) {\n            left = token;\n            left.arity = \"variable\";\n        } else {\n            return stop(\"unexpected_a\", token);\n        }\n        (function right() {\n            the_symbol = syntax[next_token.id];\n            if (\n                the_symbol !== undefined &&\n                the_symbol.led !== undefined &&\n                rbp < the_symbol.lbp\n            ) {\n                advance();\n                left = the_symbol.led(left);\n                return right();\n            }\n        }());\n        return left;\n    }\n\n    function condition() {\n\n// Parse the condition part of a do, if, while.\n\n        var the_paren = next_token;\n        var the_value;\n        the_paren.free = true;\n        advance(\"(\");\n        the_value = expression(0);\n        advance(\")\");\n        if (the_value.wrapped === true) {\n            warn(\"unexpected_a\", the_paren);\n        }\n        switch (the_value.id) {\n        case \"?\":\n        case \"~\":\n        case \"&\":\n        case \"|\":\n        case \"^\":\n        case \"<<\":\n        case \">>\":\n        case \">>>\":\n        case \"+\":\n        case \"-\":\n        case \"*\":\n        case \"/\":\n        case \"%\":\n        case \"typeof\":\n        case \"(number)\":\n        case \"(string)\":\n            warn(\"unexpected_a\", the_value);\n            break;\n        }\n        return the_value;\n    }\n\n    function is_weird(thing) {\n        return (\n            thing.id === \"(regexp)\" ||\n            thing.id === \"{\" ||\n            thing.id === \"=>\" ||\n            thing.id === \"function\" ||\n            (thing.id === \"[\" && thing.arity === \"unary\")\n        );\n    }\n\n    function are_similar(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (Array.isArray(a)) {\n            return (\n                Array.isArray(b) &&\n                a.length === b.length &&\n                a.every(function (value, index) {\n                    return are_similar(value, b[index]);\n                })\n            );\n        }\n        if (Array.isArray(b)) {\n            return false;\n        }\n        if (a.id === \"(number)\" && b.id === \"(number)\") {\n            return a.value === b.value;\n        }\n        var a_string;\n        var b_string;\n        if (a.id === \"(string)\") {\n            a_string = a.value;\n        } else if (a.id === \"`\" && a.constant) {\n            a_string = a.value[0];\n        }\n        if (b.id === \"(string)\") {\n            b_string = b.value;\n        } else if (b.id === \"`\" && b.constant) {\n            b_string = b.value[0];\n        }\n        if (typeof a_string === \"string\") {\n            return a_string === b_string;\n        }\n        if (is_weird(a) || is_weird(b)) {\n            return false;\n        }\n        if (a.arity === b.arity && a.id === b.id) {\n            if (a.id === \".\") {\n                return are_similar(a.expression, b.expression) &&\n                        are_similar(a.name, b.name);\n            }\n            switch (a.arity) {\n            case \"unary\":\n                return are_similar(a.expression, b.expression);\n            case \"binary\":\n                return (\n                    a.id !== \"(\" &&\n                    are_similar(a.expression[0], b.expression[0]) &&\n                    are_similar(a.expression[1], b.expression[1])\n                );\n            case \"ternary\":\n                return (\n                    are_similar(a.expression[0], b.expression[0]) &&\n                    are_similar(a.expression[1], b.expression[1]) &&\n                    are_similar(a.expression[2], b.expression[2])\n                );\n            case \"function\":\n            case \"regexp\":\n                return false;\n            default:\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function semicolon() {\n\n// Try to match a semicolon.\n\n        if (next_token.id === \";\") {\n            advance(\";\");\n        } else {\n            warn_at(\n                \"expected_a_b\",\n                token.line,\n                token.thru,\n                \";\",\n                artifact(next_token)\n            );\n        }\n        anon = \"anonymous\";\n    }\n\n    function statement() {\n\n// Parse a statement. Any statement may have a label, but only four statements\n// have use for one. A statement can be one of the standard statements, or\n// an assignment expression, or an invocation expression.\n\n        var first;\n        var the_label;\n        var the_statement;\n        var the_symbol;\n        advance();\n        if (token.identifier && next_token.id === \":\") {\n            the_label = token;\n            if (the_label.id === \"ignore\") {\n                warn(\"unexpected_a\", the_label);\n            }\n            advance(\":\");\n            switch (next_token.id) {\n            case \"do\":\n            case \"for\":\n            case \"switch\":\n            case \"while\":\n                enroll(the_label, \"label\", true);\n                the_label.init = true;\n                the_label.dead = false;\n                the_statement = statement();\n                the_statement.label = the_label;\n                the_statement.statement = true;\n                return the_statement;\n            default:\n                advance();\n                warn(\"unexpected_label_a\", the_label);\n            }\n        }\n\n// Parse the statement.\n\n        first = token;\n        first.statement = true;\n        the_symbol = syntax[first.id];\n        if (the_symbol !== undefined && the_symbol.fud !== undefined) {\n            the_symbol.disrupt = false;\n            the_symbol.statement = true;\n            the_statement = the_symbol.fud();\n        } else {\n\n// It is an expression statement.\n\n            the_statement = expression(0, true);\n            if (the_statement.wrapped && the_statement.id !== \"(\") {\n                warn(\"unexpected_a\", first);\n            }\n            semicolon();\n        }\n        if (the_label !== undefined) {\n            the_label.dead = true;\n        }\n        return the_statement;\n    }\n\n    function statements() {\n\n// Parse a list of statements. Give a warning if an unreachable statement\n// follows a disruptive statement.\n\n        var array = [];\n        (function next(disrupt) {\n            var a_statement;\n            switch (next_token.id) {\n            case \"}\":\n            case \"case\":\n            case \"default\":\n            case \"else\":\n            case \"(end)\":\n                break;\n            default:\n                a_statement = statement();\n                array.push(a_statement);\n                if (disrupt) {\n                    warn(\"unreachable_a\", a_statement);\n                }\n                return next(a_statement.disrupt);\n            }\n        }(false));\n        return array;\n    }\n\n    function not_top_level(thing) {\n\n// Some features should not be at the outermost level.\n\n        if (functionage === global) {\n            warn(\"unexpected_at_top_level_a\", thing);\n        }\n    }\n\n    function top_level_only(the_thing) {\n\n// Some features must be at the most outermost level.\n\n        if (blockage !== global) {\n            warn(\"misplaced_a\", the_thing);\n        }\n    }\n\n    function block(special) {\n\n// Parse a block, a sequence of statements wrapped in braces.\n//  special \"body\"      The block is a function body.\n//          \"ignore\"    No warning on an empty block.\n//          \"naked\"     No advance.\n//          undefined   Not special.\n\n        var stmts;\n        var the_block;\n        if (special !== \"naked\") {\n            advance(\"{\");\n        }\n        the_block = token;\n        the_block.arity = \"statement\";\n        the_block.body = special === \"body\";\n\n// All top level function bodies should include the \"use strict\" pragma unless\n\n        if (the_block.body && stack.length <= 1 && !global.strict) {\n            if (\n                next_token.id === \"(string)\" ||\n                next_token.value === \"use strict\"\n            ) {\n                next_token.statement = true;\n                functionage.strict = true;\n                advance(\"(string)\");\n                advance(\";\");\n            } else if (!module_mode) {\n                warn(\n                    \"expected_a_before_b\",\n                    next_token,\n                    \" \\\"use strict\\\"; \",\n                    artifact(next_token)\n                );\n            }\n        }\n        stmts = statements();\n        the_block.block = stmts;\n        if (stmts.length === 0) {\n            if (!option.devel && special !== \"ignore\") {\n                warn(\"empty_block\", the_block);\n            }\n            the_block.disrupt = false;\n        } else {\n            the_block.disrupt = stmts[stmts.length - 1].disrupt;\n        }\n        advance(\"}\");\n        return the_block;\n    }\n\n    function mutation_check(the_thing) {\n\n// The only expressions that may be assigned to are\n//      e.b\n//      e[b]\n//      v\n\n        if (\n            the_thing.id !== \".\" &&\n            (the_thing.id !== \"[\" || the_thing.arity !== \"binary\") &&\n            the_thing.arity !== \"variable\"\n        ) {\n            warn(\"bad_assignment_a\", the_thing);\n            return false;\n        }\n        return true;\n    }\n\n    function left_check(left, right) {\n\n// Warn if the left is not one of these:\n//      e.b\n//      e[b]\n//      e()\n//      identifier\n\n        var id = left.id;\n        if (\n            !left.identifier &&\n            (\n                left.arity !== \"binary\" ||\n                (id !== \".\" && id !== \"(\" && id !== \"[\")\n            )\n        ) {\n            warn(\"unexpected_a\", right);\n            return false;\n        }\n        return true;\n    }\n\n// These functions are used to specify the grammar of our language:\n\n    function symbol(id, bp) {\n\n// Make a symbol if it does not already exist in the language's syntax.\n\n        var the_symbol = syntax[id];\n        if (the_symbol === undefined) {\n            the_symbol = empty();\n            the_symbol.id = id;\n            the_symbol.lbp = bp || 0;\n            syntax[id] = the_symbol;\n        }\n        return the_symbol;\n    }\n\n    function assignment(id) {\n\n// Make an assignment operator. The one true assignment is different because\n// its left side, when it is a variable, is not treated as an expression.\n// That case is special because that is when a variable gets initialized. The\n// other assignment operators can modify, but they cannot initialize.\n\n        var the_symbol = symbol(id, 20);\n        the_symbol.led = function (left) {\n            var the_token = token;\n            var right;\n            the_token.arity = \"assignment\";\n            right = expression(20 - 1);\n            if (id === \"=\" && left.arity === \"variable\") {\n                the_token.names = left;\n                the_token.expression = right;\n            } else {\n                the_token.expression = [left, right];\n            }\n            switch (right.arity) {\n            case \"assignment\":\n            case \"pre\":\n            case \"post\":\n                warn(\"unexpected_a\", right);\n                break;\n            }\n            if (\n                option.es6 &&\n                left.arity === \"unary\" &&\n                (left.id === \"[\" || left.id === \"{\")\n            ) {\n                warn(\"expected_a_before_b\", left, \"const\", left.id);\n            } else {\n                mutation_check(left);\n            }\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function constant(id, type, value) {\n\n// Make a constant symbol.\n\n        var the_symbol = symbol(id);\n        the_symbol.constant = true;\n        the_symbol.nud = (typeof value === \"function\")\n            ? value\n            : function () {\n                token.constant = true;\n                if (value !== undefined) {\n                    token.value = value;\n                }\n                return token;\n            };\n        the_symbol.type = type;\n        the_symbol.value = value;\n        return the_symbol;\n    }\n\n    function infix(id, bp, f) {\n\n// Make an infix operator.\n\n        var the_symbol = symbol(id, bp);\n        the_symbol.led = function (left) {\n            var the_token = token;\n            the_token.arity = \"binary\";\n            if (f !== undefined) {\n                return f(left);\n            }\n            the_token.expression = [left, expression(bp)];\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function post(id) {\n\n// Make one of the post operators.\n\n        var the_symbol = symbol(id, 150);\n        the_symbol.led = function (left) {\n            token.expression = left;\n            token.arity = \"post\";\n            mutation_check(token.expression);\n            return token;\n        };\n        return the_symbol;\n    }\n\n    function pre(id) {\n\n// Make one of the pre operators.\n\n        var the_symbol = symbol(id);\n        the_symbol.nud = function () {\n            var the_token = token;\n            the_token.arity = \"pre\";\n            the_token.expression = expression(150);\n            mutation_check(the_token.expression);\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function prefix(id, f) {\n\n// Make a prefix operator.\n\n        var the_symbol = symbol(id);\n        the_symbol.nud = function () {\n            var the_token = token;\n            the_token.arity = \"unary\";\n            if (typeof f === \"function\") {\n                return f();\n            }\n            the_token.expression = expression(150);\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function stmt(id, f) {\n\n// Make a statement.\n\n        var the_symbol = symbol(id);\n        the_symbol.fud = function () {\n            token.arity = \"statement\";\n            return f();\n        };\n        return the_symbol;\n    }\n\n    function ternary(id1, id2) {\n\n// Make a ternary operator.\n\n        var the_symbol = symbol(id1, 30);\n        the_symbol.led = function (left) {\n            var the_token = token;\n            var second = expression(20);\n            advance(id2);\n            token.arity = \"ternary\";\n            the_token.arity = \"ternary\";\n            the_token.expression = [left, second, expression(10)];\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n// Begin defining the language.\n\n    syntax = empty();\n\n    symbol(\"}\");\n    symbol(\")\");\n    symbol(\"]\");\n    symbol(\",\");\n    symbol(\";\");\n    symbol(\":\");\n    symbol(\"*/\");\n    symbol(\"await\");\n    symbol(\"case\");\n    symbol(\"catch\");\n    symbol(\"class\");\n    symbol(\"default\");\n    symbol(\"else\");\n    symbol(\"enum\");\n    symbol(\"finally\");\n    symbol(\"implements\");\n    symbol(\"interface\");\n    symbol(\"package\");\n    symbol(\"private\");\n    symbol(\"protected\");\n    symbol(\"public\");\n    symbol(\"static\");\n    symbol(\"super\");\n    symbol(\"void\");\n    symbol(\"yield\");\n\n    constant(\"(number)\", \"number\");\n    constant(\"(regexp)\", \"regexp\");\n    constant(\"(string)\", \"string\");\n    constant(\"arguments\", \"object\", function () {\n        if (option.es6) {\n            warn(\"unexpected_a\", token);\n        }\n        return token;\n    });\n    constant(\"eval\", \"function\", function () {\n        if (!option.eval) {\n            warn(\"unexpected_a\", token);\n        } else if (next_token.id !== \"(\") {\n            warn(\"expected_a_before_b\", next_token, \"(\", artifact());\n        }\n        return token;\n    });\n    constant(\"false\", \"boolean\", false);\n    constant(\"Function\", \"function\", function () {\n        if (!option.eval) {\n            warn(\"unexpected_a\", token);\n        } else if (next_token.id !== \"(\") {\n            warn(\"expected_a_before_b\", next_token, \"(\", artifact());\n        }\n        return token;\n    });\n    constant(\"ignore\", \"undefined\", function () {\n        warn(\"unexpected_a\", token);\n        return token;\n    });\n    constant(\"Infinity\", \"number\", Infinity);\n    constant(\"NaN\", \"number\", NaN);\n    constant(\"null\", \"null\", null);\n    constant(\"this\", \"object\", function () {\n        if (!option.this) {\n            warn(\"unexpected_a\", token);\n        }\n        return token;\n    });\n    constant(\"true\", \"boolean\", true);\n    constant(\"undefined\", \"undefined\");\n\n    assignment(\"=\");\n    assignment(\"+=\");\n    assignment(\"-=\");\n    assignment(\"*=\");\n    assignment(\"/=\");\n    assignment(\"%=\");\n    assignment(\"&=\");\n    assignment(\"|=\");\n    assignment(\"^=\");\n    assignment(\"<<=\");\n    assignment(\">>=\");\n    assignment(\">>>=\");\n\n    infix(\"||\", 40);\n    infix(\"&&\", 50);\n    infix(\"|\", 70);\n    infix(\"^\", 80);\n    infix(\"&\", 90);\n    infix(\"==\", 100);\n    infix(\"===\", 100);\n    infix(\"!=\", 100);\n    infix(\"!==\", 100);\n    infix(\"<\", 110);\n    infix(\">\", 110);\n    infix(\"<=\", 110);\n    infix(\">=\", 110);\n    infix(\"in\", 110);\n    infix(\"instanceof\", 110);\n    infix(\"<<\", 120);\n    infix(\">>\", 120);\n    infix(\">>>\", 120);\n    infix(\"+\", 130);\n    infix(\"-\", 130);\n    infix(\"*\", 140);\n    infix(\"/\", 140);\n    infix(\"%\", 140);\n    infix(\"(\", 160, function (left) {\n        var the_paren = token;\n        var the_argument;\n        if (left.id !== \"function\") {\n            left_check(left, the_paren);\n        }\n        if (functionage.arity === \"statement\" && left.identifier) {\n            functionage.name.calls[left.id] = left;\n        }\n        the_paren.expression = [left];\n        if (next_token.id !== \")\") {\n            (function next() {\n                var ellipsis;\n                if (next_token.id === \"...\") {\n                    if (!option.es6) {\n                        warn(\"es6\");\n                    }\n                    ellipsis = true;\n                    advance(\"...\");\n                }\n                the_argument = expression(10);\n                if (ellipsis) {\n                    the_argument.ellipsis = true;\n                }\n                the_paren.expression.push(the_argument);\n                if (next_token.id === \",\") {\n                    advance(\",\");\n                    return next();\n                }\n            }());\n        }\n        advance(\")\", the_paren);\n        if (the_paren.expression.length === 2) {\n            the_paren.free = true;\n            if (the_argument.wrapped === true) {\n                warn(\"unexpected_a\", the_paren);\n            }\n            if (the_argument.id === \"(\") {\n                the_argument.wrapped = true;\n            }\n        } else {\n            the_paren.free = false;\n        }\n        return the_paren;\n    });\n    infix(\".\", 170, function (left) {\n        var the_token = token;\n        var name = next_token;\n        if (\n            (left.id !== \"(string)\" || name.id !== \"indexOf\") &&\n            (left.id !== \"[\" || (\n                name.id !== \"concat\" && name.id !== \"forEach\"\n            )) &&\n            (left.id !== \"+\" || name.id !== \"slice\") &&\n            (left.id !== \"(regexp)\" || (\n                name.id !== \"exec\" && name.id !== \"test\"\n            ))\n        ) {\n            left_check(left, the_token);\n        }\n        if (!name.identifier) {\n            stop(\"expected_identifier_a\");\n        }\n        advance();\n        survey(name);\n\n// The property name is not an expression.\n\n        the_token.name = name;\n        the_token.expression = left;\n        return the_token;\n    });\n    infix(\"[\", 170, function (left) {\n        var the_token = token;\n        var the_subscript = expression(0);\n        if (\n            the_subscript.id === \"(string)\" &&\n            rx_identifier.test(the_subscript.value)\n        ) {\n            warn(\"subscript_a\", the_subscript);\n            survey(the_subscript);\n        } else if (the_subscript.id === \"`\") {\n            warn(\"unexpected_a\", the_subscript);\n        }\n        left_check(left, the_token);\n        the_token.expression = [left, the_subscript];\n        advance(\"]\");\n        return the_token;\n    });\n    infix(\"=>\", 170, function (left) {\n        return stop(\"expected_a_before_b\", left, \"(\", artifact(left));\n    });\n\n    function do_tick() {\n        var the_tick = token;\n        if (!option.es6) {\n            warn(\"es6\", the_tick);\n        }\n        the_tick.value = [];\n        the_tick.expression = [];\n        if (next_token.id !== \"`\") {\n            (function part() {\n                advance(\"(string)\");\n                the_tick.value.push(token);\n                if (next_token.id === \"${\") {\n                    advance(\"${\");\n                    the_tick.expression.push(expression(0));\n                    advance(\"}\");\n                    return part();\n                }\n            }());\n        }\n        advance(\"`\");\n        return the_tick;\n    }\n\n    infix(\"`\", 160, function (left) {\n        var the_tick = do_tick();\n        left_check(left, the_tick);\n        the_tick.expression = [left].concat(the_tick.expression);\n        return the_tick;\n    });\n\n    post(\"++\");\n    post(\"--\");\n    pre(\"++\");\n    pre(\"--\");\n\n    prefix(\"+\");\n    prefix(\"-\");\n    prefix(\"~\");\n    prefix(\"!\");\n    prefix(\"!!\");\n    prefix(\"[\", function () {\n        var the_token = token;\n        the_token.expression = [];\n        if (next_token.id !== \"]\") {\n            (function next() {\n                var element;\n                var ellipsis = false;\n                if (next_token.id === \"...\") {\n                    ellipsis = true;\n                    if (!option.es6) {\n                        warn(\"es6\");\n                    }\n                    advance(\"...\");\n                }\n                element = expression(10);\n                if (ellipsis) {\n                    element.ellipsis = true;\n                }\n                the_token.expression.push(element);\n                if (next_token.id === \",\") {\n                    advance(\",\");\n                    return next();\n                }\n            }());\n        }\n        advance(\"]\");\n        return the_token;\n    });\n    prefix(\"/=\", function () {\n        stop(\"expected_a_b\", token, \"/\\\\=\", \"/=\");\n    });\n    prefix(\"=>\", function () {\n        return stop(\"expected_a_before_b\", token, \"()\", \"=>\");\n    });\n    prefix(\"new\", function () {\n        var the_new = token;\n        var right = expression(160);\n        if (next_token.id !== \"(\") {\n            warn(\"expected_a_before_b\", next_token, \"()\", artifact(next_token));\n        }\n        the_new.expression = right;\n        return the_new;\n    });\n    prefix(\"typeof\");\n    prefix(\"void\", function () {\n        var the_void = token;\n        warn(\"unexpected_a\", the_void);\n        the_void.expression = expression(0);\n        return the_void;\n    });\n\n    function parameter(list, signature) {\n        var ellipsis = false;\n        var param;\n        if (next_token.id === \"{\") {\n            if (!option.es6) {\n                warn(\"es6\");\n            }\n            param = next_token;\n            param.names = [];\n            advance(\"{\");\n            signature.push(\"{\");\n            (function subparameter() {\n                var subparam = next_token;\n                if (!subparam.identifier) {\n                    return stop(\"expected_identifier_a\");\n                }\n                survey(subparam);\n                advance();\n                signature.push(subparam.id);\n                if (next_token.id === \":\") {\n                    advance(\":\");\n                    advance();\n                    token.label = subparam;\n                    subparam = token;\n                    if (!subparam.identifier) {\n                        return stop(\"expected_identifier_a\");\n                    }\n                }\n                param.names.push(subparam);\n                if (next_token.id === \",\") {\n                    advance(\",\");\n                    signature.push(\", \");\n                    return subparameter();\n                }\n            }());\n            list.push(param);\n            advance(\"}\");\n            signature.push(\"}\");\n            if (next_token.id === \",\") {\n                advance(\",\");\n                signature.push(\", \");\n                return parameter(list, signature);\n            }\n        } else if (next_token.id === \"[\") {\n            if (!option.es6) {\n                warn(\"es6\");\n            }\n            param = next_token;\n            param.names = [];\n            advance(\"[\");\n            signature.push(\"[]\");\n            (function subparameter() {\n                var subparam = next_token;\n                if (!subparam.identifier) {\n                    return stop(\"expected_identifier_a\");\n                }\n                advance();\n                param.names.push(subparam);\n                if (next_token.id === \",\") {\n                    advance(\",\");\n                    return subparameter();\n                }\n            }());\n            list.push(param);\n            advance(\"]\");\n            if (next_token.id === \",\") {\n                advance(\",\");\n                signature.push(\", \");\n                return parameter(list, signature);\n            }\n        } else {\n            if (next_token.id === \"...\") {\n                if (!option.es6) {\n                    warn(\"es6\");\n                }\n                ellipsis = true;\n                signature.push(\"...\");\n                advance(\"...\");\n            }\n            if (!next_token.identifier) {\n                return stop(\"expected_identifier_a\");\n            }\n            param = next_token;\n            list.push(param);\n            advance();\n            signature.push(param.id);\n            if (ellipsis) {\n                param.ellipsis = true;\n            } else {\n                if (next_token.id === \"=\") {\n                    if (!option.es6) {\n                        warn(\"es6\");\n                    }\n                    advance(\"=\");\n                    param.expression = expression(0);\n                }\n                if (next_token.id === \",\") {\n                    advance(\",\");\n                    signature.push(\", \");\n                    return parameter(list, signature);\n                }\n            }\n        }\n    }\n\n    function parameter_list() {\n        var list = [];\n        var signature = [\"(\"];\n        if (next_token.id !== \")\" && next_token.id !== \"(end)\") {\n            parameter(list, signature);\n        }\n        advance(\")\");\n        signature.push(\")\");\n        return [list, signature.join(\"\")];\n    }\n\n    function do_function(the_function) {\n        var name;\n        if (the_function === undefined) {\n            the_function = token;\n\n// A function statement must have a name that will be in the parent's scope.\n\n            if (the_function.arity === \"statement\") {\n                if (!next_token.identifier) {\n                    return stop(\"expected_identifier_a\", next_token);\n                }\n                name = next_token;\n                enroll(name, \"variable\", true);\n                the_function.name = name;\n                name.init = true;\n                name.calls = empty();\n                advance();\n            } else if (name === undefined) {\n\n// A function expression may have an optional name.\n\n                if (next_token.identifier) {\n                    name = next_token;\n                    the_function.name = name;\n                    advance();\n                } else {\n                    the_function.name = anon;\n                }\n            }\n        } else {\n            name = the_function.name;\n        }\n        the_function.level = functionage.level + 1;\n        if (mega_mode) {\n            warn(\"unexpected_a\", the_function);\n        }\n\n// Don't make functions in loops. It is inefficient, and it can lead to scoping\n// errors.\n\n        if (functionage.loop > 0) {\n            warn(\"function_in_loop\", the_function);\n        }\n\n// Give the function properties for storing its names and for observing the\n// depth of loops and switches.\n\n        the_function.context = empty();\n        the_function.loop = 0;\n        the_function.switch = 0;\n\n// Push the current function context and establish a new one.\n\n        stack.push(functionage);\n        functions.push(the_function);\n        functionage = the_function;\n        if (the_function.arity !== \"statement\" && name) {\n            enroll(name, \"function\", true);\n            name.dead = false;\n            name.init = true;\n            name.used = 1;\n        }\n\n// Parse the parameter list.\n\n        advance(\"(\");\n        token.free = false;\n        token.arity = \"function\";\n        var pl = parameter_list();\n        functionage.parameters = pl[0];\n        functionage.signature = pl[1];\n        functionage.parameters.forEach(function enroll_parameter(name) {\n            if (name.identifier) {\n                enroll(name, \"parameter\", false);\n            } else {\n                name.names.forEach(enroll_parameter);\n            }\n        });\n\n// The function's body is a block.\n\n        the_function.block = block(\"body\");\n        if (\n            the_function.arity === \"statement\" &&\n            next_token.line === token.line\n        ) {\n            return stop(\"unexpected_a\", next_token);\n        }\n        if (next_token.id === \".\" || next_token.id === \"[\") {\n            warn(\"unexpected_a\");\n        }\n\n// Restore the previous context.\n\n        functionage = stack.pop();\n        return the_function;\n    }\n\n    prefix(\"function\", do_function);\n\n    function fart(pl) {\n        if (next_token.id === \";\") {\n            stop(\"wrap_assignment\", token);\n        }\n        advance(\"=>\");\n        var the_arrow = token;\n        the_arrow.arity = \"binary\";\n        the_arrow.name = \"=>\";\n        the_arrow.level = functionage.level + 1;\n        functions.push(the_arrow);\n        if (functionage.loop > 0) {\n            warn(\"function_in_loop\", the_arrow);\n        }\n\n// Give the function properties storing its names and for observing the depth\n// of loops and switches.\n\n        the_arrow.context = empty();\n        the_arrow.loop = 0;\n        the_arrow.switch = 0;\n\n// Push the current function context and establish a new one.\n\n        stack.push(functionage);\n        functionage = the_arrow;\n        the_arrow.parameters = pl[0];\n        the_arrow.signature = pl[1];\n        the_arrow.parameters.forEach(function (name) {\n            enroll(name, \"parameter\", true);\n        });\n        if (!option.es6) {\n            warn(\"es6\", the_arrow);\n        }\n        if (next_token.id === \"{\") {\n            warn(\"expected_a_b\", the_arrow, \"function\", \"=>\");\n            the_arrow.block = block(\"body\");\n        } else {\n            the_arrow.expression = expression(0);\n        }\n        functionage = stack.pop();\n        return the_arrow;\n    }\n\n    prefix(\"(\", function () {\n        var the_paren = token;\n        var the_value;\n        var cadet = lookahead().id;\n\n// We can distinguish between a parameter list for => and a wrapped expression\n// with one token of lookahead.\n\n        if (\n            next_token.id === \")\" ||\n            next_token.id === \"...\" ||\n            (next_token.identifier && (cadet === \",\" || cadet === \"=\"))\n        ) {\n            the_paren.free = false;\n            return fart(parameter_list());\n        }\n        the_paren.free = true;\n        the_value = expression(0);\n        if (the_value.wrapped === true) {\n            warn(\"unexpected_a\", the_paren);\n        }\n        the_value.wrapped = true;\n        advance(\")\", the_paren);\n        if (next_token.id === \"=>\") {\n            if (the_value.arity !== \"variable\") {\n                if (the_value.id === \"{\" || the_value.id === \"[\") {\n                    warn(\"expected_a_before_b\", the_paren, \"function\", \"(\");\n                    return stop(\"expected_a_b\", next_token, \"{\", \"=>\");\n                }\n                return stop(\"expected_identifier_a\", the_value);\n            }\n            the_paren.expression = [the_value];\n            return fart([the_paren.expression, \"(\" + the_value.id + \")\"]);\n        }\n        return the_value;\n    });\n    prefix(\"`\", do_tick);\n    prefix(\"{\", function () {\n        var the_brace = token;\n        var seen = empty();\n        the_brace.expression = [];\n        if (next_token.id !== \"}\") {\n            (function member() {\n                var extra = true;\n                var id;\n                var name = next_token;\n                var value;\n                advance();\n                if (\n                    (name.id === \"get\" || name.id === \"set\") &&\n                    next_token.identifier\n                ) {\n                    extra = name.id;\n                    name = next_token;\n                    advance();\n                }\n                id = survey(name);\n                if (seen[id] === true) {\n                    warn(\"duplicate_a\", name);\n                } else if (seen[id] === \"get\" && extra !== \"set\") {\n                    warn(\"expected_a_before_b\", name, \"set\", artifact(name));\n                }\n                seen[id] = (extra === \"get\")\n                    ? \"get\"\n                    : true;\n                if (name.identifier) {\n                    switch (next_token.id) {\n                    case \"}\":\n                    case \",\":\n                        if (!option.es6) {\n                            warn(\"es6\");\n                        } else if (extra !== true) {\n                            advance(\":\");\n                        }\n                        value = expression(Infinity, true);\n                        break;\n                    case \"(\":\n                        if (!option.es6 && typeof extra !== \"string\") {\n                            warn(\"es6\");\n                        }\n                        value = do_function({\n                            arity: \"unary\",\n                            from: name.from,\n                            id: \"function\",\n                            line: name.line,\n                            name: name,\n                            thru: name.from\n                        }, name);\n                        break;\n                    default:\n                        advance(\":\");\n                        value = expression(0);\n                    }\n                    value.label = name;\n                    if (typeof extra === \"string\") {\n                        value.extra = extra;\n                    }\n                    the_brace.expression.push(value);\n                } else {\n                    advance(\":\");\n                    value = expression(0);\n                    value.label = name;\n                    the_brace.expression.push(value);\n                }\n                if (next_token.id === \",\") {\n                    advance(\",\");\n                    return member();\n                }\n            }());\n        }\n        advance(\"}\");\n        return the_brace;\n    });\n\n    stmt(\";\", function () {\n        warn(\"unexpected_a\", token);\n        return token;\n    });\n    stmt(\"{\", function () {\n        warn(\"naked_block\", token);\n        return block(\"naked\");\n    });\n    stmt(\"break\", function () {\n        var the_break = token;\n        var the_label;\n        if (functionage.loop < 1 && functionage.switch < 1) {\n            warn(\"unexpected_a\", the_break);\n        }\n        the_break.disrupt = true;\n        if (next_token.identifier && token.line === next_token.line) {\n            the_label = functionage.context[next_token.id];\n            if (\n                the_label === undefined ||\n                the_label.role !== \"label\" ||\n                the_label.dead\n            ) {\n                warn((the_label !== undefined && the_label.dead)\n                    ? \"out_of_scope_a\"\n                    : \"not_label_a\");\n            } else {\n                the_label.used += 1;\n            }\n            the_break.label = next_token;\n            advance();\n        }\n        advance(\";\");\n        return the_break;\n    });\n\n    function do_var() {\n        var the_statement = token;\n        var is_const = the_statement.id === \"const\";\n        the_statement.names = [];\n\n// A program may use var or let, but not both, and let and const require\n// option.es6.\n\n        if (is_const) {\n            if (!option.es6) {\n                warn(\"es6\", the_statement);\n            }\n        } else if (var_mode === undefined) {\n            var_mode = the_statement.id;\n            if (!option.es6 && var_mode !== \"var\") {\n                warn(\"es6\", the_statement);\n            }\n        } else if (the_statement.id !== var_mode) {\n            warn(\n                \"expected_a_b\",\n                the_statement,\n                var_mode,\n                the_statement.id\n            );\n        }\n\n// We don't expect to see variables created in switch statements.\n\n        if (functionage.switch > 0) {\n            warn(\"var_switch\", the_statement);\n        }\n        if (functionage.loop > 0 && the_statement.id === \"var\") {\n            warn(\"var_loop\", the_statement);\n        }\n        (function next() {\n            if (next_token.id === \"{\" && the_statement.id !== \"var\") {\n                var the_brace = next_token;\n                the_brace.names = [];\n                advance(\"{\");\n                (function pair() {\n                    if (!next_token.identifier) {\n                        return stop(\"expected_identifier_a\", next_token);\n                    }\n                    var name = next_token;\n                    survey(name);\n                    advance();\n                    if (next_token.id === \":\") {\n                        advance(\":\");\n                        if (!next_token.identifier) {\n                            return stop(\"expected_identifier_a\", next_token);\n                        }\n                        next_token.label = name;\n                        the_brace.names.push(next_token);\n                        enroll(next_token, \"variable\", is_const);\n                        advance();\n                    } else {\n                        the_brace.names.push(name);\n                        enroll(name, \"variable\", is_const);\n                    }\n                    if (next_token.id === \",\") {\n                        advance(\",\");\n                        return pair();\n                    }\n                }());\n                advance(\"}\");\n                advance(\"=\");\n                the_brace.expression = expression(0);\n                the_statement.names.push(the_brace);\n            } else if (next_token.id === \"[\" && the_statement.id !== \"var\") {\n                var the_bracket = next_token;\n                the_bracket.names = [];\n                advance(\"[\");\n                (function element() {\n                    var ellipsis;\n                    if (next_token.id === \"...\") {\n                        ellipsis = true;\n                        advance(\"...\");\n                    }\n                    if (!next_token.identifier) {\n                        return stop(\"expected_identifier_a\", next_token);\n                    }\n                    var name = next_token;\n                    advance();\n                    the_bracket.names.push(name);\n                    enroll(name, \"variable\", the_statement.id === \"const\");\n                    if (ellipsis) {\n                        name.ellipsis = true;\n                    } else if (next_token.id === \",\") {\n                        advance(\",\");\n                        return element();\n                    }\n                }());\n                advance(\"]\");\n                advance(\"=\");\n                the_bracket.expression = expression(0);\n                the_statement.names.push(the_bracket);\n            } else if (next_token.identifier) {\n                var name = next_token;\n                advance();\n                if (name.id === \"ignore\") {\n                    warn(\"unexpected_a\", name);\n                }\n                enroll(name, \"variable\", is_const);\n                if (next_token.id === \"=\" || is_const) {\n                    advance(\"=\");\n                    name.expression = expression(0);\n                    name.init = true;\n                }\n                the_statement.names.push(name);\n            } else {\n                return stop(\"expected_identifier_a\", next_token);\n            }\n            if (next_token.id === \",\") {\n                if (!option.multivar) {\n                    warn(\"expected_a_b\", next_token, \";\", \",\");\n                }\n                advance(\",\");\n                return next();\n            }\n        }());\n        the_statement.open =\n                the_statement.names.length > 1 &&\n                the_statement.line !== the_statement.names[1].line;\n        semicolon();\n        return the_statement;\n    }\n\n    stmt(\"const\", do_var);\n    stmt(\"continue\", function () {\n        var the_continue = token;\n        if (functionage.loop < 1) {\n            warn(\"unexpected_a\", the_continue);\n        }\n        not_top_level(the_continue);\n        the_continue.disrupt = true;\n        warn(\"unexpected_a\", the_continue);\n        advance(\";\");\n        return the_continue;\n    });\n    stmt(\"debugger\", function () {\n        var the_debug = token;\n        if (!option.devel) {\n            warn(\"unexpected_a\", the_debug);\n        }\n        semicolon();\n        return the_debug;\n    });\n    stmt(\"delete\", function () {\n        var the_token = token;\n        var the_value = expression(0);\n        if (\n            (the_value.id !== \".\" && the_value.id !== \"[\") ||\n            the_value.arity !== \"binary\"\n        ) {\n            stop(\"expected_a_b\", the_value, \".\", artifact(the_value));\n        }\n        the_token.expression = the_value;\n        semicolon();\n        return the_token;\n    });\n    stmt(\"do\", function () {\n        var the_do = token;\n        not_top_level(the_do);\n        functionage.loop += 1;\n        the_do.block = block();\n        advance(\"while\");\n        the_do.expression = condition();\n        semicolon();\n        if (the_do.block.disrupt === true) {\n            warn(\"weird_loop\", the_do);\n        }\n        functionage.loop -= 1;\n        return the_do;\n    });\n    stmt(\"export\", function () {\n        var the_export = token;\n        if (!option.es6) {\n            warn(\"es6\", the_export);\n        }\n        if (typeof module_mode === \"object\") {\n            warn(\"unexpected_directive_a\", module_mode, module_mode.directive);\n        }\n        advance(\"default\");\n        if (export_mode) {\n            warn(\"duplicate_a\", token);\n        }\n        global.strict = true;\n        module_mode = true;\n        export_mode = true;\n        the_export.expression = expression(0);\n        semicolon();\n        return the_export;\n    });\n    stmt(\"for\", function () {\n        var first;\n        var the_for = token;\n        if (!option.for) {\n            warn(\"unexpected_a\", the_for);\n        }\n        not_top_level(the_for);\n        functionage.loop += 1;\n        advance(\"(\");\n        token.free = true;\n        if (next_token.id === \";\") {\n            return stop(\"expected_a_b\", the_for, \"while (\", \"for (;\");\n        }\n        if (\n            next_token.id === \"var\" ||\n            next_token.id === \"let\" ||\n            next_token.id === \"const\"\n        ) {\n            return stop(\"unexpected_a\");\n        }\n        first = expression(0);\n        if (first.id === \"in\") {\n            if (first.expression[0].arity !== \"variable\") {\n                warn(\"bad_assignment_a\", first.expression[0]);\n            }\n            the_for.name = first.expression[0];\n            the_for.expression = first.expression[1];\n            warn(\"expected_a_b\", the_for, \"Object.keys\", \"for in\");\n        } else {\n            the_for.initial = first;\n            advance(\";\");\n            the_for.expression = expression(0);\n            advance(\";\");\n            the_for.inc = expression(0);\n            if (the_for.inc.id === \"++\") {\n                warn(\"expected_a_b\", the_for.inc, \"+= 1\", \"++\");\n            }\n        }\n        advance(\")\");\n        the_for.block = block();\n        if (the_for.block.disrupt === true) {\n            warn(\"weird_loop\", the_for);\n        }\n        functionage.loop -= 1;\n        return the_for;\n    });\n    stmt(\"function\", do_function);\n    stmt(\"if\", function () {\n        var the_else;\n        var the_if = token;\n        the_if.expression = condition();\n        the_if.block = block();\n        if (next_token.id === \"else\") {\n            advance(\"else\");\n            the_else = token;\n            the_if.else = (next_token.id === \"if\")\n                ? statement()\n                : block();\n            if (the_if.block.disrupt === true) {\n                if (the_if.else.disrupt === true) {\n                    the_if.disrupt = true;\n                } else {\n                    warn(\"unexpected_a\", the_else);\n                }\n            }\n        }\n        return the_if;\n    });\n    stmt(\"import\", function () {\n        var the_import = token;\n        if (!option.es6) {\n            warn(\"es6\", the_import);\n        } else if (typeof module_mode === \"object\") {\n            warn(\"unexpected_directive_a\", module_mode, module_mode.directive);\n        }\n        module_mode = true;\n        if (!next_token.identifier) {\n            return stop(\"expected_identifier_a\");\n        }\n        var name = next_token;\n        advance();\n        if (name.id === \"ignore\") {\n            warn(\"unexpected_a\", name);\n        }\n        enroll(name, \"variable\", true);\n        advance(\"from\");\n        advance(\"(string)\");\n        the_import.import = token;\n        the_import.name = name;\n        if (!rx_identifier.test(token.value)) {\n            warn(\"bad_module_name_a\", token);\n        }\n        imports.push(token.value);\n        semicolon();\n        return the_import;\n    });\n    stmt(\"let\", do_var);\n    stmt(\"return\", function () {\n        var the_return = token;\n        not_top_level(the_return);\n        the_return.disrupt = true;\n        if (next_token.id !== \";\" && the_return.line === next_token.line) {\n            the_return.expression = expression(10);\n        }\n        advance(\";\");\n        return the_return;\n    });\n    stmt(\"switch\", function () {\n        var dups = [];\n        var last;\n        var stmts;\n        var the_cases = [];\n        var the_disrupt = true;\n        var the_switch = token;\n        not_top_level(the_switch);\n        functionage.switch += 1;\n        advance(\"(\");\n        token.free = true;\n        the_switch.expression = expression(0);\n        the_switch.block = the_cases;\n        advance(\")\");\n        advance(\"{\");\n        (function major() {\n            var the_case = next_token;\n            the_case.arity = \"statement\";\n            the_case.expression = [];\n            (function minor() {\n                advance(\"case\");\n                token.switch = true;\n                var exp = expression(0);\n                if (dups.some(function (thing) {\n                    return are_similar(thing, exp);\n                })) {\n                    warn(\"unexpected_a\", exp);\n                }\n                dups.push(exp);\n                the_case.expression.push(exp);\n                advance(\":\");\n                if (next_token.id === \"case\") {\n                    return minor();\n                }\n            }());\n            stmts = statements();\n            if (stmts.length < 1) {\n                warn(\"expected_statements_a\");\n                return;\n            }\n            the_case.block = stmts;\n            the_cases.push(the_case);\n            last = stmts[stmts.length - 1];\n            if (last.disrupt) {\n                if (last.id === \"break\" && last.label === undefined) {\n                    the_disrupt = false;\n                }\n            } else {\n                warn(\n                    \"expected_a_before_b\",\n                    next_token,\n                    \"break;\",\n                    artifact(next_token)\n                );\n            }\n            if (next_token.id === \"case\") {\n                return major();\n            }\n        }());\n        dups = undefined;\n        if (next_token.id === \"default\") {\n            var the_default = next_token;\n            advance(\"default\");\n            token.switch = true;\n            advance(\":\");\n            the_switch.else = statements();\n            if (the_switch.else.length < 1) {\n                warn(\"unexpected_a\", the_default);\n                the_disrupt = false;\n            } else {\n                var the_last = the_switch.else[the_switch.else.length - 1];\n                if (the_last.id === \"break\" && the_last.label === undefined) {\n                    warn(\"unexpected_a\", the_last);\n                    the_last.disrupt = false;\n                }\n                the_disrupt = the_disrupt && the_last.disrupt;\n            }\n        } else {\n            the_disrupt = false;\n        }\n        advance(\"}\", the_switch);\n        functionage.switch -= 1;\n        the_switch.disrupt = the_disrupt;\n        return the_switch;\n    });\n    stmt(\"throw\", function () {\n        var the_throw = token;\n        the_throw.disrupt = true;\n        the_throw.expression = expression(10);\n        semicolon();\n        return the_throw;\n    });\n    stmt(\"try\", function () {\n        var clause = false;\n        var the_catch;\n        var the_disrupt;\n        var the_try = token;\n        the_try.block = block();\n        the_disrupt = the_try.block.disrupt;\n        if (next_token.id === \"catch\") {\n            var ignored = \"ignore\";\n            clause = true;\n            the_catch = next_token;\n            the_try.catch = the_catch;\n            advance(\"catch\");\n            advance(\"(\");\n            if (!next_token.identifier) {\n                return stop(\"expected_identifier_a\", next_token);\n            }\n            if (next_token.id !== \"ignore\") {\n                ignored = undefined;\n                the_catch.name = next_token;\n                enroll(next_token, \"exception\", true);\n            }\n            advance();\n            advance(\")\");\n            the_catch.block = block(ignored);\n            if (the_catch.block.disrupt !== true) {\n                the_disrupt = false;\n            }\n        }\n        if (next_token.id === \"finally\") {\n            clause = true;\n            advance(\"finally\");\n            the_try.else = block();\n            the_disrupt = the_try.else.disrupt;\n        }\n        the_try.disrupt = the_disrupt;\n        if (!clause) {\n            warn(\n                \"expected_a_before_b\",\n                next_token,\n                \"catch\",\n                artifact(next_token)\n            );\n        }\n        return the_try;\n    });\n    stmt(\"var\", do_var);\n    stmt(\"while\", function () {\n        var the_while = token;\n        not_top_level(the_while);\n        functionage.loop += 1;\n        the_while.expression = condition();\n        the_while.block = block();\n        if (the_while.block.disrupt === true) {\n            warn(\"weird_loop\", the_while);\n        }\n        functionage.loop -= 1;\n        return the_while;\n    });\n    stmt(\"with\", function () {\n        stop(\"unexpected_a\", token);\n    });\n\n    ternary(\"?\", \":\");\n\n// Ambulation of the parse tree.\n\n    function action(when) {\n\n// Produce a function that will register task functions that will be called as\n// the tree is traversed.\n\n        return function (arity, id, task) {\n            var a_set = when[arity];\n            var i_set;\n\n// The id parameter is optional. If excluded, the task will be applied to all\n// ids.\n\n            if (typeof id !== \"string\") {\n                task = id;\n                id = \"(all)\";\n            }\n\n// If this arity has no registrations yet, then create a set object to hold\n// them.\n\n            if (a_set === undefined) {\n                a_set = empty();\n                when[arity] = a_set;\n            }\n\n// If this id has no registrations yet, then create a set array to hold them.\n\n            i_set = a_set[id];\n            if (i_set === undefined) {\n                i_set = [];\n                a_set[id] = i_set;\n            }\n\n// Register the task with the arity and the id.\n\n            i_set.push(task);\n        };\n    }\n\n    function amble(when) {\n\n// Produce a function that will act on the tasks registered by an action\n// function while walking the tree.\n\n        return function (the_token) {\n\n// Given a task set that was built by an action function, run all of the\n// relevant tasks on the token.\n\n            var a_set = when[the_token.arity];\n            var i_set;\n\n// If there are tasks associated with the token's arity...\n\n            if (a_set !== undefined) {\n\n// If there are tasks associated with the token's id...\n\n                i_set = a_set[the_token.id];\n                if (i_set !== undefined) {\n                    i_set.forEach(function (task) {\n                        return task(the_token);\n                    });\n                }\n\n// If there are tasks for all ids.\n\n                i_set = a_set[\"(all)\"];\n                if (i_set !== undefined) {\n                    i_set.forEach(function (task) {\n                        return task(the_token);\n                    });\n                }\n            }\n        };\n    }\n\n    var posts = empty();\n    var pres = empty();\n    var preaction = action(pres);\n    var postaction = action(posts);\n    var preamble = amble(pres);\n    var postamble = amble(posts);\n\n    function walk_expression(thing) {\n        if (thing) {\n            if (Array.isArray(thing)) {\n                thing.forEach(walk_expression);\n            } else {\n                preamble(thing);\n                walk_expression(thing.expression);\n                if (thing.id === \"function\") {\n                    walk_statement(thing.block);\n                }\n                switch (thing.arity) {\n                case \"post\":\n                case \"pre\":\n                    warn(\"unexpected_a\", thing);\n                    break;\n                case \"statement\":\n                case \"assignment\":\n                    warn(\"unexpected_statement_a\", thing);\n                    break;\n                }\n                postamble(thing);\n            }\n        }\n    }\n\n    function walk_statement(thing) {\n        if (thing) {\n            if (Array.isArray(thing)) {\n                thing.forEach(walk_statement);\n            } else {\n                preamble(thing);\n                walk_expression(thing.expression);\n                switch (thing.arity) {\n                case \"statement\":\n                case \"assignment\":\n                    break;\n                case \"binary\":\n                    if (thing.id !== \"(\") {\n                        warn(\"unexpected_expression_a\", thing);\n                    }\n                    break;\n                default:\n                    warn(\"unexpected_expression_a\", thing);\n                }\n                walk_statement(thing.block);\n                walk_statement(thing.else);\n                postamble(thing);\n            }\n        }\n    }\n\n    function lookup(thing) {\n        if (thing.arity === \"variable\") {\n\n// Look up the variable in the current context.\n\n            var the_variable = functionage.context[thing.id];\n\n// If it isn't local, search all the other contexts. If there are name\n// collisions, take the most recent.\n\n            if (the_variable === undefined) {\n                stack.forEach(function (outer) {\n                    var a_variable = outer.context[thing.id];\n                    if (\n                        a_variable !== undefined &&\n                        a_variable.role !== \"label\"\n                    ) {\n                        the_variable = a_variable;\n                    }\n                });\n\n// If it isn't in any of those either, perhaps it is a predefined global.\n// If so, add it to the global context.\n\n                if (the_variable === undefined) {\n                    if (declared_globals[thing.id] === undefined) {\n                        warn(\"undeclared_a\", thing);\n                        return;\n                    }\n                    the_variable = {\n                        dead: false,\n                        function: global,\n                        id: thing.id,\n                        init: true,\n                        role: \"variable\",\n                        used: 0,\n                        writable: false\n                    };\n                    global.context[thing.id] = the_variable;\n                }\n                the_variable.closure = true;\n                functionage.context[thing.id] = the_variable;\n            } else if (the_variable.role === \"label\") {\n                warn(\"label_a\", thing);\n            }\n            if (the_variable.dead) {\n                warn(\"out_of_scope_a\", thing);\n            }\n            return the_variable;\n        }\n    }\n\n    function subactivate(name) {\n        name.init = true;\n        name.dead = false;\n        blockage.live.push(name);\n    }\n\n    function preaction_function(thing) {\n        if (thing.arity === \"statement\" && blockage.body !== true) {\n            warn(\"unexpected_a\", thing);\n        }\n        stack.push(functionage);\n        block_stack.push(blockage);\n        functionage = thing;\n        blockage = thing;\n        thing.live = [];\n        if (typeof thing.name === \"object\") {\n            thing.name.dead = false;\n            thing.name.init = true;\n        }\n        switch (thing.extra) {\n        case \"get\":\n            if (thing.parameters.length !== 0) {\n                warn(\"bad_get\", thing);\n            }\n            break;\n        case \"set\":\n            if (thing.parameters.length !== 1) {\n                warn(\"bad_set\", thing);\n            }\n            break;\n        }\n        thing.parameters.forEach(function (name) {\n            walk_expression(name.expression);\n            if (name.id === \"{\" || name.id === \"[\") {\n                name.names.forEach(subactivate);\n            } else {\n                name.dead = false;\n                name.init = true;\n            }\n        });\n    }\n\n    function bitwise_check(thing) {\n        if (!option.bitwise && bitwiseop[thing.id] === true) {\n            warn(\"unexpected_a\", thing);\n        }\n        if (\n            thing.id !== \"(\" &&\n            thing.id !== \"&&\" &&\n            thing.id !== \"||\" &&\n            thing.id !== \"=\" &&\n            Array.isArray(thing.expression) &&\n            thing.expression.length === 2 && (\n                relationop[thing.expression[0].id] === true ||\n                relationop[thing.expression[1].id] === true\n            )\n        ) {\n            warn(\"unexpected_a\", thing);\n        }\n    }\n\n    function pop_block() {\n        blockage.live.forEach(function (name) {\n            name.dead = true;\n        });\n        delete blockage.live;\n        blockage = block_stack.pop();\n    }\n\n    function activate(name) {\n        if (name.expression !== undefined) {\n            walk_expression(name.expression);\n            if (name.id === \"{\" || name.id === \"[\") {\n                name.names.forEach(subactivate);\n            } else {\n                name.init = true;\n            }\n        }\n        name.dead = false;\n        blockage.live.push(name);\n    }\n\n    function action_var(thing) {\n        thing.names.forEach(activate);\n    }\n\n    preaction(\"assignment\", bitwise_check);\n    preaction(\"binary\", bitwise_check);\n    preaction(\"binary\", function (thing) {\n        if (relationop[thing.id] === true) {\n            var left = thing.expression[0];\n            var right = thing.expression[1];\n            if (left.id === \"NaN\" || right.id === \"NaN\") {\n                warn(\"isNaN\", thing);\n            } else if (left.id === \"typeof\") {\n                if (right.id !== \"(string)\") {\n                    if (right.id !== \"typeof\") {\n                        warn(\"expected_string_a\", right);\n                    }\n                } else {\n                    var value = right.value;\n                    if (value === \"symbol\") {\n                        if (!option.es6) {\n                            warn(\"es6\", right, value);\n                        }\n                    } else if (value === \"null\" || value === \"undefined\") {\n                        warn(\"unexpected_typeof_a\", right, value);\n                    } else if (\n                        value !== \"boolean\" &&\n                        value !== \"function\" &&\n                        value !== \"number\" &&\n                        value !== \"object\" &&\n                        value !== \"string\"\n                    ) {\n                        warn(\"expected_type_string_a\", right, value);\n                    }\n                }\n            }\n        }\n    });\n    preaction(\"binary\", \"==\", function (thing) {\n        warn(\"expected_a_b\", thing, \"===\", \"==\");\n    });\n    preaction(\"binary\", \"!=\", function (thing) {\n        warn(\"expected_a_b\", thing, \"!==\", \"!=\");\n    });\n    preaction(\"binary\", \"=>\", preaction_function);\n    preaction(\"binary\", \"||\", function (thing) {\n        thing.expression.forEach(function (thang) {\n            if (thang.id === \"&&\" && !thang.wrapped) {\n                warn(\"and\", thang);\n            }\n        });\n    });\n    preaction(\"binary\", \"(\", function (thing) {\n        var left = thing.expression[0];\n        if (\n            left.identifier &&\n            functionage.context[left.id] === undefined &&\n            typeof functionage.name === \"object\"\n        ) {\n            var parent = functionage.name.function;\n            if (parent) {\n                var left_variable = parent.context[left.id];\n                if (\n                    left_variable !== undefined &&\n                    left_variable.dead &&\n                    left_variable.function === parent &&\n                    left_variable.calls !== undefined &&\n                    left_variable.calls[functionage.name.id] !== undefined\n                ) {\n                    left_variable.dead = false;\n                }\n            }\n        }\n    });\n    preaction(\"binary\", \"in\", function (thing) {\n        warn(\"infix_in\", thing);\n    });\n    preaction(\"binary\", \"instanceof\", function (thing) {\n        warn(\"unexpected_a\", thing);\n    });\n    preaction(\"binary\", \".\", function (thing) {\n        if (thing.expression.new) {\n            thing.new = true;\n        }\n    });\n    preaction(\"statement\", \"{\", function (thing) {\n        block_stack.push(blockage);\n        blockage = thing;\n        thing.live = [];\n    });\n    preaction(\"statement\", \"for\", function (thing) {\n        if (thing.name !== undefined) {\n            var the_variable = lookup(thing.name);\n            if (the_variable !== undefined) {\n                the_variable.init = true;\n                if (!the_variable.writable) {\n                    warn(\"bad_assignment_a\", thing.name);\n                }\n            }\n        }\n        walk_statement(thing.initial);\n    });\n    preaction(\"statement\", \"function\", preaction_function);\n    preaction(\"unary\", \"~\", bitwise_check);\n    preaction(\"unary\", \"function\", preaction_function);\n    preaction(\"variable\", function (thing) {\n        var the_variable = lookup(thing);\n        if (the_variable !== undefined) {\n            thing.variable = the_variable;\n            the_variable.used += 1;\n        }\n    });\n\n    function init_variable(name) {\n        var the_variable = lookup(name);\n        if (the_variable !== undefined) {\n            if (the_variable.writable) {\n                the_variable.init = true;\n                return;\n            }\n        }\n        warn(\"bad_assignment_a\", name);\n    }\n\n    postaction(\"assignment\", function (thing) {\n\n// Assignment using = sets the init property of a variable. No other assignment\n// operator can do this. A = token keeps that variable (or array of variables\n// in case of destructuring) in its name property.\n\n        var lvalue = thing.expression[0];\n        if (thing.id === \"=\") {\n            if (thing.names !== undefined) {\n                if (Array.isArray(thing.names)) {\n                    thing.names.forEach(init_variable);\n                } else {\n                    init_variable(thing.names);\n                }\n            } else {\n                if (\n                    lvalue.id === \".\" &&\n                    thing.expression[1].id === \"undefined\"\n                ) {\n                    warn(\n                        \"expected_a_b\",\n                        lvalue.expression,\n                        \"delete\",\n                        \"undefined\"\n                    );\n                }\n            }\n        } else {\n            if (lvalue.arity === \"variable\") {\n                if (!lvalue.variable || lvalue.variable.writable !== true) {\n                    warn(\"bad_assignment_a\", lvalue);\n                }\n            }\n            var right = syntax[thing.expression[1].id];\n            if (\n                right !== undefined &&\n                (\n                    right.id === \"function\" ||\n                    right.id === \"=>\" ||\n                    (\n                        right.constant &&\n                        right.id !== \"(number)\" &&\n                        (right.id !== \"(string)\" || thing.id !== \"+=\")\n                    )\n                )\n            ) {\n                warn(\"unexpected_a\", thing.expression[1]);\n            }\n        }\n    });\n\n    function postaction_function(thing) {\n        delete functionage.loop;\n        delete functionage.switch;\n        functionage = stack.pop();\n        if (thing.wrapped) {\n            warn(\"unexpected_parens\", thing);\n        }\n        if (typeof thing.name === \"object\") {\n            thing.name.used = 0;\n        }\n        return pop_block();\n    }\n\n    postaction(\"binary\", function (thing) {\n        var right;\n        if (relationop[thing.id]) {\n            if (\n                is_weird(thing.expression[0]) ||\n                is_weird(thing.expression[1]) ||\n                are_similar(thing.expression[0], thing.expression[1]) ||\n                (\n                    thing.expression[0].constant === true &&\n                    thing.expression[1].constant === true\n                )\n            ) {\n                warn(\"weird_relation_a\", thing);\n            }\n        }\n        switch (thing.id) {\n        case \"+\":\n        case \"-\":\n            right = thing.expression[1];\n            if (\n                right.id === thing.id &&\n                right.arity === \"unary\" &&\n                !right.wrapped\n            ) {\n                warn(\"wrap_unary\", right);\n            }\n            break;\n        case \"=>\":\n        case \"(\":\n            break;\n        case \".\":\n            if (thing.expression.id === \"RegExp\") {\n                warn(\"weird_expression_a\", thing);\n            }\n            break;\n        default:\n            if (\n                thing.expression[0].constant === true &&\n                thing.expression[1].constant === true\n            ) {\n                thing.constant = true;\n            }\n        }\n    });\n    postaction(\"binary\", \"&&\", function (thing) {\n        if (\n            is_weird(thing.expression[0]) ||\n            are_similar(thing.expression[0], thing.expression[1]) ||\n            thing.expression[0].constant === true ||\n            thing.expression[1].constant === true\n        ) {\n            warn(\"weird_condition_a\", thing);\n        }\n    });\n    postaction(\"binary\", \"||\", function (thing) {\n        if (\n            is_weird(thing.expression[0]) ||\n            are_similar(thing.expression[0], thing.expression[1]) ||\n            thing.expression[0].constant === true\n        ) {\n            warn(\"weird_condition_a\", thing);\n        }\n    });\n    postaction(\"binary\", \"=>\", postaction_function);\n    postaction(\"binary\", \"(\", function (thing) {\n        var left = thing.expression[0];\n        var the_new;\n        if (left.id === \"new\") {\n            the_new = left;\n            left = left.expression;\n        }\n        if (left.id === \"function\") {\n            if (!thing.wrapped) {\n                warn(\"wrap_immediate\", thing);\n            }\n        } else if (left.identifier) {\n            if (the_new !== undefined) {\n                if (\n                    left.id.charAt(0) > \"Z\" ||\n                    left.id === \"Boolean\" ||\n                    left.id === \"Number\" ||\n                    left.id === \"String\" ||\n                    (left.id === \"Symbol\" && option.es6)\n                ) {\n                    warn(\"unexpected_a\", the_new);\n                } else if (left.id === \"Function\") {\n                    if (!option.eval) {\n                        warn(\"unexpected_a\", left, \"new Function\");\n                    }\n                } else if (left.id === \"Array\") {\n                    warn(\"expected_a_b\", left, \"[]\", \"new Array\");\n                } else if (left.id === \"Object\") {\n                    warn(\n                        \"expected_a_b\",\n                        left,\n                        \"Object.create(null)\",\n                        \"new Object\"\n                    );\n                }\n            } else {\n                if (\n                    left.id.charAt(0) >= \"A\" &&\n                    left.id.charAt(0) <= \"Z\" &&\n                    left.id !== \"Boolean\" &&\n                    left.id !== \"Number\" &&\n                    left.id !== \"String\" &&\n                    left.id !== \"Symbol\"\n                ) {\n                    warn(\n                        \"expected_a_before_b\",\n                        left,\n                        \"new\",\n                        artifact(left)\n                    );\n                }\n            }\n        } else if (left.id === \".\") {\n            var cack = the_new !== undefined;\n            if (left.expression.id === \"Date\" && left.name.id === \"UTC\") {\n                cack = !cack;\n            }\n            if (rx_cap.test(left.name.id) !== cack) {\n                if (the_new !== undefined) {\n                    warn(\"unexpected_a\", the_new);\n                } else {\n                    warn(\n                        \"expected_a_before_b\",\n                        left.expression,\n                        \"new\",\n                        left.name.id\n                    );\n                }\n            }\n            if (left.name.id === \"getTime\") {\n                var l1 = left.expression;\n                if (l1.id === \"(\") {\n                    var l2 = l1.expression;\n                    if (l2.length === 1) {\n                        var l3 = l2[0];\n                        if (l3.id === \"new\" && l3.expression.id === \"Date\") {\n                            warn(\n                                \"expected_a_b\",\n                                l3,\n                                \"Date.now()\",\n                                \"new Date().getTime()\"\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    });\n    postaction(\"binary\", \"[\", function (thing) {\n        if (thing.expression[0].id === \"RegExp\") {\n            warn(\"weird_expression_a\", thing);\n        }\n        if (is_weird(thing.expression[1])) {\n            warn(\"weird_expression_a\", thing.expression[1]);\n        }\n    });\n    postaction(\"statement\", \"{\", pop_block);\n    postaction(\"statement\", \"const\", action_var);\n    postaction(\"statement\", \"export\", top_level_only);\n    postaction(\"statement\", \"for\", function (thing) {\n        walk_statement(thing.inc);\n    });\n    postaction(\"statement\", \"function\", postaction_function);\n    postaction(\"statement\", \"import\", function (the_thing) {\n        var name = the_thing.name;\n        name.init = true;\n        name.dead = false;\n        blockage.live.push(name);\n        return top_level_only(the_thing);\n    });\n    postaction(\"statement\", \"let\", action_var);\n    postaction(\"statement\", \"try\", function (thing) {\n        if (thing.catch !== undefined) {\n            var the_name = thing.catch.name;\n            if (the_name !== undefined) {\n                var the_variable = functionage.context[the_name.id];\n                the_variable.dead = false;\n                the_variable.init = true;\n            }\n            walk_statement(thing.catch.block);\n        }\n    });\n    postaction(\"statement\", \"var\", action_var);\n    postaction(\"ternary\", function (thing) {\n        if (\n            is_weird(thing.expression[0]) ||\n            thing.expression[0].constant === true ||\n            are_similar(thing.expression[1], thing.expression[2])\n        ) {\n            warn(\"unexpected_a\", thing);\n        } else if (are_similar(thing.expression[0], thing.expression[1])) {\n            warn(\"expected_a_b\", thing, \"||\", \"?\");\n        } else if (are_similar(thing.expression[0], thing.expression[2])) {\n            warn(\"expected_a_b\", thing, \"&&\", \"?\");\n        } else if (\n            thing.expression[1].id === \"true\" &&\n            thing.expression[2].id === \"false\"\n        ) {\n            warn(\"expected_a_b\", thing, \"!!\", \"?\");\n        } else if (\n            thing.expression[1].id === \"false\" &&\n            thing.expression[2].id === \"true\"\n        ) {\n            warn(\"expected_a_b\", thing, \"!\", \"?\");\n        } else if (thing.expression[0].wrapped !== true && (\n            thing.expression[0].id === \"||\" ||\n            thing.expression[0].id === \"&&\"\n        )) {\n            warn(\"wrap_condition\", thing.expression[0]);\n        }\n    });\n    postaction(\"unary\", function (thing) {\n        switch (thing.id) {\n        case \"[\":\n        case \"{\":\n        case \"function\":\n        case \"new\":\n            break;\n        case \"`\":\n            if (thing.expression.every(function (thing) {\n                return thing.constant;\n            })) {\n                thing.constant = true;\n            }\n            break;\n        default:\n            if (thing.expression.constant === true) {\n                thing.constant = true;\n            }\n        }\n    });\n    postaction(\"unary\", \"function\", postaction_function);\n\n    function delve(the_function) {\n        Object.keys(the_function.context).forEach(function (id) {\n            if (id !== \"ignore\") {\n                var name = the_function.context[id];\n                if (name.function === the_function) {\n                    if (name.used === 0 && (\n                        name.role !== \"function\" ||\n                        name.function.arity !== \"unary\"\n                    )) {\n                        warn(\"unused_a\", name);\n                    } else if (!name.init) {\n                        warn(\"uninitialized_a\", name);\n                    }\n                }\n            }\n        });\n    }\n\n    function uninitialized_and_unused() {\n\n// Delve into the functions looking for variables that were not initialized\n// or used. If the file imports or exports, then its global object is also\n// delved.\n\n        if (module_mode === true || option.node) {\n            delve(global);\n        }\n        functions.forEach(delve);\n    }\n\n// Go through the token list, looking at usage of whitespace.\n\n    function whitage() {\n        var closer = \"(end)\";\n        var free = false;\n        var left = global;\n        var margin = 0;\n        var nr_comments_skipped = 0;\n        var open = true;\n        var qmark = \"\";\n        var result;\n        var right;\n\n        function expected_at(at) {\n            warn(\n                \"expected_a_at_b_c\",\n                right,\n                artifact(right),\n                fudge + at,\n                artifact_column(right)\n            );\n        }\n\n        function at_margin(fit) {\n            var at = margin + fit;\n            if (right.from !== at) {\n                return expected_at(at);\n            }\n        }\n\n        function no_space_only() {\n            if (left.id !== \"(global)\" && (\n                left.line !== right.line || left.thru !== right.from\n            )) {\n                warn(\n                    \"unexpected_space_a_b\",\n                    right,\n                    artifact(left),\n                    artifact(right)\n                );\n            }\n        }\n\n        function no_space() {\n            if (left.line === right.line) {\n                if (left.thru !== right.from && nr_comments_skipped === 0) {\n                    warn(\n                        \"unexpected_space_a_b\",\n                        right,\n                        artifact(left),\n                        artifact(right)\n                    );\n                }\n            } else {\n                if (open) {\n                    var at = (free)\n                        ? margin\n                        : margin + 8;\n                    if (right.from < at) {\n                        expected_at(at);\n                    }\n                } else {\n                    if (right.from !== margin + 8) {\n                        expected_at(margin + 8);\n                    }\n                }\n            }\n        }\n\n        function one_space_only() {\n            if (left.line !== right.line || left.thru + 1 !== right.from) {\n                warn(\n                    \"expected_space_a_b\",\n                    right,\n                    artifact(left),\n                    artifact(right)\n                );\n            }\n        }\n\n        function one_space() {\n            if (left.line === right.line) {\n                if (left.thru + 1 !== right.from && nr_comments_skipped === 0) {\n                    warn(\n                        \"expected_space_a_b\",\n                        right,\n                        artifact(left),\n                        artifact(right)\n                    );\n                }\n            } else {\n                if (free) {\n                    if (right.from < margin) {\n                        expected_at(margin);\n                    }\n                } else {\n                    if (right.from !== margin + 8) {\n                        expected_at(margin + 8);\n                    }\n                }\n            }\n        }\n\n        function unqmark() {\n\n// Undo the effects of dangling nested ternary operators.\n\n            var level = qmark.length;\n            if (level > 0) {\n                margin -= level * 4;\n            }\n            qmark = \"\";\n        }\n\n        stack = [];\n        tokens.forEach(function (the_token) {\n            right = the_token;\n            if (right.id === \"(comment)\" || right.id === \"(end)\") {\n                nr_comments_skipped += 1;\n            } else {\n\n// If left is an opener and right is not the closer, then push the previous\n// state. If the token following the opener is on the next line, then this is\n// an open form. If the tokens are on different lines, then it is a closed form.\n// Open form is more readable, with each item (statement, argument, parameter,\n// etc) starting on its own line. Closed form is more compact. Statement blocks\n// are always in open form.\n\n                var new_closer = opener[left.id];\n                if (typeof new_closer === \"string\") {\n                    if (new_closer !== right.id) {\n                        stack.push({\n                            closer: closer,\n                            free: free,\n                            margin: margin,\n                            open: open,\n                            qmark: qmark\n                        });\n                        qmark = \"\";\n                        closer = new_closer;\n                        if (left.line !== right.line) {\n                            free = closer === \")\" && left.free;\n                            open = true;\n                            margin += 4;\n                            if (right.role === \"label\") {\n                                if (right.from !== 0) {\n                                    expected_at(0);\n                                }\n                            } else if (right.switch) {\n                                unqmark();\n                                at_margin(-4);\n                            } else {\n                                at_margin(0);\n                            }\n                        } else {\n                            if (right.statement || right.role === \"label\") {\n                                warn(\n                                    \"expected_line_break_a_b\",\n                                    right,\n                                    artifact(left),\n                                    artifact(right)\n                                );\n                            }\n                            free = false;\n                            open = false;\n                            no_space_only();\n                        }\n                    } else {\n\n// If left and right are opener and closer, then the placement of right depends\n// on the openness. Illegal pairs (like {]) have already been detected.\n\n                        if (left.line === right.line) {\n                            no_space();\n                        } else {\n                            at_margin(0);\n                        }\n                    }\n                } else {\n\n// If right is a closer, then pop the previous state.\n\n                    if (right.id === closer) {\n                        var previous = stack.pop();\n                        margin = previous.margin;\n                        if (open && right.id !== \";\") {\n                            at_margin(0);\n                        } else {\n                            no_space_only();\n                        }\n                        closer = previous.closer;\n                        free = previous.free;\n                        open = previous.open;\n                        qmark = previous.qmark;\n                    } else {\n\n// Left is not an opener, and right is not a closer. The nature of left and\n// right will determine the space between them.\n\n// If left is , or ; or right is a statement then if open, right must go at the\n// margin, or if closed, a space before.\n\n\n                        if (right.switch) {\n                            unqmark();\n                            at_margin(-4);\n                        } else if (right.role === \"label\") {\n                            if (right.from !== 0) {\n                                expected_at(0);\n                            }\n                        } else if (left.id === \",\") {\n                            unqmark();\n                            if (!open || (\n                                (free || closer === \"]\") &&\n                                left.line === right.line\n                            )) {\n                                one_space();\n                            } else {\n                                at_margin(0);\n                            }\n\n// If right is a ternary operator, line it up on the margin. Use qmark to\n// deal with nested ternary operators.\n\n                        } else if (right.arity === \"ternary\") {\n                            if (right.id === \"?\") {\n                                margin += 4;\n                                qmark += \"?\";\n                            } else {\n                                result = qmark.match(rx_colons);\n                                qmark = result[1] + \":\";\n                                margin -= 4 * result[2].length;\n                            }\n                            at_margin(0);\n                        } else if (\n                            right.arity === \"binary\" &&\n                            right.id === \"(\" &&\n                            free\n                        ) {\n                            no_space();\n                        } else if (\n                            left.id === \".\" ||\n                            left.id === \"...\" ||\n                            right.id === \",\" ||\n                            right.id === \";\" ||\n                            right.id === \":\" ||\n                            (right.arity === \"binary\" && (\n                                right.id === \"(\" ||\n                                right.id === \"[\"\n                            )) ||\n                            (\n                                right.arity === \"function\" &&\n                                left.id !== \"function\"\n                            )\n                        ) {\n                            no_space_only();\n                        } else if (right.id === \".\") {\n                            if (left.line === right.line) {\n                                no_space();\n                            } else {\n                                if (!rx_dot.test(qmark)) {\n                                    qmark += \".\";\n                                    margin += 4;\n                                }\n                                at_margin(0);\n                            }\n                        } else if (left.id === \";\") {\n                            unqmark();\n                            if (open) {\n                                at_margin(0);\n                            } else {\n                                one_space();\n                            }\n                        } else if (\n                            left.arity === \"ternary\" ||\n                            left.id === \"case\" ||\n                            left.id === \"catch\" ||\n                            left.id === \"else\" ||\n                            left.id === \"finally\" ||\n                            left.id === \"while\" ||\n                            right.id === \"catch\" ||\n                            right.id === \"else\" ||\n                            right.id === \"finally\" ||\n                            (right.id === \"while\" && !right.statement) ||\n                            (left.id === \")\" && right.id === \"{\")\n                        ) {\n                            one_space_only();\n                        } else if (right.statement === true) {\n                            if (open) {\n                                at_margin(0);\n                            } else {\n                                one_space();\n                            }\n                        } else if (\n                            left.id === \"var\" ||\n                            left.id === \"const\" ||\n                            left.id === \"let\"\n                        ) {\n                            stack.push({\n                                closer: closer,\n                                free: free,\n                                margin: margin,\n                                open: open,\n                                qmark: qmark\n                            });\n                            closer = \";\";\n                            free = false;\n                            open = left.open;\n                            qmark = \"\";\n                            if (open) {\n                                margin = margin + 4;\n                                at_margin(0);\n                            } else {\n                                one_space_only();\n                            }\n                        } else if (\n\n// There is a space between left and right.\n\n                            spaceop[left.id] === true ||\n                            spaceop[right.id] === true ||\n                            (\n                                left.arity === \"binary\" &&\n                                (left.id === \"+\" || left.id === \"-\")\n                            ) ||\n                            (\n                                right.arity === \"binary\" &&\n                                (right.id === \"+\" || right.id === \"-\")\n                            ) ||\n                            left.id === \"function\" ||\n                            left.id === \":\" ||\n                            (\n                                (\n                                    left.identifier ||\n                                    left.id === \"(string)\" ||\n                                    left.id === \"(number)\"\n                                ) &&\n                                (\n                                    right.identifier ||\n                                    right.id === \"(string)\" ||\n                                    right.id === \"(number)\"\n                                )\n                            ) ||\n                            (left.arity === \"statement\" && right.id !== \";\")\n                        ) {\n                            one_space();\n                        } else if (left.arity === \"unary\" && left.id !== \"`\") {\n                            no_space_only();\n                        }\n                    }\n                }\n                nr_comments_skipped = 0;\n                delete left.calls;\n                delete left.dead;\n                delete left.free;\n                delete left.init;\n                delete left.open;\n                delete left.used;\n                left = right;\n            }\n        });\n    }\n\n// The jslint function itself.\n\n    return function (source, option_object, global_array) {\n        try {\n            warnings = [];\n            option = option_object || empty();\n            anon = \"anonymous\";\n            block_stack = [];\n            declared_globals = empty();\n            directive_mode = true;\n            directives = [];\n            early_stop = true;\n            export_mode = false;\n            fudge = (option.fudge)\n                ? 1\n                : 0;\n            functions = [];\n            global = {\n                id: \"(global)\",\n                body: true,\n                context: empty(),\n                from: 0,\n                level: 0,\n                line: 0,\n                live: [],\n                loop: 0,\n                switch: 0,\n                thru: 0\n            };\n            blockage = global;\n            functionage = global;\n            imports = [];\n            json_mode = false;\n            mega_mode = false;\n            module_mode = false;\n            next_token = global;\n            property = empty();\n            stack = [];\n            tenure = undefined;\n            token = global;\n            token_nr = 0;\n            var_mode = undefined;\n            populate(declared_globals, standard, false);\n            if (global_array !== undefined) {\n                populate(declared_globals, global_array, false);\n            }\n            Object.keys(option).forEach(function (name) {\n                if (option[name] === true) {\n                    var allowed = allowed_option[name];\n                    if (Array.isArray(allowed)) {\n                        populate(declared_globals, allowed, false);\n                    }\n                }\n            });\n            tokenize(source);\n            advance();\n            if (tokens[0].id === \"{\" || tokens[0].id === \"[\") {\n                json_mode = true;\n                tree = json_value();\n                advance(\"(end)\");\n            } else {\n\n// Because browsers encourage combining of script files, the first token might\n// be a semicolon to defend against a missing semicolon in the preceding file.\n\n                if (option.browser) {\n                    if (next_token.id === \";\") {\n                        advance(\";\");\n                    }\n                } else {\n\n// If we are not in a browser, then the file form of strict pragma may be used.\n\n                    if (\n                        next_token.id === \"(string)\" &&\n                        next_token.value === \"use strict\"\n                    ) {\n                        advance(\"(string)\");\n                        advance(\";\");\n                        global.strict = true;\n                    }\n                }\n                tree = statements();\n                advance(\"(end)\");\n                functionage = global;\n                walk_statement(tree);\n                uninitialized_and_unused();\n                if (!option.white) {\n                    whitage();\n                }\n            }\n            if (!option.browser) {\n                directives.forEach(function (comment) {\n                    if (comment.directive === \"global\") {\n                        warn(\"missing_browser\", comment);\n                    }\n                });\n            }\n            early_stop = false;\n        } catch (e) {\n            if (e.name !== \"JSLintError\") {\n                warnings.push(e);\n            }\n        }\n        return {\n            directives: directives,\n            edition: \"2016-05-13\",\n            functions: functions,\n            global: global,\n            id: \"(JSLint)\",\n            imports: imports,\n            json: json_mode,\n            lines: lines,\n            module: module_mode === true,\n            ok: warnings.length === 0 && !early_stop,\n            option: option,\n            property: property,\n            stop: early_stop,\n            tokens: tokens,\n            tree: tree,\n            warnings: warnings.sort(function (a, b) {\n                return a.line - b.line || a.column - b.column;\n            })\n        };\n    };\n}());\n\n/*node module.exports = jslint;*/\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jslint-2016-07-13.js":"// jslint.js\n// 2016-07-13\n// Copyright (c) 2015 Douglas Crockford  (www.JSLint.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// The Software shall be used for Good, not Evil.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// jslint(source, option_object, global_array) is a function that takes 3\n// arguments. The second two arguments are optional.\n\n//      source          A text to analyze, a string or an array of strings.\n//      option_object   An object whose keys correspond to option names.\n//      global_array    An array of strings containing global variables that\n//                      the file is allowed readonly access.\n\n// jslint returns an object containing its results. The object contains a lot\n// of valuable information. It can be used to generate reports. The object\n// contains:\n\n//      directives: an array of directive comment tokens.\n//      edition: the version of JSLint that did the analysis.\n//      functions: an array of objects that represent all of the functions\n//              declared in the file.\n//      global: an object representing the global object. Its .context property\n//              is an object containing a property for each global variable.\n//      id: \"(JSLint)\"\n//      imports: an array of strings representing each of the imports.\n//      json: true if the file is a JSON text.\n//      lines: an array of strings, the source.\n//      module: true if an import or export statement was used.\n//      ok: true if no warnings were generated. This is what you want.\n//      option: the option argument.\n//      property: a property object.\n//      stop: true if JSLint was unable to finish. You don't want this.\n//      tokens: an array of objects representing the tokens in the file.\n//      tree: the token objects arranged in a tree.\n//      warnings: an array of warning objects. A warning object can contain:\n//          name: \"JSLintError\"\n//          column: A column number in the file.\n//          line: A line number in the file.\n//          code: A warning code string.\n//          message: The warning message string.\n//          a: Exhibit A.\n//          b: Exhibit B.\n//          c: Exhibit C.\n//          d: Exhibit D.\n\n// jslint works in several phases. In any of these phases, errors might be\n// found. Sometimes JSLint is able to recover from an error and continue\n// parsing. In some cases, it cannot and will stop early. If that should happen,\n// repair your code and try again.\n\n// Phases:\n\n//      1. If the source is a single string, split it into an array of strings.\n//      2. Turn the source into an array of tokens.\n//      3. Furcate the tokens into a parse tree.\n//      4. Walk the tree, traversing all of the nodes of the tree. It is a\n//          recursive traversal. Each node may be processed on the way down\n//          (preaction) and on the way up (postaction).\n//      5. Check the whitespace between the tokens.\n\n// jslint can also examine JSON text. It decides that a file is JSON text if\n// the first token is \"[\" or \"{\". Processing of JSON text is much simpler than\n// the processing of JavaScript programs. Only the first three phases are\n// required.\n\n// WARNING: JSLint will hurt your feelings.\n\n/*property\n    a, and, arity, b, bad_assignment_a, bad_directive_a, bad_get,\n    bad_module_name_a, bad_option_a, bad_property_a, bad_set, bitwise, block,\n    body, browser, c, calls, catch, charAt, charCodeAt, closer, closure, code,\n    column, complex, concat, constant, context, couch, create, d, dead, devel,\n    directive, directives, disrupt, dot, duplicate_a, edition, ellipsis, else,\n    empty_block, es6, escape_mega, eval, every, expected_a, expected_a_at_b_c,\n    expected_a_b, expected_a_b_from_c_d, expected_a_before_b,\n    expected_digits_after_a, expected_four_digits, expected_identifier_a,\n    expected_line_break_a_b, expected_regexp_factor_a, expected_space_a_b,\n    expected_statements_a, expected_string_a, expected_type_string_a,\n    expression, extra, flag, for, forEach, free, from, fud, fudge, function,\n    function_in_loop, functions, g, global, i, id, identifier, import, imports,\n    inc, indexOf, infix_in, init, initial, isArray, isNaN, join, json, keys,\n    label, label_a, lbp, led, length, level, line, lines, live, loop, m,\n    margin, match, maxerr, maxlen, message, misplaced_a, misplaced_directive_a,\n    missing_browser, module, multivar, naked_block, name, names,\n    nested_comment, new, node, not_label_a, nr, nud, number_isNaN, ok, open,\n    option, out_of_scope_a, parameters, pop, property, push, qmark, quote,\n    redefinition_a_b, replace, reserved_a, role, search, signature, single,\n    slice, some, sort, split, statement, stop, strict, subscript_a, switch,\n    test, this, thru, toString, todo_comment, tokens, too_long, too_many,\n    too_many_digits, tree, type, u, unclosed_comment, unclosed_mega,\n    unclosed_string, undeclared_a, unexpected_a, unexpected_a_after_b,\n    unexpected_at_top_level_a, unexpected_char_a, unexpected_comment,\n    unexpected_directive_a, unexpected_expression_a, unexpected_label_a,\n    unexpected_parens, unexpected_space_a_b, unexpected_statement_a,\n    unexpected_trailing_space, unexpected_typeof_a, uninitialized_a,\n    unreachable_a, unregistered_property_a, unsafe, unused_a, use_spaces,\n    use_strict, used, value, var_loop, var_switch, variable, warning, warnings,\n    weird_condition_a, weird_expression_a, weird_loop, weird_relation_a, white,\n    wrap_assignment, wrap_condition, wrap_immediate, wrap_parameter,\n    wrap_regexp, wrap_unary, wrapped, writable, y\n*/\n\nvar jslint = (function JSLint() {\n    \"use strict\";\n\n    function empty() {\n\n// The empty function produces a new empty object that inherits nothing. This is\n// much better than {} because confusions around accidental method names like\n// \"constructor\" are completely avoided.\n\n        return Object.create(null);\n    }\n\n    function populate(object, array, value) {\n\n// Augment an object by taking property names from an array of strings.\n\n        array.forEach(function (name) {\n            object[name] = value;\n        });\n    }\n\n    var allowed_option = {\n\n// These are the options that are recognized in the option object or that may\n// appear in a /*jslint*/ directive. Most options will have a boolean value,\n// usually true. Some options will also predefine some number of global\n// variables.\n\n        bitwise: true,\n        browser: [\n            \"Audio\", \"clearInterval\", \"clearTimeout\", \"document\", \"event\",\n            \"FormData\", \"history\", \"Image\", \"localStorage\", \"location\", \"name\",\n            \"navigator\", \"Option\", \"screen\", \"sessionStorage\", \"setInterval\",\n            \"setTimeout\", \"Storage\", \"XMLHttpRequest\"\n        ],\n        couch: [\n            \"emit\", \"getRow\", \"isArray\", \"log\", \"provides\", \"registerType\",\n            \"require\", \"send\", \"start\", \"sum\", \"toJSON\"\n        ],\n        devel: [\n            \"alert\", \"confirm\", \"console\", \"Debug\", \"opera\", \"prompt\", \"WSH\"\n        ],\n        es6: [\n            \"ArrayBuffer\", \"DataView\", \"Float32Array\", \"Float64Array\",\n            \"Generator\", \"GeneratorFunction\", \"Int8Array\", \"Int16Array\",\n            \"Int32Array\", \"Intl\", \"Map\", \"Promise\", \"Proxy\", \"Reflect\",\n            \"Set\", \"Symbol\", \"System\", \"Uint8Array\", \"Uint8ClampedArray\",\n            \"Uint16Array\", \"Uint32Array\", \"WeakMap\", \"WeakSet\"\n        ],\n        eval: true,\n        for: true,\n        fudge: true,\n        maxerr: 10000,\n        maxlen: 10000,\n        multivar: true,\n        node: [\n            \"Buffer\", \"clearImmediate\", \"clearInterval\", \"clearTimeout\",\n            \"console\", \"exports\", \"global\", \"module\", \"process\", \"querystring\",\n            \"require\", \"setImmediate\", \"setInterval\", \"setTimeout\",\n            \"__dirname\", \"__filename\"\n        ],\n        single: true,\n        this: true,\n        white: true\n    };\n\n    var spaceop = {\n\n// This is the set of infix operators that require a space on each side.\n\n        \"!=\": true,\n        \"!==\": true,\n        \"%\": true,\n        \"%=\": true,\n        \"&\": true,\n        \"&=\": true,\n        \"&&\": true,\n        \"*\": true,\n        \"*=\": true,\n        \"+=\": true,\n        \"-=\": true,\n        \"/\": true,\n        \"/=\": true,\n        \"<\": true,\n        \"<=\": true,\n        \"<<\": true,\n        \"<<=\": true,\n        \"=\": true,\n        \"==\": true,\n        \"===\": true,\n        \"=>\": true,\n        \">\": true,\n        \">=\": true,\n        \">>\": true,\n        \">>=\": true,\n        \">>>\": true,\n        \">>>=\": true,\n        \"^\": true,\n        \"^=\": true,\n        \"|\": true,\n        \"|=\": true,\n        \"||\": true\n    };\n\n    var bitwiseop = {\n\n// These are the bitwise operators.\n\n        \"~\": true,\n        \"^\": true,\n        \"^=\": true,\n        \"&\": true,\n        \"&=\": true,\n        \"|\": true,\n        \"|=\": true,\n        \"<<\": true,\n        \"<<=\": true,\n        \">>\": true,\n        \">>=\": true,\n        \">>>\": true,\n        \">>>=\": true\n    };\n\n    var opener = {\n\n// The open and close pairs.\n\n        \"(\": \")\",       // paren\n        \"[\": \"]\",       // bracket\n        \"{\": \"}\",       // brace\n        \"${\": \"}\"       // mega\n    };\n\n    var relationop = {\n\n// The relational operators.\n\n        \"!=\": true,\n        \"!==\": true,\n        \"==\": true,\n        \"===\": true,\n        \"<\": true,\n        \"<=\": true,\n        \">\": true,\n        \">=\": true\n    };\n\n    var standard = [\n\n// These are the globals that are provided by the ES5 language standard.\n\n        \"Array\", \"Boolean\", \"Date\", \"decodeURI\", \"decodeURIComponent\",\n        \"encodeURI\", \"encodeURIComponent\", \"Error\", \"EvalError\", \"isFinite\",\n        \"JSON\", \"Math\", \"Number\", \"Object\", \"parseInt\", \"parseFloat\",\n        \"RangeError\", \"ReferenceError\", \"RegExp\", \"String\", \"SyntaxError\",\n        \"TypeError\", \"URIError\"\n    ];\n\n    var bundle = {\n\n// The bundle contains the raw text messages that are generated by jslint. It\n// seems that they are all error messages and warnings. There are no \"Atta\n// boy!\" or \"You are so awesome!\" messages. There is no positive reinforcement\n// or encouragement. This relentless negativity can undermine self-esteem and\n// wound the inner child. But if you accept it as sound advice rather than as\n// personal criticism, it can make your programs better.\n\n        and: \"The '&&' subexpression should be wrapped in parens.\",\n        bad_assignment_a: \"Bad assignment to '{a}'.\",\n        bad_directive_a: \"Bad directive '{a}'.\",\n        bad_get: \"A get function takes no parameters.\",\n        bad_module_name_a: \"Bad module name '{a}'.\",\n        bad_option_a: \"Bad option '{a}'.\",\n        bad_property_a: \"Bad property name '{a}'.\",\n        bad_set: \"A set function takes one parameter.\",\n        duplicate_a: \"Duplicate '{a}'.\",\n        empty_block: \"Empty block.\",\n        es6: \"Unexpected ES6 feature '{a}'.\",\n        escape_mega: \"Unexpected escapement in mega literal.\",\n        expected_a: \"Expected '{a}'.\",\n        expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n        expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n        expected_a_b_from_c_d: \"Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.\",\n        expected_a_before_b: \"Expected '{a}' before '{b}'.\",\n        expected_digits_after_a: \"Expected digits after '{a}'.\",\n        expected_four_digits: \"Expected four digits after '\\\\u'.\",\n        expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n        expected_line_break_a_b: \"Expected a line break between '{a}' and '{b}'.\",\n        expected_regexp_factor_a: \"Expected a regexp factor and instead saw '{a}'.\",\n        expected_space_a_b: \"Expected one space between '{a}' and '{b}'.\",\n        expected_statements_a: \"Expected statements before '{a}'.\",\n        expected_string_a: \"Expected a string and instead saw '{a}'.\",\n        expected_type_string_a: \"Expected a type string and instead saw '{a}'.\",\n        function_in_loop: \"Don't make functions within a loop.\",\n        infix_in: \"Unexpected 'in'. Compare with undefined, or use the hasOwnProperty method instead.\",\n        isNaN: \"Use the isNaN function to compare with NaN.\",\n        label_a: \"'{a}' is a statement label.\",\n        misplaced_a: \"Place '{a}' at the outermost level.\",\n        misplaced_directive_a: \"Place the '/*{a}*/' directive before the first statement.\",\n        missing_browser: \"/*global*/ requires the Assume a browser option.\",\n        naked_block: \"Naked block.\",\n        nested_comment: \"Nested comment.\",\n        not_label_a: \"'{a}' is not a label.\",\n        number_isNaN: \"Use Number.isNaN function to compare with NaN.\",\n        out_of_scope_a: \"'{a}' is out of scope.\",\n        redefinition_a_b: \"Redefinition of '{a}' from line {b}.\",\n        reserved_a: \"Reserved name '{a}'.\",\n        subscript_a: \"['{a}'] is better written in dot notation.\",\n        todo_comment: \"Unexpected TODO comment.\",\n        too_long: \"Line too long.\",\n        too_many: \"Too many warnings.\",\n        too_many_digits: \"Too many digits.\",\n        unclosed_comment: \"Unclosed comment.\",\n        unclosed_mega: \"Unclosed mega literal.\",\n        unclosed_string: \"Unclosed string.\",\n        undeclared_a: \"Undeclared '{a}'.\",\n        unexpected_a: \"Unexpected '{a}'.\",\n        unexpected_a_after_b: \"Unexpected '{a}' after '{b}'.\",\n        unexpected_at_top_level_a: \"Expected '{a}' to be in a function.\",\n        unexpected_char_a: \"Unexpected character '{a}'.\",\n        unexpected_comment: \"Unexpected comment.\",\n        unexpected_directive_a: \"When using modules, don't use directive '/*{a}'.\",\n        unexpected_expression_a: \"Unexpected expression '{a}' in statement position.\",\n        unexpected_label_a: \"Unexpected label '{a}'.\",\n        unexpected_parens: \"Don't wrap function literals in parens.\",\n        unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n        unexpected_statement_a: \"Unexpected statement '{a}' in expression position.\",\n        unexpected_trailing_space: \"Unexpected trailing space.\",\n        unexpected_typeof_a: \"Unexpected 'typeof'. Use '===' to compare directly with {a}.\",\n        uninitialized_a: \"Uninitialized '{a}'.\",\n        unreachable_a: \"Unreachable '{a}'.\",\n        unregistered_property_a: \"Unregistered property name '{a}'.\",\n        unsafe: \"Unsafe character '{a}'.\",\n        unused_a: \"Unused '{a}'.\",\n        use_spaces: \"Use spaces, not tabs.\",\n        use_strict: \"This function needs a 'use strict' pragma.\",\n        var_loop: \"Don't declare variables in a loop.\",\n        var_switch: \"Don't declare variables in a switch.\",\n        weird_condition_a: \"Weird condition '{a}'.\",\n        weird_expression_a: \"Weird expression '{a}'.\",\n        weird_loop: \"Weird loop.\",\n        weird_relation_a: \"Weird relation '{a}'.\",\n        wrap_assignment: \"Don't wrap assignment statements in parens.\",\n        wrap_condition: \"Wrap the condition in parens.\",\n        wrap_immediate: \"Wrap an immediate function invocation in \" +\n                \"parentheses to assist the reader in understanding that the \" +\n                \"expression is the result of a function, and not the \" +\n                \"function itself.\",\n        wrap_parameter: \"Wrap the parameter in parens.\",\n        wrap_regexp: \"Wrap this regexp in parens to avoid confusion.\",\n        wrap_unary: \"Wrap the unary expression in parens.\"\n    };\n\n// Regular expression literals:\n\n// supplant {variables}\n    var rx_supplant = /\\{([^{}]*)\\}/g;\n// carriage return, carriage return linefeed, or linefeed\n    var rx_crlf = /\\n|\\r\\n?/;\n// unsafe characters that are silently deleted by one or more browsers\n    var rx_unsafe = /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/;\n// identifier\n    var rx_identifier = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/;\n    var rx_module = /^[a-zA-Z0-9_$:.@\\-\\/]+$/;\n    var rx_bad_property = /^_|\\$|Sync$|_$/;\n// star slash\n    var rx_star_slash = /\\*\\//;\n// slash star\n    var rx_slash_star = /\\/\\*/;\n// slash star or ending slash\n    var rx_slash_star_or_slash = /\\/\\*|\\/$/;\n// uncompleted work comment\n    var rx_todo = /\\b(?:todo|TO\\s?DO|HACK)\\b/;\n// tab\n    var rx_tab = /\\t/g;\n// directive\n    var rx_directive = /^(jslint|property|global)\\s+(.*)$/;\n    var rx_directive_part = /^([a-zA-Z$_][a-zA-Z0-9$_]*)\\s*(?::\\s*(true|false|[0-9]+)\\s*)?(?:,\\s*)?(.*)$/;\n// token (sorry it is so long)\n    var rx_token = /^((\\s+)|([a-zA-Z_$][a-zA-Z0-9_$]*)|[(){}\\[\\]\\?,:;'\"~`]|=(?:==?|>)?|\\.+|\\/[=*\\/]?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|[\\^%]=?|&[&=]?|\\|[\\|=]?|>{1,3}=?|<<?=?|!={0,2}|(0|[1-9][0-9]*))(.*)$/;\n    var rx_digits = /^([0-9]+)(.*)$/;\n    var rx_hexs = /^([0-9a-fA-F]+)(.*)$/;\n    var rx_octals = /^([0-7]+)(.*)$/;\n    var rx_bits = /^([01]+)(.*)$/;\n// mega\n    var rx_mega = /[`\\\\]|\\$\\{/;\n// indentation\n    var rx_colons = /^(.*)\\?([:.]*)$/;\n    var rx_dot = /\\.$/;\n// JSON number\n    var rx_JSON_number = /^-?\\d+(?:\\.\\d*)?(?:e[\\-+]?\\d+)?$/i;\n// initial cap\n    var rx_cap = /^[A-Z]/;\n\n    function is_letter(string) {\n        return (string >= \"a\" && string <= \"z\\uffff\") ||\n                (string >= \"A\" && string <= \"Z\\uffff\");\n    }\n\n    function supplant(string, object) {\n        return string.replace(rx_supplant, function (found, filling) {\n            var replacement = object[filling];\n            return (replacement !== undefined)\n                ? replacement\n                : found;\n        });\n    }\n\n    var anon = \"anonymous\"; // The guessed name for anonymous functions.\n    var blockage;           // The current block.\n    var block_stack;        // The stack of blocks.\n    var declared_globals;   // The object containing the global declarations.\n    var directives;         // The directive comments.\n    var directive_mode;     // true if directives are still allowed.\n    var early_stop;         // true if JSLint cannot finish.\n    var export_mode;        // true if an export statement was seen.\n    var fudge;              // true if the natural numbers start with 1.\n    var functionage;        // The current function.\n    var functions;          // The array containing all of the functions.\n    var global;             // The global object; the outermost context.\n    var imports;            // The array collecting all import-from strings.\n    var json_mode;          // true if parsing JSON.\n    var lines;              // The array containing source lines.\n    var module_mode;        // true if import or export was used.\n    var next_token;         // The next token to be examined in the parse.\n    var option;             // The options parameter.\n    var property;           // The object containing the tallied property names.\n    var mega_mode;          // true if currently parsing a megastring literal.\n    var stack;              // The stack of functions.\n    var syntax;             // The object containing the parser.\n    var token;              // The current token being examined in the parse.\n    var token_nr;           // The number of the next token.\n    var tokens;             // The array of tokens.\n    var tenure;             // The predefined property registry.\n    var tree;               // The abstract parse tree.\n    var var_mode;           // true if using var; false if using let.\n    var warnings;           // The array collecting all generated warnings.\n\n// Error reportage functions:\n\n    function artifact(the_token) {\n\n// Return a string representing an artifact.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        return (the_token.id === \"(string)\" || the_token.id === \"(number)\")\n            ? String(the_token.value)\n            : the_token.id;\n    }\n\n    function artifact_line(the_token) {\n\n// Return the fudged line number of an artifact.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        return the_token.line + fudge;\n    }\n\n    function artifact_column(the_token) {\n\n// Return the fudged column number of an artifact.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        return the_token.from + fudge;\n    }\n\n    function warn_at(code, line, column, a, b, c, d) {\n\n// Report an error at some line and column of the program. The warning object\n// resembles an exception.\n\n        var warning = {         // ~~\n            name: \"JSLintError\",\n            column: column,\n            line: line,\n            code: code\n        };\n        if (a !== undefined) {\n            warning.a = a;\n        }\n        if (b !== undefined) {\n            warning.b = b;\n        }\n        if (c !== undefined) {\n            warning.c = c;\n        }\n        if (d !== undefined) {\n            warning.d = d;\n        }\n        warning.message = supplant(bundle[code] || code, warning);\n        warnings.push(warning);\n        return (\n            typeof option.maxerr === \"number\" &&\n            warnings.length === option.maxerr\n        )   ? stop_at(\"too_many\", line, column)\n            : warning;\n    }\n\n    function stop_at(code, line, column, a, b, c, d) {\n\n// Same as warn_at, except that it stops the analysis.\n\n        throw warn_at(code, line, column, a, b, c, d);\n    }\n\n    function warn(code, the_token, a, b, c, d) {\n\n// Same as warn_at, except the warning will be associated with a specific token.\n// If there is already a warning on this token, suppress the new one. It is\n// likely that the first warning will be the most meaningful.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        if (the_token.warning === undefined) {\n            the_token.warning = warn_at(\n                code,\n                the_token.line,\n                the_token.from,\n                a || artifact(the_token),\n                b,\n                c,\n                d\n            );\n            return the_token.warning;\n        }\n    }\n\n    function stop(code, the_token, a, b, c, d) {\n\n// Similar to warn and stop_at. If the token already had a warning, that\n// warning will be replaced with this new one. It is likely that the stopping\n// warning will be the more meaningful.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        delete the_token.warning;\n        throw warn(code, the_token, a, b, c, d);\n    }\n\n// Tokenize:\n\n    function tokenize(source) {\n\n// tokenize takes a source and produces from it an array of token objects.\n// JavaScript is notoriously difficult to tokenize because of the horrible\n// interactions between automatic semicolon insertion, regular expression\n// literals, and now megastring literals. JSLint benefits from eliminating\n// automatic semicolon insertion and nested megastring literals, which allows\n// full tokenization to precede parsing.\n\n// If the source is not an array, then it is split into lines at the\n// carriage return/linefeed.\n\n        lines = (Array.isArray(source))\n            ? source\n            : source.split(rx_crlf);\n        tokens = [];\n\n        var char;                   // a popular character\n        var column = 0;             // the column number of the next character\n        var from;                   // the starting column number of the token\n        var line = -1;              // the line number of the next character\n        var nr = 0;                 // the next token number\n        var previous = global;      // the previous token including comments\n        var prior = global;         // the previous token excluding comments\n        var mega_from;              // the starting column of megastring\n        var mega_line;              // the starting line of megastring\n        var snippet;                // a piece of string\n        var source_line;            // the current line source string\n\n        function next_line() {\n\n// Put the next line of source in source_line. If the line contains tabs,\n// replace them with spaces and give a warning. Also warn if the line contains\n// unsafe characters or is too damn long.\n\n            var at;\n            column = 0;\n            line += 1;\n            source_line = lines[line];\n            if (source_line !== undefined) {\n                at = source_line.search(rx_tab);\n                if (at >= 0) {\n                    if (!option.white) {\n                        warn_at(\"use_spaces\", line, at + 1);\n                    }\n                    source_line = source_line.replace(rx_tab, \" \");\n                }\n                at = source_line.search(rx_unsafe);\n                if (at >= 0) {\n                    warn_at(\n                        \"unsafe\",\n                        line,\n                        column + at,\n                        \"U+\" + source_line.charCodeAt(at).toString(16)\n                    );\n                }\n                if (option.maxlen && option.maxlen < source_line.length) {\n                    warn_at(\"too_long\", line, source_line.length);\n                } else if (!option.white && source_line.slice(-1) === \" \") {\n                    warn_at(\n                        \"unexpected_trailing_space\",\n                        line,\n                        source_line.length - 1\n                    );\n                }\n            }\n            return source_line;\n        }\n\n// Most tokens, including the identifiers, operators, and punctuators, can be\n// found with a regular expression. Regular expressions cannot correctly match\n// regular expression literals, so we will match those the hard way. String\n// literals and number literals can be matched by regular expressions, but they\n// don't provide good warnings. The functions snip, next_char, prev_char,\n// some_digits, and escape help in the parsing of literals.\n\n        function snip() {\n\n// Remove the last character from snippet.\n\n            snippet = snippet.slice(0, -1);\n        }\n\n        function next_char(match) {\n\n// Get the next character from the source line. Remove it from the source_line,\n// and append it to the snippet. Optionally check that the previous character\n// matched an expected value.\n\n            if (match !== undefined && char !== match) {\n                return stop_at(\n                    (char === \"\")\n                        ? \"expected_a\"\n                        : \"expected_a_b\",\n                    line,\n                    column - 1,\n                    match,\n                    char\n                );\n            }\n            if (source_line) {\n                char = source_line.charAt(0);\n                source_line = source_line.slice(1);\n                snippet += char;\n            } else {\n                char = \"\";\n                snippet += \" \";\n            }\n            column += 1;\n            return char;\n        }\n\n        function back_char() {\n\n// Back up one character by moving a character from the end of the snippet to\n// the front of the source_line.\n\n            if (snippet) {\n                char = snippet.slice(-1);\n                source_line = char + source_line;\n                column -= 1;\n                snip();\n            } else {\n                char = \"\";\n            }\n            return char;\n        }\n\n        function some_digits(rx, quiet) {\n            var result = source_line.match(rx);\n            if (result) {\n                char = result[1];\n                column += char.length;\n                source_line = result[2];\n                snippet += char;\n            } else {\n                char = \"\";\n                if (!quiet) {\n                    warn_at(\n                        \"expected_digits_after_a\",\n                        line,\n                        column,\n                        snippet\n                    );\n                }\n            }\n            return char.length;\n        }\n\n        function escape(extra) {\n            switch (next_char(\"\\\\\")) {\n            case \"\\\\\":\n            case \"\\\"\":\n            case \"'\":\n            case \"/\":\n            case \":\":\n            case \"=\":\n            case \"|\":\n            case \"b\":\n            case \"f\":\n            case \"n\":\n            case \"r\":\n            case \"t\":\n            case \" \":\n                break;\n            case \"u\":\n                if (next_char(\"u\") === \"{\") {\n                    if (some_digits(rx_hexs) > 5) {\n                        warn_at(\"too_many_digits\", line, column - 1);\n                    }\n                    if (!option.es6) {\n                        warn_at(\"es6\", line, column, \"u{\");\n                    }\n                    if (next_char() !== \"}\") {\n                        stop_at(\"expected_a_before_b\", line, column, \"}\", char);\n                    }\n                    next_char();\n                    return;\n                }\n                back_char();\n                if (some_digits(rx_hexs, true) < 4) {\n                    warn_at(\"expected_four_digits\", line, column - 1);\n                }\n                break;\n            case \"\":\n                return stop_at(\"unclosed_string\", line, column);\n            default:\n                if (extra && extra.indexOf(char) < 0) {\n                    warn_at(\"unexpected_a_after_b\", line, column, char, \"\\\\\");\n                }\n            }\n            next_char();\n        }\n\n        function make(id, value, identifier) {\n\n// Make the token object and append it to the tokens list.\n\n            var the_token = {\n                from: from,\n                id: id,\n                identifier: !!identifier,\n                line: line,\n                nr: nr,\n                thru: column\n            };\n            tokens[nr] = the_token;\n            nr += 1;\n\n// Directives must appear before the first statement.\n\n            if (id !== \"(comment)\" && id !== \";\") {\n                directive_mode = false;\n            }\n\n// If the token is to have a value, give it one.\n\n            if (value !== undefined) {\n                the_token.value = value;\n            }\n\n// If this token is an identifier that touches a preceding number, or\n// a \"/\", comment, or regular expression literal that touches a preceding\n// comment or regular expression literal, then give a missing space warning.\n// This warning is not suppressed by option.white.\n\n            if (\n                previous.line === line &&\n                previous.thru === from &&\n                (\n                    (id === \"(comment)\" || id === \"(regexp)\" || id === \"/\") &&\n                    (\n                        previous.id === \"(comment)\" ||\n                        previous.id === \"(regexp)\"\n                    )\n                )\n            ) {\n                warn(\n                    \"expected_space_a_b\",\n                    the_token,\n                    artifact(previous),\n                    artifact(the_token)\n                );\n            }\n            if (previous.id === \".\" && id === \"(number)\") {\n                warn(\"expected_a_before_b\", previous, \"0\", \".\");\n            }\n            if (prior.id === \".\" && the_token.identifier) {\n                the_token.dot = true;\n            }\n\n// The previous token is used to detect adjacency problems.\n\n            previous = the_token;\n\n// The prior token is a previous token that was not a comment. The prior token\n// is used to disambiguate \"/\", which can mean division or regular expression\n// literal.\n\n            if (previous.id !== \"(comment)\") {\n                prior = previous;\n            }\n            return the_token;\n        }\n\n        function parse_directive(the_comment, body) {\n\n// JSLint recognizes three directives that can be encoded in comments. This\n// function processes one item, and calls itself recursively to process the\n// next one.\n\n            var result = body.match(rx_directive_part);\n            if (result) {\n                var allowed;\n                var name = result[1];\n                var value = result[2];\n                switch (the_comment.directive) {\n                case \"jslint\":\n                    allowed = allowed_option[name];\n                    switch (typeof allowed) {\n                    case \"boolean\":\n                    case \"object\":\n                        switch (value) {\n                        case \"true\":\n                        case \"\":\n                        case undefined:\n                            option[name] = true;\n                            if (Array.isArray(allowed)) {\n                                populate(declared_globals, allowed, false);\n                            }\n                            break;\n                        case \"false\":\n                            option[name] = false;\n                            break;\n                        default:\n                            warn(\n                                \"bad_option_a\",\n                                the_comment,\n                                name + \":\" + value\n                            );\n                        }\n                        break;\n                    case \"number\":\n                        if (isFinite(+value)) {\n                            option[name] = +value;\n                        } else {\n                            warn(\n                                \"bad_option_a\",\n                                the_comment,\n                                name + \":\" + value\n                            );\n                        }\n                        break;\n                    default:\n                        warn(\"bad_option_a\", the_comment, name);\n                    }\n                    break;\n                case \"property\":\n                    if (tenure === undefined) {\n                        tenure = empty();\n                    }\n                    tenure[name] = true;\n                    break;\n                case \"global\":\n                    if (value) {\n                        warn(\"bad_option_a\", the_comment, name + \":\" + value);\n                    }\n                    declared_globals[name] = false;\n                    module_mode = the_comment;\n                    break;\n                }\n                return parse_directive(the_comment, result[3]);\n            }\n            if (body) {\n                return stop(\"bad_directive_a\", the_comment, body);\n            }\n        }\n\n        function comment(snippet) {\n\n// Make a comment object. Comments are not allowed in JSON text. Comments can\n// include directives and notices of incompletion.\n\n            var the_comment = make(\"(comment)\", snippet);\n            if (Array.isArray(snippet)) {\n                snippet = snippet.join(\" \");\n            }\n            if (!option.devel && rx_todo.test(snippet)) {\n                warn(\"todo_comment\", the_comment);\n            }\n            var result = snippet.match(rx_directive);\n            if (result) {\n                if (!directive_mode) {\n                    warn_at(\"misplaced_directive_a\", line, from, result[1]);\n                } else {\n                    the_comment.directive = result[1];\n                    parse_directive(the_comment, result[2]);\n                }\n                directives.push(the_comment);\n            }\n            return the_comment;\n        }\n\n        function regexp() {\n\n// Parse a regular expression literal.\n\n            var result;\n            var value;\n\n            function quantifier() {\n\n// Match an optional quantifier.\n\n                switch (char) {\n                case \"?\":\n                case \"*\":\n                case \"+\":\n                    next_char();\n                    break;\n                case \"{\":\n                    if (some_digits(rx_digits, true) === 0) {\n                        warn_at(\"expected_a\", line, column, \"0\");\n                    }\n                    if (next_char() === \",\") {\n                        some_digits(rx_digits, true);\n                        next_char();\n                    }\n                    next_char(\"}\");\n                    break;\n                default:\n                    return;\n                }\n                if (char === \"?\") {\n                    next_char(\"?\");\n                }\n            }\n\n            function subklass() {\n\n// Match a character in a character class.\n\n                switch (char) {\n                case \"\\\\\":\n                    escape();\n                    return true;\n                case \"[\":\n                case \"]\":\n                case \"/\":\n                case \"^\":\n                case \"-\":\n                case \"|\":\n                case \"\":\n                    return false;\n                case \"`\":\n                    if (mega_mode) {\n                        warn_at(\"unexpected_a\", line, column, \"`\");\n                    }\n                    next_char();\n                    return true;\n                case \" \":\n                    warn_at(\"expected_a_before_b\", line, column, \"\\\\\", \" \");\n                    next_char();\n                    return true;\n                default:\n                    next_char();\n                    return true;\n                }\n            }\n\n            function ranges() {\n\n// Match a range of subclasses.\n\n                if (subklass()) {\n                    if (char === \"-\") {\n                        next_char(\"-\");\n                        if (!subklass()) {\n                            return stop_at(\n                                \"unexpected_a\",\n                                line,\n                                column - 1,\n                                \"-\"\n                            );\n                        }\n                    }\n                    return ranges();\n                }\n            }\n\n            function klass() {\n\n// Match a class.\n\n                next_char(\"[\");\n                if (char === \"^\") {\n                    next_char(\"^\");\n                }\n                (function classy() {\n                    ranges();\n                    if (char !== \"]\" && char !== \"\") {\n                        warn_at(\n                            \"expected_a_before_b\",\n                            line,\n                            column,\n                            \"\\\\\",\n                            char\n                        );\n                        next_char();\n                        return classy();\n                    }\n                }());\n                next_char(\"]\");\n            }\n\n            function choice() {\n\n                function group() {\n\n// Match a group that starts with left paren.\n\n                    next_char(\"(\");\n                    if (char === \"?\") {\n                        next_char(\"?\");\n                        switch (char) {\n                        case \":\":\n                        case \"=\":\n                        case \"!\":\n                            next_char();\n                            break;\n                        default:\n                            next_char(\":\");\n                        }\n                    } else if (char === \":\") {\n                        warn_at(\"expected_a_before_b\", line, column, \"?\", \":\");\n                    }\n                    choice();\n                    next_char(\")\");\n                }\n\n                function factor() {\n                    switch (char) {\n                    case \"[\":\n                        klass();\n                        return true;\n                    case \"\\\\\":\n                        escape(\"BbDdSsWw^${}[]().|*+?\");\n                        return true;\n                    case \"(\":\n                        group();\n                        return true;\n                    case \"/\":\n                    case \"|\":\n                    case \"]\":\n                    case \")\":\n                    case \"}\":\n                    case \"{\":\n                    case \"?\":\n                    case \"+\":\n                    case \"*\":\n                    case \"\":\n                        return false;\n                    case \"`\":\n                        if (mega_mode) {\n                            warn_at(\"unexpected_a\", line, column, \"`\");\n                        }\n                        break;\n                    case \" \":\n                        warn_at(\"expected_a_before_b\", line, column, \"\\\\\", \" \");\n                        break;\n                    }\n                    next_char();\n                    return true;\n                }\n\n                function sequence(follow) {\n                    if (factor()) {\n                        quantifier();\n                        return sequence(true);\n                    }\n                    if (!follow) {\n                        warn_at(\"expected_regexp_factor_a\", line, column, char);\n                    }\n                }\n\n// Match a choice (a sequence that can be followed by | and another choice).\n\n                sequence();\n                if (char === \"|\") {\n                    next_char(\"|\");\n                    return choice();\n                }\n            }\n\n// Scan the regexp literal. Give a warning if the first character is = because\n// /= looks like a division assignment operator.\n\n            snippet = \"\";\n            next_char();\n            if (char === \"=\") {\n                warn_at(\"expected_a_before_b\", line, column, \"\\\\\", \"=\");\n            }\n            choice();\n\n// Make sure there is a closing slash.\n\n            snip();\n            value = snippet;\n            next_char(\"/\");\n\n// Process dangling flag letters.\n\n            var allowed = {\n                g: true,\n                i: true,\n                m: true,\n                u: 6,\n                y: 6\n            };\n            var flag = empty();\n            (function make_flag() {\n                if (is_letter(char)) {\n                    switch (allowed[char]) {\n                    case true:\n                        break;\n                    case 6:\n                        if (!option.es6) {\n                            warn_at(\"es6\", line, column, char);\n                        }\n                        break;\n                    default:\n                        warn_at(\"unexpected_a\", line, column, char);\n                    }\n                    allowed[char] = false;\n                    flag[char] = true;\n                    next_char();\n                    return make_flag();\n                }\n            }());\n            back_char();\n            if (char === \"/\" || char === \"*\") {\n                return stop_at(\"unexpected_a\", line, from, char);\n            }\n            result = make(\"(regexp)\", char);\n            result.flag = flag;\n            result.value = value;\n            return result;\n        }\n\n        function string(quote) {\n\n// Make a string token.\n\n            var the_token;\n            snippet = \"\";\n            next_char();\n\n            return (function next() {\n                switch (char) {\n                case quote:\n                    snip();\n                    the_token = make(\"(string)\", snippet);\n                    the_token.quote = quote;\n                    return the_token;\n                case \"\\\\\":\n                    escape();\n                    break;\n                case \"\":\n                    return stop_at(\"unclosed_string\", line, column);\n                case \"`\":\n                    if (mega_mode) {\n                        warn_at(\"unexpected_a\", line, column, \"`\");\n                    }\n                    next_char(\"`\");\n                    break;\n                default:\n                    next_char();\n                }\n                return next();\n            }());\n        }\n\n        function frack() {\n            if (char === \".\") {\n                some_digits(rx_digits);\n                next_char();\n            }\n            if (char === \"E\" || char === \"e\") {\n                next_char();\n                if (char !== \"+\" && char !== \"-\") {\n                    back_char();\n                }\n                some_digits(rx_digits);\n                next_char();\n            }\n        }\n\n        function number() {\n            if (snippet === \"0\") {\n                switch (next_char()) {\n                case \".\":\n                    frack();\n                    break;\n                case \"b\":\n                    some_digits(rx_bits);\n                    next_char();\n                    break;\n                case \"o\":\n                    some_digits(rx_octals);\n                    next_char();\n                    break;\n                case \"x\":\n                    some_digits(rx_hexs);\n                    next_char();\n                    break;\n                }\n            } else {\n                next_char();\n                frack();\n            }\n\n// If the next character after a number is a digit or letter, then something\n// unexpected is going on.\n\n            if (\n                (char >= \"0\" && char <= \"9\") ||\n                (char >= \"a\" && char <= \"z\") ||\n                (char >= \"A\" && char <= \"Z\")\n            ) {\n                return stop_at(\n                    \"unexpected_a_after_b\",\n                    line,\n                    column - 1,\n                    snippet.slice(-1),\n                    snippet.slice(0, -1)\n                );\n            }\n            back_char();\n            return make(\"(number)\", snippet);\n        }\n\n        function lex() {\n            var array;\n            var i = 0;\n            var j = 0;\n            var last;\n            var result;\n            var the_token;\n            if (!source_line) {\n                source_line = next_line();\n                from = 0;\n                return (source_line === undefined)\n                    ? (mega_mode)\n                        ? stop_at(\"unclosed_mega\", mega_line, mega_from)\n                        : make(\"(end)\")\n                    : lex();\n            }\n            from = column;\n            result = source_line.match(rx_token);\n\n// result[1] token\n// result[2] whitespace\n// result[3] identifier\n// result[4] number\n// result[5] rest\n\n            if (!result) {\n                return stop_at(\n                    \"unexpected_char_a\",\n                    line,\n                    column,\n                    source_line.charAt(0)\n                );\n            }\n\n            snippet = result[1];\n            column += snippet.length;\n            source_line = result[5];\n\n// Whitespace was matched. Call lex again to get more.\n\n            if (result[2]) {\n                return lex();\n            }\n\n// The token is an identifier.\n\n            if (result[3]) {\n                return make(snippet, undefined, true);\n            }\n\n// The token is a number.\n\n            if (result[4]) {\n                return number(snippet);\n            }\n\n// The token is something miscellaneous.\n\n            switch (snippet) {\n\n// The token is a single or double quote string.\n\n            case \"\\\"\":\n                return string(snippet);\n\n            case \"'\":\n                if (!option.single) {\n                    warn_at(\"expected_a_b\", line, column, \"\\\"\", \"'\");\n                }\n                return string(snippet);\n\n// The token is a megastring. We don't allow any kind of mega nesting.\n\n            case \"`\":\n                if (mega_mode) {\n                    return stop_at(\"expected_a_b\", line, column, \"}\", \"`\");\n                }\n                snippet = \"\";\n                mega_from = from;\n                mega_line = line;\n                mega_mode = true;\n\n// Parsing a mega literal is tricky. First make a ` token.\n\n                make(\"`\");\n                from += 1;\n\n// Then loop, building up a string, possibly from many lines, until seeing\n// the end of file, a closing `, or a ${ indicting an expression within the\n// string.\n\n                (function part() {\n                    var at = source_line.search(rx_mega);\n\n// If neither ` nor ${ is seen, then the whole line joins the snippet.\n\n                    if (at < 0) {\n                        snippet += source_line + \"\\n\";\n                        return (next_line() === undefined)\n                            ? stop_at(\"unclosed_mega\", mega_line, mega_from)\n                            : part();\n                    }\n\n// if either ` or ${ was found, then the preceding joins the snippet to become\n// a string token.\n\n                    snippet += source_line.slice(0, at);\n                    column += at;\n                    source_line = source_line.slice(at);\n                    if (source_line.charAt(0) === \"\\\\\") {\n                        stop_at(\"escape_mega\", line, at);\n                    }\n                    make(\"(string)\", snippet).quote = \"`\";\n                    snippet = \"\";\n\n// If ${, then make tokens that will become part of an expression until\n// a } token is made.\n\n                    if (source_line.charAt(0) === \"$\") {\n                        column += 2;\n                        make(\"${\");\n                        source_line = source_line.slice(2);\n                        (function expr() {\n                            var id = lex().id;\n                            if (id === \"{\") {\n                                return stop_at(\n                                    \"expected_a_b\",\n                                    line,\n                                    column,\n                                    \"}\",\n                                    \"{\"\n                                );\n                            }\n                            if (id !== \"}\") {\n                                return expr();\n                            }\n                        }());\n                        return part();\n                    }\n                }());\n                source_line = source_line.slice(1);\n                column += 1;\n                mega_mode = false;\n                return make(\"`\");\n\n// The token is a // comment.\n\n            case \"//\":\n                snippet = source_line;\n                source_line = \"\";\n                the_token = comment(snippet);\n                if (mega_mode) {\n                    warn(\"unexpected_comment\", the_token, \"`\");\n                }\n                return the_token;\n\n// The token is a /* comment.\n\n            case \"/*\":\n                array = [];\n                if (source_line.charAt(0) === \"/\") {\n                    warn_at(\"unexpected_a\", line, column + i, \"/\");\n                }\n                (function next() {\n                    if (source_line > \"\") {\n                        i = source_line.search(rx_star_slash);\n                        if (i >= 0) {\n                            return;\n                        }\n                        j = source_line.search(rx_slash_star);\n                        if (j >= 0) {\n                            warn_at(\"nested_comment\", line, column + j);\n                        }\n                    }\n                    array.push(source_line);\n                    source_line = next_line();\n                    if (source_line === undefined) {\n                        return stop_at(\"unclosed_comment\", line, column);\n                    }\n                    return next();\n                }());\n                snippet = source_line.slice(0, i);\n                j = snippet.search(rx_slash_star_or_slash);\n                if (j >= 0) {\n                    warn_at(\"nested_comment\", line, column + j);\n                }\n                array.push(snippet);\n                column += i + 2;\n                source_line = source_line.slice(i + 2);\n                return comment(array);\n\n// The token is a slash.\n\n            case \"/\":\n\n// The / can be a division operator or the beginning of a regular expression\n// literal. It is not possible to know which without doing a complete parse.\n// We want to complete the tokenization before we begin to parse, so we will\n// estimate. This estimator can fail in some cases. For example, it cannot\n// know if \"}\" is ending a block or ending an object literal, so it can\n// behave incorrectly in that case; it is not meaningful to divide an\n// object, so it is likely that we can get away with it. We avoided the worst\n// cases by eliminating automatic semicolon insertion.\n\n                if (prior.identifier) {\n                    if (!prior.dot) {\n                        switch (prior.id) {\n                        case \"return\":\n                            return regexp();\n                        case \"(begin)\":\n                        case \"case\":\n                        case \"delete\":\n                        case \"in\":\n                        case \"instanceof\":\n                        case \"new\":\n                        case \"typeof\":\n                        case \"void\":\n                        case \"yield\":\n                            the_token = regexp();\n                            return stop(\"unexpected_a\", the_token);\n                        }\n                    }\n                } else {\n                    last = prior.id.charAt(prior.id.length - 1);\n                    if (\"(,=:?[\".indexOf(last) >= 0) {\n                        return regexp();\n                    }\n                    if (\"!&|{};~+-*%/^<>\".indexOf(last) >= 0) {\n                        the_token = regexp();\n                        warn(\"wrap_regexp\", the_token);\n                        return the_token;\n                    }\n                }\n                if (source_line.charAt(0) === \"/\") {\n                    column += 1;\n                    source_line = source_line.slice(1);\n                    snippet = \"/=\";\n                    warn_at(\"unexpected_a\", line, column, \"/=\");\n                }\n                break;\n            }\n            return make(snippet);\n        }\n\n// This is the only loop in JSLint. It will turn into a recursive call to lex\n// when ES6 has been finished and widely deployed and adopted.\n\n        while (true) {\n            if (lex().id === \"(end)\") {\n                break;\n            }\n        }\n    }\n\n// Parsing:\n\n// Parsing weaves the tokens into an abstract syntax tree. During that process,\n// a token may be given any of these properties:\n\n//      arity       string\n//      label       identifier\n//      name        identifier\n//      expression  expressions\n//      block       statements\n//      else        statements (else, default, catch)\n\n// Specialized tokens may have additional properties.\n\n    function survey(name) {\n        var id = name.id;\n\n// Tally the property name. If it is a string, only tally strings that conform\n// to the identifier rules.\n\n        if (id === \"(string)\") {\n            id = name.value;\n            if (!rx_identifier.test(id)) {\n                return id;\n            }\n        } else if (id === \"`\") {\n            if (name.value.length === 1) {\n                id = name.value[0].value;\n                if (!rx_identifier.test(id)) {\n                    return id;\n                }\n            }\n        } else if (!name.identifier) {\n            return stop(\"expected_identifier_a\", name);\n        }\n\n// If we have seen this name before, increment its count.\n\n        if (typeof property[id] === \"number\") {\n            property[id] += 1;\n\n// If this is the first time seeing this property name, and if there is a\n// tenure list, then it must be on the list. Otherwise, it must conform to\n// the rules for good property names.\n\n        } else {\n            if (tenure !== undefined) {\n                if (tenure[id] !== true) {\n                    warn(\"unregistered_property_a\", name);\n                }\n            } else {\n                if (name.identifier && rx_bad_property.test(id)) {\n                    warn(\"bad_property_a\", name);\n                }\n            }\n            property[id] = 1;\n        }\n        return id;\n    }\n\n    function dispense() {\n\n// Deliver the next token, skipping the comments.\n\n        var cadet = tokens[token_nr];\n        token_nr += 1;\n        if (cadet.id === \"(comment)\") {\n            if (json_mode) {\n                warn(\"unexpected_a\", cadet);\n            }\n            return dispense();\n        } else {\n            return cadet;\n        }\n    }\n\n    function lookahead() {\n\n// Look ahead one token without advancing.\n\n        var old_token_nr = token_nr;\n        var cadet = dispense(true);\n        token_nr = old_token_nr;\n        return cadet;\n    }\n\n    function advance(id, match) {\n\n// Produce the next token.\n\n// Attempt to give helpful names to anonymous functions.\n\n        if (token.identifier && token.id !== \"function\") {\n            anon = token.id;\n        } else if (token.id === \"(string)\" && rx_identifier.test(token.value)) {\n            anon = token.value;\n        }\n\n// Attempt to match next_token with an expected id.\n\n        if (id !== undefined && next_token.id !== id) {\n            return (match === undefined)\n                ? stop(\"expected_a_b\", next_token, id, artifact())\n                : stop(\n                    \"expected_a_b_from_c_d\",\n                    next_token,\n                    id,\n                    artifact(match),\n                    artifact_line(match),\n                    artifact(next_token)\n                );\n        }\n\n// Promote the tokens, skipping comments.\n\n        token = next_token;\n        next_token = dispense();\n        if (next_token.id === \"(end)\") {\n            token_nr -= 1;\n        }\n    }\n\n// Parsing of JSON is simple:\n\n    function json_value() {\n\n        function json_object() {\n            var brace = next_token;\n            var object = empty();\n            advance(\"{\");\n            if (next_token.id !== \"}\") {\n                (function next() {\n                    if (next_token.quote !== \"\\\"\") {\n                        warn(\"unexpected_a\", next_token, next_token.quote);\n                    }\n                    advance(\"(string)\");\n                    if (object[token.value] !== undefined) {\n                        warn(\"duplicate_a\", token);\n                    } else if (token.value === \"__proto__\") {\n                        warn(\"bad_property_a\", token);\n                    } else {\n                        object[token.value] = token;\n                    }\n                    advance(\":\");\n                    json_value();\n                    if (next_token.id === \",\") {\n                        advance(\",\");\n                        return next();\n                    }\n                }());\n            }\n            advance(\"}\", brace);\n        }\n\n        function json_array() {\n            var bracket = next_token;\n            advance(\"[\");\n            if (next_token.id !== \"]\") {\n                (function next() {\n                    json_value();\n                    if (next_token.id === \",\") {\n                        advance(\",\");\n                        return next();\n                    }\n                }());\n            }\n            advance(\"]\", bracket);\n        }\n\n        switch (next_token.id) {\n        case \"{\":\n            json_object();\n            break;\n        case \"[\":\n            json_array();\n            break;\n        case \"true\":\n        case \"false\":\n        case \"null\":\n            advance();\n            break;\n        case \"(number)\":\n            if (!rx_JSON_number.test(next_token.value)) {\n                warn(\"unexpected_a\");\n            }\n            advance();\n            break;\n        case \"(string)\":\n            if (next_token.quote !== \"\\\"\") {\n                warn(\"unexpected_a\", next_token, next_token.quote);\n            }\n            advance();\n            break;\n        case \"-\":\n            advance(\"-\");\n            advance(\"(number)\");\n            break;\n        default:\n            stop(\"unexpected_a\");\n        }\n    }\n\n// Now we parse JavaScript.\n\n    function enroll(name, role, readonly) {\n\n// Enroll a name into the current function context. The role can be exception,\n// function, label, parameter, or variable. We look for variable redefinition\n// because it causes confusion.\n\n        var id = name.id;\n\n// Reserved words may not be enrolled.\n\n        if (syntax[id] !== undefined && id !== \"ignore\") {\n            warn(\"reserved_a\", name);\n        } else {\n\n// Has the name been enrolled in this context?\n\n            var earlier = functionage.context[id];\n            if (earlier) {\n                warn(\n                    \"redefinition_a_b\",\n                    name,\n                    name.id,\n                    earlier.line + fudge\n                );\n\n// Has the name been enrolled in an outer context?\n\n            } else {\n                stack.forEach(function (value) {\n                    var item = value.context[id];\n                    if (item !== undefined) {\n                        earlier = item;\n                    }\n                });\n                if (earlier) {\n                    if (id === \"ignore\") {\n                        if (earlier.role === \"variable\") {\n                            warn(\"unexpected_a\", name);\n                        }\n                    } else {\n                        if ((\n                            role !== \"exception\" ||\n                            earlier.role !== \"exception\"\n                        ) && role !== \"parameter\") {\n                            warn(\n                                \"redefinition_a_b\",\n                                name,\n                                name.id,\n                                earlier.line + fudge\n                            );\n                        }\n                    }\n                }\n\n// Enroll it.\n\n                functionage.context[id] = name;\n                name.dead = true;\n                name.function = functionage;\n                name.init = false;\n                name.role = role;\n                name.used = 0;\n                name.writable = !readonly;\n            }\n        }\n    }\n\n    function expression(rbp, initial) {\n\n// This is the heart of the Pratt parser. I retained Pratt's nomenclature.\n// They are elements of the parsing method called Top Down Operator Precedence.\n\n// nud     Null denotation\n// led     Left denotation\n// lbp     Left binding power\n// rbp     Right binding power\n\n// It processes a nud (variable, constant, prefix operator). It will then\n// process leds (infix operators) until the bind powers cause it to stop. It\n// returns the expression's parse tree.\n\n        var left;\n        var the_symbol;\n\n// Statements will have already advanced, so advance now only if the token is\n// not the first of a statement,\n\n        if (!initial) {\n            advance();\n        }\n        the_symbol = syntax[token.id];\n        if (the_symbol !== undefined && the_symbol.nud !== undefined) {\n            left = the_symbol.nud();\n        } else if (token.identifier) {\n            left = token;\n            left.arity = \"variable\";\n        } else {\n            return stop(\"unexpected_a\", token);\n        }\n        (function right() {\n            the_symbol = syntax[next_token.id];\n            if (\n                the_symbol !== undefined &&\n                the_symbol.led !== undefined &&\n                rbp < the_symbol.lbp\n            ) {\n                advance();\n                left = the_symbol.led(left);\n                return right();\n            }\n        }());\n        return left;\n    }\n\n    function condition() {\n\n// Parse the condition part of a do, if, while.\n\n        var the_paren = next_token;\n        var the_value;\n        the_paren.free = true;\n        advance(\"(\");\n        the_value = expression(0);\n        advance(\")\");\n        if (the_value.wrapped === true) {\n            warn(\"unexpected_a\", the_paren);\n        }\n        switch (the_value.id) {\n        case \"?\":\n        case \"~\":\n        case \"&\":\n        case \"|\":\n        case \"^\":\n        case \"<<\":\n        case \">>\":\n        case \">>>\":\n        case \"+\":\n        case \"-\":\n        case \"*\":\n        case \"/\":\n        case \"%\":\n        case \"typeof\":\n        case \"(number)\":\n        case \"(string)\":\n            warn(\"unexpected_a\", the_value);\n            break;\n        }\n        return the_value;\n    }\n\n    function is_weird(thing) {\n        return (\n            thing.id === \"(regexp)\" ||\n            thing.id === \"{\" ||\n            thing.id === \"=>\" ||\n            thing.id === \"function\" ||\n            (thing.id === \"[\" && thing.arity === \"unary\")\n        );\n    }\n\n    function are_similar(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (Array.isArray(a)) {\n            return (\n                Array.isArray(b) &&\n                a.length === b.length &&\n                a.every(function (value, index) {\n                    return are_similar(value, b[index]);\n                })\n            );\n        }\n        if (Array.isArray(b)) {\n            return false;\n        }\n        if (a.id === \"(number)\" && b.id === \"(number)\") {\n            return a.value === b.value;\n        }\n        var a_string;\n        var b_string;\n        if (a.id === \"(string)\") {\n            a_string = a.value;\n        } else if (a.id === \"`\" && a.constant) {\n            a_string = a.value[0];\n        }\n        if (b.id === \"(string)\") {\n            b_string = b.value;\n        } else if (b.id === \"`\" && b.constant) {\n            b_string = b.value[0];\n        }\n        if (typeof a_string === \"string\") {\n            return a_string === b_string;\n        }\n        if (is_weird(a) || is_weird(b)) {\n            return false;\n        }\n        if (a.arity === b.arity && a.id === b.id) {\n            if (a.id === \".\") {\n                return are_similar(a.expression, b.expression) &&\n                        are_similar(a.name, b.name);\n            }\n            switch (a.arity) {\n            case \"unary\":\n                return are_similar(a.expression, b.expression);\n            case \"binary\":\n                return (\n                    a.id !== \"(\" &&\n                    are_similar(a.expression[0], b.expression[0]) &&\n                    are_similar(a.expression[1], b.expression[1])\n                );\n            case \"ternary\":\n                return (\n                    are_similar(a.expression[0], b.expression[0]) &&\n                    are_similar(a.expression[1], b.expression[1]) &&\n                    are_similar(a.expression[2], b.expression[2])\n                );\n            case \"function\":\n            case \"regexp\":\n                return false;\n            default:\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function semicolon() {\n\n// Try to match a semicolon.\n\n        if (next_token.id === \";\") {\n            advance(\";\");\n        } else {\n            warn_at(\n                \"expected_a_b\",\n                token.line,\n                token.thru,\n                \";\",\n                artifact(next_token)\n            );\n        }\n        anon = \"anonymous\";\n    }\n\n    function statement() {\n\n// Parse a statement. Any statement may have a label, but only four statements\n// have use for one. A statement can be one of the standard statements, or\n// an assignment expression, or an invocation expression.\n\n        var first;\n        var the_label;\n        var the_statement;\n        var the_symbol;\n        advance();\n        if (token.identifier && next_token.id === \":\") {\n            the_label = token;\n            if (the_label.id === \"ignore\") {\n                warn(\"unexpected_a\", the_label);\n            }\n            advance(\":\");\n            switch (next_token.id) {\n            case \"do\":\n            case \"for\":\n            case \"switch\":\n            case \"while\":\n                enroll(the_label, \"label\", true);\n                the_label.init = true;\n                the_label.dead = false;\n                the_statement = statement();\n                the_statement.label = the_label;\n                the_statement.statement = true;\n                return the_statement;\n            default:\n                advance();\n                warn(\"unexpected_label_a\", the_label);\n            }\n        }\n\n// Parse the statement.\n\n        first = token;\n        first.statement = true;\n        the_symbol = syntax[first.id];\n        if (the_symbol !== undefined && the_symbol.fud !== undefined) {\n            the_symbol.disrupt = false;\n            the_symbol.statement = true;\n            the_statement = the_symbol.fud();\n        } else {\n\n// It is an expression statement.\n\n            the_statement = expression(0, true);\n            if (the_statement.wrapped && the_statement.id !== \"(\") {\n                warn(\"unexpected_a\", first);\n            }\n            semicolon();\n        }\n        if (the_label !== undefined) {\n            the_label.dead = true;\n        }\n        return the_statement;\n    }\n\n    function statements() {\n\n// Parse a list of statements. Give a warning if an unreachable statement\n// follows a disruptive statement.\n\n        var array = [];\n        (function next(disrupt) {\n            var a_statement;\n            switch (next_token.id) {\n            case \"}\":\n            case \"case\":\n            case \"default\":\n            case \"else\":\n            case \"(end)\":\n                break;\n            default:\n                a_statement = statement();\n                array.push(a_statement);\n                if (disrupt) {\n                    warn(\"unreachable_a\", a_statement);\n                }\n                return next(a_statement.disrupt);\n            }\n        }(false));\n        return array;\n    }\n\n    function not_top_level(thing) {\n\n// Some features should not be at the outermost level.\n\n        if (functionage === global) {\n            warn(\"unexpected_at_top_level_a\", thing);\n        }\n    }\n\n    function top_level_only(the_thing) {\n\n// Some features must be at the most outermost level.\n\n        if (blockage !== global) {\n            warn(\"misplaced_a\", the_thing);\n        }\n    }\n\n    function block(special) {\n\n// Parse a block, a sequence of statements wrapped in braces.\n//  special \"body\"      The block is a function body.\n//          \"ignore\"    No warning on an empty block.\n//          \"naked\"     No advance.\n//          undefined   An ordinary block.\n\n        var stmts;\n        var the_block;\n        if (special !== \"naked\") {\n            advance(\"{\");\n        }\n        the_block = token;\n        the_block.arity = \"statement\";\n        the_block.body = special === \"body\";\n\n// All top level function bodies should include the \"use strict\" pragma unless\n// the whole file is strict or the file is a module or the function parameters\n// use es6 syntax.\n\n        if (\n            special === \"body\" &&\n            stack.length === 1 &&\n            next_token.value === \"use strict\"\n        ) {\n            the_block.strict = next_token;\n            next_token.statement = true;\n            advance(\"(string)\");\n            advance(\";\");\n        }\n        stmts = statements();\n        the_block.block = stmts;\n        if (stmts.length === 0) {\n            if (!option.devel && special !== \"ignore\") {\n                warn(\"empty_block\", the_block);\n            }\n            the_block.disrupt = false;\n        } else {\n            the_block.disrupt = stmts[stmts.length - 1].disrupt;\n        }\n        advance(\"}\");\n        return the_block;\n    }\n\n    function mutation_check(the_thing) {\n\n// The only expressions that may be assigned to are\n//      e.b\n//      e[b]\n//      v\n\n        if (\n            the_thing.id !== \".\" &&\n            the_thing.arity !== \"variable\" &&\n            (the_thing.id !== \"[\" || the_thing.arity !== \"binary\")\n        ) {\n            warn(\"bad_assignment_a\", the_thing);\n            return false;\n        }\n        return true;\n    }\n\n    function left_check(left, right) {\n\n// Warn if the left is not one of these:\n//      e.b\n//      e[b]\n//      e()\n//      identifier\n\n        var id = left.id;\n        if (\n            !left.identifier &&\n            (\n                left.arity !== \"binary\" ||\n                (id !== \".\" && id !== \"(\" && id !== \"[\")\n            )\n        ) {\n            warn(\"unexpected_a\", right);\n            return false;\n        }\n        return true;\n    }\n\n// These functions are used to specify the grammar of our language:\n\n    function symbol(id, bp) {\n\n// Make a symbol if it does not already exist in the language's syntax.\n\n        var the_symbol = syntax[id];\n        if (the_symbol === undefined) {\n            the_symbol = empty();\n            the_symbol.id = id;\n            the_symbol.lbp = bp || 0;\n            syntax[id] = the_symbol;\n        }\n        return the_symbol;\n    }\n\n    function assignment(id) {\n\n// Make an assignment operator. The one true assignment is different because\n// its left side, when it is a variable, is not treated as an expression.\n// That case is special because that is when a variable gets initialized. The\n// other assignment operators can modify, but they cannot initialize.\n\n        var the_symbol = symbol(id, 20);\n        the_symbol.led = function (left) {\n            var the_token = token;\n            var right;\n            the_token.arity = \"assignment\";\n            right = expression(20 - 1);\n            if (id === \"=\" && left.arity === \"variable\") {\n                the_token.names = left;\n                the_token.expression = right;\n            } else {\n                the_token.expression = [left, right];\n            }\n            switch (right.arity) {\n            case \"assignment\":\n            case \"pre\":\n            case \"post\":\n                warn(\"unexpected_a\", right);\n                break;\n            }\n            if (\n                option.es6 &&\n                left.arity === \"unary\" &&\n                (left.id === \"[\" || left.id === \"{\")\n            ) {\n                warn(\"expected_a_before_b\", left, \"const\", left.id);\n            } else {\n                mutation_check(left);\n            }\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function constant(id, type, value) {\n\n// Make a constant symbol.\n\n        var the_symbol = symbol(id);\n        the_symbol.constant = true;\n        the_symbol.nud = (typeof value === \"function\")\n            ? value\n            : function () {\n                token.constant = true;\n                if (value !== undefined) {\n                    token.value = value;\n                }\n                return token;\n            };\n        the_symbol.type = type;\n        the_symbol.value = value;\n        return the_symbol;\n    }\n\n    function infix(id, bp, f) {\n\n// Make an infix operator.\n\n        var the_symbol = symbol(id, bp);\n        the_symbol.led = function (left) {\n            var the_token = token;\n            the_token.arity = \"binary\";\n            if (f !== undefined) {\n                return f(left);\n            }\n            the_token.expression = [left, expression(bp)];\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function post(id) {\n\n// Make one of the post operators.\n\n        var the_symbol = symbol(id, 150);\n        the_symbol.led = function (left) {\n            token.expression = left;\n            token.arity = \"post\";\n            mutation_check(token.expression);\n            return token;\n        };\n        return the_symbol;\n    }\n\n    function pre(id) {\n\n// Make one of the pre operators.\n\n        var the_symbol = symbol(id);\n        the_symbol.nud = function () {\n            var the_token = token;\n            the_token.arity = \"pre\";\n            the_token.expression = expression(150);\n            mutation_check(the_token.expression);\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function prefix(id, f) {\n\n// Make a prefix operator.\n\n        var the_symbol = symbol(id);\n        the_symbol.nud = function () {\n            var the_token = token;\n            the_token.arity = \"unary\";\n            if (typeof f === \"function\") {\n                return f();\n            }\n            the_token.expression = expression(150);\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function stmt(id, f) {\n\n// Make a statement.\n\n        var the_symbol = symbol(id);\n        the_symbol.fud = function () {\n            token.arity = \"statement\";\n            return f();\n        };\n        return the_symbol;\n    }\n\n    function ternary(id1, id2) {\n\n// Make a ternary operator.\n\n        var the_symbol = symbol(id1, 30);\n        the_symbol.led = function (left) {\n            var the_token = token;\n            var second = expression(20);\n            advance(id2);\n            token.arity = \"ternary\";\n            the_token.arity = \"ternary\";\n            the_token.expression = [left, second, expression(10)];\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n// Begin defining the language.\n\n    syntax = empty();\n\n    symbol(\"}\");\n    symbol(\")\");\n    symbol(\"]\");\n    symbol(\",\");\n    symbol(\";\");\n    symbol(\":\");\n    symbol(\"*/\");\n    symbol(\"await\");\n    symbol(\"case\");\n    symbol(\"catch\");\n    symbol(\"class\");\n    symbol(\"default\");\n    symbol(\"else\");\n    symbol(\"enum\");\n    symbol(\"finally\");\n    symbol(\"implements\");\n    symbol(\"interface\");\n    symbol(\"package\");\n    symbol(\"private\");\n    symbol(\"protected\");\n    symbol(\"public\");\n    symbol(\"static\");\n    symbol(\"super\");\n    symbol(\"void\");\n    symbol(\"yield\");\n\n    constant(\"(number)\", \"number\");\n    constant(\"(regexp)\", \"regexp\");\n    constant(\"(string)\", \"string\");\n    constant(\"arguments\", \"object\", function () {\n        if (option.es6) {\n            warn(\"unexpected_a\", token);\n        }\n        return token;\n    });\n    constant(\"eval\", \"function\", function () {\n        if (!option.eval) {\n            warn(\"unexpected_a\", token);\n        } else if (next_token.id !== \"(\") {\n            warn(\"expected_a_before_b\", next_token, \"(\", artifact());\n        }\n        return token;\n    });\n    constant(\"false\", \"boolean\", false);\n    constant(\"Function\", \"function\", function () {\n        if (!option.eval) {\n            warn(\"unexpected_a\", token);\n        } else if (next_token.id !== \"(\") {\n            warn(\"expected_a_before_b\", next_token, \"(\", artifact());\n        }\n        return token;\n    });\n    constant(\"ignore\", \"undefined\", function () {\n        warn(\"unexpected_a\", token);\n        return token;\n    });\n    constant(\"Infinity\", \"number\", Infinity);\n    constant(\"isNaN\", \"function\", function () {\n        if (option.es6) {\n            warn(\"expected_a_b\", token, \"Number.isNaN\", \"isNaN\");\n        }\n        return token;\n    });\n    constant(\"NaN\", \"number\", NaN);\n    constant(\"null\", \"null\", null);\n    constant(\"this\", \"object\", function () {\n        if (!option.this) {\n            warn(\"unexpected_a\", token);\n        }\n        return token;\n    });\n    constant(\"true\", \"boolean\", true);\n    constant(\"undefined\", \"undefined\");\n\n    assignment(\"=\");\n    assignment(\"+=\");\n    assignment(\"-=\");\n    assignment(\"*=\");\n    assignment(\"/=\");\n    assignment(\"%=\");\n    assignment(\"&=\");\n    assignment(\"|=\");\n    assignment(\"^=\");\n    assignment(\"<<=\");\n    assignment(\">>=\");\n    assignment(\">>>=\");\n\n    infix(\"||\", 40);\n    infix(\"&&\", 50);\n    infix(\"|\", 70);\n    infix(\"^\", 80);\n    infix(\"&\", 90);\n    infix(\"==\", 100);\n    infix(\"===\", 100);\n    infix(\"!=\", 100);\n    infix(\"!==\", 100);\n    infix(\"<\", 110);\n    infix(\">\", 110);\n    infix(\"<=\", 110);\n    infix(\">=\", 110);\n    infix(\"in\", 110);\n    infix(\"instanceof\", 110);\n    infix(\"<<\", 120);\n    infix(\">>\", 120);\n    infix(\">>>\", 120);\n    infix(\"+\", 130);\n    infix(\"-\", 130);\n    infix(\"*\", 140);\n    infix(\"/\", 140);\n    infix(\"%\", 140);\n    infix(\"(\", 160, function (left) {\n        var the_paren = token;\n        var the_argument;\n        if (left.id !== \"function\") {\n            left_check(left, the_paren);\n        }\n        if (functionage.arity === \"statement\" && left.identifier) {\n            functionage.name.calls[left.id] = left;\n        }\n        the_paren.expression = [left];\n        if (next_token.id !== \")\") {\n            (function next() {\n                var ellipsis;\n                if (next_token.id === \"...\") {\n                    if (!option.es6) {\n                        warn(\"es6\");\n                    }\n                    ellipsis = true;\n                    advance(\"...\");\n                }\n                the_argument = expression(10);\n                if (ellipsis) {\n                    the_argument.ellipsis = true;\n                }\n                the_paren.expression.push(the_argument);\n                if (next_token.id === \",\") {\n                    advance(\",\");\n                    return next();\n                }\n            }());\n        }\n        advance(\")\", the_paren);\n        if (the_paren.expression.length === 2) {\n            the_paren.free = true;\n            if (the_argument.wrapped === true) {\n                warn(\"unexpected_a\", the_paren);\n            }\n            if (the_argument.id === \"(\") {\n                the_argument.wrapped = true;\n            }\n        } else {\n            the_paren.free = false;\n        }\n        return the_paren;\n    });\n    infix(\".\", 170, function (left) {\n        var the_token = token;\n        var name = next_token;\n        if (\n            (left.id !== \"(string)\" || name.id !== \"indexOf\") &&\n            (left.id !== \"[\" || (\n                name.id !== \"concat\" && name.id !== \"forEach\"\n            )) &&\n            (left.id !== \"+\" || name.id !== \"slice\") &&\n            (left.id !== \"(regexp)\" || (\n                name.id !== \"exec\" && name.id !== \"test\"\n            ))\n        ) {\n            left_check(left, the_token);\n        }\n        if (!name.identifier) {\n            stop(\"expected_identifier_a\");\n        }\n        advance();\n        survey(name);\n\n// The property name is not an expression.\n\n        the_token.name = name;\n        the_token.expression = left;\n        return the_token;\n    });\n    infix(\"[\", 170, function (left) {\n        var the_token = token;\n        var the_subscript = expression(0);\n        if (the_subscript.id === \"(string)\" || the_subscript.id === \"`\") {\n            var name = survey(the_subscript);\n            if (rx_identifier.test(name)) {\n                warn(\"subscript_a\", the_subscript, name);\n            }\n        }\n        left_check(left, the_token);\n        the_token.expression = [left, the_subscript];\n        advance(\"]\");\n        return the_token;\n    });\n    infix(\"=>\", 170, function (left) {\n        return stop(\"wrap_parameter\", left);\n    });\n\n    function do_tick() {\n        var the_tick = token;\n        if (!option.es6) {\n            warn(\"es6\", the_tick);\n        }\n        the_tick.value = [];\n        the_tick.expression = [];\n        if (next_token.id !== \"`\") {\n            (function part() {\n                advance(\"(string)\");\n                the_tick.value.push(token);\n                if (next_token.id === \"${\") {\n                    advance(\"${\");\n                    the_tick.expression.push(expression(0));\n                    advance(\"}\");\n                    return part();\n                }\n            }());\n        }\n        advance(\"`\");\n        return the_tick;\n    }\n\n    infix(\"`\", 160, function (left) {\n        var the_tick = do_tick();\n        left_check(left, the_tick);\n        the_tick.expression = [left].concat(the_tick.expression);\n        return the_tick;\n    });\n\n    post(\"++\");\n    post(\"--\");\n    pre(\"++\");\n    pre(\"--\");\n\n    prefix(\"+\");\n    prefix(\"-\");\n    prefix(\"~\");\n    prefix(\"!\");\n    prefix(\"!!\");\n    prefix(\"[\", function () {\n        var the_token = token;\n        the_token.expression = [];\n        if (next_token.id !== \"]\") {\n            (function next() {\n                var element;\n                var ellipsis = false;\n                if (next_token.id === \"...\") {\n                    ellipsis = true;\n                    if (!option.es6) {\n                        warn(\"es6\");\n                    }\n                    advance(\"...\");\n                }\n                element = expression(10);\n                if (ellipsis) {\n                    element.ellipsis = true;\n                }\n                the_token.expression.push(element);\n                if (next_token.id === \",\") {\n                    advance(\",\");\n                    return next();\n                }\n            }());\n        }\n        advance(\"]\");\n        return the_token;\n    });\n    prefix(\"/=\", function () {\n        stop(\"expected_a_b\", token, \"/\\\\=\", \"/=\");\n    });\n    prefix(\"=>\", function () {\n        return stop(\"expected_a_before_b\", token, \"()\", \"=>\");\n    });\n    prefix(\"new\", function () {\n        var the_new = token;\n        var right = expression(160);\n        if (next_token.id !== \"(\") {\n            warn(\"expected_a_before_b\", next_token, \"()\", artifact(next_token));\n        }\n        the_new.expression = right;\n        return the_new;\n    });\n    prefix(\"typeof\");\n    prefix(\"void\", function () {\n        var the_void = token;\n        warn(\"unexpected_a\", the_void);\n        the_void.expression = expression(0);\n        return the_void;\n    });\n\n    function parameter_list() {\n        var complex = false;\n        var list = [];\n        var signature = [\"(\"];\n        if (next_token.id !== \")\" && next_token.id !== \"(end)\") {\n            (function parameter() {\n                var ellipsis = false;\n                var param;\n                if (next_token.id === \"{\") {\n                    complex = true;\n                    if (!option.es6) {\n                        warn(\"es6\");\n                    }\n                    param = next_token;\n                    param.names = [];\n                    advance(\"{\");\n                    signature.push(\"{\");\n                    (function subparameter() {\n                        var subparam = next_token;\n                        if (!subparam.identifier) {\n                            return stop(\"expected_identifier_a\");\n                        }\n                        survey(subparam);\n                        advance();\n                        signature.push(subparam.id);\n                        if (next_token.id === \":\") {\n                            advance(\":\");\n                            advance();\n                            token.label = subparam;\n                            subparam = token;\n                            if (!subparam.identifier) {\n                                return stop(\"expected_identifier_a\");\n                            }\n                        }\n                        param.names.push(subparam);\n                        if (next_token.id === \",\") {\n                            advance(\",\");\n                            signature.push(\", \");\n                            return subparameter();\n                        }\n                    }());\n                    list.push(param);\n                    advance(\"}\");\n                    signature.push(\"}\");\n                    if (next_token.id === \",\") {\n                        advance(\",\");\n                        signature.push(\", \");\n                        return parameter();\n                    }\n                } else if (next_token.id === \"[\") {\n                    complex = true;\n                    if (!option.es6) {\n                        warn(\"es6\");\n                    }\n                    param = next_token;\n                    param.names = [];\n                    advance(\"[\");\n                    signature.push(\"[]\");\n                    (function subparameter() {\n                        var subparam = next_token;\n                        if (!subparam.identifier) {\n                            return stop(\"expected_identifier_a\");\n                        }\n                        advance();\n                        param.names.push(subparam);\n                        if (next_token.id === \",\") {\n                            advance(\",\");\n                            return subparameter();\n                        }\n                    }());\n                    list.push(param);\n                    advance(\"]\");\n                    if (next_token.id === \",\") {\n                        advance(\",\");\n                        signature.push(\", \");\n                        return parameter();\n                    }\n                } else {\n                    if (next_token.id === \"...\") {\n                        complex = true;\n                        if (!option.es6) {\n                            warn(\"es6\");\n                        }\n                        ellipsis = true;\n                        signature.push(\"...\");\n                        advance(\"...\");\n                    }\n                    if (!next_token.identifier) {\n                        return stop(\"expected_identifier_a\");\n                    }\n                    param = next_token;\n                    list.push(param);\n                    advance();\n                    signature.push(param.id);\n                    if (ellipsis) {\n                        param.ellipsis = true;\n                    } else {\n                        if (next_token.id === \"=\") {\n                            complex = true;\n                            if (!option.es6) {\n                                stop(\"unexpected_statement_a\");\n                            }\n                            advance(\"=\");\n                            param.expression = expression(0);\n                        }\n                        if (next_token.id === \",\") {\n                            advance(\",\");\n                            signature.push(\", \");\n                            return parameter();\n                        }\n                    }\n                }\n            }());\n        }\n        advance(\")\");\n        signature.push(\")\");\n        return [list, signature.join(\"\"), complex];\n    }\n\n    function do_function(the_function) {\n        var name;\n        if (the_function === undefined) {\n            the_function = token;\n\n// A function statement must have a name that will be in the parent's scope.\n\n            if (the_function.arity === \"statement\") {\n                if (!next_token.identifier) {\n                    return stop(\"expected_identifier_a\", next_token);\n                }\n                name = next_token;\n                enroll(name, \"variable\", true);\n                the_function.name = name;\n                name.init = true;\n                name.calls = empty();\n                advance();\n            } else if (name === undefined) {\n\n// A function expression may have an optional name.\n\n                if (next_token.identifier) {\n                    name = next_token;\n                    the_function.name = name;\n                    advance();\n                } else {\n                    the_function.name = anon;\n                }\n            }\n        } else {\n            name = the_function.name;\n        }\n        the_function.level = functionage.level + 1;\n        if (mega_mode) {\n            warn(\"unexpected_a\", the_function);\n        }\n\n// Don't make functions in loops. It is inefficient, and it can lead to scoping\n// errors.\n\n        if (functionage.loop > 0) {\n            warn(\"function_in_loop\", the_function);\n        }\n\n// Give the function properties for storing its names and for observing the\n// depth of loops and switches.\n\n        the_function.context = empty();\n        the_function.loop = 0;\n        the_function.switch = 0;\n\n// Push the current function context and establish a new one.\n\n        stack.push(functionage);\n        functions.push(the_function);\n        functionage = the_function;\n        if (the_function.arity !== \"statement\" && typeof name === \"object\") {\n            enroll(name, \"function\", true);\n            name.dead = false;\n            name.init = true;\n            name.used = 1;\n        }\n\n// Parse the parameter list.\n\n        advance(\"(\");\n        token.free = false;\n        token.arity = \"function\";\n        var pl = parameter_list();\n        functionage.parameters = pl[0];\n        functionage.signature = pl[1];\n        functionage.complex = pl[2];\n        functionage.parameters.forEach(function enroll_parameter(name) {\n            if (name.identifier) {\n                enroll(name, \"parameter\", false);\n            } else {\n                name.names.forEach(enroll_parameter);\n            }\n        });\n\n// The function's body is a block.\n\n        the_function.block = block(\"body\");\n        if (\n            the_function.arity === \"statement\" &&\n            next_token.line === token.line\n        ) {\n            return stop(\"unexpected_a\", next_token);\n        }\n        if (next_token.id === \".\" || next_token.id === \"[\") {\n            warn(\"unexpected_a\");\n        }\n\n// Restore the previous context.\n\n        functionage = stack.pop();\n        return the_function;\n    }\n\n    prefix(\"function\", do_function);\n\n    function fart(pl) {\n        if (next_token.id === \";\") {\n            stop(\"wrap_assignment\", token);\n        }\n        advance(\"=>\");\n        var the_arrow = token;\n        the_arrow.arity = \"binary\";\n        the_arrow.name = \"=>\";\n        the_arrow.level = functionage.level + 1;\n        functions.push(the_arrow);\n        if (functionage.loop > 0) {\n            warn(\"function_in_loop\", the_arrow);\n        }\n\n// Give the function properties storing its names and for observing the depth\n// of loops and switches.\n\n        the_arrow.context = empty();\n        the_arrow.loop = 0;\n        the_arrow.switch = 0;\n\n// Push the current function context and establish a new one.\n\n        stack.push(functionage);\n        functionage = the_arrow;\n        the_arrow.parameters = pl[0];\n        the_arrow.signature = pl[1];\n        the_arrow.complex = true;\n        the_arrow.parameters.forEach(function (name) {\n            enroll(name, \"parameter\", true);\n        });\n        if (!option.es6) {\n            warn(\"es6\", the_arrow);\n        }\n        if (next_token.id === \"{\") {\n            warn(\"expected_a_b\", the_arrow, \"function\", \"=>\");\n            the_arrow.block = block(\"body\");\n        } else {\n            the_arrow.expression = expression(0);\n        }\n        functionage = stack.pop();\n        return the_arrow;\n    }\n\n    prefix(\"(\", function () {\n        var the_paren = token;\n        var the_value;\n        var cadet = lookahead().id;\n\n// We can distinguish between a parameter list for => and a wrapped expression\n// with one token of lookahead.\n\n        if (\n            next_token.id === \")\" ||\n            next_token.id === \"...\" ||\n            (next_token.identifier && (cadet === \",\" || cadet === \"=\"))\n        ) {\n            the_paren.free = false;\n            return fart(parameter_list());\n        }\n        the_paren.free = true;\n        the_value = expression(0);\n        if (the_value.wrapped === true) {\n            warn(\"unexpected_a\", the_paren);\n        }\n        the_value.wrapped = true;\n        advance(\")\", the_paren);\n        if (next_token.id === \"=>\") {\n            if (the_value.arity !== \"variable\") {\n                if (the_value.id === \"{\" || the_value.id === \"[\") {\n                    warn(\"expected_a_before_b\", the_paren, \"function\", \"(\");\n                    return stop(\"expected_a_b\", next_token, \"{\", \"=>\");\n                }\n                return stop(\"expected_identifier_a\", the_value);\n            }\n            the_paren.expression = [the_value];\n            return fart([the_paren.expression, \"(\" + the_value.id + \")\"]);\n        }\n        return the_value;\n    });\n    prefix(\"`\", do_tick);\n    prefix(\"{\", function () {\n        var the_brace = token;\n        var seen = empty();\n        the_brace.expression = [];\n        if (next_token.id !== \"}\") {\n            (function member() {\n                var extra;\n                var id;\n                var name = next_token;\n                var value;\n                advance();\n                if (\n                    (name.id === \"get\" || name.id === \"set\") &&\n                    next_token.identifier\n                ) {\n                    extra = name.id + \" \" + next_token.id;\n                    name = next_token;\n                    advance();\n                    id = survey(name);\n                    if (seen[extra] === true || seen[id] === true) {\n                        warn(\"duplicate_a\", name);\n                    }\n                    seen[id] = false;\n                    seen[extra] = true;\n                } else {\n                    id = survey(name);\n                    if (typeof seen[id] === \"boolean\") {\n                        warn(\"duplicate_a\", name);\n                    }\n                    seen[id] = true;\n                }\n                if (name.identifier) {\n                    switch (next_token.id) {\n                    case \"}\":\n                    case \",\":\n                        if (!option.es6) {\n                            warn(\"es6\");\n                        }\n                        if (typeof extra === \"string\") {\n                            advance(\"(\");\n                        }\n                        value = expression(Infinity, true);\n                        break;\n                    case \"(\":\n                        if (!option.es6 && typeof extra !== \"string\") {\n                            warn(\"es6\");\n                        }\n                        value = do_function({\n                            arity: \"unary\",\n                            from: name.from,\n                            id: \"function\",\n                            line: name.line,\n                            name: (typeof extra === \"string\")\n                                ? extra\n                                : id,\n                            thru: name.from\n                        });\n                        break;\n                    default:\n                        if (typeof extra === \"string\") {\n                            advance(\"(\");\n                        }\n                        advance(\":\");\n                        value = expression(0);\n                    }\n                    value.label = name;\n                    if (typeof extra === \"string\") {\n                        value.extra = extra;\n                    }\n                    the_brace.expression.push(value);\n                } else {\n                    advance(\":\");\n                    value = expression(0);\n                    value.label = name;\n                    the_brace.expression.push(value);\n                }\n                if (next_token.id === \",\") {\n                    advance(\",\");\n                    return member();\n                }\n            }());\n        }\n        advance(\"}\");\n        return the_brace;\n    });\n\n    stmt(\";\", function () {\n        warn(\"unexpected_a\", token);\n        return token;\n    });\n    stmt(\"{\", function () {\n        warn(\"naked_block\", token);\n        return block(\"naked\");\n    });\n    stmt(\"break\", function () {\n        var the_break = token;\n        var the_label;\n        if (functionage.loop < 1 && functionage.switch < 1) {\n            warn(\"unexpected_a\", the_break);\n        }\n        the_break.disrupt = true;\n        if (next_token.identifier && token.line === next_token.line) {\n            the_label = functionage.context[next_token.id];\n            if (\n                the_label === undefined ||\n                the_label.role !== \"label\" ||\n                the_label.dead\n            ) {\n                warn((the_label !== undefined && the_label.dead)\n                    ? \"out_of_scope_a\"\n                    : \"not_label_a\");\n            } else {\n                the_label.used += 1;\n            }\n            the_break.label = next_token;\n            advance();\n        }\n        advance(\";\");\n        return the_break;\n    });\n\n    function do_var() {\n        var the_statement = token;\n        var is_const = the_statement.id === \"const\";\n        the_statement.names = [];\n\n// A program may use var or let, but not both, and let and const require\n// option.es6.\n\n        if (is_const) {\n            if (!option.es6) {\n                warn(\"es6\", the_statement);\n            }\n        } else if (var_mode === undefined) {\n            var_mode = the_statement.id;\n            if (!option.es6 && var_mode !== \"var\") {\n                warn(\"es6\", the_statement);\n            }\n        } else if (the_statement.id !== var_mode) {\n            warn(\n                \"expected_a_b\",\n                the_statement,\n                var_mode,\n                the_statement.id\n            );\n        }\n\n// We don't expect to see variables created in switch statements.\n\n        if (functionage.switch > 0) {\n            warn(\"var_switch\", the_statement);\n        }\n        if (functionage.loop > 0 && the_statement.id === \"var\") {\n            warn(\"var_loop\", the_statement);\n        }\n        (function next() {\n            if (next_token.id === \"{\" && the_statement.id !== \"var\") {\n                var the_brace = next_token;\n                the_brace.names = [];\n                advance(\"{\");\n                (function pair() {\n                    if (!next_token.identifier) {\n                        return stop(\"expected_identifier_a\", next_token);\n                    }\n                    var name = next_token;\n                    survey(name);\n                    advance();\n                    if (next_token.id === \":\") {\n                        advance(\":\");\n                        if (!next_token.identifier) {\n                            return stop(\"expected_identifier_a\", next_token);\n                        }\n                        next_token.label = name;\n                        the_brace.names.push(next_token);\n                        enroll(next_token, \"variable\", is_const);\n                        advance();\n                    } else {\n                        the_brace.names.push(name);\n                        enroll(name, \"variable\", is_const);\n                    }\n                    if (next_token.id === \",\") {\n                        advance(\",\");\n                        return pair();\n                    }\n                }());\n                advance(\"}\");\n                advance(\"=\");\n                the_brace.expression = expression(0);\n                the_statement.names.push(the_brace);\n            } else if (next_token.id === \"[\" && the_statement.id !== \"var\") {\n                var the_bracket = next_token;\n                the_bracket.names = [];\n                advance(\"[\");\n                (function element() {\n                    var ellipsis;\n                    if (next_token.id === \"...\") {\n                        ellipsis = true;\n                        advance(\"...\");\n                    }\n                    if (!next_token.identifier) {\n                        return stop(\"expected_identifier_a\", next_token);\n                    }\n                    var name = next_token;\n                    advance();\n                    the_bracket.names.push(name);\n                    enroll(name, \"variable\", the_statement.id === \"const\");\n                    if (ellipsis) {\n                        name.ellipsis = true;\n                    } else if (next_token.id === \",\") {\n                        advance(\",\");\n                        return element();\n                    }\n                }());\n                advance(\"]\");\n                advance(\"=\");\n                the_bracket.expression = expression(0);\n                the_statement.names.push(the_bracket);\n            } else if (next_token.identifier) {\n                var name = next_token;\n                advance();\n                if (name.id === \"ignore\") {\n                    warn(\"unexpected_a\", name);\n                }\n                enroll(name, \"variable\", is_const);\n                if (next_token.id === \"=\" || is_const) {\n                    advance(\"=\");\n                    name.expression = expression(0);\n                    name.init = true;\n                }\n                the_statement.names.push(name);\n            } else {\n                return stop(\"expected_identifier_a\", next_token);\n            }\n            if (next_token.id === \",\") {\n                if (!option.multivar) {\n                    warn(\"expected_a_b\", next_token, \";\", \",\");\n                }\n                advance(\",\");\n                return next();\n            }\n        }());\n        the_statement.open =\n                the_statement.names.length > 1 &&\n                the_statement.line !== the_statement.names[1].line;\n        semicolon();\n        return the_statement;\n    }\n\n    stmt(\"const\", do_var);\n    stmt(\"continue\", function () {\n        var the_continue = token;\n        if (functionage.loop < 1) {\n            warn(\"unexpected_a\", the_continue);\n        }\n        not_top_level(the_continue);\n        the_continue.disrupt = true;\n        warn(\"unexpected_a\", the_continue);\n        advance(\";\");\n        return the_continue;\n    });\n    stmt(\"debugger\", function () {\n        var the_debug = token;\n        if (!option.devel) {\n            warn(\"unexpected_a\", the_debug);\n        }\n        semicolon();\n        return the_debug;\n    });\n    stmt(\"delete\", function () {\n        var the_token = token;\n        var the_value = expression(0);\n        if (\n            (the_value.id !== \".\" && the_value.id !== \"[\") ||\n            the_value.arity !== \"binary\"\n        ) {\n            stop(\"expected_a_b\", the_value, \".\", artifact(the_value));\n        }\n        the_token.expression = the_value;\n        semicolon();\n        return the_token;\n    });\n    stmt(\"do\", function () {\n        var the_do = token;\n        not_top_level(the_do);\n        functionage.loop += 1;\n        the_do.block = block();\n        advance(\"while\");\n        the_do.expression = condition();\n        semicolon();\n        if (the_do.block.disrupt === true) {\n            warn(\"weird_loop\", the_do);\n        }\n        functionage.loop -= 1;\n        return the_do;\n    });\n    stmt(\"export\", function () {\n        var the_export = token;\n        if (!option.es6) {\n            warn(\"es6\", the_export);\n        }\n        if (typeof module_mode === \"object\") {\n            warn(\"unexpected_directive_a\", module_mode, module_mode.directive);\n        }\n        advance(\"default\");\n        if (export_mode) {\n            warn(\"duplicate_a\", token);\n        }\n        module_mode = true;\n        export_mode = true;\n        the_export.expression = expression(0);\n        semicolon();\n        return the_export;\n    });\n    stmt(\"for\", function () {\n        var first;\n        var the_for = token;\n        if (!option.for) {\n            warn(\"unexpected_a\", the_for);\n        }\n        not_top_level(the_for);\n        functionage.loop += 1;\n        advance(\"(\");\n        token.free = true;\n        if (next_token.id === \";\") {\n            return stop(\"expected_a_b\", the_for, \"while (\", \"for (;\");\n        }\n        if (\n            next_token.id === \"var\" ||\n            next_token.id === \"let\" ||\n            next_token.id === \"const\"\n        ) {\n            return stop(\"unexpected_a\");\n        }\n        first = expression(0);\n        if (first.id === \"in\") {\n            if (first.expression[0].arity !== \"variable\") {\n                warn(\"bad_assignment_a\", first.expression[0]);\n            }\n            the_for.name = first.expression[0];\n            the_for.expression = first.expression[1];\n            warn(\"expected_a_b\", the_for, \"Object.keys\", \"for in\");\n        } else {\n            the_for.initial = first;\n            advance(\";\");\n            the_for.expression = expression(0);\n            advance(\";\");\n            the_for.inc = expression(0);\n            if (the_for.inc.id === \"++\") {\n                warn(\"expected_a_b\", the_for.inc, \"+= 1\", \"++\");\n            }\n        }\n        advance(\")\");\n        the_for.block = block();\n        if (the_for.block.disrupt === true) {\n            warn(\"weird_loop\", the_for);\n        }\n        functionage.loop -= 1;\n        return the_for;\n    });\n    stmt(\"function\", do_function);\n    stmt(\"if\", function () {\n        var the_else;\n        var the_if = token;\n        the_if.expression = condition();\n        the_if.block = block();\n        if (next_token.id === \"else\") {\n            advance(\"else\");\n            the_else = token;\n            the_if.else = (next_token.id === \"if\")\n                ? statement()\n                : block();\n            if (the_if.block.disrupt === true) {\n                if (the_if.else.disrupt === true) {\n                    the_if.disrupt = true;\n                } else {\n                    warn(\"unexpected_a\", the_else);\n                }\n            }\n        }\n        return the_if;\n    });\n    stmt(\"import\", function () {\n        var the_import = token;\n        var name;\n        if (!option.es6) {\n            warn(\"es6\", the_import);\n        } else if (typeof module_mode === \"object\") {\n            warn(\"unexpected_directive_a\", module_mode, module_mode.directive);\n        }\n        module_mode = true;\n        if (next_token.identifier) {\n            name = next_token;\n            advance();\n            if (name.id === \"ignore\") {\n                warn(\"unexpected_a\", name);\n            }\n            enroll(name, \"variable\", true);\n            the_import.name = name;\n        } else {\n            var names = [];\n            advance(\"{\");\n            if (next_token.id !== \"}\") {\n                while (true) {\n                    if (!next_token.identifier) {\n                        stop(\"expected_identifier_a\");\n                    }\n                    name = next_token;\n                    advance();\n                    if (name.id === \"ignore\") {\n                        warn(\"unexpected_a\", name);\n                    }\n                    enroll(name, \"variable\", true);\n                    names.push(name);\n                    if (next_token.id !== \",\") {\n                        break;\n                    }\n                    advance(\",\");\n                }\n            }\n            advance(\"}\");\n            the_import.name = names;\n        }\n        advance(\"from\");\n        advance(\"(string)\");\n        the_import.import = token;\n        if (!rx_module.test(token.value)) {\n            warn(\"bad_module_name_a\", token);\n        }\n        imports.push(token.value);\n        semicolon();\n        return the_import;\n    });\n    stmt(\"let\", do_var);\n    stmt(\"return\", function () {\n        var the_return = token;\n        not_top_level(the_return);\n        the_return.disrupt = true;\n        if (next_token.id !== \";\" && the_return.line === next_token.line) {\n            the_return.expression = expression(10);\n        }\n        advance(\";\");\n        return the_return;\n    });\n    stmt(\"switch\", function () {\n        var dups = [];\n        var last;\n        var stmts;\n        var the_cases = [];\n        var the_disrupt = true;\n        var the_switch = token;\n        not_top_level(the_switch);\n        functionage.switch += 1;\n        advance(\"(\");\n        token.free = true;\n        the_switch.expression = expression(0);\n        the_switch.block = the_cases;\n        advance(\")\");\n        advance(\"{\");\n        (function major() {\n            var the_case = next_token;\n            the_case.arity = \"statement\";\n            the_case.expression = [];\n            (function minor() {\n                advance(\"case\");\n                token.switch = true;\n                var exp = expression(0);\n                if (dups.some(function (thing) {\n                    return are_similar(thing, exp);\n                })) {\n                    warn(\"unexpected_a\", exp);\n                }\n                dups.push(exp);\n                the_case.expression.push(exp);\n                advance(\":\");\n                if (next_token.id === \"case\") {\n                    return minor();\n                }\n            }());\n            stmts = statements();\n            if (stmts.length < 1) {\n                warn(\"expected_statements_a\");\n                return;\n            }\n            the_case.block = stmts;\n            the_cases.push(the_case);\n            last = stmts[stmts.length - 1];\n            if (last.disrupt) {\n                if (last.id === \"break\" && last.label === undefined) {\n                    the_disrupt = false;\n                }\n            } else {\n                warn(\n                    \"expected_a_before_b\",\n                    next_token,\n                    \"break;\",\n                    artifact(next_token)\n                );\n            }\n            if (next_token.id === \"case\") {\n                return major();\n            }\n        }());\n        dups = undefined;\n        if (next_token.id === \"default\") {\n            var the_default = next_token;\n            advance(\"default\");\n            token.switch = true;\n            advance(\":\");\n            the_switch.else = statements();\n            if (the_switch.else.length < 1) {\n                warn(\"unexpected_a\", the_default);\n                the_disrupt = false;\n            } else {\n                var the_last = the_switch.else[the_switch.else.length - 1];\n                if (the_last.id === \"break\" && the_last.label === undefined) {\n                    warn(\"unexpected_a\", the_last);\n                    the_last.disrupt = false;\n                }\n                the_disrupt = the_disrupt && the_last.disrupt;\n            }\n        } else {\n            the_disrupt = false;\n        }\n        advance(\"}\", the_switch);\n        functionage.switch -= 1;\n        the_switch.disrupt = the_disrupt;\n        return the_switch;\n    });\n    stmt(\"throw\", function () {\n        var the_throw = token;\n        the_throw.disrupt = true;\n        the_throw.expression = expression(10);\n        semicolon();\n        return the_throw;\n    });\n    stmt(\"try\", function () {\n        var clause = false;\n        var the_catch;\n        var the_disrupt;\n        var the_try = token;\n        the_try.block = block();\n        the_disrupt = the_try.block.disrupt;\n        if (next_token.id === \"catch\") {\n            var ignored = \"ignore\";\n            clause = true;\n            the_catch = next_token;\n            the_try.catch = the_catch;\n            advance(\"catch\");\n            advance(\"(\");\n            if (!next_token.identifier) {\n                return stop(\"expected_identifier_a\", next_token);\n            }\n            if (next_token.id !== \"ignore\") {\n                ignored = undefined;\n                the_catch.name = next_token;\n                enroll(next_token, \"exception\", true);\n            }\n            advance();\n            advance(\")\");\n            the_catch.block = block(ignored);\n            if (the_catch.block.disrupt !== true) {\n                the_disrupt = false;\n            }\n        }\n        if (next_token.id === \"finally\") {\n            clause = true;\n            advance(\"finally\");\n            the_try.else = block();\n            the_disrupt = the_try.else.disrupt;\n        }\n        the_try.disrupt = the_disrupt;\n        if (!clause) {\n            warn(\n                \"expected_a_before_b\",\n                next_token,\n                \"catch\",\n                artifact(next_token)\n            );\n        }\n        return the_try;\n    });\n    stmt(\"var\", do_var);\n    stmt(\"while\", function () {\n        var the_while = token;\n        not_top_level(the_while);\n        functionage.loop += 1;\n        the_while.expression = condition();\n        the_while.block = block();\n        if (the_while.block.disrupt === true) {\n            warn(\"weird_loop\", the_while);\n        }\n        functionage.loop -= 1;\n        return the_while;\n    });\n    stmt(\"with\", function () {\n        stop(\"unexpected_a\", token);\n    });\n\n    ternary(\"?\", \":\");\n\n// Ambulation of the parse tree.\n\n    function action(when) {\n\n// Produce a function that will register task functions that will be called as\n// the tree is traversed.\n\n        return function (arity, id, task) {\n            var a_set = when[arity];\n            var i_set;\n\n// The id parameter is optional. If excluded, the task will be applied to all\n// ids.\n\n            if (typeof id !== \"string\") {\n                task = id;\n                id = \"(all)\";\n            }\n\n// If this arity has no registrations yet, then create a set object to hold\n// them.\n\n            if (a_set === undefined) {\n                a_set = empty();\n                when[arity] = a_set;\n            }\n\n// If this id has no registrations yet, then create a set array to hold them.\n\n            i_set = a_set[id];\n            if (i_set === undefined) {\n                i_set = [];\n                a_set[id] = i_set;\n            }\n\n// Register the task with the arity and the id.\n\n            i_set.push(task);\n        };\n    }\n\n    function amble(when) {\n\n// Produce a function that will act on the tasks registered by an action\n// function while walking the tree.\n\n        return function (the_token) {\n\n// Given a task set that was built by an action function, run all of the\n// relevant tasks on the token.\n\n            var a_set = when[the_token.arity];\n            var i_set;\n\n// If there are tasks associated with the token's arity...\n\n            if (a_set !== undefined) {\n\n// If there are tasks associated with the token's id...\n\n                i_set = a_set[the_token.id];\n                if (i_set !== undefined) {\n                    i_set.forEach(function (task) {\n                        return task(the_token);\n                    });\n                }\n\n// If there are tasks for all ids.\n\n                i_set = a_set[\"(all)\"];\n                if (i_set !== undefined) {\n                    i_set.forEach(function (task) {\n                        return task(the_token);\n                    });\n                }\n            }\n        };\n    }\n\n    var posts = empty();\n    var pres = empty();\n    var preaction = action(pres);\n    var postaction = action(posts);\n    var preamble = amble(pres);\n    var postamble = amble(posts);\n\n    function walk_expression(thing) {\n        if (thing) {\n            if (Array.isArray(thing)) {\n                thing.forEach(walk_expression);\n            } else {\n                preamble(thing);\n                walk_expression(thing.expression);\n                if (thing.id === \"function\") {\n                    walk_statement(thing.block);\n                }\n                switch (thing.arity) {\n                case \"post\":\n                case \"pre\":\n                    warn(\"unexpected_a\", thing);\n                    break;\n                case \"statement\":\n                case \"assignment\":\n                    warn(\"unexpected_statement_a\", thing);\n                    break;\n                }\n                postamble(thing);\n            }\n        }\n    }\n\n    function walk_statement(thing) {\n        if (thing) {\n            if (Array.isArray(thing)) {\n                thing.forEach(walk_statement);\n            } else {\n                preamble(thing);\n                walk_expression(thing.expression);\n                switch (thing.arity) {\n                case \"statement\":\n                case \"assignment\":\n                    break;\n                case \"binary\":\n                    if (thing.id !== \"(\") {\n                        warn(\"unexpected_expression_a\", thing);\n                    }\n                    break;\n                default:\n                    warn((\n                        thing.id === \"(string)\" &&\n                        thing.value === \"use strict\"\n                    )\n                        ? \"unexpected_a\"\n                        : \"unexpected_expression_a\", thing);\n                }\n                walk_statement(thing.block);\n                walk_statement(thing.else);\n                postamble(thing);\n            }\n        }\n    }\n\n    function lookup(thing) {\n        if (thing.arity === \"variable\") {\n\n// Look up the variable in the current context.\n\n            var the_variable = functionage.context[thing.id];\n\n// If it isn't local, search all the other contexts. If there are name\n// collisions, take the most recent.\n\n            if (the_variable === undefined) {\n                stack.forEach(function (outer) {\n                    var a_variable = outer.context[thing.id];\n                    if (\n                        a_variable !== undefined &&\n                        a_variable.role !== \"label\"\n                    ) {\n                        the_variable = a_variable;\n                    }\n                });\n\n// If it isn't in any of those either, perhaps it is a predefined global.\n// If so, add it to the global context.\n\n                if (the_variable === undefined) {\n                    if (declared_globals[thing.id] === undefined) {\n                        warn(\"undeclared_a\", thing);\n                        return;\n                    }\n                    the_variable = {\n                        dead: false,\n                        function: global,\n                        id: thing.id,\n                        init: true,\n                        role: \"variable\",\n                        used: 0,\n                        writable: false\n                    };\n                    global.context[thing.id] = the_variable;\n                }\n                the_variable.closure = true;\n                functionage.context[thing.id] = the_variable;\n            } else if (the_variable.role === \"label\") {\n                warn(\"label_a\", thing);\n            }\n            if (the_variable.dead) {\n                warn(\"out_of_scope_a\", thing);\n            }\n            return the_variable;\n        }\n    }\n\n    function subactivate(name) {\n        name.init = true;\n        name.dead = false;\n        blockage.live.push(name);\n    }\n\n    function preaction_function(thing) {\n        if (thing.arity === \"statement\" && blockage.body !== true) {\n            warn(\"unexpected_a\", thing);\n        }\n        if (thing.level === 1) {\n            if (\n                module_mode === true ||\n                global.strict !== undefined ||\n                thing.complex\n            ) {\n                if (thing.id !== \"=>\" && thing.block.strict !== undefined) {\n                    warn(\"unexpected_a\", thing.block.strict);\n                }\n            } else {\n                if (thing.block.strict === undefined) {\n                    warn(\"use_strict\", thing);\n                }\n            }\n        }\n        stack.push(functionage);\n        block_stack.push(blockage);\n        functionage = thing;\n        blockage = thing;\n        thing.live = [];\n        if (typeof thing.name === \"object\") {\n            thing.name.dead = false;\n            thing.name.init = true;\n        }\n        switch (thing.extra) {\n        case \"get\":\n            if (thing.parameters.length !== 0) {\n                warn(\"bad_get\", thing);\n            }\n            break;\n        case \"set\":\n            if (thing.parameters.length !== 1) {\n                warn(\"bad_set\", thing);\n            }\n            break;\n        }\n        thing.parameters.forEach(function (name) {\n            walk_expression(name.expression);\n            if (name.id === \"{\" || name.id === \"[\") {\n                name.names.forEach(subactivate);\n            } else {\n                name.dead = false;\n                name.init = true;\n            }\n        });\n    }\n\n    function bitwise_check(thing) {\n        if (!option.bitwise && bitwiseop[thing.id] === true) {\n            warn(\"unexpected_a\", thing);\n        }\n        if (\n            thing.id !== \"(\" &&\n            thing.id !== \"&&\" &&\n            thing.id !== \"||\" &&\n            thing.id !== \"=\" &&\n            Array.isArray(thing.expression) &&\n            thing.expression.length === 2 && (\n                relationop[thing.expression[0].id] === true ||\n                relationop[thing.expression[1].id] === true\n            )\n        ) {\n            warn(\"unexpected_a\", thing);\n        }\n    }\n\n    function pop_block() {\n        blockage.live.forEach(function (name) {\n            name.dead = true;\n        });\n        delete blockage.live;\n        blockage = block_stack.pop();\n    }\n\n    function activate(name) {\n        if (name.expression !== undefined) {\n            walk_expression(name.expression);\n            if (name.id === \"{\" || name.id === \"[\") {\n                name.names.forEach(subactivate);\n            } else {\n                name.init = true;\n            }\n        }\n        name.dead = false;\n        blockage.live.push(name);\n    }\n\n    function action_var(thing) {\n        thing.names.forEach(activate);\n    }\n\n    preaction(\"assignment\", bitwise_check);\n    preaction(\"binary\", bitwise_check);\n    preaction(\"binary\", function (thing) {\n        if (relationop[thing.id] === true) {\n            var left = thing.expression[0];\n            var right = thing.expression[1];\n            if (left.id === \"NaN\" || right.id === \"NaN\") {\n                if (option.es6) {\n                    warn(\"number_isNaN\", thing);\n                } else {\n                    warn(\"isNaN\", thing);\n                }\n            } else if (left.id === \"typeof\") {\n                if (right.id !== \"(string)\") {\n                    if (right.id !== \"typeof\") {\n                        warn(\"expected_string_a\", right);\n                    }\n                } else {\n                    var value = right.value;\n                    if (value === \"symbol\") {\n                        if (!option.es6) {\n                            warn(\"es6\", right, value);\n                        }\n                    } else if (value === \"null\" || value === \"undefined\") {\n                        warn(\"unexpected_typeof_a\", right, value);\n                    } else if (\n                        value !== \"boolean\" &&\n                        value !== \"function\" &&\n                        value !== \"number\" &&\n                        value !== \"object\" &&\n                        value !== \"string\"\n                    ) {\n                        warn(\"expected_type_string_a\", right, value);\n                    }\n                }\n            }\n        }\n    });\n    preaction(\"binary\", \"==\", function (thing) {\n        warn(\"expected_a_b\", thing, \"===\", \"==\");\n    });\n    preaction(\"binary\", \"!=\", function (thing) {\n        warn(\"expected_a_b\", thing, \"!==\", \"!=\");\n    });\n    preaction(\"binary\", \"=>\", preaction_function);\n    preaction(\"binary\", \"||\", function (thing) {\n        thing.expression.forEach(function (thang) {\n            if (thang.id === \"&&\" && !thang.wrapped) {\n                warn(\"and\", thang);\n            }\n        });\n    });\n    preaction(\"binary\", \"(\", function (thing) {\n        var left = thing.expression[0];\n        if (\n            left.identifier &&\n            functionage.context[left.id] === undefined &&\n            typeof functionage.name === \"object\"\n        ) {\n            var parent = functionage.name.function;\n            if (parent) {\n                var left_variable = parent.context[left.id];\n                if (\n                    left_variable !== undefined &&\n                    left_variable.dead &&\n                    left_variable.function === parent &&\n                    left_variable.calls !== undefined &&\n                    left_variable.calls[functionage.name.id] !== undefined\n                ) {\n                    left_variable.dead = false;\n                }\n            }\n        }\n    });\n    preaction(\"binary\", \"in\", function (thing) {\n        warn(\"infix_in\", thing);\n    });\n    preaction(\"binary\", \"instanceof\", function (thing) {\n        warn(\"unexpected_a\", thing);\n    });\n    preaction(\"binary\", \".\", function (thing) {\n        if (thing.expression.new) {\n            thing.new = true;\n        }\n    });\n    preaction(\"statement\", \"{\", function (thing) {\n        block_stack.push(blockage);\n        blockage = thing;\n        thing.live = [];\n    });\n    preaction(\"statement\", \"for\", function (thing) {\n        if (thing.name !== undefined) {\n            var the_variable = lookup(thing.name);\n            if (the_variable !== undefined) {\n                the_variable.init = true;\n                if (!the_variable.writable) {\n                    warn(\"bad_assignment_a\", thing.name);\n                }\n            }\n        }\n        walk_statement(thing.initial);\n    });\n    preaction(\"statement\", \"function\", preaction_function);\n    preaction(\"unary\", \"~\", bitwise_check);\n    preaction(\"unary\", \"function\", preaction_function);\n    preaction(\"variable\", function (thing) {\n        var the_variable = lookup(thing);\n        if (the_variable !== undefined) {\n            thing.variable = the_variable;\n            the_variable.used += 1;\n        }\n    });\n\n    function init_variable(name) {\n        var the_variable = lookup(name);\n        if (the_variable !== undefined) {\n            if (the_variable.writable) {\n                the_variable.init = true;\n                return;\n            }\n        }\n        warn(\"bad_assignment_a\", name);\n    }\n\n    postaction(\"assignment\", function (thing) {\n\n// Assignment using = sets the init property of a variable. No other assignment\n// operator can do this. A = token keeps that variable (or array of variables\n// in case of destructuring) in its name property.\n\n        var lvalue = thing.expression[0];\n        if (thing.id === \"=\") {\n            if (thing.names !== undefined) {\n                if (Array.isArray(thing.names)) {\n                    thing.names.forEach(init_variable);\n                } else {\n                    init_variable(thing.names);\n                }\n            } else {\n                if (\n                    lvalue.id === \".\" &&\n                    thing.expression[1].id === \"undefined\"\n                ) {\n                    warn(\n                        \"expected_a_b\",\n                        lvalue.expression,\n                        \"delete\",\n                        \"undefined\"\n                    );\n                }\n            }\n        } else {\n            if (lvalue.arity === \"variable\") {\n                if (!lvalue.variable || lvalue.variable.writable !== true) {\n                    warn(\"bad_assignment_a\", lvalue);\n                }\n            }\n            var right = syntax[thing.expression[1].id];\n            if (\n                right !== undefined &&\n                (\n                    right.id === \"function\" ||\n                    right.id === \"=>\" ||\n                    (\n                        right.constant &&\n                        right.id !== \"(number)\" &&\n                        (right.id !== \"(string)\" || thing.id !== \"+=\")\n                    )\n                )\n            ) {\n                warn(\"unexpected_a\", thing.expression[1]);\n            }\n        }\n    });\n\n    function postaction_function(thing) {\n        delete functionage.loop;\n        delete functionage.switch;\n        functionage = stack.pop();\n        if (thing.wrapped) {\n            warn(\"unexpected_parens\", thing);\n        }\n        if (typeof thing.name === \"object\") {\n            thing.name.used = 0;\n        }\n        return pop_block();\n    }\n\n    postaction(\"binary\", function (thing) {\n        var right;\n        if (relationop[thing.id]) {\n            if (\n                is_weird(thing.expression[0]) ||\n                is_weird(thing.expression[1]) ||\n                are_similar(thing.expression[0], thing.expression[1]) ||\n                (\n                    thing.expression[0].constant === true &&\n                    thing.expression[1].constant === true\n                )\n            ) {\n                warn(\"weird_relation_a\", thing);\n            }\n        }\n        switch (thing.id) {\n        case \"+\":\n        case \"-\":\n            right = thing.expression[1];\n            if (\n                right.id === thing.id &&\n                right.arity === \"unary\" &&\n                !right.wrapped\n            ) {\n                warn(\"wrap_unary\", right);\n            }\n            break;\n        case \"=>\":\n        case \"(\":\n            break;\n        case \".\":\n            if (thing.expression.id === \"RegExp\") {\n                warn(\"weird_expression_a\", thing);\n            }\n            break;\n        default:\n            if (\n                thing.expression[0].constant === true &&\n                thing.expression[1].constant === true\n            ) {\n                thing.constant = true;\n            }\n        }\n    });\n    postaction(\"binary\", \"&&\", function (thing) {\n        if (\n            is_weird(thing.expression[0]) ||\n            are_similar(thing.expression[0], thing.expression[1]) ||\n            thing.expression[0].constant === true ||\n            thing.expression[1].constant === true\n        ) {\n            warn(\"weird_condition_a\", thing);\n        }\n    });\n    postaction(\"binary\", \"||\", function (thing) {\n        if (\n            is_weird(thing.expression[0]) ||\n            are_similar(thing.expression[0], thing.expression[1]) ||\n            thing.expression[0].constant === true\n        ) {\n            warn(\"weird_condition_a\", thing);\n        }\n    });\n    postaction(\"binary\", \"=>\", postaction_function);\n    postaction(\"binary\", \"(\", function (thing) {\n        var left = thing.expression[0];\n        var the_new;\n        if (left.id === \"new\") {\n            the_new = left;\n            left = left.expression;\n        }\n        if (left.id === \"function\") {\n            if (!thing.wrapped) {\n                warn(\"wrap_immediate\", thing);\n            }\n        } else if (left.identifier) {\n            if (the_new !== undefined) {\n                if (\n                    left.id.charAt(0) > \"Z\" ||\n                    left.id === \"Boolean\" ||\n                    left.id === \"Number\" ||\n                    left.id === \"String\" ||\n                    (left.id === \"Symbol\" && option.es6)\n                ) {\n                    warn(\"unexpected_a\", the_new);\n                } else if (left.id === \"Function\") {\n                    if (!option.eval) {\n                        warn(\"unexpected_a\", left, \"new Function\");\n                    }\n                } else if (left.id === \"Array\") {\n                    warn(\"expected_a_b\", left, \"[]\", \"new Array\");\n                } else if (left.id === \"Object\") {\n                    warn(\n                        \"expected_a_b\",\n                        left,\n                        \"Object.create(null)\",\n                        \"new Object\"\n                    );\n                }\n            } else {\n                if (\n                    left.id.charAt(0) >= \"A\" &&\n                    left.id.charAt(0) <= \"Z\" &&\n                    left.id !== \"Boolean\" &&\n                    left.id !== \"Number\" &&\n                    left.id !== \"String\" &&\n                    left.id !== \"Symbol\"\n                ) {\n                    warn(\n                        \"expected_a_before_b\",\n                        left,\n                        \"new\",\n                        artifact(left)\n                    );\n                }\n            }\n        } else if (left.id === \".\") {\n            var cack = the_new !== undefined;\n            if (left.expression.id === \"Date\" && left.name.id === \"UTC\") {\n                cack = !cack;\n            }\n            if (rx_cap.test(left.name.id) !== cack) {\n                if (the_new !== undefined) {\n                    warn(\"unexpected_a\", the_new);\n                } else {\n                    warn(\n                        \"expected_a_before_b\",\n                        left.expression,\n                        \"new\",\n                        left.name.id\n                    );\n                }\n            }\n            if (left.name.id === \"getTime\") {\n                var l1 = left.expression;\n                if (l1.id === \"(\") {\n                    var l2 = l1.expression;\n                    if (l2.length === 1) {\n                        var l3 = l2[0];\n                        if (l3.id === \"new\" && l3.expression.id === \"Date\") {\n                            warn(\n                                \"expected_a_b\",\n                                l3,\n                                \"Date.now()\",\n                                \"new Date().getTime()\"\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    });\n    postaction(\"binary\", \"[\", function (thing) {\n        if (thing.expression[0].id === \"RegExp\") {\n            warn(\"weird_expression_a\", thing);\n        }\n        if (is_weird(thing.expression[1])) {\n            warn(\"weird_expression_a\", thing.expression[1]);\n        }\n    });\n    postaction(\"statement\", \"{\", pop_block);\n    postaction(\"statement\", \"const\", action_var);\n    postaction(\"statement\", \"export\", top_level_only);\n    postaction(\"statement\", \"for\", function (thing) {\n        walk_statement(thing.inc);\n    });\n    postaction(\"statement\", \"function\", postaction_function);\n    postaction(\"statement\", \"import\", function (the_thing) {\n        var name = the_thing.name;\n        if (Array.isArray(name)) {\n            name.forEach(function (name) {\n                name.dead = false;\n                name.init = true;\n                blockage.live.push(name);\n            });\n        } else {\n            name.dead = false;\n            name.init = true;\n            blockage.live.push(name);\n        }\n        return top_level_only(the_thing);\n    });\n    postaction(\"statement\", \"let\", action_var);\n    postaction(\"statement\", \"try\", function (thing) {\n        if (thing.catch !== undefined) {\n            var the_name = thing.catch.name;\n            if (the_name !== undefined) {\n                var the_variable = functionage.context[the_name.id];\n                the_variable.dead = false;\n                the_variable.init = true;\n            }\n            walk_statement(thing.catch.block);\n        }\n    });\n    postaction(\"statement\", \"var\", action_var);\n    postaction(\"ternary\", function (thing) {\n        if (\n            is_weird(thing.expression[0]) ||\n            thing.expression[0].constant === true ||\n            are_similar(thing.expression[1], thing.expression[2])\n        ) {\n            warn(\"unexpected_a\", thing);\n        } else if (are_similar(thing.expression[0], thing.expression[1])) {\n            warn(\"expected_a_b\", thing, \"||\", \"?\");\n        } else if (are_similar(thing.expression[0], thing.expression[2])) {\n            warn(\"expected_a_b\", thing, \"&&\", \"?\");\n        } else if (\n            thing.expression[1].id === \"true\" &&\n            thing.expression[2].id === \"false\"\n        ) {\n            warn(\"expected_a_b\", thing, \"!!\", \"?\");\n        } else if (\n            thing.expression[1].id === \"false\" &&\n            thing.expression[2].id === \"true\"\n        ) {\n            warn(\"expected_a_b\", thing, \"!\", \"?\");\n        } else if (thing.expression[0].wrapped !== true && (\n            thing.expression[0].id === \"||\" ||\n            thing.expression[0].id === \"&&\"\n        )) {\n            warn(\"wrap_condition\", thing.expression[0]);\n        }\n    });\n    postaction(\"unary\", function (thing) {\n        switch (thing.id) {\n        case \"[\":\n        case \"{\":\n        case \"function\":\n        case \"new\":\n            break;\n        case \"`\":\n            if (thing.expression.every(function (thing) {\n                return thing.constant;\n            })) {\n                thing.constant = true;\n            }\n            break;\n        default:\n            if (thing.expression.constant === true) {\n                thing.constant = true;\n            }\n        }\n    });\n    postaction(\"unary\", \"function\", postaction_function);\n\n    function delve(the_function) {\n        Object.keys(the_function.context).forEach(function (id) {\n            if (id !== \"ignore\") {\n                var name = the_function.context[id];\n                if (name.function === the_function) {\n                    if (name.used === 0 && (\n                        name.role !== \"function\" ||\n                        name.function.arity !== \"unary\"\n                    )) {\n                        warn(\"unused_a\", name);\n                    } else if (!name.init) {\n                        warn(\"uninitialized_a\", name);\n                    }\n                }\n            }\n        });\n    }\n\n    function uninitialized_and_unused() {\n\n// Delve into the functions looking for variables that were not initialized\n// or used. If the file imports or exports, then its global object is also\n// delved.\n\n        if (module_mode === true || option.node) {\n            delve(global);\n        }\n        functions.forEach(delve);\n    }\n\n// Go through the token list, looking at usage of whitespace.\n\n    function whitage() {\n        var closer = \"(end)\";\n        var free = false;\n        var left = global;\n        var margin = 0;\n        var nr_comments_skipped = 0;\n        var open = true;\n        var qmark = \"\";\n        var result;\n        var right;\n\n        function expected_at(at) {\n            warn(\n                \"expected_a_at_b_c\",\n                right,\n                artifact(right),\n                fudge + at,\n                artifact_column(right)\n            );\n        }\n\n        function at_margin(fit) {\n            var at = margin + fit;\n            if (right.from !== at) {\n                return expected_at(at);\n            }\n        }\n\n        function no_space_only() {\n            if (\n                left.id !== \"(global)\" &&\n                left.nr + 1 === right.nr && (\n                    left.line !== right.line ||\n                    left.thru !== right.from\n                )\n            ) {\n                warn(\n                    \"unexpected_space_a_b\",\n                    right,\n                    artifact(left),\n                    artifact(right)\n                );\n            }\n        }\n\n        function no_space() {\n            if (left.line === right.line) {\n                if (left.thru !== right.from && nr_comments_skipped === 0) {\n                    warn(\n                        \"unexpected_space_a_b\",\n                        right,\n                        artifact(left),\n                        artifact(right)\n                    );\n                }\n            } else {\n                if (open) {\n                    var at = (free)\n                        ? margin\n                        : margin + 8;\n                    if (right.from < at) {\n                        expected_at(at);\n                    }\n                } else {\n                    if (right.from !== margin + 8) {\n                        expected_at(margin + 8);\n                    }\n                }\n            }\n        }\n\n        function one_space_only() {\n            if (left.line !== right.line || left.thru + 1 !== right.from) {\n                warn(\n                    \"expected_space_a_b\",\n                    right,\n                    artifact(left),\n                    artifact(right)\n                );\n            }\n        }\n\n        function one_space() {\n            if (left.line === right.line) {\n                if (left.thru + 1 !== right.from && nr_comments_skipped === 0) {\n                    warn(\n                        \"expected_space_a_b\",\n                        right,\n                        artifact(left),\n                        artifact(right)\n                    );\n                }\n            } else {\n                if (free) {\n                    if (right.from < margin) {\n                        expected_at(margin);\n                    }\n                } else {\n                    if (right.from !== margin + 8) {\n                        expected_at(margin + 8);\n                    }\n                }\n            }\n        }\n\n        function unqmark() {\n\n// Undo the effects of dangling nested ternary operators.\n\n            var level = qmark.length;\n            if (level > 0) {\n                margin -= level * 4;\n            }\n            qmark = \"\";\n        }\n\n        stack = [];\n        tokens.forEach(function (the_token) {\n            right = the_token;\n            if (right.id === \"(comment)\" || right.id === \"(end)\") {\n                nr_comments_skipped += 1;\n            } else {\n\n// If left is an opener and right is not the closer, then push the previous\n// state. If the token following the opener is on the next line, then this is\n// an open form. If the tokens are on the same line, then it is a closed form.\n// Open form is more readable, with each item (statement, argument, parameter,\n// etc) starting on its own line. Closed form is more compact. Statement blocks\n// are always in open form.\n\n                var new_closer = opener[left.id];\n                if (typeof new_closer === \"string\") {\n                    if (new_closer !== right.id) {\n                        stack.push({\n                            closer: closer,\n                            free: free,\n                            margin: margin,\n                            open: open,\n                            qmark: qmark\n                        });\n                        qmark = \"\";\n                        closer = new_closer;\n                        if (left.line !== right.line) {\n                            free = closer === \")\" && left.free;\n                            open = true;\n                            margin += 4;\n                            if (right.role === \"label\") {\n                                if (right.from !== 0) {\n                                    expected_at(0);\n                                }\n                            } else if (right.switch) {\n                                unqmark();\n                                at_margin(-4);\n                            } else {\n                                at_margin(0);\n                            }\n                        } else {\n                            if (right.statement || right.role === \"label\") {\n                                warn(\n                                    \"expected_line_break_a_b\",\n                                    right,\n                                    artifact(left),\n                                    artifact(right)\n                                );\n                            }\n                            free = false;\n                            open = false;\n                            no_space_only();\n                        }\n                    } else {\n\n// If left and right are opener and closer, then the placement of right depends\n// on the openness. Illegal pairs (like {]) have already been detected.\n\n                        if (left.line === right.line) {\n                            no_space();\n                        } else {\n                            at_margin(0);\n                        }\n                    }\n                } else {\n\n// If right is a closer, then pop the previous state.\n\n                    if (right.id === closer) {\n                        var previous = stack.pop();\n                        margin = previous.margin;\n                        if (open && right.id !== \";\") {\n                            at_margin(0);\n                        } else {\n                            no_space_only();\n                        }\n                        closer = previous.closer;\n                        free = previous.free;\n                        open = previous.open;\n                        qmark = previous.qmark;\n                    } else {\n\n// Left is not an opener, and right is not a closer. The nature of left and\n// right will determine the space between them.\n\n// If left is , or ; or right is a statement then if open, right must go at the\n// margin, or if closed, a space between.\n\n\n                        if (right.switch) {\n                            unqmark();\n                            at_margin(-4);\n                        } else if (right.role === \"label\") {\n                            if (right.from !== 0) {\n                                expected_at(0);\n                            }\n                        } else if (left.id === \",\") {\n                            unqmark();\n                            if (!open || (\n                                (free || closer === \"]\") &&\n                                left.line === right.line\n                            )) {\n                                one_space();\n                            } else {\n                                at_margin(0);\n                            }\n\n// If right is a ternary operator, line it up on the margin. Use qmark to\n// deal with nested ternary operators.\n\n                        } else if (right.arity === \"ternary\") {\n                            if (right.id === \"?\") {\n                                margin += 4;\n                                qmark += \"?\";\n                            } else {\n                                result = qmark.match(rx_colons);\n                                qmark = result[1] + \":\";\n                                margin -= 4 * result[2].length;\n                            }\n                            at_margin(0);\n                        } else if (\n                            right.arity === \"binary\" &&\n                            right.id === \"(\" &&\n                            free\n                        ) {\n                            no_space();\n                        } else if (\n                            left.id === \".\" ||\n                            left.id === \"...\" ||\n                            right.id === \",\" ||\n                            right.id === \";\" ||\n                            right.id === \":\" ||\n                            (right.arity === \"binary\" && (\n                                right.id === \"(\" ||\n                                right.id === \"[\"\n                            )) ||\n                            (\n                                right.arity === \"function\" &&\n                                left.id !== \"function\"\n                            )\n                        ) {\n                            no_space_only();\n                        } else if (right.id === \".\") {\n                            if (left.line === right.line) {\n                                no_space();\n                            } else {\n                                if (!rx_dot.test(qmark)) {\n                                    qmark += \".\";\n                                    margin += 4;\n                                }\n                                at_margin(0);\n                            }\n                        } else if (left.id === \";\") {\n                            unqmark();\n                            if (open) {\n                                at_margin(0);\n                            } else {\n                                one_space();\n                            }\n                        } else if (\n                            left.arity === \"ternary\" ||\n                            left.id === \"case\" ||\n                            left.id === \"catch\" ||\n                            left.id === \"else\" ||\n                            left.id === \"finally\" ||\n                            left.id === \"while\" ||\n                            right.id === \"catch\" ||\n                            right.id === \"else\" ||\n                            right.id === \"finally\" ||\n                            (right.id === \"while\" && !right.statement) ||\n                            (left.id === \")\" && right.id === \"{\")\n                        ) {\n                            one_space_only();\n                        } else if (right.statement === true) {\n                            if (open) {\n                                at_margin(0);\n                            } else {\n                                one_space();\n                            }\n                        } else if (\n                            left.id === \"var\" ||\n                            left.id === \"const\" ||\n                            left.id === \"let\"\n                        ) {\n                            stack.push({\n                                closer: closer,\n                                free: free,\n                                margin: margin,\n                                open: open,\n                                qmark: qmark\n                            });\n                            closer = \";\";\n                            free = false;\n                            open = left.open;\n                            qmark = \"\";\n                            if (open) {\n                                margin = margin + 4;\n                                at_margin(0);\n                            } else {\n                                one_space_only();\n                            }\n                        } else if (\n\n// There is a space between left and right.\n\n                            spaceop[left.id] === true ||\n                            spaceop[right.id] === true ||\n                            (\n                                left.arity === \"binary\" &&\n                                (left.id === \"+\" || left.id === \"-\")\n                            ) ||\n                            (\n                                right.arity === \"binary\" &&\n                                (right.id === \"+\" || right.id === \"-\")\n                            ) ||\n                            left.id === \"function\" ||\n                            left.id === \":\" ||\n                            (\n                                (\n                                    left.identifier ||\n                                    left.id === \"(string)\" ||\n                                    left.id === \"(number)\"\n                                ) &&\n                                (\n                                    right.identifier ||\n                                    right.id === \"(string)\" ||\n                                    right.id === \"(number)\"\n                                )\n                            ) ||\n                            (left.arity === \"statement\" && right.id !== \";\")\n                        ) {\n                            one_space();\n                        } else if (left.arity === \"unary\" && left.id !== \"`\") {\n                            no_space_only();\n                        }\n                    }\n                }\n                nr_comments_skipped = 0;\n                delete left.calls;\n                delete left.dead;\n                delete left.free;\n                delete left.init;\n                delete left.open;\n                delete left.used;\n                left = right;\n            }\n        });\n    }\n\n// The jslint function itself.\n\n    return function (source, option_object, global_array) {\n        try {\n            warnings = [];\n            option = option_object || empty();\n            anon = \"anonymous\";\n            block_stack = [];\n            declared_globals = empty();\n            directive_mode = true;\n            directives = [];\n            early_stop = true;\n            export_mode = false;\n            fudge = (option.fudge)\n                ? 1\n                : 0;\n            functions = [];\n            global = {\n                id: \"(global)\",\n                body: true,\n                context: empty(),\n                from: 0,\n                level: 0,\n                line: 0,\n                live: [],\n                loop: 0,\n                switch: 0,\n                thru: 0\n            };\n            blockage = global;\n            functionage = global;\n            imports = [];\n            json_mode = false;\n            mega_mode = false;\n            module_mode = false;\n            next_token = global;\n            property = empty();\n            stack = [];\n            tenure = undefined;\n            token = global;\n            token_nr = 0;\n            var_mode = undefined;\n            populate(declared_globals, standard, false);\n            if (global_array !== undefined) {\n                populate(declared_globals, global_array, false);\n            }\n            Object.keys(option).forEach(function (name) {\n                if (option[name] === true) {\n                    var allowed = allowed_option[name];\n                    if (Array.isArray(allowed)) {\n                        populate(declared_globals, allowed, false);\n                    }\n                }\n            });\n            tokenize(source);\n            advance();\n            if (tokens[0].id === \"{\" || tokens[0].id === \"[\") {\n                json_mode = true;\n                tree = json_value();\n                advance(\"(end)\");\n            } else {\n\n// Because browsers encourage combining of script files, the first token might\n// be a semicolon to defend against a missing semicolon in the preceding file.\n\n                if (option.browser) {\n                    if (next_token.id === \";\") {\n                        advance(\";\");\n                    }\n                } else {\n\n// If we are not in a browser, then the file form of strict pragma may be used.\n\n                    if (\n                        next_token.value === \"use strict\"\n                    ) {\n                        global.strict = next_token;\n                        advance(\"(string)\");\n                        advance(\";\");\n                    }\n                }\n                tree = statements();\n                advance(\"(end)\");\n                functionage = global;\n                walk_statement(tree);\n                if (module_mode && global.strict !== undefined) {\n                    warn(\"unexpected_a\", global.strict);\n                }\n                uninitialized_and_unused();\n                if (!option.white) {\n                    whitage();\n                }\n            }\n            if (!option.browser) {\n                directives.forEach(function (comment) {\n                    if (comment.directive === \"global\") {\n                        warn(\"missing_browser\", comment);\n                    }\n                });\n            }\n            early_stop = false;\n        } catch (e) {\n            if (e.name !== \"JSLintError\") {\n                warnings.push(e);\n            }\n        }\n        return {\n            directives: directives,\n            edition: \"2016-07-13\",\n            functions: functions,\n            global: global,\n            id: \"(JSLint)\",\n            imports: imports,\n            json: json_mode,\n            lines: lines,\n            module: module_mode === true,\n            ok: warnings.length === 0 && !early_stop,\n            option: option,\n            property: property,\n            stop: early_stop,\n            tokens: tokens,\n            tree: tree,\n            warnings: warnings.sort(function (a, b) {\n                return a.line - b.line || a.column - b.column;\n            })\n        };\n    };\n}());\n\n/*node module.exports = jslint;*/\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jslint-es5.js":"// jslint.js\n// 2014-07-08\n\n// Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// The Software shall be used for Good, not Evil.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// WARNING: JSLint will hurt your feelings.\n\n// JSLINT is a global function. It takes two parameters.\n\n//     var myResult = JSLINT(source, option);\n\n// The first parameter is either a string or an array of strings. If it is a\n// string, it will be split on '\\n' or '\\r'. If it is an array of strings, it\n// is assumed that each string represents one line. The source can be a\n// JavaScript text or a JSON text.\n\n// The second parameter is an optional object of options that control the\n// operation of JSLINT. Most of the options are booleans: They are all\n// optional and have a default value of false. One of the options, predef,\n// can be an array of names, which will be used to declare global variables,\n// or an object whose keys are used as global names, with a boolean value\n// that determines if they are assignable.\n\n// If it checks out, JSLINT returns true. Otherwise, it returns false.\n\n// If false, you can inspect JSLINT.errors to find out the problems.\n// JSLINT.errors is an array of objects containing these properties:\n\n//  {\n//      line      : The line (relative to 0) at which the lint was found\n//      character : The character (relative to 0) at which the lint was found\n//      reason    : The problem\n//      evidence  : The text line in which the problem occurred\n//      raw       : The raw message before the details were inserted\n//      a         : The first detail\n//      b         : The second detail\n//      c         : The third detail\n//      d         : The fourth detail\n//  }\n\n// If a stopping error was found, a null will be the last element of the\n// JSLINT.errors array. A stopping error means that JSLint was not confident\n// enough to continue. It does not necessarily mean that the error was\n// especially heinous.\n\n// You can request a data structure that contains JSLint's results.\n\n//     var myData = JSLINT.data();\n\n// It returns a structure with this form:\n\n//     {\n//         errors: [\n//             {\n//                 line: NUMBER,\n//                 character: NUMBER,\n//                 reason: STRING,\n//                 evidence: STRING\n//             }\n//         ],\n//         functions: [\n//             {\n//                 name: STRING,\n//                 line: NUMBER,\n//                 level: NUMBER,\n//                 parameter: [\n//                     STRING\n//                 ],\n//                 var: [\n//                     STRING\n//                 ],\n//                 exception: [\n//                     STRING\n//                 ],\n//                 closure: [\n//                     STRING\n//                 ],\n//                 outer: [\n//                     STRING\n//                 ],\n//                 global: [\n//                     STRING\n//                 ],\n//                 label: [\n//                     STRING\n//                 ]\n//             }\n//         ],\n//         global: [\n//             STRING\n//         ],\n//         member: {\n//             STRING: NUMBER\n//         },\n//         json: BOOLEAN\n//     }\n\n// You can request a Function Report, which shows all of the functions\n// and the parameters and vars that they use. This can be used to find\n// implied global variables and other problems. The report is in HTML and\n// can be inserted into an HTML <body>. It should be given the result of the\n// JSLINT.data function.\n\n//     var myReport = JSLINT.report(data);\n\n// You can request an HTML error report.\n\n//     var myErrorReport = JSLINT.error_report(data);\n\n// You can obtain an object containing all of the properties found in the\n// file. JSLINT.property contains an object containing a key for each\n// property used in the program, the value being the number of times that\n// property name was used in the file.\n\n// You can request a properties report, which produces a list of the program's\n// properties in the form of a /*properties*/ declaration.\n\n//      var myPropertyReport = JSLINT.properties_report(JSLINT.property);\n\n// You can obtain the parse tree that JSLint constructed while parsing. The\n// latest tree is kept in JSLINT.tree. A nice stringification can be produced\n// with\n\n//     JSON.stringify(JSLINT.tree, [\n//         'string',  'arity', 'name',  'first',\n//         'second', 'third', 'block', 'else'\n//     ], 4));\n\n// You can request a context coloring table. It contains information that can be\n// applied to the file that was analyzed. Context coloring colors functions\n// based on their nesting level, and variables on the color of the functions\n// in which they are defined.\n\n//      var myColorization = JSLINT.color(data);\n\n// It returns an array containing objects of this form:\n\n//      {\n//          from: COLUMN,\n//          thru: COLUMN,\n//          line: ROW,\n//          level: 0 or higher\n//      }\n\n// JSLint provides three inline directives. They look like slashstar comments,\n// and allow for setting options, declaring global variables, and establishing a\n// set of allowed property names.\n\n// These directives respect function scope.\n\n// The jslint directive is a special comment that can set one or more options.\n// For example:\n\n/*jslint\n    evil: true, nomen: true, regexp: true, todo: true\n*/\n\n// The current option set is\n\n//     ass        true, if assignment expressions should be allowed\n//     bitwise    true, if bitwise operators should be allowed\n//     browser    true, if the standard browser globals should be predefined\n//     closure    true, if Google Closure idioms should be tolerated\n//     continue   true, if the continuation statement should be tolerated\n//     debug      true, if debugger statements should be allowed\n//     devel      true, if logging should be allowed (console, alert, etc.)\n//     eqeq       true, if == should be allowed\n//     evil       true, if eval should be allowed\n//     forin      true, if for in statements need not filter\n//     indent     the indentation factor\n//     maxerr     the maximum number of errors to allow\n//     maxlen     the maximum length of a source line\n//     newcap     true, if constructor names capitalization is ignored\n//     node       true, if Node.js globals should be predefined\n//     nomen      true, if names may have dangling _\n//     passfail   true, if the scan should stop on first error\n//     plusplus   true, if increment/decrement should be allowed\n//     properties true, if all property names must be declared with /*properties*/\n//     regexp     true, if the . should be allowed in regexp literals\n//     rhino      true, if the Rhino environment globals should be predefined\n//     unparam    true, if unused parameters should be tolerated\n//     sloppy     true, if the 'use strict'; pragma is optional\n//     stupid     true, if really stupid practices are tolerated\n//     sub        true, if all forms of subscript notation are tolerated\n//     todo       true, if TODO comments are tolerated\n//     vars       true, if multiple var statements per function should be allowed\n//     white      true, if sloppy whitespace is tolerated\n\n// The properties directive declares an exclusive list of property names.\n// Any properties named in the program that are not in the list will\n// produce a warning.\n\n// For example:\n\n/*properties\n    '\\b', '\\t', '\\n', '\\f', '\\r', '!', '!=', '!==', '\"', '%', '\\'', '(begin)',\n    '(error)', '*', '+', '-', '/', '<', '<=', '==', '===', '>', '>=', '\\\\', a,\n    a_label, a_scope, already_defined, and, apply, arguments, arity, ass,\n    assign, assignment_expression, assignment_function_expression, at, avoid_a,\n    b, bad_assignment, bad_constructor, bad_in_a, bad_invocation, bad_new,\n    bad_number, bad_operand, bad_wrap, bitwise, block, break, breakage, browser,\n    c, call, charAt, charCodeAt, character, closure, code, color, combine_var,\n    comments, conditional_assignment, confusing_a, confusing_regexp,\n    constructor_name_a, continue, control_a, couch, create, d, dangling_a, data,\n    dead, debug, deleted, devel, disrupt, duplicate_a, edge, edition, elif,\n    else, empty_block, empty_case, empty_class, entityify, eqeq, error_report,\n    errors, evidence, evil, exception, exec, expected_a_at_b_c, expected_a_b,\n    expected_a_b_from_c_d, expected_id_a, expected_identifier_a,\n    expected_identifier_a_reserved, expected_number_a, expected_operator_a,\n    expected_positive_a, expected_small_a, expected_space_a_b,\n    expected_string_a, f, first, flag, floor, forEach, for_if, forin, from,\n    fromCharCode, fud, function, function_block, function_eval, function_loop,\n    function_statement, function_strict, functions, global, hasOwnProperty, id,\n    identifier, identifier_function, immed, implied_evil, indent, indexOf,\n    infix_in, init, insecure_a, isAlpha, isArray, isDigit, isNaN, join, jslint,\n    json, keys, kind, label, labeled, lbp, leading_decimal_a, led, left, length,\n    level, line, loopage, master, match, maxerr, maxlen, message, missing_a,\n    missing_a_after_b, missing_property, missing_space_a_b, missing_use_strict,\n    mode, move_invocation, move_var, n, name, name_function, nested_comment,\n    newcap, node, nomen, not, not_a_constructor, not_a_defined, not_a_function,\n    not_a_label, not_a_scope, not_greater, nud, number, octal_a, open, outer,\n    parameter, parameter_a_get_b, parameter_arguments_a, parameter_set_a,\n    params, paren, passfail, plusplus, pop, postscript, predef, properties,\n    properties_report, property, prototype, push, quote, r, radix, raw,\n    read_only, reason, redefinition_a_b, regexp, relation, replace, report,\n    reserved, reserved_a, rhino, right, scanned_a_b, scope, search, second,\n    shift, slash_equal, slice, sloppy, sort, split, statement, statement_block,\n    stop, stopping, strange_loop, strict, string, stupid, sub, subscript,\n    substr, supplant, sync_a, t, tag_a_in_b, test, third, thru, toString, todo,\n    todo_comment, token, tokens, too_long, too_many, trailing_decimal_a, tree,\n    unclosed, unclosed_comment, unclosed_regexp, unescaped_a, unexpected_a,\n    unexpected_char_a, unexpected_comment, unexpected_label_a,\n    unexpected_property_a, unexpected_space_a_b, unexpected_typeof_a,\n    uninitialized_a, unnecessary_else, unnecessary_initialize, unnecessary_use,\n    unparam, unreachable_a_b, unsafe, unused_a, url, use_array, use_braces,\n    use_nested_if, use_object, use_or, use_param, use_spaces, used,\n    used_before_a, var, var_a_not, var_loop, vars, varstatement, warn, warning,\n    was, weird_assignment, weird_condition, weird_new, weird_program,\n    weird_relation, weird_ternary, white, wrap, wrap_immediate, wrap_regexp,\n    write_is_wrong, writeable\n*/\n\n// The global directive is used to declare global variables that can\n// be accessed by the program. If a declaration is true, then the variable\n// is writeable. Otherwise, it is read-only.\n\n// We build the application inside a function so that we produce only a single\n// global variable. That function will be invoked immediately, and its return\n// value is the JSLINT function itself. That function is also an object that\n// can contain data and other functions.\n\nvar JSLINT = (function () {\n    'use strict';\n\n    function array_to_object(array, value) {\n\n// Make an object from an array of keys and a common value.\n\n        var i, length = array.length, object = Object.create(null);\n        for (i = 0; i < length; i += 1) {\n            object[array[i]] = value;\n        }\n        return object;\n    }\n\n\n    var allowed_option = {\n            ass       : true,\n            bitwise   : true,\n            browser   : true,\n            closure   : true,\n            continue  : true,\n            couch     : true,\n            debug     : true,\n            devel     : true,\n            eqeq      : true,\n            evil      : true,\n            forin     : true,\n            indent    :   10,\n            maxerr    : 1000,\n            maxlen    :  256,\n            newcap    : true,\n            node      : true,\n            nomen     : true,\n            passfail  : true,\n            plusplus  : true,\n            properties: true,\n            regexp    : true,\n            rhino     : true,\n            unparam   : true,\n            sloppy    : true,\n            stupid    : true,\n            sub       : true,\n            todo      : true,\n            vars      : true,\n            white     : true\n        },\n        anonname,       // The guessed name for anonymous functions.\n\n// These are operators that should not be used with the ! operator.\n\n        bang = {\n            '<'  : true,\n            '<=' : true,\n            '==' : true,\n            '===': true,\n            '!==': true,\n            '!=' : true,\n            '>'  : true,\n            '>=' : true,\n            '+'  : true,\n            '-'  : true,\n            '*'  : true,\n            '/'  : true,\n            '%'  : true\n        },\n        begin,          // The root token\n        block_var,     // vars defined in the current block\n\n// browser contains a set of global names that are commonly provided by a\n// web browser environment.\n\n        browser = array_to_object([\n            'clearInterval', 'clearTimeout', 'document', 'event', 'FormData',\n            'frames', 'history', 'Image', 'localStorage', 'location', 'name',\n            'navigator', 'Option', 'parent', 'screen', 'sessionStorage',\n            'setInterval', 'setTimeout', 'Storage', 'window', 'XMLHttpRequest'\n        ], false),\n\n// bundle contains the text messages.\n\n        bundle = {\n            a_label: \"'{a}' is a statement label.\",\n            a_scope: \"'{a}' used out of scope.\",\n            already_defined: \"'{a}' is already defined.\",\n            and: \"The '&&' subexpression should be wrapped in parens.\",\n            assignment_expression: \"Unexpected assignment expression.\",\n            assignment_function_expression: \"Expected an assignment or \" +\n                \"function call and instead saw an expression.\",\n            avoid_a: \"Avoid '{a}'.\",\n            bad_assignment: \"Bad assignment.\",\n            bad_constructor: \"Bad constructor.\",\n            bad_in_a: \"Bad for in variable '{a}'.\",\n            bad_invocation: \"Bad invocation.\",\n            bad_new: \"Do not use 'new' for side effects.\",\n            bad_number: \"Bad number '{a}'.\",\n            bad_operand: \"Bad operand.\",\n            bad_wrap: \"Do not wrap function literals in parens unless they \" +\n                \"are to be immediately invoked.\",\n            combine_var: \"Combine this with the previous 'var' statement.\",\n            conditional_assignment: \"Expected a conditional expression and \" +\n                \"instead saw an assignment.\",\n            confusing_a: \"Confusing use of '{a}'.\",\n            confusing_regexp: \"Confusing regular expression.\",\n            constructor_name_a: \"A constructor name '{a}' should start with \" +\n                \"an uppercase letter.\",\n            control_a: \"Unexpected control character '{a}'.\",\n            dangling_a: \"Unexpected dangling '_' in '{a}'.\",\n            deleted: \"Only properties should be deleted.\",\n            duplicate_a: \"Duplicate '{a}'.\",\n            empty_block: \"Empty block.\",\n            empty_case: \"Empty case.\",\n            empty_class: \"Empty class.\",\n            evil: \"eval is evil.\",\n            expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n            expected_a_b_from_c_d: \"Expected '{a}' to match '{b}' from line \" +\n                \"{c} and instead saw '{d}'.\",\n            expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n            expected_id_a: \"Expected an id, and instead saw #{a}.\",\n            expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n            expected_identifier_a_reserved: \"Expected an identifier and \" +\n                \"instead saw '{a}' (a reserved word).\",\n            expected_number_a: \"Expected a number and instead saw '{a}'.\",\n            expected_operator_a: \"Expected an operator and instead saw '{a}'.\",\n            expected_positive_a: \"Expected a positive number and instead saw '{a}'\",\n            expected_small_a: \"Expected a small positive integer and instead saw '{a}'\",\n            expected_space_a_b: \"Expected exactly one space between '{a}' and '{b}'.\",\n            expected_string_a: \"Expected a string and instead saw '{a}'.\",\n            for_if: \"The body of a for in should be wrapped in an if \" +\n                \"statement to filter unwanted properties from the prototype.\",\n            function_block: \"Function statements should not be placed in blocks.\" +\n                \"Use a function expression or move the statement to the top of \" +\n                \"the outer function.\",\n            function_eval: \"The Function constructor is eval.\",\n            function_loop: \"Don't make functions within a loop.\",\n            function_statement: \"Function statements are not invocable. \" +\n                \"Wrap the whole function invocation in parens.\",\n            function_strict: \"Use the function form of 'use strict'.\",\n            identifier_function: \"Expected an identifier in an assignment \" +\n                \"and instead saw a function invocation.\",\n            implied_evil: \"Implied eval is evil. Pass a function instead of a string.\",\n            infix_in: \"Unexpected 'in'. Compare with undefined, or use the \" +\n                \"hasOwnProperty method instead.\",\n            insecure_a: \"Insecure '{a}'.\",\n            isNaN: \"Use the isNaN function to compare with NaN.\",\n            leading_decimal_a: \"A leading decimal point can be confused with a dot: '.{a}'.\",\n            missing_a: \"Missing '{a}'.\",\n            missing_a_after_b: \"Missing '{a}' after '{b}'.\",\n            missing_property: \"Missing property name.\",\n            missing_space_a_b: \"Missing space between '{a}' and '{b}'.\",\n            missing_use_strict: \"Missing 'use strict' statement.\",\n            move_invocation: \"Move the invocation into the parens that \" +\n                \"contain the function.\",\n            move_var: \"Move 'var' declarations to the top of the function.\",\n            name_function: \"Missing name in function statement.\",\n            nested_comment: \"Nested comment.\",\n            not: \"Nested not.\",\n            not_a_constructor: \"Do not use {a} as a constructor.\",\n            not_a_defined: \"'{a}' has not been fully defined yet.\",\n            not_a_function: \"'{a}' is not a function.\",\n            not_a_label: \"'{a}' is not a label.\",\n            not_a_scope: \"'{a}' is out of scope.\",\n            not_greater: \"'{a}' should not be greater than '{b}'.\",\n            octal_a: \"Don't use octal: '{a}'. Use '\\\\u....' instead.\",\n            parameter_arguments_a: \"Do not mutate parameter '{a}' when using 'arguments'.\",\n            parameter_a_get_b: \"Unexpected parameter '{a}' in get {b} function.\",\n            parameter_set_a: \"Expected parameter (value) in set {a} function.\",\n            radix: \"Missing radix parameter.\",\n            read_only: \"Read only.\",\n            redefinition_a_b: \"Redefinition of '{a}' from line {b}.\",\n            reserved_a: \"Reserved name '{a}'.\",\n            scanned_a_b: \"{a} ({b}% scanned).\",\n            slash_equal: \"A regular expression literal can be confused with '/='.\",\n            statement_block: \"Expected to see a statement and instead saw a block.\",\n            stopping: \"Stopping.\",\n            strange_loop: \"Strange loop.\",\n            strict: \"Strict violation.\",\n            subscript: \"['{a}'] is better written in dot notation.\",\n            sync_a: \"Unexpected sync method: '{a}'.\",\n            tag_a_in_b: \"A '<{a}>' must be within '<{b}>'.\",\n            todo_comment: \"Unexpected TODO comment.\",\n            too_long: \"Line too long.\",\n            too_many: \"Too many errors.\",\n            trailing_decimal_a: \"A trailing decimal point can be confused \" +\n                \"with a dot: '.{a}'.\",\n            unclosed: \"Unclosed string.\",\n            unclosed_comment: \"Unclosed comment.\",\n            unclosed_regexp: \"Unclosed regular expression.\",\n            unescaped_a: \"Unescaped '{a}'.\",\n            unexpected_a: \"Unexpected '{a}'.\",\n            unexpected_char_a: \"Unexpected character '{a}'.\",\n            unexpected_comment: \"Unexpected comment.\",\n            unexpected_label_a: \"Unexpected label '{a}'.\",\n            unexpected_property_a: \"Unexpected /*property*/ '{a}'.\",\n            unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n            unexpected_typeof_a: \"Unexpected 'typeof'. \" +\n                \"Use '===' to compare directly with {a}.\",\n            uninitialized_a: \"Uninitialized '{a}'.\",\n            unnecessary_else: \"Unnecessary 'else' after disruption.\",\n            unnecessary_initialize: \"It is not necessary to initialize '{a}' \" +\n                \"to 'undefined'.\",\n            unnecessary_use: \"Unnecessary 'use strict'.\",\n            unreachable_a_b: \"Unreachable '{a}' after '{b}'.\",\n            unsafe: \"Unsafe character.\",\n            unused_a: \"Unused '{a}'.\",\n            url: \"JavaScript URL.\",\n            use_array: \"Use the array literal notation [].\",\n            use_braces: \"Spaces are hard to count. Use {{a}}.\",\n            use_nested_if: \"Expected 'else { if' and instead saw 'else if'.\",\n            use_object: \"Use the object literal notation {} or Object.create(null).\",\n            use_or: \"Use the || operator.\",\n            use_param: \"Use a named parameter.\",\n            use_spaces: \"Use spaces, not tabs.\",\n            used_before_a: \"'{a}' was used before it was defined.\",\n            var_a_not: \"Variable {a} was not declared correctly.\",\n            var_loop: \"Don't declare variables in a loop.\",\n            weird_assignment: \"Weird assignment.\",\n            weird_condition: \"Weird condition.\",\n            weird_new: \"Weird construction. Delete 'new'.\",\n            weird_program: \"Weird program.\",\n            weird_relation: \"Weird relation.\",\n            weird_ternary: \"Weird ternary.\",\n            wrap_immediate: \"Wrap an immediate function invocation in \" +\n                \"parentheses to assist the reader in understanding that the \" +\n                \"expression is the result of a function, and not the \" +\n                \"function itself.\",\n            wrap_regexp: \"Wrap the /regexp/ literal in parens to \" +\n                \"disambiguate the slash operator.\",\n            write_is_wrong: \"document.write can be a form of eval.\"\n        },\n        closure = array_to_object([\n            'goog'\n        ], false),\n        comments,\n        comments_off,\n        couch = array_to_object([\n            'emit', 'getRow', 'isArray', 'log', 'provides', 'registerType',\n            'require', 'send', 'start', 'sum', 'toJSON'\n        ], false),\n\n        descapes = {\n            'b': '\\b',\n            't': '\\t',\n            'n': '\\n',\n            'f': '\\f',\n            'r': '\\r',\n            '\"': '\"',\n            '/': '/',\n            '\\\\': '\\\\',\n            '!': '!'\n        },\n\n        devel = array_to_object([\n            'alert', 'confirm', 'console', 'Debug', 'opera', 'prompt', 'WSH'\n        ], false),\n        directive,\n        escapes = {\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\\'': '\\\\\\'',\n            '\"' : '\\\\\"',\n            '/' : '\\\\/',\n            '\\\\': '\\\\\\\\'\n        },\n\n        funct,          // The current function\n\n        functions,      // All of the functions\n        global_funct,   // The global body\n        global_scope,   // The global scope\n        in_block,       // Where function statements are not allowed\n        indent,\n        itself,         // JSLINT itself\n        json_mode,\n        lex,            // the tokenizer\n        lines,\n        lookahead,\n        node = array_to_object([\n            'Buffer', 'clearImmediate', 'clearInterval', 'clearTimeout',\n            'console', 'exports', 'global', 'module', 'process',\n            'require', 'setImmediate', 'setInterval', 'setTimeout',\n            '__dirname', '__filename'\n        ], false),\n        node_js,\n        numbery = array_to_object(['indexOf', 'lastIndexOf', 'search'], true),\n        next_token,\n        option,\n        predefined,     // Global variables defined by option\n        prereg,\n        prev_token,\n        property,\n        protosymbol,\n        regexp_flag = array_to_object(['g', 'i', 'm'], true),\n        return_this = function return_this() {\n            return this;\n        },\n        rhino = array_to_object([\n            'defineClass', 'deserialize', 'gc', 'help', 'load', 'loadClass',\n            'print', 'quit', 'readFile', 'readUrl', 'runCommand', 'seal',\n            'serialize', 'spawn', 'sync', 'toint32', 'version'\n        ], false),\n\n        scope,      // An object containing an object for each variable in scope\n        semicolon_coda = array_to_object([';', '\"', '\\'', ')'], true),\n\n// standard contains the global names that are provided by the\n// ECMAScript standard.\n\n        standard = array_to_object([\n            'Array', 'Boolean', 'Date', 'decodeURI', 'decodeURIComponent',\n            'encodeURI', 'encodeURIComponent', 'Error', 'eval', 'EvalError',\n            'Function', 'isFinite', 'isNaN', 'JSON', 'Map', 'Math', 'Number',\n            'Object', 'parseInt', 'parseFloat', 'Promise', 'Proxy',\n            'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set',\n            'String', 'Symbol', 'SyntaxError', 'System', 'TypeError',\n            'URIError', 'WeakMap', 'WeakSet'\n        ], false),\n\n        strict_mode,\n        syntax = Object.create(null),\n        token,\n        tokens,\n        var_mode,\n        warnings,\n\n// Regular expressions. Some of these are stupidly long.\n\n// carriage return, carriage return linefeed, or linefeed\n        crlfx = /\\r\\n?|\\n/,\n// unsafe characters that are silently deleted by one or more browsers\n        cx = /[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n// identifier\n        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,\n// javascript url\n        jx = /^(?:javascript|jscript|ecmascript|vbscript)\\s*:/i,\n// star slash\n        lx = /\\*\\/|\\/\\*/,\n// characters in strings that need escapement\n        nx = /[\\u0000-\\u001f'\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n// sync\n        syx = /Sync$/,\n// comment todo\n        tox = /^\\W*to\\s*do(?:\\W|$)/i,\n// token\n        tx = /^\\s*([(){}\\[\\]\\?.,:;'\"~#@`]|={1,3}|\\/(\\*(jslint|properties|property|members?|globals?)?|=|\\/)?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|[\\^%]=?|&[&=]?|\\|[|=]?|>{1,3}=?|<(?:[\\/=!]|\\!(\\[|--)?|<=?)?|\\!(\\!|==?)?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+(?:[xX][0-9a-fA-F]+|\\.[0-9]*)?(?:[eE][+\\-]?[0-9]+)?)/;\n\n\n    if (typeof String.prototype.entityify !== 'function') {\n        String.prototype.entityify = function () {\n            return this\n                .replace(/&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;');\n        };\n    }\n\n    if (typeof String.prototype.isAlpha !== 'function') {\n        String.prototype.isAlpha = function () {\n            return (this >= 'a' && this <= 'z\\uffff') ||\n                (this >= 'A' && this <= 'Z\\uffff');\n        };\n    }\n\n    if (typeof String.prototype.isDigit !== 'function') {\n        String.prototype.isDigit = function () {\n            return (this >= '0' && this <= '9');\n        };\n    }\n\n    if (typeof String.prototype.supplant !== 'function') {\n        String.prototype.supplant = function (o) {\n            return this.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n                var replacement = o[b];\n                return typeof replacement === 'string' ||\n                    typeof replacement === 'number' ? replacement : a;\n            });\n        };\n    }\n\n\n    function sanitize(a) {\n\n//  Escapify a troublesome character.\n\n        return escapes[a] ||\n            '\\\\u' + ('0000' + a.charCodeAt().toString(16)).slice(-4);\n    }\n\n\n    function add_to_predefined(group) {\n        Object.keys(group).forEach(function (name) {\n            predefined[name] = group[name];\n        });\n    }\n\n\n    function assume() {\n        if (option.browser) {\n            add_to_predefined(browser);\n            option.browser = false;\n        }\n        if (option.closure) {\n            add_to_predefined(closure);\n        }\n        if (option.couch) {\n            add_to_predefined(couch);\n            option.couch = false;\n        }\n        if (option.devel) {\n            add_to_predefined(devel);\n            option.devel = false;\n        }\n        if (option.node) {\n            add_to_predefined(node);\n            option.node = false;\n            node_js = true;\n        }\n        if (option.rhino) {\n            add_to_predefined(rhino);\n            option.rhino = false;\n        }\n    }\n\n\n// Produce an error warning.\n\n    function artifact(tok) {\n        if (!tok) {\n            tok = next_token;\n        }\n        return tok.id === '(number)' ? tok.number : tok.string;\n    }\n\n    function quit(message, line, character) {\n        throw {\n            name: 'JSLintError',\n            line: line,\n            character: character,\n            message: bundle.scanned_a_b.supplant({\n                a: bundle[message] || message,\n                b: Math.floor((line / lines.length) * 100)\n            })\n        };\n    }\n\n    function warn(code, line, character, a, b, c, d) {\n        var warning = {         // ~~\n            id: '(error)',\n            raw: bundle[code] || code,\n            code: code,\n            evidence: lines[line - 1] || '',\n            line: line,\n            character: character,\n            a: a || artifact(this),\n            b: b,\n            c: c,\n            d: d\n        };\n        warning.reason = warning.raw.supplant(warning);\n        itself.errors.push(warning);\n        if (option.passfail) {\n            quit('stopping', line, character);\n        }\n        warnings += 1;\n        if (warnings >= option.maxerr) {\n            quit('too_many', line, character);\n        }\n        return warning;\n    }\n\n    function stop(code, line, character, a, b, c, d) {\n        var warning = warn(code, line, character, a, b, c, d);\n        quit('stopping', warning.line, warning.character);\n    }\n\n    function expected_at(at) {\n        if (!option.white && next_token.from !== at) {\n            next_token.warn('expected_a_at_b_c', '', at, next_token.from);\n        }\n    }\n\n// lexical analysis and token construction\n\n    lex = (function lex() {\n        var character, c, from, length, line, pos, source_row;\n\n// Private lex methods\n\n        function next_line() {\n            var at;\n            character = 1;\n            source_row = lines[line];\n            line += 1;\n            if (source_row === undefined) {\n                return false;\n            }\n            at = source_row.search(/\\t/);\n            if (at >= 0) {\n                if (option.white) {\n                    source_row = source_row.replace(/\\t/g, ' ');\n                } else {\n                    warn('use_spaces', line, at + 1);\n                }\n            }\n            at = source_row.search(cx);\n            if (at >= 0) {\n                warn('unsafe', line, at);\n            }\n            if (option.maxlen && option.maxlen < source_row.length) {\n                warn('too_long', line, source_row.length);\n            }\n            return true;\n        }\n\n// Produce a token object.  The token inherits from a syntax symbol.\n\n        function it(type, value) {\n            var id, the_token;\n            if (type === '(string)') {\n                if (jx.test(value)) {\n                    warn('url', line, from);\n                }\n            }\n            the_token = Object.create(syntax[(\n                type === '(punctuator)' || (type === '(identifier)' &&\n                        Object.prototype.hasOwnProperty.call(syntax, value))\n                    ? value\n                    : type\n            )] || syntax['(error)']);\n            if (type === '(identifier)') {\n                the_token.identifier = true;\n                if (value === '__iterator__' || value === '__proto__') {\n                    stop('reserved_a', line, from, value);\n                } else if (!option.nomen &&\n                        (value.charAt(0) === '_' ||\n                        value.charAt(value.length - 1) === '_')) {\n                    warn('dangling_a', line, from, value);\n                }\n            }\n            if (type === '(number)') {\n                the_token.number = +value;\n            } else if (value !== undefined) {\n                the_token.string = String(value);\n            }\n            the_token.line = line;\n            the_token.from = from;\n            the_token.thru = character;\n            if (comments.length) {\n                the_token.comments = comments;\n                comments = [];\n            }\n            id = the_token.id;\n            prereg = id && (\n                ('(,=:[!&|?{};~+-*%^<>'.indexOf(id.charAt(id.length - 1)) >= 0) ||\n                id === 'return' || id === 'case'\n            );\n            return the_token;\n        }\n\n        function match(x) {\n            var exec = x.exec(source_row), first;\n            if (exec) {\n                length = exec[0].length;\n                first = exec[1];\n                c = first.charAt(0);\n                source_row = source_row.slice(length);\n                from = character + length - first.length;\n                character += length;\n                return first;\n            }\n            for (;;) {\n                if (!source_row) {\n                    if (!option.white) {\n                        warn('unexpected_char_a', line, character - 1, '(space)');\n                    }\n                    return;\n                }\n                c = source_row.charAt(0);\n                if (c !== ' ') {\n                    break;\n                }\n                source_row = source_row.slice(1);\n                character += 1;\n            }\n            stop('unexpected_char_a', line, character, c);\n\n        }\n\n        function string(x) {\n            var ch, at = 0, r = '', result;\n\n            function hex(n) {\n                var i = parseInt(source_row.substr(at + 1, n), 16);\n                at += n;\n                if (i >= 32 && i <= 126 &&\n                        i !== 34 && i !== 92 && i !== 39) {\n                    warn('unexpected_a', line, character, '\\\\');\n                }\n                character += n;\n                ch = String.fromCharCode(i);\n            }\n\n            if (json_mode && x !== '\"') {\n                warn('expected_a_b', line, character, '\"', x);\n            }\n\n            for (;;) {\n                while (at >= source_row.length) {\n                    at = 0;\n                    if (!next_line()) {\n                        stop('unclosed', line - 1, from);\n                    }\n                }\n                ch = source_row.charAt(at);\n                if (ch === x) {\n                    character += 1;\n                    source_row = source_row.slice(at + 1);\n                    result = it('(string)', r);\n                    result.quote = x;\n                    return result;\n                }\n                if (ch < ' ') {\n                    if (ch === '\\n' || ch === '\\r') {\n                        break;\n                    }\n                    warn('control_a', line, character + at,\n                        source_row.slice(0, at));\n                } else if (ch === '\\\\') {\n                    at += 1;\n                    character += 1;\n                    ch = source_row.charAt(at);\n                    switch (ch) {\n                    case '':\n                        warn('unexpected_a', line, character, '\\\\');\n                        next_line();\n                        at = -1;\n                        break;\n                    case '\\'':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\\\'');\n                        }\n                        break;\n                    case 'u':\n                        hex(4);\n                        break;\n                    case 'v':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\v');\n                        }\n                        ch = '\\v';\n                        break;\n                    case 'x':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\x');\n                        }\n                        hex(2);\n                        break;\n                    default:\n                        if (typeof descapes[ch] !== 'string') {\n                            warn(ch >= '0' && ch <= '7' ? 'octal_a' : 'unexpected_a',\n                                line, character, '\\\\' + ch);\n                        } else {\n                            ch = descapes[ch];\n                        }\n                    }\n                }\n                r += ch;\n                character += 1;\n                at += 1;\n            }\n        }\n\n        function number(snippet) {\n            var digit;\n            if (source_row.charAt(0).isAlpha()) {\n                warn('expected_space_a_b',\n                    line, character, c, source_row.charAt(0));\n            }\n            if (c === '0') {\n                digit = snippet.charAt(1);\n                if (digit.isDigit()) {\n                    if (token.id !== '.') {\n                        warn('unexpected_a', line, character, snippet);\n                    }\n                } else if (json_mode && (digit === 'x' || digit === 'X')) {\n                    warn('unexpected_a', line, character, '0x');\n                }\n            }\n            if (snippet.slice(snippet.length - 1) === '.') {\n                warn('trailing_decimal_a', line, character, snippet);\n            }\n            digit = +snippet;\n            if (!isFinite(digit)) {\n                warn('bad_number', line, character, snippet);\n            }\n            snippet = digit;\n            return it('(number)', snippet);\n        }\n\n        function comment(snippet, type) {\n            if (comments_off) {\n                warn('unexpected_comment', line, character);\n            } else if (!option.todo && tox.test(snippet)) {\n                warn('todo_comment', line, character);\n            }\n            comments.push({\n                id: type,\n                from: from,\n                thru: character,\n                line: line,\n                string: snippet\n            });\n        }\n\n        function regexp() {\n            var at = 0,\n                b,\n                bit,\n                depth = 0,\n                flag = '',\n                high,\n                letter,\n                low,\n                potential,\n                quote,\n                result;\n            for (;;) {\n                b = true;\n                c = source_row.charAt(at);\n                at += 1;\n                switch (c) {\n                case '':\n                    stop('unclosed_regexp', line, from);\n                    return;\n                case '/':\n                    if (depth > 0) {\n                        warn('unescaped_a', line, from + at, '/');\n                    }\n                    c = source_row.slice(0, at - 1);\n                    potential = Object.create(regexp_flag);\n                    for (;;) {\n                        letter = source_row.charAt(at);\n                        if (potential[letter] !== true) {\n                            break;\n                        }\n                        potential[letter] = false;\n                        at += 1;\n                        flag += letter;\n                    }\n                    if (source_row.charAt(at).isAlpha()) {\n                        stop('unexpected_a', line, from, source_row.charAt(at));\n                    }\n                    character += at;\n                    source_row = source_row.slice(at);\n                    quote = source_row.charAt(0);\n                    if (quote === '/' || quote === '*') {\n                        stop('confusing_regexp', line, from);\n                    }\n                    result = it('(regexp)', c);\n                    result.flag = flag;\n                    return result;\n                case '\\\\':\n                    c = source_row.charAt(at);\n                    if (c < ' ') {\n                        warn('control_a', line, from + at, String(c));\n                    } else if (c === '<') {\n                        warn('unexpected_a', line, from + at, '\\\\');\n                    }\n                    at += 1;\n                    break;\n                case '(':\n                    depth += 1;\n                    b = false;\n                    if (source_row.charAt(at) === '?') {\n                        at += 1;\n                        switch (source_row.charAt(at)) {\n                        case ':':\n                        case '=':\n                        case '!':\n                            at += 1;\n                            break;\n                        default:\n                            warn('expected_a_b', line, from + at,\n                                ':', source_row.charAt(at));\n                        }\n                    }\n                    break;\n                case '|':\n                    b = false;\n                    break;\n                case ')':\n                    if (depth === 0) {\n                        warn('unescaped_a', line, from + at, ')');\n                    } else {\n                        depth -= 1;\n                    }\n                    break;\n                case ' ':\n                    pos = 1;\n                    while (source_row.charAt(at) === ' ') {\n                        at += 1;\n                        pos += 1;\n                    }\n                    if (pos > 1) {\n                        warn('use_braces', line, from + at, pos);\n                    }\n                    break;\n                case '[':\n                    c = source_row.charAt(at);\n                    if (c === '^') {\n                        at += 1;\n                        if (!option.regexp) {\n                            warn('insecure_a', line, from + at, c);\n                        } else if (source_row.charAt(at) === ']') {\n                            stop('unescaped_a', line, from + at, '^');\n                        }\n                    }\n                    bit = false;\n                    if (c === ']') {\n                        warn('empty_class', line, from + at - 1);\n                        bit = true;\n                    }\nklass:              do {\n                        c = source_row.charAt(at);\n                        at += 1;\n                        switch (c) {\n                        case '[':\n                        case '^':\n                            warn('unescaped_a', line, from + at, c);\n                            bit = true;\n                            break;\n                        case '-':\n                            if (bit) {\n                                bit = false;\n                            } else {\n                                warn('unescaped_a', line, from + at, '-');\n                                bit = true;\n                            }\n                            break;\n                        case ']':\n                            if (!bit) {\n                                warn('unescaped_a', line, from + at - 1, '-');\n                            }\n                            break klass;\n                        case '\\\\':\n                            c = source_row.charAt(at);\n                            if (c < ' ') {\n                                warn('control_a', line, from + at, String(c));\n                            } else if (c === '<') {\n                                warn('unexpected_a', line, from + at, '\\\\');\n                            }\n                            at += 1;\n                            bit = true;\n                            break;\n                        case '/':\n                            warn('unescaped_a', line, from + at - 1, '/');\n                            bit = true;\n                            break;\n                        default:\n                            bit = true;\n                        }\n                    } while (c);\n                    break;\n                case '.':\n                    if (!option.regexp) {\n                        warn('insecure_a', line, from + at, c);\n                    }\n                    break;\n                case ']':\n                case '?':\n                case '{':\n                case '}':\n                case '+':\n                case '*':\n                    warn('unescaped_a', line, from + at, c);\n                    break;\n                }\n                if (b) {\n                    switch (source_row.charAt(at)) {\n                    case '?':\n                    case '+':\n                    case '*':\n                        at += 1;\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        break;\n                    case '{':\n                        at += 1;\n                        c = source_row.charAt(at);\n                        if (c < '0' || c > '9') {\n                            warn('expected_number_a', line,\n                                from + at, c);\n                        }\n                        at += 1;\n                        low = +c;\n                        for (;;) {\n                            c = source_row.charAt(at);\n                            if (c < '0' || c > '9') {\n                                break;\n                            }\n                            at += 1;\n                            low = +c + (low * 10);\n                        }\n                        high = low;\n                        if (c === ',') {\n                            at += 1;\n                            high = Infinity;\n                            c = source_row.charAt(at);\n                            if (c >= '0' && c <= '9') {\n                                at += 1;\n                                high = +c;\n                                for (;;) {\n                                    c = source_row.charAt(at);\n                                    if (c < '0' || c > '9') {\n                                        break;\n                                    }\n                                    at += 1;\n                                    high = +c + (high * 10);\n                                }\n                            }\n                        }\n                        if (source_row.charAt(at) !== '}') {\n                            warn('expected_a_b', line, from + at,\n                                '}', c);\n                        } else {\n                            at += 1;\n                        }\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        if (low > high) {\n                            warn('not_greater', line, from + at,\n                                low, high);\n                        }\n                        break;\n                    }\n                }\n            }\n            c = source_row.slice(0, at - 1);\n            character += at;\n            source_row = source_row.slice(at);\n            return it('(regexp)', c);\n        }\n\n// Public lex methods\n\n        return {\n            init: function (source) {\n                if (typeof source === 'string') {\n                    lines = source.split(crlfx);\n                } else {\n                    lines = source;\n                }\n                line = 0;\n                next_line();\n                from = 1;\n            },\n\n// token -- this is called by advance to get the next token.\n\n            token: function () {\n                var first, i, snippet;\n\n                for (;;) {\n                    while (!source_row) {\n                        if (!next_line()) {\n                            return it('(end)');\n                        }\n                    }\n                    snippet = match(tx);\n                    if (snippet) {\n\n//      identifier\n\n                        first = snippet.charAt(0);\n                        if (first.isAlpha() || first === '_' || first === '$') {\n                            return it('(identifier)', snippet);\n                        }\n\n//      number\n\n                        if (first.isDigit()) {\n                            return number(snippet);\n                        }\n                        switch (snippet) {\n\n//      string\n\n                        case '\"':\n                        case \"'\":\n                            return string(snippet);\n\n//      // comment\n\n                        case '//':\n                            comment(source_row, '//');\n                            source_row = '';\n                            break;\n\n//      /* comment\n\n                        case '/*':\n                            for (;;) {\n                                i = source_row.search(lx);\n                                if (i >= 0) {\n                                    break;\n                                }\n                                character = source_row.length;\n                                comment(source_row);\n                                from = 0;\n                                if (!next_line()) {\n                                    stop('unclosed_comment', line, character);\n                                }\n                            }\n                            comment(source_row.slice(0, i), '/*');\n                            character += i + 2;\n                            if (source_row.charAt(i) === '/') {\n                                stop('nested_comment', line, character);\n                            }\n                            source_row = source_row.slice(i + 2);\n                            break;\n\n                        case '':\n                            break;\n//      /\n                        case '/':\n                            if (token.id === '/=') {\n                                stop('slash_equal', line, from);\n                            }\n                            return prereg\n                                ? regexp()\n                                : it('(punctuator)', snippet);\n\n//      punctuator\n                        default:\n                            return it('(punctuator)', snippet);\n                        }\n                    }\n                }\n            }\n        };\n    }());\n\n    function define(kind, token) {\n\n// Define a name.\n\n        var name = token.string,\n            master = scope[name];       // The current definition of the name\n\n// vars are created with a deadzone, so that the expression that initializes\n// the var cannot access the var. Functions are not writeable.\n\n        token.dead = false;\n        token.init = false;\n        token.kind = kind;\n        token.master = master;\n        token.used = 0;\n        token.writeable = true;\n\n// Global variables are a little weird. They can be defined multiple times.\n// Some predefined global vars are (or should) not be writeable.\n\n        if (kind === 'var' && funct === global_funct) {\n            if (!master) {\n                if (predefined[name] === false) {\n                    token.writeable = false;\n                }\n                global_scope[name] = token;\n            }\n        } else {\n\n// It is an error if the name has already been defined in this scope, except\n// when reusing an exception variable name.\n\n            if (master) {\n                if (master.function === funct) {\n                    if (master.kind !== 'exception' || kind !== 'exception' ||\n                            !master.dead) {\n                        token.warn('already_defined', name);\n                    }\n                } else if (master.function !== global_funct) {\n                    if (kind === 'var') {\n                        token.warn('redefinition_a_b', name, master.line);\n                    }\n                }\n            }\n            scope[name] = token;\n            if (kind === 'var') {\n                block_var.push(name);\n            }\n        }\n    }\n\n    function peek(distance) {\n\n// Peek ahead to a future token. The distance is how far ahead to look. The\n// default is the next token.\n\n        var found, slot = 0;\n\n        distance = distance || 0;\n        while (slot <= distance) {\n            found = lookahead[slot];\n            if (!found) {\n                found = lookahead[slot] = lex.token();\n            }\n            slot += 1;\n        }\n        return found;\n    }\n\n\n    function advance(id, match) {\n\n// Produce the next token, also looking for programming errors.\n\n        if (indent) {\n\n// If indentation checking was requested, then inspect all of the line breakings.\n// The var statement is tricky because the names might be aligned or not. We\n// look at the first line break after the var to determine the programmer's\n// intention.\n\n            if (var_mode && next_token.line !== token.line) {\n                if ((var_mode !== indent || !next_token.edge) &&\n                        next_token.from === indent.at -\n                        (next_token.edge ? option.indent : 0)) {\n                    var dent = indent;\n                    for (;;) {\n                        dent.at -= option.indent;\n                        if (dent === var_mode) {\n                            break;\n                        }\n                        dent = dent.was;\n                    }\n                    dent.open = false;\n                }\n                var_mode = null;\n            }\n            if (next_token.id === '?' && indent.mode === ':' &&\n                    token.line !== next_token.line) {\n                indent.at -= option.indent;\n            }\n            if (indent.open) {\n\n// If the token is an edge.\n\n                if (next_token.edge) {\n                    if (next_token.edge === 'label') {\n                        expected_at(1);\n                    } else if (next_token.edge === 'case' || indent.mode === 'statement') {\n                        expected_at(indent.at - option.indent);\n                    } else if (indent.mode !== 'array' || next_token.line !== token.line) {\n                        expected_at(indent.at);\n                    }\n\n// If the token is not an edge, but is the first token on the line.\n\n                } else if (next_token.line !== token.line) {\n                    if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                    indent.wrap = true;\n                }\n            } else if (next_token.line !== token.line) {\n                if (next_token.edge) {\n                    expected_at(indent.at);\n                } else {\n                    indent.wrap = true;\n                    if (indent.mode === 'statement' || indent.mode === 'var') {\n                        expected_at(indent.at + option.indent);\n                    } else if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                }\n            }\n        }\n\n        switch (token.id) {\n        case '(number)':\n            if (next_token.id === '.') {\n                next_token.warn('trailing_decimal_a');\n            }\n            break;\n        case '-':\n            if (next_token.id === '-' || next_token.id === '--') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        case '+':\n            if (next_token.id === '+' || next_token.id === '++') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        }\n        if (token.id === '(string)' || token.identifier) {\n            anonname = token.string;\n        }\n\n        if (id && next_token.id !== id) {\n            if (match) {\n                next_token.warn('expected_a_b_from_c_d', id,\n                    match.id, match.line, artifact());\n            } else if (!next_token.identifier || next_token.string !== id) {\n                next_token.warn('expected_a_b', id, artifact());\n            }\n        }\n        prev_token = token;\n        token = next_token;\n        next_token = lookahead.shift() || lex.token();\n        next_token.function = funct;\n        tokens.push(next_token);\n    }\n\n\n    function do_globals() {\n        var name, writeable;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            writeable = false;\n            if (next_token.id === ':') {\n                advance(':');\n                switch (next_token.id) {\n                case 'true':\n                    writeable = predefined[name] !== false;\n                    advance('true');\n                    break;\n                case 'false':\n                    advance('false');\n                    break;\n                default:\n                    next_token.stop('unexpected_a');\n                }\n            }\n            predefined[name] = writeable;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    function do_jslint() {\n        var name, value;\n        while (next_token.id === '(string)' || next_token.identifier) {\n            name = next_token.string;\n            if (!allowed_option[name]) {\n                next_token.stop('unexpected_a');\n            }\n            advance();\n            if (next_token.id !== ':') {\n                next_token.stop('expected_a_b', ':', artifact());\n            }\n            advance(':');\n            if (typeof allowed_option[name] === 'number') {\n                value = next_token.number;\n                if (value > allowed_option[name] || value <= 0 ||\n                        Math.floor(value) !== value) {\n                    next_token.stop('expected_small_a');\n                }\n                option[name] = value;\n            } else {\n                if (next_token.id === 'true') {\n                    option[name] = true;\n                } else if (next_token.id === 'false') {\n                    option[name] = false;\n                } else {\n                    next_token.stop('unexpected_a');\n                }\n            }\n            advance();\n            if (next_token.id === ',') {\n                advance(',');\n            }\n        }\n        assume();\n    }\n\n\n    function do_properties() {\n        var name;\n        option.properties = true;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            if (next_token.id === ':') {\n                for (;;) {\n                    advance();\n                    if (next_token.id !== '(string)' && !next_token.identifier) {\n                        break;\n                    }\n                }\n            }\n            property[name] = 0;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    directive = function directive() {\n        var command = this.id,\n            old_comments_off = comments_off,\n            old_indent = indent;\n        comments_off = true;\n        indent = null;\n        if (next_token.line === token.line && next_token.from === token.thru) {\n            next_token.warn('missing_space_a_b', artifact(token), artifact());\n        }\n        if (lookahead.length > 0) {\n            this.warn('unexpected_a');\n        }\n        switch (command) {\n        case '/*properties':\n        case '/*property':\n        case '/*members':\n        case '/*member':\n            do_properties();\n            break;\n        case '/*jslint':\n            do_jslint();\n            break;\n        case '/*globals':\n        case '/*global':\n            do_globals();\n            break;\n        default:\n            this.stop('unexpected_a');\n        }\n        comments_off = old_comments_off;\n        advance('*/');\n        indent = old_indent;\n    };\n\n\n// Indentation intention\n\n    function edge(mode) {\n        next_token.edge = indent ? indent.open && (mode || 'edge') : '';\n    }\n\n\n    function step_in(mode) {\n        var open;\n        if (typeof mode === 'number') {\n            indent = {\n                at: +mode,\n                open: true,\n                was: indent\n            };\n        } else if (!indent) {\n            indent = {\n                at: 1,\n                mode: 'statement',\n                open: true\n            };\n        } else if (mode === 'statement') {\n            indent = {\n                at: indent.at,\n                open: true,\n                was: indent\n            };\n        } else {\n            open = mode === 'var' || next_token.line !== token.line;\n            indent = {\n                at: (open || mode === 'control'\n                    ? indent.at + option.indent\n                    : indent.at) + (indent.wrap ? option.indent : 0),\n                mode: mode,\n                open: open,\n                was: indent\n            };\n            if (mode === 'var' && open) {\n                var_mode = indent;\n            }\n        }\n    }\n\n    function step_out(id, symbol) {\n        if (id) {\n            if (indent && indent.open) {\n                indent.at -= option.indent;\n                edge();\n            }\n            advance(id, symbol);\n        }\n        if (indent) {\n            indent = indent.was;\n        }\n    }\n\n// Functions for conformance of whitespace.\n\n    function one_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && !option.white &&\n                (token.line !== right.line ||\n                token.thru + 1 !== right.from)) {\n            right.warn('expected_space_a_b', artifact(token), artifact(right));\n        }\n    }\n\n    function one_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru + 1 !== right.from))) {\n            right.warn('expected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if ((!option.white) &&\n                left.thru !== right.from && left.line === right.line) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru !== right.from))) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function spaces(left, right) {\n        if (!option.white) {\n            left = left || token;\n            right = right || next_token;\n            if (left.thru === right.from && left.line === right.line) {\n                right.warn('missing_space_a_b', artifact(left), artifact(right));\n            }\n        }\n    }\n\n    function comma() {\n        if (next_token.id !== ',') {\n            warn('expected_a_b', token.line, token.thru, ',', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(',');\n            spaces();\n        }\n    }\n\n\n    function semicolon() {\n        if (next_token.id !== ';') {\n            warn('expected_a_b', token.line, token.thru, ';', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(';');\n            if (semicolon_coda[next_token.id] !== true) {\n                spaces();\n            }\n        }\n    }\n\n    function use_strict() {\n        if (next_token.string === 'use strict') {\n            if (strict_mode) {\n                next_token.warn('unnecessary_use');\n            }\n            edge();\n            advance();\n            semicolon();\n            strict_mode = true;\n            return true;\n        }\n        return false;\n    }\n\n\n    function are_similar(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (Array.isArray(a)) {\n            if (Array.isArray(b) && a.length === b.length) {\n                var i;\n                for (i = 0; i < a.length; i += 1) {\n                    if (!are_similar(a[i], b[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n        if (Array.isArray(b)) {\n            return false;\n        }\n        if (a.id === '(number)' && b.id === '(number)') {\n            return a.number === b.number;\n        }\n        if (a.arity === b.arity && a.string === b.string) {\n            switch (a.arity) {\n            case undefined:\n                return a.string === b.string;\n            case 'prefix':\n            case 'suffix':\n                return a.id === b.id && are_similar(a.first, b.first) &&\n                    a.id !== '{' && a.id !== '[';\n            case 'infix':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second);\n            case 'ternary':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second) &&\n                    are_similar(a.third, b.third);\n            case 'function':\n            case 'regexp':\n                return false;\n            default:\n                return true;\n            }\n        }\n        if (a.id === '.' && b.id === '[' && b.arity === 'infix') {\n            return a.second.string === b.second.string && b.second.id === '(string)';\n        }\n        if (a.id === '[' && a.arity === 'infix' && b.id === '.') {\n            return a.second.string === b.second.string && a.second.id === '(string)';\n        }\n        return false;\n    }\n\n\n// This is the heart of JSLINT, the Pratt parser. In addition to parsing, it\n// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is\n// like .nud except that it is only used on the first token of a statement.\n// Having .fud makes it much easier to define statement-oriented languages like\n// JavaScript. I retained Pratt's nomenclature.\n\n// .nud     Null denotation\n// .fud     First null denotation\n// .led     Left denotation\n//  lbp     Left binding power\n//  rbp     Right binding power\n\n// They are elements of the parsing method called Top Down Operator Precedence.\n\n    function expression(rbp, initial) {\n\n// rbp is the right binding power.\n// initial indicates that this is the first expression of a statement.\n\n        var left;\n        if (next_token.id === '(end)') {\n            token.stop('unexpected_a', next_token.id);\n        }\n        advance();\n        if (initial) {\n            anonname = 'anonymous';\n        }\n        if (initial === true && token.fud) {\n            left = token.fud();\n        } else {\n            if (token.nud) {\n                left = token.nud();\n            } else {\n                if (next_token.id === '(number)' && token.id === '.') {\n                    token.warn('leading_decimal_a', artifact());\n                    advance();\n                    return token;\n                }\n                token.stop('expected_identifier_a', artifact(token));\n            }\n            while (rbp < next_token.lbp) {\n                advance();\n                left = token.led(left);\n            }\n        }\n        if (left && left.assign && !initial) {\n            if (!option.ass) {\n                left.warn('assignment_expression');\n            }\n            if (left.id !== '=' && left.first.master) {\n                left.first.master.used = true;\n            }\n        }\n        return left;\n    }\n\n    protosymbol = {\n        nud: function () {\n            this.stop('unexpected_a');\n        },\n        led: function () {\n            this.stop('expected_operator_a');\n        },\n        warn: function (code, a, b, c, d) {\n            if (!this.warning) {\n                this.warning = warn(code, this.line || 0, this.from || 0,\n                    a || artifact(this), b, c, d);\n            }\n        },\n        stop: function (code, a, b, c, d) {\n            this.warning = undefined;\n            this.warn(code, a, b, c, d);\n            return quit('stopping', this.line, this.character);\n        },\n        lbp: 0\n    };\n\n// Functional constructors for making the symbols that will be inherited by\n// tokens.\n\n    function symbol(s, bp) {\n        var x = syntax[s];\n        if (!x) {\n            x = Object.create(protosymbol);\n            x.id = x.string = s;\n            x.lbp = bp || 0;\n            syntax[s] = x;\n        }\n        return x;\n    }\n\n    function postscript(x) {\n        x.postscript = true;\n        return x;\n    }\n\n    function ultimate(s) {\n        var x = symbol(s, 0);\n        x.from = 1;\n        x.thru = 1;\n        x.line = 0;\n        x.edge = 'edge';\n        x.string = s;\n        return postscript(x);\n    }\n\n    function reserve_name(x) {\n        var c = x.id.charAt(0);\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            x.identifier = x.reserved = true;\n        }\n        return x;\n    }\n\n    function stmt(s, f) {\n        var x = symbol(s);\n        x.fud = f;\n        return reserve_name(x);\n    }\n\n    function disrupt_stmt(s, f) {\n        var x = stmt(s, f);\n        x.disrupt = true;\n    }\n\n    function labeled_stmt(s, f) {\n        var x = stmt(s, function labeled() {\n            var the_statement;\n            if (funct.breakage) {\n                funct.breakage.push(this);\n            } else {\n                funct.breakage = [this];\n            }\n            the_statement = f.apply(this);\n            if (funct.breakage.length > 1) {\n                funct.breakage.pop();\n            } else {\n                delete funct.breakage;\n            }\n            return the_statement;\n        });\n        x.labeled = true;\n    }\n\n    function prefix(s, f) {\n        var x = symbol(s, 150);\n        reserve_name(x);\n        x.nud = function () {\n            var that = this;\n            that.arity = 'prefix';\n            if (typeof f === 'function') {\n                that = f(that);\n                if (that.arity !== 'prefix') {\n                    return that;\n                }\n            } else {\n                if (s === 'typeof') {\n                    one_space();\n                } else {\n                    no_space_only();\n                }\n                that.first = expression(150);\n            }\n            switch (that.id) {\n            case '++':\n            case '--':\n                if (!option.plusplus) {\n                    that.warn('unexpected_a');\n                } else if ((!that.first.identifier || that.first.reserved) &&\n                        that.first.id !== '.' && that.first.id !== '[') {\n                    that.warn('bad_operand');\n                }\n                break;\n            default:\n                if (that.first.arity === 'prefix' ||\n                        that.first.arity === 'function') {\n                    that.warn('unexpected_a');\n                }\n            }\n            return that;\n        };\n        return x;\n    }\n\n\n    function type(s, t, nud) {\n        var x = symbol(s);\n        x.arity = t;\n        if (nud) {\n            x.nud = nud;\n        }\n        return x;\n    }\n\n\n    function reserve(s, f) {\n        var x = symbol(s);\n        x.identifier = x.reserved = true;\n        if (typeof f === 'function') {\n            x.nud = f;\n        }\n        return x;\n    }\n\n\n    function constant(name) {\n        var x = reserve(name);\n        x.string = name;\n        x.nud = return_this;\n        return x;\n    }\n\n\n    function reservevar(s, v) {\n        return reserve(s, function () {\n            if (typeof v === 'function') {\n                v(this);\n            }\n            return this;\n        });\n    }\n\n\n    function infix(s, p, f, w) {\n        var x = symbol(s, p);\n        reserve_name(x);\n        x.led = function (left) {\n            this.arity = 'infix';\n            if (!w) {\n                spaces(prev_token, token);\n                spaces();\n            }\n            if (!option.bitwise && this.bitwise) {\n                this.warn('unexpected_a');\n            }\n            if (typeof f === 'function') {\n                return f(left, this);\n            }\n            this.first = left;\n            this.second = expression(p);\n            return this;\n        };\n        return x;\n    }\n\n    function expected_relation(node, message) {\n        if (node.assign) {\n            node.warn(message || 'conditional_assignment');\n        }\n        return node;\n    }\n\n    function expected_condition(node, message) {\n        switch (node.id) {\n        case '[':\n        case '-':\n            if (node.arity !== 'infix') {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        case 'false':\n        case 'function':\n        case 'Infinity':\n        case 'NaN':\n        case 'null':\n        case 'true':\n        case 'undefined':\n        case 'void':\n        case '(number)':\n        case '(regexp)':\n        case '(string)':\n        case '{':\n        case '?':\n        case '~':\n            node.warn(message || 'weird_condition');\n            break;\n        case '(':\n            if (node.first.id === 'new' ||\n                    (node.first.string === 'Boolean') ||\n                    (node.first.id === '.' &&\n                        numbery[node.first.second.string] === true)) {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        }\n        return node;\n    }\n\n    function check_relation(node) {\n        switch (node.arity) {\n        case 'prefix':\n            switch (node.id) {\n            case '{':\n            case '[':\n                node.warn('unexpected_a');\n                break;\n            case '!':\n                node.warn('confusing_a');\n                break;\n            }\n            break;\n        case 'function':\n        case 'regexp':\n            node.warn('unexpected_a');\n            break;\n        default:\n            if (node.id  === 'NaN') {\n                node.warn('isNaN');\n            } else if (node.relation) {\n                node.warn('weird_relation');\n            }\n        }\n        return node;\n    }\n\n\n    function relation(s, eqeq) {\n        var x = infix(s, 100, function (left, that) {\n            check_relation(left);\n            if (eqeq && !option.eqeq) {\n                that.warn('expected_a_b', eqeq, that.id);\n            }\n            var right = expression(100);\n            if (are_similar(left, right) ||\n                    ((left.id === '(string)' || left.id === '(number)') &&\n                    (right.id === '(string)' || right.id === '(number)'))) {\n                that.warn('weird_relation');\n            } else if (left.id === 'typeof') {\n                if (right.id !== '(string)') {\n                    right.warn(\"expected_string_a\", artifact(right));\n                } else if (right.string === 'undefined' ||\n                        right.string === 'null') {\n                    left.warn(\"unexpected_typeof_a\", right.string);\n                }\n            } else if (right.id === 'typeof') {\n                if (left.id !== '(string)') {\n                    left.warn(\"expected_string_a\", artifact(left));\n                } else if (left.string === 'undefined' ||\n                        left.string === 'null') {\n                    right.warn(\"unexpected_typeof_a\", left.string);\n                }\n            }\n            that.first = left;\n            that.second = check_relation(right);\n            return that;\n        });\n        x.relation = true;\n        return x;\n    }\n\n    function lvalue(that, s) {\n        var master;\n        if (that.identifier) {\n            master = scope[that.string];\n            if (master) {\n                if (scope[that.string].writeable !== true) {\n                    that.warn('read_only');\n                }\n                master.used -= 1;\n                if (s === '=') {\n                    master.init = true;\n                }\n            } else if (that.reserved) {\n                that.warn('expected_identifier_a_reserved');\n            }\n        } else if (that.id === '.' || that.id === '[') {\n            if (!that.first || that.first.string === 'arguments') {\n                that.warn('bad_assignment');\n            }\n        } else {\n            that.warn('bad_assignment');\n        }\n    }\n\n\n    function assignop(s, op) {\n        var x = infix(s, 20, function (left, that) {\n            var next;\n            that.first = left;\n            lvalue(left, s);\n            that.second = expression(20);\n            if (that.id === '=' && are_similar(that.first, that.second)) {\n                that.warn('weird_assignment');\n            }\n            next = that;\n            while (next_token.id === '=') {\n                lvalue(next.second, '=');\n                next_token.first = next.second;\n                next.second = next_token;\n                next = next_token;\n                advance('=');\n                next.second = expression(20);\n            }\n            return that;\n        });\n        x.assign = true;\n        if (op) {\n            if (syntax[op].bitwise) {\n                x.bitwise = true;\n            }\n        }\n        return x;\n    }\n\n\n    function bitwise(s, p) {\n        var x = infix(s, p, 'number');\n        x.bitwise = true;\n        return x;\n    }\n\n\n    function suffix(s) {\n        var x = symbol(s, 150);\n        x.led = function (left) {\n            no_space_only(prev_token, token);\n            if (!option.plusplus) {\n                this.warn('unexpected_a');\n            } else if ((!left.identifier || left.reserved) &&\n                    left.id !== '.' && left.id !== '[') {\n                this.warn('bad_operand');\n            }\n            this.first = left;\n            this.arity = 'suffix';\n            return this;\n        };\n        return x;\n    }\n\n\n    function optional_identifier(variable) {\n        if (next_token.identifier) {\n            advance();\n            if (token.reserved && variable) {\n                token.warn('expected_identifier_a_reserved');\n            }\n            return token.string;\n        }\n    }\n\n\n    function identifier(variable) {\n        var i = optional_identifier(variable);\n        if (!i) {\n            next_token.stop(token.id === 'function' && next_token.id === '('\n                ? 'name_function'\n                : 'expected_identifier_a');\n        }\n        return i;\n    }\n\n\n    function statement() {\n\n        var label, preamble, the_statement;\n\n// We don't like the empty statement.\n\n        if (next_token.id === ';') {\n            next_token.warn('unexpected_a');\n            semicolon();\n            return;\n        }\n\n// Is this a labeled statement?\n\n        if (next_token.identifier && !next_token.reserved && peek().id === ':') {\n            edge('label');\n            label = next_token;\n            advance();\n            advance(':');\n            define('label', label);\n            if (next_token.labeled !== true || funct === global_funct) {\n                label.stop('unexpected_label_a');\n            } else if (jx.test(label.string + ':')) {\n                label.warn('url');\n            }\n            next_token.label = label;\n            label.init = true;\n            label.statement = next_token;\n        }\n\n// Parse the statement.\n\n        preamble = next_token;\n        if (token.id !== 'else') {\n            edge();\n        }\n        step_in('statement');\n        the_statement = expression(0, true);\n        if (the_statement) {\n\n// Look for the final semicolon.\n\n            if (the_statement.arity === 'statement') {\n                if (the_statement.id === 'switch' ||\n                        (the_statement.block && the_statement.id !== 'do')) {\n                    spaces();\n                } else {\n                    semicolon();\n                }\n            } else {\n\n// If this is an expression statement, determine if it is acceptable.\n// We do not like\n//      new Blah;\n// statements. If it is to be used at all, new should only be used to make\n// objects, not side effects. The expression statements we do like do\n// assignment or invocation or delete.\n\n                if (the_statement.id === '(') {\n                    if (the_statement.first.id === 'new') {\n                        next_token.warn('bad_new');\n                    }\n                } else if (the_statement.id === '++' ||\n                        the_statement.id === '--') {\n                    lvalue(the_statement.first);\n                } else if (!the_statement.assign &&\n                        the_statement.id !== 'delete') {\n                    if (!option.closure || !preamble.comments) {\n                        preamble.warn('assignment_function_expression');\n                    }\n                }\n                semicolon();\n            }\n        }\n        step_out();\n        if (label) {\n            label.dead = true;\n        }\n        return the_statement;\n    }\n\n\n    function statements() {\n        var array = [], disruptor, the_statement;\n\n// A disrupt statement may not be followed by any other statement.\n// If the last statement is disrupt, then the sequence is disrupt.\n\n        while (next_token.postscript !== true) {\n            if (next_token.id === ';') {\n                next_token.warn('unexpected_a');\n                semicolon();\n            } else {\n                if (next_token.string === 'use strict') {\n                    if ((!node_js) || funct !== global_funct || array.length > 0) {\n                        next_token.warn('function_strict');\n                    }\n                    use_strict();\n                }\n                if (disruptor) {\n                    next_token.warn('unreachable_a_b', next_token.string,\n                        disruptor.string);\n                    disruptor = null;\n                }\n                the_statement = statement();\n                if (the_statement) {\n                    array.push(the_statement);\n                    if (the_statement.disrupt) {\n                        disruptor = the_statement;\n                        array.disrupt = true;\n                    }\n                }\n            }\n        }\n        return array;\n    }\n\n\n    function block(kind) {\n\n// A block is a sequence of statements wrapped in braces.\n\n        var array,\n            curly = next_token,\n            old_block_var = block_var,\n            old_in_block = in_block,\n            old_strict_mode = strict_mode;\n\n        in_block = kind !== 'function' && kind !== 'try' && kind !== 'catch';\n        block_var = [];\n        if (curly.id === '{') {\n            spaces();\n            advance('{');\n            step_in();\n            if (kind === 'function' && !use_strict() && !old_strict_mode &&\n                    !option.sloppy && funct.level === 1) {\n                next_token.warn('missing_use_strict');\n            }\n            array = statements();\n            strict_mode = old_strict_mode;\n            step_out('}', curly);\n        } else if (in_block) {\n            curly.stop('expected_a_b', '{', artifact());\n        } else {\n            curly.warn('expected_a_b', '{', artifact());\n            array = [statement()];\n            array.disrupt = array[0].disrupt;\n        }\n        if (kind !== 'catch' && array.length === 0 && !option.debug) {\n            curly.warn('empty_block');\n        }\n        block_var.forEach(function (name) {\n            scope[name].dead = true;\n        });\n        block_var = old_block_var;\n        in_block = old_in_block;\n        return array;\n    }\n\n\n    function tally_property(name) {\n        if (option.properties && typeof property[name] !== 'number') {\n            token.warn('unexpected_property_a', name);\n        }\n        if (property[name]) {\n            property[name] += 1;\n        } else {\n            property[name] = 1;\n        }\n    }\n\n\n// ECMAScript parser\n\n    (function () {\n        var x = symbol('(identifier)');\n        x.nud = function () {\n            var name = this.string,\n                master = scope[name],\n                writeable;\n\n// If the master is not in scope, then we may have an undeclared variable.\n// Check the predefined list. If it was predefined, create the global\n// variable.\n\n            if (!master) {\n                writeable = predefined[name];\n                if (typeof writeable === 'boolean') {\n                    global_scope[name] = master = {\n                        dead: false,\n                        function: global_funct,\n                        kind: 'var',\n                        string: name,\n                        writeable: writeable\n                    };\n\n// But if the variable is not in scope, and is not predefined, and if we are not\n// in the global scope, then we have an undefined variable error.\n\n                } else {\n                    token.warn('used_before_a');\n                }\n            } else {\n                this.master = master;\n            }\n\n// Annotate uses that cross scope boundaries.\n\n            if (master) {\n                if (master.kind === 'label') {\n                    this.warn('a_label');\n                } else {\n                    if (master.dead === true || master.dead === funct) {\n                        this.warn('a_scope');\n                    }\n                    master.used += 1;\n                    if (master.function !== funct) {\n                        if (master.function === global_funct) {\n                            funct.global.push(name);\n                        } else {\n                            master.function.closure.push(name);\n                            funct.outer.push(name);\n                        }\n                    }\n                }\n            }\n            return this;\n        };\n        x.identifier = true;\n    }());\n\n\n// Build the syntax table by declaring the syntactic elements.\n\n    type('(array)', 'array');\n    type('(function)', 'function');\n    type('(number)', 'number', return_this);\n    type('(object)', 'object');\n    type('(string)', 'string', return_this);\n    type('(boolean)', 'boolean', return_this);\n    type('(regexp)', 'regexp', return_this);\n\n    ultimate('(begin)');\n    ultimate('(end)');\n    ultimate('(error)');\n    postscript(symbol('}'));\n    symbol(')');\n    symbol(']');\n    postscript(symbol('\"'));\n    postscript(symbol('\\''));\n    symbol(';');\n    symbol(':');\n    symbol(',');\n    symbol('#');\n    symbol('@');\n    symbol('*/');\n    postscript(reserve('case'));\n    reserve('catch');\n    postscript(reserve('default'));\n    reserve('else');\n    reserve('finally');\n\n    reservevar('arguments', function (x) {\n        if (strict_mode && funct === global_funct) {\n            x.warn('strict');\n        }\n        funct.arguments = true;\n    });\n    reservevar('eval');\n    constant('false', 'boolean');\n    constant('Infinity', 'number');\n    constant('NaN', 'number');\n    constant('null', '');\n    reservevar('this', function (x) {\n        if (strict_mode && funct.statement && funct.name.charAt(0) > 'Z') {\n            x.warn('strict');\n        }\n    });\n    constant('true', 'boolean');\n    constant('undefined', '');\n\n    infix('?', 30, function (left, that) {\n        step_in('?');\n        that.first = expected_condition(expected_relation(left));\n        that.second = expression(0);\n        spaces();\n        step_out();\n        var colon = next_token;\n        advance(':');\n        step_in(':');\n        spaces();\n        that.third = expression(10);\n        that.arity = 'ternary';\n        if (are_similar(that.second, that.third)) {\n            colon.warn('weird_ternary');\n        } else if (are_similar(that.first, that.second)) {\n            that.warn('use_or');\n        }\n        step_out();\n        return that;\n    });\n\n    infix('||', 40, function (left, that) {\n        function paren_check(that) {\n            if (that.id === '&&' && !that.paren) {\n                that.warn('and');\n            }\n            return that;\n        }\n\n        that.first = paren_check(expected_condition(expected_relation(left)));\n        that.second = paren_check(expected_relation(expression(40)));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    infix('&&', 50, function (left, that) {\n        that.first = expected_condition(expected_relation(left));\n        that.second = expected_relation(expression(50));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    prefix('void', function (that) {\n        that.first = expression(0);\n        that.warn('expected_a_b', 'undefined', 'void');\n        return that;\n    });\n\n    bitwise('|', 70);\n    bitwise('^', 80);\n    bitwise('&', 90);\n\n    relation('==', '===');\n    relation('===');\n    relation('!=', '!==');\n    relation('!==');\n    relation('<');\n    relation('>');\n    relation('<=');\n    relation('>=');\n\n    bitwise('<<', 120);\n    bitwise('>>', 120);\n    bitwise('>>>', 120);\n\n    infix('in', 120, function (left, that) {\n        that.warn('infix_in');\n        that.left = left;\n        that.right = expression(130);\n        return that;\n    });\n    infix('instanceof', 120);\n    infix('+', 130, function (left, that) {\n        if (left.id === '(number)') {\n            if (left.number === 0) {\n                left.warn('unexpected_a', '0');\n            }\n        } else if (left.id === '(string)') {\n            if (left.string === '') {\n                left.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        var right = expression(130);\n        if (right.id === '(number)') {\n            if (right.number === 0) {\n                right.warn('unexpected_a', '0');\n            }\n        } else if (right.id === '(string)') {\n            if (right.string === '') {\n                right.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        if (left.id === right.id) {\n            if (left.id === '(string)' || left.id === '(number)') {\n                if (left.id === '(string)') {\n                    left.string += right.string;\n                    if (jx.test(left.string)) {\n                        left.warn('url');\n                    }\n                } else {\n                    left.number += right.number;\n                }\n                left.thru = right.thru;\n                return left;\n            }\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('+');\n    prefix('+++', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('+++', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('-', 130, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(130);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number -= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('-');\n    prefix('---', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('---', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('*', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number *= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('/', 140, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number /= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('%', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number %= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n\n    suffix('++');\n    prefix('++');\n\n    suffix('--');\n    prefix('--');\n    prefix('delete', function (that) {\n        one_space();\n        var p = expression(0);\n        if (!p || (p.id !== '.' && p.id !== '[')) {\n            next_token.warn('deleted');\n        }\n        that.first = p;\n        return that;\n    });\n\n\n    prefix('~', function (that) {\n        no_space_only();\n        if (!option.bitwise) {\n            that.warn('unexpected_a');\n        }\n        that.first = expression(150);\n        return that;\n    });\n    function banger(that) {\n        no_space_only();\n        that.first = expected_condition(expression(150));\n        if (bang[that.first.id] === that || that.first.assign) {\n            that.warn('confusing_a');\n        }\n        return that;\n    }\n    prefix('!', banger);\n    prefix('!!', banger);\n    prefix('typeof');\n    prefix('new', function (that) {\n        one_space();\n        var c = expression(160), n, p, v;\n        that.first = c;\n        if (c.id !== 'function') {\n            if (c.identifier) {\n                switch (c.string) {\n                case 'Object':\n                    token.warn('use_object');\n                    break;\n                case 'Array':\n                    if (next_token.id === '(') {\n                        p = next_token;\n                        p.first = this;\n                        advance('(');\n                        if (next_token.id !== ')') {\n                            n = expression(0);\n                            p.second = [n];\n                            if (n.id === '(string)' || next_token.id === ',') {\n                                p.warn('use_array');\n                            }\n                            while (next_token.id === ',') {\n                                advance(',');\n                                p.second.push(expression(0));\n                            }\n                        } else {\n                            token.warn('use_array');\n                        }\n                        advance(')', p);\n                        return p;\n                    }\n                    token.warn('use_array');\n                    break;\n                case 'Number':\n                case 'String':\n                case 'Boolean':\n                case 'Math':\n                case 'JSON':\n                    c.warn('not_a_constructor');\n                    break;\n                case 'Function':\n                    if (!option.evil) {\n                        next_token.warn('function_eval');\n                    }\n                    break;\n                case 'Date':\n                case 'RegExp':\n                case 'this':\n                    break;\n                default:\n                    if (c.id !== 'function') {\n                        v = c.string.charAt(0);\n                        if (!option.newcap && (v < 'A' || v > 'Z')) {\n                            token.warn('constructor_name_a');\n                        }\n                    }\n                }\n            } else {\n                if (c.id !== '.' && c.id !== '[' && c.id !== '(') {\n                    token.warn('bad_constructor');\n                }\n            }\n        } else {\n            that.warn('weird_new');\n        }\n        if (next_token.id !== '(') {\n            next_token.warn('missing_a', '()');\n        }\n        return that;\n    });\n\n    infix('(', 160, function (left, that) {\n        var e, p;\n        if (indent && indent.mode === 'expression') {\n            no_space(prev_token, token);\n        } else {\n            no_space_only(prev_token, token);\n        }\n        if (!left.immed && left.id === 'function') {\n            next_token.warn('wrap_immediate');\n        }\n        p = [];\n        if (left.identifier) {\n            if (left.string.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {\n                if (left.string !== 'Number' && left.string !== 'String' &&\n                        left.string !== 'Boolean' && left.string !== 'Date') {\n                    if (left.string === 'Math') {\n                        left.warn('not_a_function');\n                    } else if (left.string === 'Object') {\n                        token.warn('use_object');\n                    } else if (left.string === 'Array' || !option.newcap) {\n                        left.warn('missing_a', 'new');\n                    }\n                }\n            } else if (left.string === 'JSON') {\n                left.warn('not_a_function');\n            }\n        } else if (left.id === '.') {\n            if (left.second.string === 'split' &&\n                    left.first.id === '(string)') {\n                left.second.warn('use_array');\n            }\n        }\n        step_in();\n        if (next_token.id !== ')') {\n            no_space();\n            for (;;) {\n                edge();\n                e = expression(10);\n                if (left.string === 'Boolean' && (e.id === '!' || e.id === '~')) {\n                    e.warn('weird_condition');\n                }\n                p.push(e);\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', that);\n        if (typeof left === 'object') {\n            if (left.string === 'parseInt' && p.length === 1) {\n                left.warn('radix');\n            } else if (left.string === 'String' && p.length >= 1 && p[0].id === '(string)') {\n                left.warn('unexpected_a');\n            }\n            if (!option.evil) {\n                if (left.string === 'eval' || left.string === 'Function' ||\n                        left.string === 'execScript') {\n                    left.warn('evil');\n                } else if (p[0] && p[0].id === '(string)' &&\n                        (left.string === 'setTimeout' ||\n                        left.string === 'setInterval')) {\n                    left.warn('implied_evil');\n                }\n            }\n            if (!left.identifier && left.id !== '.' && left.id !== '[' &&\n                    left.id !== '(' && left.id !== '&&' && left.id !== '||' &&\n                    left.id !== '?') {\n                left.warn('bad_invocation');\n            }\n            if (left.id === '.') {\n                if (p.length > 0 &&\n                        left.first && left.first.first &&\n                        are_similar(p[0], left.first.first)) {\n                    if (left.second.string === 'call' ||\n                            (left.second.string === 'apply' && (p.length === 1 ||\n                            (p[1].arity === 'prefix' && p[1].id === '[')))) {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n                if (left.second.string === 'toString') {\n                    if (left.first.id === '(string)' || left.first.id === '(number)') {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n            }\n        }\n        that.first = left;\n        that.second = p;\n        return that;\n    }, true);\n\n    prefix('(', function (that) {\n        step_in('expression');\n        no_space();\n        edge();\n        if (next_token.id === 'function') {\n            next_token.immed = true;\n        }\n        var value = expression(0);\n        value.paren = true;\n        no_space();\n        step_out(')', that);\n        if (value.id === 'function') {\n            switch (next_token.id) {\n            case '(':\n                next_token.warn('move_invocation');\n                break;\n            case '.':\n            case '[':\n                next_token.warn('unexpected_a');\n                break;\n            default:\n                that.warn('bad_wrap');\n            }\n        } else if (!value.arity) {\n            if (!option.closure || !that.comments) {\n                that.warn('unexpected_a');\n            }\n        }\n        return value;\n    });\n\n    infix('.', 170, function (left, that) {\n        no_space(prev_token, token);\n        no_space();\n        var name = identifier();\n        if (typeof name === 'string') {\n            tally_property(name);\n        }\n        that.first = left;\n        that.second = token;\n        if (left && left.string === 'arguments' &&\n                (name === 'callee' || name === 'caller')) {\n            left.warn('avoid_a', 'arguments.' + name);\n        } else if (!option.evil && left && left.string === 'document' &&\n                (name === 'write' || name === 'writeln')) {\n            left.warn('write_is_wrong');\n        } else if (!option.stupid && syx.test(name)) {\n            token.warn('sync_a');\n        } else if (left && left.id === '{') {\n            that.warn('unexpected_a');\n        }\n        if (!option.evil && (name === 'eval' || name === 'execScript')) {\n            next_token.warn('evil');\n        }\n        return that;\n    }, true);\n\n    infix('[', 170, function (left, that) {\n        var e, s;\n        no_space_only(prev_token, token);\n        no_space();\n        step_in();\n        edge();\n        e = expression(0);\n        switch (e.id) {\n        case '(number)':\n            if (e.id === '(number)' && left.id === 'arguments') {\n                left.warn('use_param');\n            }\n            break;\n        case '(string)':\n            if (!option.evil &&\n                    (e.string === 'eval' || e.string === 'execScript')) {\n                e.warn('evil');\n            } else if (!option.sub && ix.test(e.string)) {\n                s = syntax[e.string];\n                if (!s || !s.reserved) {\n                    e.warn('subscript');\n                }\n            }\n            tally_property(e.string);\n            break;\n        }\n        if (left && (left.id === '{' || (left.id === '[' && left.arity === 'prefix'))) {\n            that.warn('unexpected_a');\n        }\n        step_out(']', that);\n        no_space(prev_token, token);\n        that.first = left;\n        that.second = e;\n        return that;\n    }, true);\n\n    prefix('[', function (that) {\n        that.first = [];\n        step_in('array');\n        while (next_token.id !== '(end)') {\n            while (next_token.id === ',') {\n                next_token.warn('unexpected_a');\n                advance(',');\n            }\n            if (next_token.id === ']') {\n                break;\n            }\n            indent.wrap = false;\n            edge();\n            that.first.push(expression(10));\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id === ']') {\n                    token.warn('unexpected_a');\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        step_out(']', that);\n        return that;\n    }, 170);\n\n\n    function property_name() {\n        var id = optional_identifier();\n        if (!id) {\n            if (next_token.id === '(string)') {\n                id = next_token.string;\n                advance();\n            } else if (next_token.id === '(number)') {\n                id = next_token.number.toString();\n                advance();\n            }\n        }\n        return id;\n    }\n\n\n\n    assignop('=');\n    assignop('+=', '+');\n    assignop('-=', '-');\n    assignop('*=', '*');\n    assignop('/=', '/').nud = function () {\n        next_token.stop('slash_equal');\n    };\n    assignop('%=', '%');\n    assignop('&=', '&');\n    assignop('|=', '|');\n    assignop('^=', '^');\n    assignop('<<=', '<<');\n    assignop('>>=', '>>');\n    assignop('>>>=', '>>>');\n\n    function function_parameters() {\n        var id, parameters = [], paren = next_token;\n        advance('(');\n        token.function = funct;\n        step_in();\n        no_space();\n        if (next_token.id !== ')') {\n            for (;;) {\n                edge();\n                id = identifier();\n                if (token.reserved) {\n                    token.warn('expected_identifier_a_reserved');\n                }\n                define('parameter', token);\n                parameters.push(id);\n                token.init = true;\n                token.writeable = true;\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', paren);\n        return parameters;\n    }\n\n    function do_function(func, name) {\n        var old_funct = funct,\n            old_option = option,\n            old_scope = scope;\n        scope = Object.create(old_scope);\n        funct = {\n            closure: [],\n            global: [],\n            level: old_funct.level + 1,\n            line: next_token.line,\n            loopage: 0,\n            name: name || '\\'' + (anonname || '').replace(nx, sanitize) + '\\'',\n            outer: [],\n            scope: scope\n        };\n        funct.parameter = function_parameters();\n        func.function = funct;\n        option = Object.create(old_option);\n        functions.push(funct);\n        if (name) {\n            func.name = name;\n            func.string = name;\n            define('function', func);\n            func.init = true;\n            func.used += 1;\n        }\n        func.writeable = false;\n        one_space();\n        func.block = block('function');\n        Object.keys(scope).forEach(function (name) {\n            var master = scope[name];\n            if (!master.used && master.kind !== 'exception' &&\n                    (master.kind !== 'parameter' || !option.unparam)) {\n                master.warn('unused_a');\n            } else if (!master.init) {\n                master.warn('uninitialized_a');\n            }\n        });\n        funct = old_funct;\n        option = old_option;\n        scope = old_scope;\n    }\n\n    prefix('{', function (that) {\n        var get, i, j, name, set, seen = Object.create(null);\n        that.first = [];\n        step_in();\n        while (next_token.id !== '}') {\n            indent.wrap = false;\n\n// JSLint recognizes the ES5 extension for get/set in object literals,\n// but requires that they be used in pairs.\n\n            edge();\n            if (next_token.string === 'get' && peek().id !== ':') {\n                get = next_token;\n                advance('get');\n                one_space_only();\n                name = next_token;\n                i = property_name();\n                if (!i) {\n                    next_token.stop('missing_property');\n                }\n                get.string = '';\n                do_function(get);\n                if (funct.loopage) {\n                    get.warn('function_loop');\n                }\n                if (get.function.parameter.length) {\n                    get.warn('parameter_a_get_b', get.function.parameter[0], i);\n                }\n                comma();\n                set = next_token;\n                spaces();\n                edge();\n                advance('set');\n                set.string = '';\n                one_space_only();\n                j = property_name();\n                if (i !== j) {\n                    token.stop('expected_a_b', i, j || next_token.string);\n                }\n                do_function(set);\n                if (set.block.length === 0) {\n                    token.warn('missing_a', 'throw');\n                }\n                if (set.function.parameter.length === 0) {\n                    set.stop('parameter_set_a', 'value');\n                } else if (set.function.parameter[0] !== 'value') {\n                    set.stop('expected_a_b', 'value',\n                        set.function.parameter[0]);\n                }\n                name.first = [get, set];\n            } else {\n                name = next_token;\n                i = property_name();\n                if (typeof i !== 'string') {\n                    next_token.stop('missing_property');\n                }\n                advance(':');\n                spaces();\n                name.first = expression(10);\n            }\n            that.first.push(name);\n            if (seen[i] === true) {\n                next_token.warn('duplicate_a', i);\n            }\n            seen[i] = true;\n            tally_property(i);\n            if (next_token.id !== ',') {\n                break;\n            }\n            for (;;) {\n                comma();\n                if (next_token.id !== ',') {\n                    break;\n                }\n                next_token.warn('unexpected_a');\n            }\n            if (next_token.id === '}') {\n                token.warn('unexpected_a');\n            }\n        }\n        step_out('}', that);\n        return that;\n    });\n\n    stmt('{', function () {\n        next_token.warn('statement_block');\n        this.arity = 'statement';\n        this.block = statements();\n        this.disrupt = this.block.disrupt;\n        advance('}', this);\n        return this;\n    });\n\n    stmt('/*global', directive);\n    stmt('/*globals', directive);\n    stmt('/*jslint', directive);\n    stmt('/*member', directive);\n    stmt('/*members', directive);\n    stmt('/*property', directive);\n    stmt('/*properties', directive);\n\n    stmt('var', function () {\n\n// JavaScript does not have block scope. It only has function scope. So,\n// declaring a variable in a block can have unexpected consequences.\n\n// var.first will contain an array, the array containing name tokens\n// and assignment tokens.\n\n        var assign, id, name;\n\n        if (funct.loopage) {\n            next_token.warn('var_loop');\n        } else if (funct.varstatement && !option.vars) {\n            next_token.warn('combine_var');\n        }\n        if (funct !== global_funct) {\n            funct.varstatement = true;\n        }\n        this.arity = 'statement';\n        this.first = [];\n        step_in('var');\n        for (;;) {\n            name = next_token;\n            id = identifier(true);\n            define('var', name);\n            name.dead = funct;\n            if (next_token.id === '=') {\n                if (funct === global_funct && !name.writeable) {\n                    name.warn('read_only');\n                }\n                assign = next_token;\n                assign.first = name;\n                spaces();\n                advance('=');\n                spaces();\n                if (next_token.id === 'undefined') {\n                    token.warn('unnecessary_initialize', id);\n                }\n                if (peek(0).id === '=' && next_token.identifier) {\n                    next_token.stop('var_a_not');\n                }\n                assign.second = expression(0);\n                assign.arity = 'infix';\n                name.init = true;\n                this.first.push(assign);\n            } else {\n                this.first.push(name);\n            }\n            name.dead = false;\n            name.writeable = true;\n            if (next_token.id !== ',') {\n                break;\n            }\n            comma();\n            indent.wrap = false;\n            if (var_mode && next_token.line === token.line &&\n                    this.first.length === 1) {\n                var_mode = null;\n                indent.open = false;\n                indent.at -= option.indent;\n            }\n            spaces();\n            edge();\n        }\n        var_mode = null;\n        step_out();\n        return this;\n    });\n\n    stmt('function', function () {\n        one_space();\n        if (in_block) {\n            token.warn('function_block');\n        }\n        var name = next_token,\n            id = identifier(true);\n        define('var', name);\n        if (!name.writeable) {\n            name.warn('read_only');\n        }\n        name.init = true;\n        name.statement = true;\n        no_space();\n        this.arity = 'statement';\n        do_function(this, id);\n        if (next_token.id === '(' && next_token.line === token.line) {\n            next_token.stop('function_statement');\n        }\n        return this;\n    });\n\n    prefix('function', function (that) {\n        var id = optional_identifier(true), name;\n        if (id) {\n            name = token;\n            no_space();\n        } else {\n            id = '';\n            one_space();\n        }\n        do_function(that, id);\n        if (name) {\n            name.function = that.function;\n        }\n        if (funct.loopage) {\n            that.warn('function_loop');\n        }\n        switch (next_token.id) {\n        case ';':\n        case '(':\n        case ')':\n        case ',':\n        case ']':\n        case '}':\n        case ':':\n        case '(end)':\n            break;\n        case '.':\n            if (peek().string !== 'bind' || peek(1).id !== '(') {\n                next_token.warn('unexpected_a');\n            }\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n        that.arity = 'function';\n        return that;\n    });\n\n    stmt('if', function () {\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('if');\n        if (next_token.id === 'else') {\n            if (this.block.disrupt) {\n                next_token.warn(this.elif ? 'use_nested_if' : 'unnecessary_else');\n            }\n            one_space();\n            advance('else');\n            one_space();\n            if (next_token.id === 'if') {\n                next_token.elif = true;\n                this.else = statement(true);\n            } else {\n                this.else = block('else');\n            }\n            if (this.else.disrupt && this.block.disrupt) {\n                this.disrupt = true;\n            }\n        }\n        return this;\n    });\n\n    stmt('try', function () {\n\n// try.first    The catch variable\n// try.second   The catch clause\n// try.third    The finally clause\n// try.block    The try block\n\n        var exception_variable, paren;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('try');\n        if (next_token.id === 'catch') {\n            one_space();\n            advance('catch');\n            one_space();\n            paren = next_token;\n            advance('(');\n            step_in('control');\n            no_space();\n            edge();\n            exception_variable = next_token;\n            this.first = identifier();\n            define('exception', exception_variable);\n            exception_variable.init = true;\n            no_space();\n            step_out(')', paren);\n            one_space();\n            this.second = block('catch');\n            if (this.second.length) {\n                if (this.first === 'ignore') {\n                    exception_variable.warn('unexpected_a');\n                }\n            } else {\n                if (this.first !== 'ignore') {\n                    exception_variable.warn('expected_a_b', 'ignore',\n                        exception_variable.string);\n                }\n            }\n            exception_variable.dead = true;\n        }\n        if (next_token.id === 'finally') {\n            one_space();\n            advance('finally');\n            one_space();\n            this.third = block('finally');\n        } else if (!this.second) {\n            next_token.stop('expected_a_b', 'catch', artifact());\n        }\n        return this;\n    });\n\n    labeled_stmt('while', function () {\n        one_space();\n        var paren = next_token;\n        funct.loopage += 1;\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_relation(expression(0));\n        if (this.first.id !== 'true') {\n            expected_condition(this.first, 'unexpected_a');\n        }\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('while');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        funct.loopage -= 1;\n        return this;\n    });\n\n    reserve('with');\n\n    labeled_stmt('switch', function () {\n\n// switch.first         the switch expression\n// switch.second        the array of cases. A case is 'case' or 'default' token:\n//    case.first        the array of case expressions\n//    case.second       the array of statements\n// If all of the arrays of statements are disrupt, then the switch is disrupt.\n\n        var cases = [],\n            old_in_block = in_block,\n            particular,\n            that = token,\n            the_case = next_token;\n\n        function find_duplicate_case(value) {\n            if (are_similar(particular, value)) {\n                value.warn('duplicate_a');\n            }\n        }\n\n        one_space();\n        advance('(');\n        no_space();\n        step_in();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', the_case);\n        one_space();\n        advance('{');\n        step_in();\n        in_block = true;\n        this.second = [];\n        if (that.from !== next_token.from && !option.white) {\n            next_token.warn('expected_a_at_b_c', next_token.string, that.from, next_token.from);\n        }\n        while (next_token.id === 'case') {\n            the_case = next_token;\n            the_case.first = [];\n            the_case.arity = 'case';\n            for (;;) {\n                spaces();\n                edge('case');\n                advance('case');\n                one_space();\n                particular = expression(0);\n                cases.forEach(find_duplicate_case);\n                cases.push(particular);\n                the_case.first.push(particular);\n                if (particular.id === 'NaN') {\n                    particular.warn('unexpected_a');\n                }\n                no_space_only();\n                advance(':');\n                if (next_token.id !== 'case') {\n                    break;\n                }\n            }\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                if (!the_case.second[the_case.second.length - 1].disrupt) {\n                    next_token.warn('missing_a_after_b', 'break', 'case');\n                }\n            } else {\n                next_token.warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.second.length === 0) {\n            next_token.warn('missing_a', 'case');\n        }\n        if (next_token.id === 'default') {\n            spaces();\n            the_case = next_token;\n            the_case.arity = 'case';\n            edge('case');\n            advance('default');\n            no_space_only();\n            advance(':');\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                this.disrupt = the_case.second[the_case.second.length - 1].disrupt;\n            } else {\n                the_case.warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.break) {\n            this.disrupt = false;\n        }\n        spaces();\n        step_out('}', this);\n        in_block = old_in_block;\n        return this;\n    });\n\n    stmt('debugger', function () {\n        if (!option.debug) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        return this;\n    });\n\n    labeled_stmt('do', function () {\n        funct.loopage += 1;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('do');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        one_space();\n        advance('while');\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in();\n        no_space();\n        edge();\n        this.first = expected_condition(expected_relation(expression(0)), 'unexpected_a');\n        no_space();\n        step_out(')', paren);\n        funct.loopage -= 1;\n        return this;\n    });\n\n    labeled_stmt('for', function () {\n\n        var blok, filter, master, ok = false, paren = next_token, value;\n        this.arity = 'statement';\n        funct.loopage += 1;\n        advance('(');\n        if (next_token.id === ';') {\n            no_space();\n            advance(';');\n            no_space();\n            advance(';');\n            no_space();\n            advance(')');\n            blok = block('for');\n        } else {\n            step_in('control');\n            spaces(this, paren);\n            no_space();\n            if (next_token.id === 'var') {\n                next_token.stop('move_var');\n            }\n            edge();\n            if (peek(0).id === 'in') {\n                this.forin = true;\n                value = expression(1000);\n                master = value.master;\n                if (!master) {\n                    value.stop('bad_in_a');\n                }\n                if (master.kind !== 'var' || master.function !== funct ||\n                        !master.writeable || master.dead) {\n                    value.warn('bad_in_a');\n                }\n                master.init = true;\n                master.used -= 1;\n                this.first = value;\n                advance('in');\n                this.second = expression(20);\n                step_out(')', paren);\n                blok = block('for');\n                if (!option.forin) {\n                    if (blok.length === 1 && typeof blok[0] === 'object') {\n                        if (blok[0].id === 'if' && !blok[0].else) {\n                            filter = blok[0].first;\n                            while (filter.id === '&&') {\n                                filter = filter.first;\n                            }\n                            switch (filter.id) {\n                            case '===':\n                            case '!==':\n                                ok = filter.first.id === '['\n                                    ? are_similar(filter.first.first, this.second) &&\n                                        are_similar(filter.first.second, this.first)\n                                    : filter.first.id === 'typeof' &&\n                                        filter.first.first.id === '[' &&\n                                        are_similar(filter.first.first.first, this.second) &&\n                                        are_similar(filter.first.first.second, this.first);\n                                break;\n                            case '(':\n                                ok = filter.first.id === '.' && ((\n                                    are_similar(filter.first.first, this.second) &&\n                                    filter.first.second.string === 'hasOwnProperty' &&\n                                    are_similar(filter.second[0], this.first)\n                                ) || (\n                                    filter.first.first.id === '.' &&\n                                    filter.first.first.first.first &&\n                                    filter.first.first.first.first.string === 'Object' &&\n                                    filter.first.first.first.id === '.' &&\n                                    filter.first.first.first.second.string === 'prototype' &&\n                                    filter.first.first.second.string === 'hasOwnProperty' &&\n                                    filter.first.second.string === 'call' &&\n                                    are_similar(filter.second[0], this.second) &&\n                                    are_similar(filter.second[1], this.first)\n                                ));\n                                break;\n                            }\n                        } else if (blok[0].id === 'switch') {\n                            ok = blok[0].id === 'switch' &&\n                                blok[0].first.id === 'typeof' &&\n                                blok[0].first.first.id === '[' &&\n                                are_similar(blok[0].first.first.first, this.second) &&\n                                are_similar(blok[0].first.first.second, this.first);\n                        }\n                    }\n                    if (!ok) {\n                        this.warn('for_if');\n                    }\n                }\n            } else {\n                edge();\n                this.first = [];\n                for (;;) {\n                    this.first.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                semicolon();\n                edge();\n                this.second = expected_relation(expression(0));\n                if (this.second.id !== 'true') {\n                    expected_condition(this.second, 'unexpected_a');\n                }\n                semicolon(token);\n                if (next_token.id === ';') {\n                    next_token.stop('expected_a_b', ')', ';');\n                }\n                this.third = [];\n                edge();\n                for (;;) {\n                    this.third.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                no_space();\n                step_out(')', paren);\n                one_space();\n                blok = block('for');\n            }\n        }\n        if (blok.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        this.block = blok;\n        funct.loopage -= 1;\n        return this;\n    });\n\n    function optional_label(that) {\n        var label = next_token.string,\n            master;\n        that.arity = 'statement';\n        if (!funct.breakage || (!option.continue && that.id === 'continue')) {\n            that.warn('unexpected_a');\n        } else if (next_token.identifier && token.line === next_token.line) {\n            one_space_only();\n            master = scope[label];\n            if (!master || master.kind !== 'label') {\n                next_token.warn('not_a_label');\n            } else if (master.dead || master.function !== funct) {\n                next_token.warn('not_a_scope');\n            } else {\n                master.used += 1;\n                if (that.id === 'break') {\n                    master.statement.break = true;\n                }\n                if (funct.breakage[funct.breakage.length - 1] === master.statement) {\n                    next_token.warn('unexpected_a');\n                }\n            }\n            that.first = next_token;\n            advance();\n        } else {\n            if (that.id === 'break') {\n                funct.breakage[funct.breakage.length - 1].break = true;\n            }\n        }\n        return that;\n\n    }\n\n    disrupt_stmt('break', function () {\n        return optional_label(this);\n    });\n\n    disrupt_stmt('continue', function () {\n        return optional_label(this);\n    });\n\n    disrupt_stmt('return', function () {\n        if (funct === global_funct) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        if (next_token.id !== ';' && next_token.line === token.line) {\n            if (option.closure) {\n                spaces();\n            } else {\n                one_space_only();\n            }\n            if (next_token.id === '/' || next_token.id === '(regexp)') {\n                next_token.warn('wrap_regexp');\n            }\n            this.first = expression(0);\n            if (this.first.assign) {\n                this.first.warn('unexpected_a');\n            }\n        }\n        return this;\n    });\n\n    disrupt_stmt('throw', function () {\n        this.arity = 'statement';\n        one_space_only();\n        this.first = expression(20);\n        return this;\n    });\n\n\n//  Superfluous reserved words\n\n    reserve('class');\n    reserve('const');\n    reserve('enum');\n    reserve('export');\n    reserve('extends');\n    reserve('import');\n    reserve('super');\n\n// Harmony reserved words\n\n    reserve('implements');\n    reserve('interface');\n    reserve('let');\n    reserve('package');\n    reserve('private');\n    reserve('protected');\n    reserve('public');\n    reserve('static');\n    reserve('yield');\n\n\n// Parse JSON\n\n    function json_value() {\n\n        function json_object() {\n            var brace = next_token, object = Object.create(null);\n            advance('{');\n            if (next_token.id !== '}') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    if (next_token.id !== '(string)') {\n                        next_token.warn('expected_string_a');\n                    }\n                    if (object[next_token.string] === true) {\n                        next_token.warn('duplicate_a');\n                    } else if (next_token.string === '__proto__') {\n                        next_token.warn('dangling_a');\n                    } else {\n                        object[next_token.string] = true;\n                    }\n                    advance();\n                    advance(':');\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === '}') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance('}', brace);\n        }\n\n        function json_array() {\n            var bracket = next_token;\n            advance('[');\n            if (next_token.id !== ']') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === ']') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance(']', bracket);\n        }\n\n        switch (next_token.id) {\n        case '{':\n            json_object();\n            break;\n        case '[':\n            json_array();\n            break;\n        case 'true':\n        case 'false':\n        case 'null':\n        case '(number)':\n        case '(string)':\n            advance();\n            break;\n        case '-':\n            advance('-');\n            no_space_only();\n            advance('(number)');\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n    }\n\n\n// The actual JSLINT function itself.\n\n    itself = function JSLint(the_source, the_option) {\n\n        var i, predef, tree;\n        itself.errors = [];\n        itself.tree = '';\n        itself.properties = '';\n        begin = prev_token = token = next_token =\n            Object.create(syntax['(begin)']);\n        tokens = [];\n        predefined = Object.create(null);\n        add_to_predefined(standard);\n        property = Object.create(null);\n        if (the_option) {\n            option = Object.create(the_option);\n            predef = option.predef;\n            if (predef) {\n                if (Array.isArray(predef)) {\n                    for (i = 0; i < predef.length; i += 1) {\n                        predefined[predef[i]] = true;\n                    }\n                } else if (typeof predef === 'object') {\n                    add_to_predefined(predef);\n                }\n            }\n        } else {\n            option = Object.create(null);\n        }\n        option.indent = +option.indent || 4;\n        option.maxerr = +option.maxerr || 50;\n        global_scope = scope = Object.create(null);\n        global_funct = funct = {\n            scope: scope,\n            loopage: 0,\n            level: 0\n        };\n        functions = [funct];\n        block_var = [];\n\n        comments = [];\n        comments_off = false;\n        in_block = false;\n        indent = null;\n        json_mode = false;\n        lookahead = [];\n        node_js = false;\n        prereg = true;\n        strict_mode = false;\n        var_mode = null;\n        warnings = 0;\n        lex.init(the_source);\n\n        assume();\n\n        try {\n            advance();\n            if (next_token.id === '(number)') {\n                next_token.stop('unexpected_a');\n            } else {\n                switch (next_token.id) {\n                case '{':\n                case '[':\n                    comments_off = true;\n                    json_mode = true;\n                    json_value();\n                    break;\n                default:\n\n// If the first token is a semicolon, ignore it. This is sometimes used when\n// files are intended to be appended to files that may be sloppy. A sloppy\n// file may be depending on semicolon insertion on its last line.\n\n                    step_in(1);\n                    if (next_token.id === ';' && !node_js) {\n                        next_token.edge = true;\n                        advance(';');\n                    }\n                    tree = statements();\n                    begin.first = tree;\n                    itself.tree = begin;\n                    if (tree.disrupt) {\n                        prev_token.warn('weird_program');\n                    }\n                }\n            }\n            indent = null;\n            advance('(end)');\n            itself.property = property;\n        } catch (e) {\n            if (e) {        // ~~\n                itself.errors.push({\n                    reason    : e.message,\n                    line      : e.line || next_token.line,\n                    character : e.character || next_token.from\n                }, null);\n            }\n        }\n        return itself.errors.length === 0;\n    };\n\n    function unique(array) {\n        array = array.sort();\n        var i, length = 0, previous, value;\n        for (i = 0; i < array.length; i += 1) {\n            value = array[i];\n            if (value !== previous) {\n                array[length] = value;\n                previous = value;\n                length += 1;\n            }\n        }\n        array.length = length;\n        return array;\n    }\n\n// Data summary.\n\n    itself.data = function () {\n        var data = {functions: []},\n            function_data,\n            i,\n            the_function,\n            the_scope;\n        data.errors = itself.errors;\n        data.json = json_mode;\n        data.global = unique(Object.keys(global_scope));\n\n        function selects(name) {\n            var kind = the_scope[name].kind;\n            switch (kind) {\n            case 'var':\n            case 'exception':\n            case 'label':\n                function_data[kind].push(name);\n                break;\n            }\n        }\n\n        for (i = 1; i < functions.length; i += 1) {\n            the_function = functions[i];\n            function_data = {\n                name: the_function.name,\n                line: the_function.line,\n                level: the_function.level,\n                parameter: the_function.parameter,\n                var: [],\n                exception: [],\n                closure: unique(the_function.closure),\n                outer: unique(the_function.outer),\n                global: unique(the_function.global),\n                label: []\n            };\n            the_scope = the_function.scope;\n            Object.keys(the_scope).forEach(selects);\n            function_data.var.sort();\n            function_data.exception.sort();\n            function_data.label.sort();\n            data.functions.push(function_data);\n        }\n        data.tokens = tokens;\n        return data;\n    };\n\n    itself.error_report = function (data) {\n        var evidence, i, output = [], warning;\n        if (data.errors.length) {\n            if (data.json) {\n                output.push('<cite>JSON: bad.</cite><br>');\n            }\n            for (i = 0; i < data.errors.length; i += 1) {\n                warning = data.errors[i];\n                if (warning) {\n                    evidence = warning.evidence || '';\n                    output.push('<cite>');\n                    if (isFinite(warning.line)) {\n                        output.push('<address>line ' +\n                            String(warning.line) +\n                            ' character ' + String(warning.character) +\n                            '</address>');\n                    }\n                    output.push(warning.reason.entityify() + '</cite>');\n                    if (evidence) {\n                        output.push('<pre>' + evidence.entityify() + '</pre>');\n                    }\n                }\n            }\n        }\n        return output.join('');\n    };\n\n\n    itself.report = function (data) {\n        var dl, i, j, names, output = [], the_function;\n\n        function detail(h, array) {\n            var comma_needed = false;\n            if (array.length) {\n                output.push(\"<dt>\" + h + \"</dt><dd>\");\n                array.forEach(function (item) {\n                    output.push((comma_needed ? ', ' : '') + item);\n                    comma_needed = true;\n                });\n                output.push(\"</dd>\");\n            }\n        }\n\n        output.push('<dl class=level0>');\n        if (data.global.length) {\n            detail('global', data.global);\n            dl = true;\n        } else if (data.json) {\n            if (!data.errors.length) {\n                output.push(\"<dt>JSON: good.</dt>\");\n            }\n        } else {\n            output.push(\"<dt><i>No new global variables introduced.</i></dt>\");\n        }\n        if (dl) {\n            output.push(\"</dl>\");\n        } else {\n            output[0] = '';\n        }\n\n        if (data.functions) {\n            for (i = 0; i < data.functions.length; i += 1) {\n                the_function = data.functions[i];\n                names = [];\n                if (the_function.params) {\n                    for (j = 0; j < the_function.params.length; j += 1) {\n                        names[j] = the_function.params[j].string;\n                    }\n                }\n                output.push('<dl class=level' + the_function.level +\n                    '><address>line ' + String(the_function.line) +\n                    '</address>' + the_function.name.entityify());\n                detail('parameter', the_function.parameter);\n                detail('variable', the_function.var);\n                detail('exception', the_function.exception);\n                detail('closure', the_function.closure);\n                detail('outer', the_function.outer);\n                detail('global', the_function.global);\n                detail('label', the_function.label);\n                output.push('</dl>');\n            }\n        }\n        return output.join('');\n    };\n\n    itself.properties_report = function (property) {\n        if (!property) {\n            return '';\n        }\n        var i,\n            key,\n            keys = Object.keys(property).sort(),\n            mem = '   ',\n            name,\n            not_first = false,\n            output = ['/*properties'];\n        for (i = 0; i < keys.length; i += 1) {\n            key = keys[i];\n            if (property[key] > 0) {\n                if (not_first) {\n                    mem += ',';\n                }\n                name = ix.test(key)\n                    ? key\n                    : '\\'' + key.replace(nx, sanitize) + '\\'';\n                if (mem.length + name.length >= 80) {\n                    output.push(mem);\n                    mem = '    ';\n                } else {\n                    mem += ' ';\n                }\n                mem += name;\n                not_first = true;\n            }\n        }\n        output.push(mem, '*/\\n');\n        return output.join('\\n');\n    };\n\n    itself.color = function (data) {\n        var from,\n            i = 1,\n            level,\n            line,\n            result = [],\n            thru,\n            data_token = data.tokens[0];\n        while (data_token && data_token.id !== '(end)') {\n            from = data_token.from;\n            line = data_token.line;\n            thru = data_token.thru;\n            level = data_token.function.level;\n            do {\n                thru = data_token.thru;\n                data_token = data.tokens[i];\n                i += 1;\n            } while (data_token && data_token.line === line &&\n                    data_token.from - thru < 5 &&\n                    level === data_token.function.level);\n            result.push({\n                line: line,\n                level: level,\n                from: from,\n                thru: thru\n            });\n        }\n        return result;\n    };\n\n    itself.jslint = itself;\n\n    itself.edition = '2014-07-08';\n\n    return itself;\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jslint-es6.js":"// jslint.js\n// 2016-07-13\n// Copyright (c) 2015 Douglas Crockford  (www.JSLint.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// The Software shall be used for Good, not Evil.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// jslint(source, option_object, global_array) is a function that takes 3\n// arguments. The second two arguments are optional.\n\n//      source          A text to analyze, a string or an array of strings.\n//      option_object   An object whose keys correspond to option names.\n//      global_array    An array of strings containing global variables that\n//                      the file is allowed readonly access.\n\n// jslint returns an object containing its results. The object contains a lot\n// of valuable information. It can be used to generate reports. The object\n// contains:\n\n//      directives: an array of directive comment tokens.\n//      edition: the version of JSLint that did the analysis.\n//      functions: an array of objects that represent all of the functions\n//              declared in the file.\n//      global: an object representing the global object. Its .context property\n//              is an object containing a property for each global variable.\n//      id: \"(JSLint)\"\n//      imports: an array of strings representing each of the imports.\n//      json: true if the file is a JSON text.\n//      lines: an array of strings, the source.\n//      module: true if an import or export statement was used.\n//      ok: true if no warnings were generated. This is what you want.\n//      option: the option argument.\n//      property: a property object.\n//      stop: true if JSLint was unable to finish. You don't want this.\n//      tokens: an array of objects representing the tokens in the file.\n//      tree: the token objects arranged in a tree.\n//      warnings: an array of warning objects. A warning object can contain:\n//          name: \"JSLintError\"\n//          column: A column number in the file.\n//          line: A line number in the file.\n//          code: A warning code string.\n//          message: The warning message string.\n//          a: Exhibit A.\n//          b: Exhibit B.\n//          c: Exhibit C.\n//          d: Exhibit D.\n\n// jslint works in several phases. In any of these phases, errors might be\n// found. Sometimes JSLint is able to recover from an error and continue\n// parsing. In some cases, it cannot and will stop early. If that should happen,\n// repair your code and try again.\n\n// Phases:\n\n//      1. If the source is a single string, split it into an array of strings.\n//      2. Turn the source into an array of tokens.\n//      3. Furcate the tokens into a parse tree.\n//      4. Walk the tree, traversing all of the nodes of the tree. It is a\n//          recursive traversal. Each node may be processed on the way down\n//          (preaction) and on the way up (postaction).\n//      5. Check the whitespace between the tokens.\n\n// jslint can also examine JSON text. It decides that a file is JSON text if\n// the first token is \"[\" or \"{\". Processing of JSON text is much simpler than\n// the processing of JavaScript programs. Only the first three phases are\n// required.\n\n// WARNING: JSLint will hurt your feelings.\n\n/*property\n    a, and, arity, b, bad_assignment_a, bad_directive_a, bad_get,\n    bad_module_name_a, bad_option_a, bad_property_a, bad_set, bitwise, block,\n    body, browser, c, calls, catch, charAt, charCodeAt, closer, closure, code,\n    column, complex, concat, constant, context, couch, create, d, dead, devel,\n    directive, directives, disrupt, dot, duplicate_a, edition, ellipsis, else,\n    empty_block, es6, escape_mega, eval, every, expected_a, expected_a_at_b_c,\n    expected_a_b, expected_a_b_from_c_d, expected_a_before_b,\n    expected_digits_after_a, expected_four_digits, expected_identifier_a,\n    expected_line_break_a_b, expected_regexp_factor_a, expected_space_a_b,\n    expected_statements_a, expected_string_a, expected_type_string_a,\n    expression, extra, flag, for, forEach, free, from, fud, fudge, function,\n    function_in_loop, functions, g, global, i, id, identifier, import, imports,\n    inc, indexOf, infix_in, init, initial, isArray, isNaN, join, json, keys,\n    label, label_a, lbp, led, length, level, line, lines, live, loop, m,\n    margin, match, maxerr, maxlen, message, misplaced_a, misplaced_directive_a,\n    missing_browser, module, multivar, naked_block, name, names,\n    nested_comment, new, node, not_label_a, nr, nud, number_isNaN, ok, open,\n    option, out_of_scope_a, parameters, pop, property, push, qmark, quote,\n    redefinition_a_b, replace, reserved_a, role, search, signature, single,\n    slice, some, sort, split, statement, stop, strict, subscript_a, switch,\n    test, this, thru, toString, todo_comment, tokens, too_long, too_many,\n    too_many_digits, tree, type, u, unclosed_comment, unclosed_mega,\n    unclosed_string, undeclared_a, unexpected_a, unexpected_a_after_b,\n    unexpected_at_top_level_a, unexpected_char_a, unexpected_comment,\n    unexpected_directive_a, unexpected_expression_a, unexpected_label_a,\n    unexpected_parens, unexpected_space_a_b, unexpected_statement_a,\n    unexpected_trailing_space, unexpected_typeof_a, uninitialized_a,\n    unreachable_a, unregistered_property_a, unsafe, unused_a, use_spaces,\n    use_strict, used, value, var_loop, var_switch, variable, warning, warnings,\n    weird_condition_a, weird_expression_a, weird_loop, weird_relation_a, white,\n    wrap_assignment, wrap_condition, wrap_immediate, wrap_parameter,\n    wrap_regexp, wrap_unary, wrapped, writable, y\n*/\n\nvar jslint = (function JSLint() {\n    \"use strict\";\n\n    function empty() {\n\n// The empty function produces a new empty object that inherits nothing. This is\n// much better than {} because confusions around accidental method names like\n// \"constructor\" are completely avoided.\n\n        return Object.create(null);\n    }\n\n    function populate(object, array, value) {\n\n// Augment an object by taking property names from an array of strings.\n\n        array.forEach(function (name) {\n            object[name] = value;\n        });\n    }\n\n    var allowed_option = {\n\n// These are the options that are recognized in the option object or that may\n// appear in a /*jslint*/ directive. Most options will have a boolean value,\n// usually true. Some options will also predefine some number of global\n// variables.\n\n        bitwise: true,\n        browser: [\n            \"Audio\", \"clearInterval\", \"clearTimeout\", \"document\", \"event\",\n            \"FormData\", \"history\", \"Image\", \"localStorage\", \"location\", \"name\",\n            \"navigator\", \"Option\", \"screen\", \"sessionStorage\", \"setInterval\",\n            \"setTimeout\", \"Storage\", \"XMLHttpRequest\"\n        ],\n        couch: [\n            \"emit\", \"getRow\", \"isArray\", \"log\", \"provides\", \"registerType\",\n            \"require\", \"send\", \"start\", \"sum\", \"toJSON\"\n        ],\n        devel: [\n            \"alert\", \"confirm\", \"console\", \"Debug\", \"opera\", \"prompt\", \"WSH\"\n        ],\n        es6: [\n            \"ArrayBuffer\", \"DataView\", \"Float32Array\", \"Float64Array\",\n            \"Generator\", \"GeneratorFunction\", \"Int8Array\", \"Int16Array\",\n            \"Int32Array\", \"Intl\", \"Map\", \"Promise\", \"Proxy\", \"Reflect\",\n            \"Set\", \"Symbol\", \"System\", \"Uint8Array\", \"Uint8ClampedArray\",\n            \"Uint16Array\", \"Uint32Array\", \"WeakMap\", \"WeakSet\"\n        ],\n        eval: true,\n        for: true,\n        fudge: true,\n        maxerr: 10000,\n        maxlen: 10000,\n        multivar: true,\n        node: [\n            \"Buffer\", \"clearImmediate\", \"clearInterval\", \"clearTimeout\",\n            \"console\", \"exports\", \"global\", \"module\", \"process\", \"querystring\",\n            \"require\", \"setImmediate\", \"setInterval\", \"setTimeout\",\n            \"__dirname\", \"__filename\"\n        ],\n        single: true,\n        this: true,\n        white: true\n    };\n\n    var spaceop = {\n\n// This is the set of infix operators that require a space on each side.\n\n        \"!=\": true,\n        \"!==\": true,\n        \"%\": true,\n        \"%=\": true,\n        \"&\": true,\n        \"&=\": true,\n        \"&&\": true,\n        \"*\": true,\n        \"*=\": true,\n        \"+=\": true,\n        \"-=\": true,\n        \"/\": true,\n        \"/=\": true,\n        \"<\": true,\n        \"<=\": true,\n        \"<<\": true,\n        \"<<=\": true,\n        \"=\": true,\n        \"==\": true,\n        \"===\": true,\n        \"=>\": true,\n        \">\": true,\n        \">=\": true,\n        \">>\": true,\n        \">>=\": true,\n        \">>>\": true,\n        \">>>=\": true,\n        \"^\": true,\n        \"^=\": true,\n        \"|\": true,\n        \"|=\": true,\n        \"||\": true\n    };\n\n    var bitwiseop = {\n\n// These are the bitwise operators.\n\n        \"~\": true,\n        \"^\": true,\n        \"^=\": true,\n        \"&\": true,\n        \"&=\": true,\n        \"|\": true,\n        \"|=\": true,\n        \"<<\": true,\n        \"<<=\": true,\n        \">>\": true,\n        \">>=\": true,\n        \">>>\": true,\n        \">>>=\": true\n    };\n\n    var opener = {\n\n// The open and close pairs.\n\n        \"(\": \")\",       // paren\n        \"[\": \"]\",       // bracket\n        \"{\": \"}\",       // brace\n        \"${\": \"}\"       // mega\n    };\n\n    var relationop = {\n\n// The relational operators.\n\n        \"!=\": true,\n        \"!==\": true,\n        \"==\": true,\n        \"===\": true,\n        \"<\": true,\n        \"<=\": true,\n        \">\": true,\n        \">=\": true\n    };\n\n    var standard = [\n\n// These are the globals that are provided by the ES5 language standard.\n\n        \"Array\", \"Boolean\", \"Date\", \"decodeURI\", \"decodeURIComponent\",\n        \"encodeURI\", \"encodeURIComponent\", \"Error\", \"EvalError\", \"isFinite\",\n        \"JSON\", \"Math\", \"Number\", \"Object\", \"parseInt\", \"parseFloat\",\n        \"RangeError\", \"ReferenceError\", \"RegExp\", \"String\", \"SyntaxError\",\n        \"TypeError\", \"URIError\"\n    ];\n\n    var bundle = {\n\n// The bundle contains the raw text messages that are generated by jslint. It\n// seems that they are all error messages and warnings. There are no \"Atta\n// boy!\" or \"You are so awesome!\" messages. There is no positive reinforcement\n// or encouragement. This relentless negativity can undermine self-esteem and\n// wound the inner child. But if you accept it as sound advice rather than as\n// personal criticism, it can make your programs better.\n\n        and: \"The '&&' subexpression should be wrapped in parens.\",\n        bad_assignment_a: \"Bad assignment to '{a}'.\",\n        bad_directive_a: \"Bad directive '{a}'.\",\n        bad_get: \"A get function takes no parameters.\",\n        bad_module_name_a: \"Bad module name '{a}'.\",\n        bad_option_a: \"Bad option '{a}'.\",\n        bad_property_a: \"Bad property name '{a}'.\",\n        bad_set: \"A set function takes one parameter.\",\n        duplicate_a: \"Duplicate '{a}'.\",\n        empty_block: \"Empty block.\",\n        es6: \"Unexpected ES6 feature '{a}'.\",\n        escape_mega: \"Unexpected escapement in mega literal.\",\n        expected_a: \"Expected '{a}'.\",\n        expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n        expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n        expected_a_b_from_c_d: \"Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.\",\n        expected_a_before_b: \"Expected '{a}' before '{b}'.\",\n        expected_digits_after_a: \"Expected digits after '{a}'.\",\n        expected_four_digits: \"Expected four digits after '\\\\u'.\",\n        expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n        expected_line_break_a_b: \"Expected a line break between '{a}' and '{b}'.\",\n        expected_regexp_factor_a: \"Expected a regexp factor and instead saw '{a}'.\",\n        expected_space_a_b: \"Expected one space between '{a}' and '{b}'.\",\n        expected_statements_a: \"Expected statements before '{a}'.\",\n        expected_string_a: \"Expected a string and instead saw '{a}'.\",\n        expected_type_string_a: \"Expected a type string and instead saw '{a}'.\",\n        function_in_loop: \"Don't make functions within a loop.\",\n        infix_in: \"Unexpected 'in'. Compare with undefined, or use the hasOwnProperty method instead.\",\n        isNaN: \"Use the isNaN function to compare with NaN.\",\n        label_a: \"'{a}' is a statement label.\",\n        misplaced_a: \"Place '{a}' at the outermost level.\",\n        misplaced_directive_a: \"Place the '/*{a}*/' directive before the first statement.\",\n        missing_browser: \"/*global*/ requires the Assume a browser option.\",\n        naked_block: \"Naked block.\",\n        nested_comment: \"Nested comment.\",\n        not_label_a: \"'{a}' is not a label.\",\n        number_isNaN: \"Use Number.isNaN function to compare with NaN.\",\n        out_of_scope_a: \"'{a}' is out of scope.\",\n        redefinition_a_b: \"Redefinition of '{a}' from line {b}.\",\n        reserved_a: \"Reserved name '{a}'.\",\n        subscript_a: \"['{a}'] is better written in dot notation.\",\n        todo_comment: \"Unexpected TODO comment.\",\n        too_long: \"Line too long.\",\n        too_many: \"Too many warnings.\",\n        too_many_digits: \"Too many digits.\",\n        unclosed_comment: \"Unclosed comment.\",\n        unclosed_mega: \"Unclosed mega literal.\",\n        unclosed_string: \"Unclosed string.\",\n        undeclared_a: \"Undeclared '{a}'.\",\n        unexpected_a: \"Unexpected '{a}'.\",\n        unexpected_a_after_b: \"Unexpected '{a}' after '{b}'.\",\n        unexpected_at_top_level_a: \"Expected '{a}' to be in a function.\",\n        unexpected_char_a: \"Unexpected character '{a}'.\",\n        unexpected_comment: \"Unexpected comment.\",\n        unexpected_directive_a: \"When using modules, don't use directive '/*{a}'.\",\n        unexpected_expression_a: \"Unexpected expression '{a}' in statement position.\",\n        unexpected_label_a: \"Unexpected label '{a}'.\",\n        unexpected_parens: \"Don't wrap function literals in parens.\",\n        unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n        unexpected_statement_a: \"Unexpected statement '{a}' in expression position.\",\n        unexpected_trailing_space: \"Unexpected trailing space.\",\n        unexpected_typeof_a: \"Unexpected 'typeof'. Use '===' to compare directly with {a}.\",\n        uninitialized_a: \"Uninitialized '{a}'.\",\n        unreachable_a: \"Unreachable '{a}'.\",\n        unregistered_property_a: \"Unregistered property name '{a}'.\",\n        unsafe: \"Unsafe character '{a}'.\",\n        unused_a: \"Unused '{a}'.\",\n        use_spaces: \"Use spaces, not tabs.\",\n        use_strict: \"This function needs a 'use strict' pragma.\",\n        var_loop: \"Don't declare variables in a loop.\",\n        var_switch: \"Don't declare variables in a switch.\",\n        weird_condition_a: \"Weird condition '{a}'.\",\n        weird_expression_a: \"Weird expression '{a}'.\",\n        weird_loop: \"Weird loop.\",\n        weird_relation_a: \"Weird relation '{a}'.\",\n        wrap_assignment: \"Don't wrap assignment statements in parens.\",\n        wrap_condition: \"Wrap the condition in parens.\",\n        wrap_immediate: \"Wrap an immediate function invocation in \" +\n                \"parentheses to assist the reader in understanding that the \" +\n                \"expression is the result of a function, and not the \" +\n                \"function itself.\",\n        wrap_parameter: \"Wrap the parameter in parens.\",\n        wrap_regexp: \"Wrap this regexp in parens to avoid confusion.\",\n        wrap_unary: \"Wrap the unary expression in parens.\"\n    };\n\n// Regular expression literals:\n\n// supplant {variables}\n    var rx_supplant = /\\{([^{}]*)\\}/g;\n// carriage return, carriage return linefeed, or linefeed\n    var rx_crlf = /\\n|\\r\\n?/;\n// unsafe characters that are silently deleted by one or more browsers\n    var rx_unsafe = /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/;\n// identifier\n    var rx_identifier = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/;\n    var rx_module = /^[a-zA-Z0-9_$:.@\\-\\/]+$/;\n    var rx_bad_property = /^_|\\$|Sync$|_$/;\n// star slash\n    var rx_star_slash = /\\*\\//;\n// slash star\n    var rx_slash_star = /\\/\\*/;\n// slash star or ending slash\n    var rx_slash_star_or_slash = /\\/\\*|\\/$/;\n// uncompleted work comment\n    var rx_todo = /\\b(?:todo|TO\\s?DO|HACK)\\b/;\n// tab\n    var rx_tab = /\\t/g;\n// directive\n    var rx_directive = /^(jslint|property|global)\\s+(.*)$/;\n    var rx_directive_part = /^([a-zA-Z$_][a-zA-Z0-9$_]*)\\s*(?::\\s*(true|false|[0-9]+)\\s*)?(?:,\\s*)?(.*)$/;\n// token (sorry it is so long)\n    var rx_token = /^((\\s+)|([a-zA-Z_$][a-zA-Z0-9_$]*)|[(){}\\[\\]\\?,:;'\"~`]|=(?:==?|>)?|\\.+|\\/[=*\\/]?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|[\\^%]=?|&[&=]?|\\|[\\|=]?|>{1,3}=?|<<?=?|!={0,2}|(0|[1-9][0-9]*))(.*)$/;\n    var rx_digits = /^([0-9]+)(.*)$/;\n    var rx_hexs = /^([0-9a-fA-F]+)(.*)$/;\n    var rx_octals = /^([0-7]+)(.*)$/;\n    var rx_bits = /^([01]+)(.*)$/;\n// mega\n    var rx_mega = /[`\\\\]|\\$\\{/;\n// indentation\n    var rx_colons = /^(.*)\\?([:.]*)$/;\n    var rx_dot = /\\.$/;\n// JSON number\n    var rx_JSON_number = /^-?\\d+(?:\\.\\d*)?(?:e[\\-+]?\\d+)?$/i;\n// initial cap\n    var rx_cap = /^[A-Z]/;\n\n    function is_letter(string) {\n        return (string >= \"a\" && string <= \"z\\uffff\") ||\n                (string >= \"A\" && string <= \"Z\\uffff\");\n    }\n\n    function supplant(string, object) {\n        return string.replace(rx_supplant, function (found, filling) {\n            var replacement = object[filling];\n            return (replacement !== undefined)\n                ? replacement\n                : found;\n        });\n    }\n\n    var anon = \"anonymous\"; // The guessed name for anonymous functions.\n    var blockage;           // The current block.\n    var block_stack;        // The stack of blocks.\n    var declared_globals;   // The object containing the global declarations.\n    var directives;         // The directive comments.\n    var directive_mode;     // true if directives are still allowed.\n    var early_stop;         // true if JSLint cannot finish.\n    var export_mode;        // true if an export statement was seen.\n    var fudge;              // true if the natural numbers start with 1.\n    var functionage;        // The current function.\n    var functions;          // The array containing all of the functions.\n    var global;             // The global object; the outermost context.\n    var imports;            // The array collecting all import-from strings.\n    var json_mode;          // true if parsing JSON.\n    var lines;              // The array containing source lines.\n    var module_mode;        // true if import or export was used.\n    var next_token;         // The next token to be examined in the parse.\n    var option;             // The options parameter.\n    var property;           // The object containing the tallied property names.\n    var mega_mode;          // true if currently parsing a megastring literal.\n    var stack;              // The stack of functions.\n    var syntax;             // The object containing the parser.\n    var token;              // The current token being examined in the parse.\n    var token_nr;           // The number of the next token.\n    var tokens;             // The array of tokens.\n    var tenure;             // The predefined property registry.\n    var tree;               // The abstract parse tree.\n    var var_mode;           // true if using var; false if using let.\n    var warnings;           // The array collecting all generated warnings.\n\n// Error reportage functions:\n\n    function artifact(the_token) {\n\n// Return a string representing an artifact.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        return (the_token.id === \"(string)\" || the_token.id === \"(number)\")\n            ? String(the_token.value)\n            : the_token.id;\n    }\n\n    function artifact_line(the_token) {\n\n// Return the fudged line number of an artifact.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        return the_token.line + fudge;\n    }\n\n    function artifact_column(the_token) {\n\n// Return the fudged column number of an artifact.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        return the_token.from + fudge;\n    }\n\n    function warn_at(code, line, column, a, b, c, d) {\n\n// Report an error at some line and column of the program. The warning object\n// resembles an exception.\n\n        var warning = {         // ~~\n            name: \"JSLintError\",\n            column: column,\n            line: line,\n            code: code\n        };\n        if (a !== undefined) {\n            warning.a = a;\n        }\n        if (b !== undefined) {\n            warning.b = b;\n        }\n        if (c !== undefined) {\n            warning.c = c;\n        }\n        if (d !== undefined) {\n            warning.d = d;\n        }\n        warning.message = supplant(bundle[code] || code, warning);\n        warnings.push(warning);\n        return (\n            typeof option.maxerr === \"number\" &&\n            warnings.length === option.maxerr\n        )   ? stop_at(\"too_many\", line, column)\n            : warning;\n    }\n\n    function stop_at(code, line, column, a, b, c, d) {\n\n// Same as warn_at, except that it stops the analysis.\n\n        throw warn_at(code, line, column, a, b, c, d);\n    }\n\n    function warn(code, the_token, a, b, c, d) {\n\n// Same as warn_at, except the warning will be associated with a specific token.\n// If there is already a warning on this token, suppress the new one. It is\n// likely that the first warning will be the most meaningful.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        if (the_token.warning === undefined) {\n            the_token.warning = warn_at(\n                code,\n                the_token.line,\n                the_token.from,\n                a || artifact(the_token),\n                b,\n                c,\n                d\n            );\n            return the_token.warning;\n        }\n    }\n\n    function stop(code, the_token, a, b, c, d) {\n\n// Similar to warn and stop_at. If the token already had a warning, that\n// warning will be replaced with this new one. It is likely that the stopping\n// warning will be the more meaningful.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        delete the_token.warning;\n        throw warn(code, the_token, a, b, c, d);\n    }\n\n// Tokenize:\n\n    function tokenize(source) {\n\n// tokenize takes a source and produces from it an array of token objects.\n// JavaScript is notoriously difficult to tokenize because of the horrible\n// interactions between automatic semicolon insertion, regular expression\n// literals, and now megastring literals. JSLint benefits from eliminating\n// automatic semicolon insertion and nested megastring literals, which allows\n// full tokenization to precede parsing.\n\n// If the source is not an array, then it is split into lines at the\n// carriage return/linefeed.\n\n        lines = (Array.isArray(source))\n            ? source\n            : source.split(rx_crlf);\n        tokens = [];\n\n        var char;                   // a popular character\n        var column = 0;             // the column number of the next character\n        var from;                   // the starting column number of the token\n        var line = -1;              // the line number of the next character\n        var nr = 0;                 // the next token number\n        var previous = global;      // the previous token including comments\n        var prior = global;         // the previous token excluding comments\n        var mega_from;              // the starting column of megastring\n        var mega_line;              // the starting line of megastring\n        var snippet;                // a piece of string\n        var source_line;            // the current line source string\n\n        function next_line() {\n\n// Put the next line of source in source_line. If the line contains tabs,\n// replace them with spaces and give a warning. Also warn if the line contains\n// unsafe characters or is too damn long.\n\n            var at;\n            column = 0;\n            line += 1;\n            source_line = lines[line];\n            if (source_line !== undefined) {\n                at = source_line.search(rx_tab);\n                if (at >= 0) {\n                    if (!option.white) {\n                        warn_at(\"use_spaces\", line, at + 1);\n                    }\n                    source_line = source_line.replace(rx_tab, \" \");\n                }\n                at = source_line.search(rx_unsafe);\n                if (at >= 0) {\n                    warn_at(\n                        \"unsafe\",\n                        line,\n                        column + at,\n                        \"U+\" + source_line.charCodeAt(at).toString(16)\n                    );\n                }\n                if (option.maxlen && option.maxlen < source_line.length) {\n                    warn_at(\"too_long\", line, source_line.length);\n                } else if (!option.white && source_line.slice(-1) === \" \") {\n                    warn_at(\n                        \"unexpected_trailing_space\",\n                        line,\n                        source_line.length - 1\n                    );\n                }\n            }\n            return source_line;\n        }\n\n// Most tokens, including the identifiers, operators, and punctuators, can be\n// found with a regular expression. Regular expressions cannot correctly match\n// regular expression literals, so we will match those the hard way. String\n// literals and number literals can be matched by regular expressions, but they\n// don't provide good warnings. The functions snip, next_char, prev_char,\n// some_digits, and escape help in the parsing of literals.\n\n        function snip() {\n\n// Remove the last character from snippet.\n\n            snippet = snippet.slice(0, -1);\n        }\n\n        function next_char(match) {\n\n// Get the next character from the source line. Remove it from the source_line,\n// and append it to the snippet. Optionally check that the previous character\n// matched an expected value.\n\n            if (match !== undefined && char !== match) {\n                return stop_at(\n                    (char === \"\")\n                        ? \"expected_a\"\n                        : \"expected_a_b\",\n                    line,\n                    column - 1,\n                    match,\n                    char\n                );\n            }\n            if (source_line) {\n                char = source_line.charAt(0);\n                source_line = source_line.slice(1);\n                snippet += char;\n            } else {\n                char = \"\";\n                snippet += \" \";\n            }\n            column += 1;\n            return char;\n        }\n\n        function back_char() {\n\n// Back up one character by moving a character from the end of the snippet to\n// the front of the source_line.\n\n            if (snippet) {\n                char = snippet.slice(-1);\n                source_line = char + source_line;\n                column -= 1;\n                snip();\n            } else {\n                char = \"\";\n            }\n            return char;\n        }\n\n        function some_digits(rx, quiet) {\n            var result = source_line.match(rx);\n            if (result) {\n                char = result[1];\n                column += char.length;\n                source_line = result[2];\n                snippet += char;\n            } else {\n                char = \"\";\n                if (!quiet) {\n                    warn_at(\n                        \"expected_digits_after_a\",\n                        line,\n                        column,\n                        snippet\n                    );\n                }\n            }\n            return char.length;\n        }\n\n        function escape(extra) {\n            switch (next_char(\"\\\\\")) {\n            case \"\\\\\":\n            case \"\\\"\":\n            case \"'\":\n            case \"/\":\n            case \":\":\n            case \"=\":\n            case \"|\":\n            case \"b\":\n            case \"f\":\n            case \"n\":\n            case \"r\":\n            case \"t\":\n            case \" \":\n                break;\n            case \"u\":\n                if (next_char(\"u\") === \"{\") {\n                    if (some_digits(rx_hexs) > 5) {\n                        warn_at(\"too_many_digits\", line, column - 1);\n                    }\n                    if (!option.es6) {\n                        warn_at(\"es6\", line, column, \"u{\");\n                    }\n                    if (next_char() !== \"}\") {\n                        stop_at(\"expected_a_before_b\", line, column, \"}\", char);\n                    }\n                    next_char();\n                    return;\n                }\n                back_char();\n                if (some_digits(rx_hexs, true) < 4) {\n                    warn_at(\"expected_four_digits\", line, column - 1);\n                }\n                break;\n            case \"\":\n                return stop_at(\"unclosed_string\", line, column);\n            default:\n                if (extra && extra.indexOf(char) < 0) {\n                    warn_at(\"unexpected_a_after_b\", line, column, char, \"\\\\\");\n                }\n            }\n            next_char();\n        }\n\n        function make(id, value, identifier) {\n\n// Make the token object and append it to the tokens list.\n\n            var the_token = {\n                from: from,\n                id: id,\n                identifier: !!identifier,\n                line: line,\n                nr: nr,\n                thru: column\n            };\n            tokens[nr] = the_token;\n            nr += 1;\n\n// Directives must appear before the first statement.\n\n            if (id !== \"(comment)\" && id !== \";\") {\n                directive_mode = false;\n            }\n\n// If the token is to have a value, give it one.\n\n            if (value !== undefined) {\n                the_token.value = value;\n            }\n\n// If this token is an identifier that touches a preceding number, or\n// a \"/\", comment, or regular expression literal that touches a preceding\n// comment or regular expression literal, then give a missing space warning.\n// This warning is not suppressed by option.white.\n\n            if (\n                previous.line === line &&\n                previous.thru === from &&\n                (\n                    (id === \"(comment)\" || id === \"(regexp)\" || id === \"/\") &&\n                    (\n                        previous.id === \"(comment)\" ||\n                        previous.id === \"(regexp)\"\n                    )\n                )\n            ) {\n                warn(\n                    \"expected_space_a_b\",\n                    the_token,\n                    artifact(previous),\n                    artifact(the_token)\n                );\n            }\n            if (previous.id === \".\" && id === \"(number)\") {\n                warn(\"expected_a_before_b\", previous, \"0\", \".\");\n            }\n            if (prior.id === \".\" && the_token.identifier) {\n                the_token.dot = true;\n            }\n\n// The previous token is used to detect adjacency problems.\n\n            previous = the_token;\n\n// The prior token is a previous token that was not a comment. The prior token\n// is used to disambiguate \"/\", which can mean division or regular expression\n// literal.\n\n            if (previous.id !== \"(comment)\") {\n                prior = previous;\n            }\n            return the_token;\n        }\n\n        function parse_directive(the_comment, body) {\n\n// JSLint recognizes three directives that can be encoded in comments. This\n// function processes one item, and calls itself recursively to process the\n// next one.\n\n            var result = body.match(rx_directive_part);\n            if (result) {\n                var allowed;\n                var name = result[1];\n                var value = result[2];\n                switch (the_comment.directive) {\n                case \"jslint\":\n                    allowed = allowed_option[name];\n                    switch (typeof allowed) {\n                    case \"boolean\":\n                    case \"object\":\n                        switch (value) {\n                        case \"true\":\n                        case \"\":\n                        case undefined:\n                            option[name] = true;\n                            if (Array.isArray(allowed)) {\n                                populate(declared_globals, allowed, false);\n                            }\n                            break;\n                        case \"false\":\n                            option[name] = false;\n                            break;\n                        default:\n                            warn(\n                                \"bad_option_a\",\n                                the_comment,\n                                name + \":\" + value\n                            );\n                        }\n                        break;\n                    case \"number\":\n                        if (isFinite(+value)) {\n                            option[name] = +value;\n                        } else {\n                            warn(\n                                \"bad_option_a\",\n                                the_comment,\n                                name + \":\" + value\n                            );\n                        }\n                        break;\n                    default:\n                        warn(\"bad_option_a\", the_comment, name);\n                    }\n                    break;\n                case \"property\":\n                    if (tenure === undefined) {\n                        tenure = empty();\n                    }\n                    tenure[name] = true;\n                    break;\n                case \"global\":\n                    if (value) {\n                        warn(\"bad_option_a\", the_comment, name + \":\" + value);\n                    }\n                    declared_globals[name] = false;\n                    module_mode = the_comment;\n                    break;\n                }\n                return parse_directive(the_comment, result[3]);\n            }\n            if (body) {\n                return stop(\"bad_directive_a\", the_comment, body);\n            }\n        }\n\n        function comment(snippet) {\n\n// Make a comment object. Comments are not allowed in JSON text. Comments can\n// include directives and notices of incompletion.\n\n            var the_comment = make(\"(comment)\", snippet);\n            if (Array.isArray(snippet)) {\n                snippet = snippet.join(\" \");\n            }\n            if (!option.devel && rx_todo.test(snippet)) {\n                warn(\"todo_comment\", the_comment);\n            }\n            var result = snippet.match(rx_directive);\n            if (result) {\n                if (!directive_mode) {\n                    warn_at(\"misplaced_directive_a\", line, from, result[1]);\n                } else {\n                    the_comment.directive = result[1];\n                    parse_directive(the_comment, result[2]);\n                }\n                directives.push(the_comment);\n            }\n            return the_comment;\n        }\n\n        function regexp() {\n\n// Parse a regular expression literal.\n\n            var result;\n            var value;\n\n            function quantifier() {\n\n// Match an optional quantifier.\n\n                switch (char) {\n                case \"?\":\n                case \"*\":\n                case \"+\":\n                    next_char();\n                    break;\n                case \"{\":\n                    if (some_digits(rx_digits, true) === 0) {\n                        warn_at(\"expected_a\", line, column, \"0\");\n                    }\n                    if (next_char() === \",\") {\n                        some_digits(rx_digits, true);\n                        next_char();\n                    }\n                    next_char(\"}\");\n                    break;\n                default:\n                    return;\n                }\n                if (char === \"?\") {\n                    next_char(\"?\");\n                }\n            }\n\n            function subklass() {\n\n// Match a character in a character class.\n\n                switch (char) {\n                case \"\\\\\":\n                    escape();\n                    return true;\n                case \"[\":\n                case \"]\":\n                case \"/\":\n                case \"^\":\n                case \"-\":\n                case \"|\":\n                case \"\":\n                    return false;\n                case \"`\":\n                    if (mega_mode) {\n                        warn_at(\"unexpected_a\", line, column, \"`\");\n                    }\n                    next_char();\n                    return true;\n                case \" \":\n                    warn_at(\"expected_a_before_b\", line, column, \"\\\\\", \" \");\n                    next_char();\n                    return true;\n                default:\n                    next_char();\n                    return true;\n                }\n            }\n\n            function ranges() {\n\n// Match a range of subclasses.\n\n                if (subklass()) {\n                    if (char === \"-\") {\n                        next_char(\"-\");\n                        if (!subklass()) {\n                            return stop_at(\n                                \"unexpected_a\",\n                                line,\n                                column - 1,\n                                \"-\"\n                            );\n                        }\n                    }\n                    return ranges();\n                }\n            }\n\n            function klass() {\n\n// Match a class.\n\n                next_char(\"[\");\n                if (char === \"^\") {\n                    next_char(\"^\");\n                }\n                (function classy() {\n                    ranges();\n                    if (char !== \"]\" && char !== \"\") {\n                        warn_at(\n                            \"expected_a_before_b\",\n                            line,\n                            column,\n                            \"\\\\\",\n                            char\n                        );\n                        next_char();\n                        return classy();\n                    }\n                }());\n                next_char(\"]\");\n            }\n\n            function choice() {\n\n                function group() {\n\n// Match a group that starts with left paren.\n\n                    next_char(\"(\");\n                    if (char === \"?\") {\n                        next_char(\"?\");\n                        switch (char) {\n                        case \":\":\n                        case \"=\":\n                        case \"!\":\n                            next_char();\n                            break;\n                        default:\n                            next_char(\":\");\n                        }\n                    } else if (char === \":\") {\n                        warn_at(\"expected_a_before_b\", line, column, \"?\", \":\");\n                    }\n                    choice();\n                    next_char(\")\");\n                }\n\n                function factor() {\n                    switch (char) {\n                    case \"[\":\n                        klass();\n                        return true;\n                    case \"\\\\\":\n                        escape(\"BbDdSsWw^${}[]().|*+?\");\n                        return true;\n                    case \"(\":\n                        group();\n                        return true;\n                    case \"/\":\n                    case \"|\":\n                    case \"]\":\n                    case \")\":\n                    case \"}\":\n                    case \"{\":\n                    case \"?\":\n                    case \"+\":\n                    case \"*\":\n                    case \"\":\n                        return false;\n                    case \"`\":\n                        if (mega_mode) {\n                            warn_at(\"unexpected_a\", line, column, \"`\");\n                        }\n                        break;\n                    case \" \":\n                        warn_at(\"expected_a_before_b\", line, column, \"\\\\\", \" \");\n                        break;\n                    }\n                    next_char();\n                    return true;\n                }\n\n                function sequence(follow) {\n                    if (factor()) {\n                        quantifier();\n                        return sequence(true);\n                    }\n                    if (!follow) {\n                        warn_at(\"expected_regexp_factor_a\", line, column, char);\n                    }\n                }\n\n// Match a choice (a sequence that can be followed by | and another choice).\n\n                sequence();\n                if (char === \"|\") {\n                    next_char(\"|\");\n                    return choice();\n                }\n            }\n\n// Scan the regexp literal. Give a warning if the first character is = because\n// /= looks like a division assignment operator.\n\n            snippet = \"\";\n            next_char();\n            if (char === \"=\") {\n                warn_at(\"expected_a_before_b\", line, column, \"\\\\\", \"=\");\n            }\n            choice();\n\n// Make sure there is a closing slash.\n\n            snip();\n            value = snippet;\n            next_char(\"/\");\n\n// Process dangling flag letters.\n\n            var allowed = {\n                g: true,\n                i: true,\n                m: true,\n                u: 6,\n                y: 6\n            };\n            var flag = empty();\n            (function make_flag() {\n                if (is_letter(char)) {\n                    switch (allowed[char]) {\n                    case true:\n                        break;\n                    case 6:\n                        if (!option.es6) {\n                            warn_at(\"es6\", line, column, char);\n                        }\n                        break;\n                    default:\n                        warn_at(\"unexpected_a\", line, column, char);\n                    }\n                    allowed[char] = false;\n                    flag[char] = true;\n                    next_char();\n                    return make_flag();\n                }\n            }());\n            back_char();\n            if (char === \"/\" || char === \"*\") {\n                return stop_at(\"unexpected_a\", line, from, char);\n            }\n            result = make(\"(regexp)\", char);\n            result.flag = flag;\n            result.value = value;\n            return result;\n        }\n\n        function string(quote) {\n\n// Make a string token.\n\n            var the_token;\n            snippet = \"\";\n            next_char();\n\n            return (function next() {\n                switch (char) {\n                case quote:\n                    snip();\n                    the_token = make(\"(string)\", snippet);\n                    the_token.quote = quote;\n                    return the_token;\n                case \"\\\\\":\n                    escape();\n                    break;\n                case \"\":\n                    return stop_at(\"unclosed_string\", line, column);\n                case \"`\":\n                    if (mega_mode) {\n                        warn_at(\"unexpected_a\", line, column, \"`\");\n                    }\n                    next_char(\"`\");\n                    break;\n                default:\n                    next_char();\n                }\n                return next();\n            }());\n        }\n\n        function frack() {\n            if (char === \".\") {\n                some_digits(rx_digits);\n                next_char();\n            }\n            if (char === \"E\" || char === \"e\") {\n                next_char();\n                if (char !== \"+\" && char !== \"-\") {\n                    back_char();\n                }\n                some_digits(rx_digits);\n                next_char();\n            }\n        }\n\n        function number() {\n            if (snippet === \"0\") {\n                switch (next_char()) {\n                case \".\":\n                    frack();\n                    break;\n                case \"b\":\n                    some_digits(rx_bits);\n                    next_char();\n                    break;\n                case \"o\":\n                    some_digits(rx_octals);\n                    next_char();\n                    break;\n                case \"x\":\n                    some_digits(rx_hexs);\n                    next_char();\n                    break;\n                }\n            } else {\n                next_char();\n                frack();\n            }\n\n// If the next character after a number is a digit or letter, then something\n// unexpected is going on.\n\n            if (\n                (char >= \"0\" && char <= \"9\") ||\n                (char >= \"a\" && char <= \"z\") ||\n                (char >= \"A\" && char <= \"Z\")\n            ) {\n                return stop_at(\n                    \"unexpected_a_after_b\",\n                    line,\n                    column - 1,\n                    snippet.slice(-1),\n                    snippet.slice(0, -1)\n                );\n            }\n            back_char();\n            return make(\"(number)\", snippet);\n        }\n\n        function lex() {\n            var array;\n            var i = 0;\n            var j = 0;\n            var last;\n            var result;\n            var the_token;\n            if (!source_line) {\n                source_line = next_line();\n                from = 0;\n                return (source_line === undefined)\n                    ? (mega_mode)\n                        ? stop_at(\"unclosed_mega\", mega_line, mega_from)\n                        : make(\"(end)\")\n                    : lex();\n            }\n            from = column;\n            result = source_line.match(rx_token);\n\n// result[1] token\n// result[2] whitespace\n// result[3] identifier\n// result[4] number\n// result[5] rest\n\n            if (!result) {\n                return stop_at(\n                    \"unexpected_char_a\",\n                    line,\n                    column,\n                    source_line.charAt(0)\n                );\n            }\n\n            snippet = result[1];\n            column += snippet.length;\n            source_line = result[5];\n\n// Whitespace was matched. Call lex again to get more.\n\n            if (result[2]) {\n                return lex();\n            }\n\n// The token is an identifier.\n\n            if (result[3]) {\n                return make(snippet, undefined, true);\n            }\n\n// The token is a number.\n\n            if (result[4]) {\n                return number(snippet);\n            }\n\n// The token is something miscellaneous.\n\n            switch (snippet) {\n\n// The token is a single or double quote string.\n\n            case \"\\\"\":\n                return string(snippet);\n\n            case \"'\":\n                if (!option.single) {\n                    warn_at(\"expected_a_b\", line, column, \"\\\"\", \"'\");\n                }\n                return string(snippet);\n\n// The token is a megastring. We don't allow any kind of mega nesting.\n\n            case \"`\":\n                if (mega_mode) {\n                    return stop_at(\"expected_a_b\", line, column, \"}\", \"`\");\n                }\n                snippet = \"\";\n                mega_from = from;\n                mega_line = line;\n                mega_mode = true;\n\n// Parsing a mega literal is tricky. First make a ` token.\n\n                make(\"`\");\n                from += 1;\n\n// Then loop, building up a string, possibly from many lines, until seeing\n// the end of file, a closing `, or a ${ indicting an expression within the\n// string.\n\n                (function part() {\n                    var at = source_line.search(rx_mega);\n\n// If neither ` nor ${ is seen, then the whole line joins the snippet.\n\n                    if (at < 0) {\n                        snippet += source_line + \"\\n\";\n                        return (next_line() === undefined)\n                            ? stop_at(\"unclosed_mega\", mega_line, mega_from)\n                            : part();\n                    }\n\n// if either ` or ${ was found, then the preceding joins the snippet to become\n// a string token.\n\n                    snippet += source_line.slice(0, at);\n                    column += at;\n                    source_line = source_line.slice(at);\n                    if (source_line.charAt(0) === \"\\\\\") {\n                        stop_at(\"escape_mega\", line, at);\n                    }\n                    make(\"(string)\", snippet).quote = \"`\";\n                    snippet = \"\";\n\n// If ${, then make tokens that will become part of an expression until\n// a } token is made.\n\n                    if (source_line.charAt(0) === \"$\") {\n                        column += 2;\n                        make(\"${\");\n                        source_line = source_line.slice(2);\n                        (function expr() {\n                            var id = lex().id;\n                            if (id === \"{\") {\n                                return stop_at(\n                                    \"expected_a_b\",\n                                    line,\n                                    column,\n                                    \"}\",\n                                    \"{\"\n                                );\n                            }\n                            if (id !== \"}\") {\n                                return expr();\n                            }\n                        }());\n                        return part();\n                    }\n                }());\n                source_line = source_line.slice(1);\n                column += 1;\n                mega_mode = false;\n                return make(\"`\");\n\n// The token is a // comment.\n\n            case \"//\":\n                snippet = source_line;\n                source_line = \"\";\n                the_token = comment(snippet);\n                if (mega_mode) {\n                    warn(\"unexpected_comment\", the_token, \"`\");\n                }\n                return the_token;\n\n// The token is a /* comment.\n\n            case \"/*\":\n                array = [];\n                if (source_line.charAt(0) === \"/\") {\n                    warn_at(\"unexpected_a\", line, column + i, \"/\");\n                }\n                (function next() {\n                    if (source_line > \"\") {\n                        i = source_line.search(rx_star_slash);\n                        if (i >= 0) {\n                            return;\n                        }\n                        j = source_line.search(rx_slash_star);\n                        if (j >= 0) {\n                            warn_at(\"nested_comment\", line, column + j);\n                        }\n                    }\n                    array.push(source_line);\n                    source_line = next_line();\n                    if (source_line === undefined) {\n                        return stop_at(\"unclosed_comment\", line, column);\n                    }\n                    return next();\n                }());\n                snippet = source_line.slice(0, i);\n                j = snippet.search(rx_slash_star_or_slash);\n                if (j >= 0) {\n                    warn_at(\"nested_comment\", line, column + j);\n                }\n                array.push(snippet);\n                column += i + 2;\n                source_line = source_line.slice(i + 2);\n                return comment(array);\n\n// The token is a slash.\n\n            case \"/\":\n\n// The / can be a division operator or the beginning of a regular expression\n// literal. It is not possible to know which without doing a complete parse.\n// We want to complete the tokenization before we begin to parse, so we will\n// estimate. This estimator can fail in some cases. For example, it cannot\n// know if \"}\" is ending a block or ending an object literal, so it can\n// behave incorrectly in that case; it is not meaningful to divide an\n// object, so it is likely that we can get away with it. We avoided the worst\n// cases by eliminating automatic semicolon insertion.\n\n                if (prior.identifier) {\n                    if (!prior.dot) {\n                        switch (prior.id) {\n                        case \"return\":\n                            return regexp();\n                        case \"(begin)\":\n                        case \"case\":\n                        case \"delete\":\n                        case \"in\":\n                        case \"instanceof\":\n                        case \"new\":\n                        case \"typeof\":\n                        case \"void\":\n                        case \"yield\":\n                            the_token = regexp();\n                            return stop(\"unexpected_a\", the_token);\n                        }\n                    }\n                } else {\n                    last = prior.id.charAt(prior.id.length - 1);\n                    if (\"(,=:?[\".indexOf(last) >= 0) {\n                        return regexp();\n                    }\n                    if (\"!&|{};~+-*%/^<>\".indexOf(last) >= 0) {\n                        the_token = regexp();\n                        warn(\"wrap_regexp\", the_token);\n                        return the_token;\n                    }\n                }\n                if (source_line.charAt(0) === \"/\") {\n                    column += 1;\n                    source_line = source_line.slice(1);\n                    snippet = \"/=\";\n                    warn_at(\"unexpected_a\", line, column, \"/=\");\n                }\n                break;\n            }\n            return make(snippet);\n        }\n\n// This is the only loop in JSLint. It will turn into a recursive call to lex\n// when ES6 has been finished and widely deployed and adopted.\n\n        while (true) {\n            if (lex().id === \"(end)\") {\n                break;\n            }\n        }\n    }\n\n// Parsing:\n\n// Parsing weaves the tokens into an abstract syntax tree. During that process,\n// a token may be given any of these properties:\n\n//      arity       string\n//      label       identifier\n//      name        identifier\n//      expression  expressions\n//      block       statements\n//      else        statements (else, default, catch)\n\n// Specialized tokens may have additional properties.\n\n    function survey(name) {\n        var id = name.id;\n\n// Tally the property name. If it is a string, only tally strings that conform\n// to the identifier rules.\n\n        if (id === \"(string)\") {\n            id = name.value;\n            if (!rx_identifier.test(id)) {\n                return id;\n            }\n        } else if (id === \"`\") {\n            if (name.value.length === 1) {\n                id = name.value[0].value;\n                if (!rx_identifier.test(id)) {\n                    return id;\n                }\n            }\n        } else if (!name.identifier) {\n            return stop(\"expected_identifier_a\", name);\n        }\n\n// If we have seen this name before, increment its count.\n\n        if (typeof property[id] === \"number\") {\n            property[id] += 1;\n\n// If this is the first time seeing this property name, and if there is a\n// tenure list, then it must be on the list. Otherwise, it must conform to\n// the rules for good property names.\n\n        } else {\n            if (tenure !== undefined) {\n                if (tenure[id] !== true) {\n                    warn(\"unregistered_property_a\", name);\n                }\n            } else {\n                if (name.identifier && rx_bad_property.test(id)) {\n                    warn(\"bad_property_a\", name);\n                }\n            }\n            property[id] = 1;\n        }\n        return id;\n    }\n\n    function dispense() {\n\n// Deliver the next token, skipping the comments.\n\n        var cadet = tokens[token_nr];\n        token_nr += 1;\n        if (cadet.id === \"(comment)\") {\n            if (json_mode) {\n                warn(\"unexpected_a\", cadet);\n            }\n            return dispense();\n        } else {\n            return cadet;\n        }\n    }\n\n    function lookahead() {\n\n// Look ahead one token without advancing.\n\n        var old_token_nr = token_nr;\n        var cadet = dispense(true);\n        token_nr = old_token_nr;\n        return cadet;\n    }\n\n    function advance(id, match) {\n\n// Produce the next token.\n\n// Attempt to give helpful names to anonymous functions.\n\n        if (token.identifier && token.id !== \"function\") {\n            anon = token.id;\n        } else if (token.id === \"(string)\" && rx_identifier.test(token.value)) {\n            anon = token.value;\n        }\n\n// Attempt to match next_token with an expected id.\n\n        if (id !== undefined && next_token.id !== id) {\n            return (match === undefined)\n                ? stop(\"expected_a_b\", next_token, id, artifact())\n                : stop(\n                    \"expected_a_b_from_c_d\",\n                    next_token,\n                    id,\n                    artifact(match),\n                    artifact_line(match),\n                    artifact(next_token)\n                );\n        }\n\n// Promote the tokens, skipping comments.\n\n        token = next_token;\n        next_token = dispense();\n        if (next_token.id === \"(end)\") {\n            token_nr -= 1;\n        }\n    }\n\n// Parsing of JSON is simple:\n\n    function json_value() {\n\n        function json_object() {\n            var brace = next_token;\n            var object = empty();\n            advance(\"{\");\n            if (next_token.id !== \"}\") {\n                (function next() {\n                    if (next_token.quote !== \"\\\"\") {\n                        warn(\"unexpected_a\", next_token, next_token.quote);\n                    }\n                    advance(\"(string)\");\n                    if (object[token.value] !== undefined) {\n                        warn(\"duplicate_a\", token);\n                    } else if (token.value === \"__proto__\") {\n                        warn(\"bad_property_a\", token);\n                    } else {\n                        object[token.value] = token;\n                    }\n                    advance(\":\");\n                    json_value();\n                    if (next_token.id === \",\") {\n                        advance(\",\");\n                        return next();\n                    }\n                }());\n            }\n            advance(\"}\", brace);\n        }\n\n        function json_array() {\n            var bracket = next_token;\n            advance(\"[\");\n            if (next_token.id !== \"]\") {\n                (function next() {\n                    json_value();\n                    if (next_token.id === \",\") {\n                        advance(\",\");\n                        return next();\n                    }\n                }());\n            }\n            advance(\"]\", bracket);\n        }\n\n        switch (next_token.id) {\n        case \"{\":\n            json_object();\n            break;\n        case \"[\":\n            json_array();\n            break;\n        case \"true\":\n        case \"false\":\n        case \"null\":\n            advance();\n            break;\n        case \"(number)\":\n            if (!rx_JSON_number.test(next_token.value)) {\n                warn(\"unexpected_a\");\n            }\n            advance();\n            break;\n        case \"(string)\":\n            if (next_token.quote !== \"\\\"\") {\n                warn(\"unexpected_a\", next_token, next_token.quote);\n            }\n            advance();\n            break;\n        case \"-\":\n            advance(\"-\");\n            advance(\"(number)\");\n            break;\n        default:\n            stop(\"unexpected_a\");\n        }\n    }\n\n// Now we parse JavaScript.\n\n    function enroll(name, role, readonly) {\n\n// Enroll a name into the current function context. The role can be exception,\n// function, label, parameter, or variable. We look for variable redefinition\n// because it causes confusion.\n\n        var id = name.id;\n\n// Reserved words may not be enrolled.\n\n        if (syntax[id] !== undefined && id !== \"ignore\") {\n            warn(\"reserved_a\", name);\n        } else {\n\n// Has the name been enrolled in this context?\n\n            var earlier = functionage.context[id];\n            if (earlier) {\n                warn(\n                    \"redefinition_a_b\",\n                    name,\n                    name.id,\n                    earlier.line + fudge\n                );\n\n// Has the name been enrolled in an outer context?\n\n            } else {\n                stack.forEach(function (value) {\n                    var item = value.context[id];\n                    if (item !== undefined) {\n                        earlier = item;\n                    }\n                });\n                if (earlier) {\n                    if (id === \"ignore\") {\n                        if (earlier.role === \"variable\") {\n                            warn(\"unexpected_a\", name);\n                        }\n                    } else {\n                        if ((\n                            role !== \"exception\" ||\n                            earlier.role !== \"exception\"\n                        ) && role !== \"parameter\") {\n                            warn(\n                                \"redefinition_a_b\",\n                                name,\n                                name.id,\n                                earlier.line + fudge\n                            );\n                        }\n                    }\n                }\n\n// Enroll it.\n\n                functionage.context[id] = name;\n                name.dead = true;\n                name.function = functionage;\n                name.init = false;\n                name.role = role;\n                name.used = 0;\n                name.writable = !readonly;\n            }\n        }\n    }\n\n    function expression(rbp, initial) {\n\n// This is the heart of the Pratt parser. I retained Pratt's nomenclature.\n// They are elements of the parsing method called Top Down Operator Precedence.\n\n// nud     Null denotation\n// led     Left denotation\n// lbp     Left binding power\n// rbp     Right binding power\n\n// It processes a nud (variable, constant, prefix operator). It will then\n// process leds (infix operators) until the bind powers cause it to stop. It\n// returns the expression's parse tree.\n\n        var left;\n        var the_symbol;\n\n// Statements will have already advanced, so advance now only if the token is\n// not the first of a statement,\n\n        if (!initial) {\n            advance();\n        }\n        the_symbol = syntax[token.id];\n        if (the_symbol !== undefined && the_symbol.nud !== undefined) {\n            left = the_symbol.nud();\n        } else if (token.identifier) {\n            left = token;\n            left.arity = \"variable\";\n        } else {\n            return stop(\"unexpected_a\", token);\n        }\n        (function right() {\n            the_symbol = syntax[next_token.id];\n            if (\n                the_symbol !== undefined &&\n                the_symbol.led !== undefined &&\n                rbp < the_symbol.lbp\n            ) {\n                advance();\n                left = the_symbol.led(left);\n                return right();\n            }\n        }());\n        return left;\n    }\n\n    function condition() {\n\n// Parse the condition part of a do, if, while.\n\n        var the_paren = next_token;\n        var the_value;\n        the_paren.free = true;\n        advance(\"(\");\n        the_value = expression(0);\n        advance(\")\");\n        if (the_value.wrapped === true) {\n            warn(\"unexpected_a\", the_paren);\n        }\n        switch (the_value.id) {\n        case \"?\":\n        case \"~\":\n        case \"&\":\n        case \"|\":\n        case \"^\":\n        case \"<<\":\n        case \">>\":\n        case \">>>\":\n        case \"+\":\n        case \"-\":\n        case \"*\":\n        case \"/\":\n        case \"%\":\n        case \"typeof\":\n        case \"(number)\":\n        case \"(string)\":\n            warn(\"unexpected_a\", the_value);\n            break;\n        }\n        return the_value;\n    }\n\n    function is_weird(thing) {\n        return (\n            thing.id === \"(regexp)\" ||\n            thing.id === \"{\" ||\n            thing.id === \"=>\" ||\n            thing.id === \"function\" ||\n            (thing.id === \"[\" && thing.arity === \"unary\")\n        );\n    }\n\n    function are_similar(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (Array.isArray(a)) {\n            return (\n                Array.isArray(b) &&\n                a.length === b.length &&\n                a.every(function (value, index) {\n                    return are_similar(value, b[index]);\n                })\n            );\n        }\n        if (Array.isArray(b)) {\n            return false;\n        }\n        if (a.id === \"(number)\" && b.id === \"(number)\") {\n            return a.value === b.value;\n        }\n        var a_string;\n        var b_string;\n        if (a.id === \"(string)\") {\n            a_string = a.value;\n        } else if (a.id === \"`\" && a.constant) {\n            a_string = a.value[0];\n        }\n        if (b.id === \"(string)\") {\n            b_string = b.value;\n        } else if (b.id === \"`\" && b.constant) {\n            b_string = b.value[0];\n        }\n        if (typeof a_string === \"string\") {\n            return a_string === b_string;\n        }\n        if (is_weird(a) || is_weird(b)) {\n            return false;\n        }\n        if (a.arity === b.arity && a.id === b.id) {\n            if (a.id === \".\") {\n                return are_similar(a.expression, b.expression) &&\n                        are_similar(a.name, b.name);\n            }\n            switch (a.arity) {\n            case \"unary\":\n                return are_similar(a.expression, b.expression);\n            case \"binary\":\n                return (\n                    a.id !== \"(\" &&\n                    are_similar(a.expression[0], b.expression[0]) &&\n                    are_similar(a.expression[1], b.expression[1])\n                );\n            case \"ternary\":\n                return (\n                    are_similar(a.expression[0], b.expression[0]) &&\n                    are_similar(a.expression[1], b.expression[1]) &&\n                    are_similar(a.expression[2], b.expression[2])\n                );\n            case \"function\":\n            case \"regexp\":\n                return false;\n            default:\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function semicolon() {\n\n// Try to match a semicolon.\n\n        if (next_token.id === \";\") {\n            advance(\";\");\n        } else {\n            warn_at(\n                \"expected_a_b\",\n                token.line,\n                token.thru,\n                \";\",\n                artifact(next_token)\n            );\n        }\n        anon = \"anonymous\";\n    }\n\n    function statement() {\n\n// Parse a statement. Any statement may have a label, but only four statements\n// have use for one. A statement can be one of the standard statements, or\n// an assignment expression, or an invocation expression.\n\n        var first;\n        var the_label;\n        var the_statement;\n        var the_symbol;\n        advance();\n        if (token.identifier && next_token.id === \":\") {\n            the_label = token;\n            if (the_label.id === \"ignore\") {\n                warn(\"unexpected_a\", the_label);\n            }\n            advance(\":\");\n            switch (next_token.id) {\n            case \"do\":\n            case \"for\":\n            case \"switch\":\n            case \"while\":\n                enroll(the_label, \"label\", true);\n                the_label.init = true;\n                the_label.dead = false;\n                the_statement = statement();\n                the_statement.label = the_label;\n                the_statement.statement = true;\n                return the_statement;\n            default:\n                advance();\n                warn(\"unexpected_label_a\", the_label);\n            }\n        }\n\n// Parse the statement.\n\n        first = token;\n        first.statement = true;\n        the_symbol = syntax[first.id];\n        if (the_symbol !== undefined && the_symbol.fud !== undefined) {\n            the_symbol.disrupt = false;\n            the_symbol.statement = true;\n            the_statement = the_symbol.fud();\n        } else {\n\n// It is an expression statement.\n\n            the_statement = expression(0, true);\n            if (the_statement.wrapped && the_statement.id !== \"(\") {\n                warn(\"unexpected_a\", first);\n            }\n            semicolon();\n        }\n        if (the_label !== undefined) {\n            the_label.dead = true;\n        }\n        return the_statement;\n    }\n\n    function statements() {\n\n// Parse a list of statements. Give a warning if an unreachable statement\n// follows a disruptive statement.\n\n        var array = [];\n        (function next(disrupt) {\n            var a_statement;\n            switch (next_token.id) {\n            case \"}\":\n            case \"case\":\n            case \"default\":\n            case \"else\":\n            case \"(end)\":\n                break;\n            default:\n                a_statement = statement();\n                array.push(a_statement);\n                if (disrupt) {\n                    warn(\"unreachable_a\", a_statement);\n                }\n                return next(a_statement.disrupt);\n            }\n        }(false));\n        return array;\n    }\n\n    function not_top_level(thing) {\n\n// Some features should not be at the outermost level.\n\n        if (functionage === global) {\n            warn(\"unexpected_at_top_level_a\", thing);\n        }\n    }\n\n    function top_level_only(the_thing) {\n\n// Some features must be at the most outermost level.\n\n        if (blockage !== global) {\n            warn(\"misplaced_a\", the_thing);\n        }\n    }\n\n    function block(special) {\n\n// Parse a block, a sequence of statements wrapped in braces.\n//  special \"body\"      The block is a function body.\n//          \"ignore\"    No warning on an empty block.\n//          \"naked\"     No advance.\n//          undefined   An ordinary block.\n\n        var stmts;\n        var the_block;\n        if (special !== \"naked\") {\n            advance(\"{\");\n        }\n        the_block = token;\n        the_block.arity = \"statement\";\n        the_block.body = special === \"body\";\n\n// All top level function bodies should include the \"use strict\" pragma unless\n// the whole file is strict or the file is a module or the function parameters\n// use es6 syntax.\n\n        if (\n            special === \"body\" &&\n            stack.length === 1 &&\n            next_token.value === \"use strict\"\n        ) {\n            the_block.strict = next_token;\n            next_token.statement = true;\n            advance(\"(string)\");\n            advance(\";\");\n        }\n        stmts = statements();\n        the_block.block = stmts;\n        if (stmts.length === 0) {\n            if (!option.devel && special !== \"ignore\") {\n                warn(\"empty_block\", the_block);\n            }\n            the_block.disrupt = false;\n        } else {\n            the_block.disrupt = stmts[stmts.length - 1].disrupt;\n        }\n        advance(\"}\");\n        return the_block;\n    }\n\n    function mutation_check(the_thing) {\n\n// The only expressions that may be assigned to are\n//      e.b\n//      e[b]\n//      v\n\n        if (\n            the_thing.id !== \".\" &&\n            the_thing.arity !== \"variable\" &&\n            (the_thing.id !== \"[\" || the_thing.arity !== \"binary\")\n        ) {\n            warn(\"bad_assignment_a\", the_thing);\n            return false;\n        }\n        return true;\n    }\n\n    function left_check(left, right) {\n\n// Warn if the left is not one of these:\n//      e.b\n//      e[b]\n//      e()\n//      identifier\n\n        var id = left.id;\n        if (\n            !left.identifier &&\n            (\n                left.arity !== \"binary\" ||\n                (id !== \".\" && id !== \"(\" && id !== \"[\")\n            )\n        ) {\n            warn(\"unexpected_a\", right);\n            return false;\n        }\n        return true;\n    }\n\n// These functions are used to specify the grammar of our language:\n\n    function symbol(id, bp) {\n\n// Make a symbol if it does not already exist in the language's syntax.\n\n        var the_symbol = syntax[id];\n        if (the_symbol === undefined) {\n            the_symbol = empty();\n            the_symbol.id = id;\n            the_symbol.lbp = bp || 0;\n            syntax[id] = the_symbol;\n        }\n        return the_symbol;\n    }\n\n    function assignment(id) {\n\n// Make an assignment operator. The one true assignment is different because\n// its left side, when it is a variable, is not treated as an expression.\n// That case is special because that is when a variable gets initialized. The\n// other assignment operators can modify, but they cannot initialize.\n\n        var the_symbol = symbol(id, 20);\n        the_symbol.led = function (left) {\n            var the_token = token;\n            var right;\n            the_token.arity = \"assignment\";\n            right = expression(20 - 1);\n            if (id === \"=\" && left.arity === \"variable\") {\n                the_token.names = left;\n                the_token.expression = right;\n            } else {\n                the_token.expression = [left, right];\n            }\n            switch (right.arity) {\n            case \"assignment\":\n            case \"pre\":\n            case \"post\":\n                warn(\"unexpected_a\", right);\n                break;\n            }\n            if (\n                option.es6 &&\n                left.arity === \"unary\" &&\n                (left.id === \"[\" || left.id === \"{\")\n            ) {\n                warn(\"expected_a_before_b\", left, \"const\", left.id);\n            } else {\n                mutation_check(left);\n            }\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function constant(id, type, value) {\n\n// Make a constant symbol.\n\n        var the_symbol = symbol(id);\n        the_symbol.constant = true;\n        the_symbol.nud = (typeof value === \"function\")\n            ? value\n            : function () {\n                token.constant = true;\n                if (value !== undefined) {\n                    token.value = value;\n                }\n                return token;\n            };\n        the_symbol.type = type;\n        the_symbol.value = value;\n        return the_symbol;\n    }\n\n    function infix(id, bp, f) {\n\n// Make an infix operator.\n\n        var the_symbol = symbol(id, bp);\n        the_symbol.led = function (left) {\n            var the_token = token;\n            the_token.arity = \"binary\";\n            if (f !== undefined) {\n                return f(left);\n            }\n            the_token.expression = [left, expression(bp)];\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function post(id) {\n\n// Make one of the post operators.\n\n        var the_symbol = symbol(id, 150);\n        the_symbol.led = function (left) {\n            token.expression = left;\n            token.arity = \"post\";\n            mutation_check(token.expression);\n            return token;\n        };\n        return the_symbol;\n    }\n\n    function pre(id) {\n\n// Make one of the pre operators.\n\n        var the_symbol = symbol(id);\n        the_symbol.nud = function () {\n            var the_token = token;\n            the_token.arity = \"pre\";\n            the_token.expression = expression(150);\n            mutation_check(the_token.expression);\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function prefix(id, f) {\n\n// Make a prefix operator.\n\n        var the_symbol = symbol(id);\n        the_symbol.nud = function () {\n            var the_token = token;\n            the_token.arity = \"unary\";\n            if (typeof f === \"function\") {\n                return f();\n            }\n            the_token.expression = expression(150);\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function stmt(id, f) {\n\n// Make a statement.\n\n        var the_symbol = symbol(id);\n        the_symbol.fud = function () {\n            token.arity = \"statement\";\n            return f();\n        };\n        return the_symbol;\n    }\n\n    function ternary(id1, id2) {\n\n// Make a ternary operator.\n\n        var the_symbol = symbol(id1, 30);\n        the_symbol.led = function (left) {\n            var the_token = token;\n            var second = expression(20);\n            advance(id2);\n            token.arity = \"ternary\";\n            the_token.arity = \"ternary\";\n            the_token.expression = [left, second, expression(10)];\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n// Begin defining the language.\n\n    syntax = empty();\n\n    symbol(\"}\");\n    symbol(\")\");\n    symbol(\"]\");\n    symbol(\",\");\n    symbol(\";\");\n    symbol(\":\");\n    symbol(\"*/\");\n    symbol(\"await\");\n    symbol(\"case\");\n    symbol(\"catch\");\n    symbol(\"class\");\n    symbol(\"default\");\n    symbol(\"else\");\n    symbol(\"enum\");\n    symbol(\"finally\");\n    symbol(\"implements\");\n    symbol(\"interface\");\n    symbol(\"package\");\n    symbol(\"private\");\n    symbol(\"protected\");\n    symbol(\"public\");\n    symbol(\"static\");\n    symbol(\"super\");\n    symbol(\"void\");\n    symbol(\"yield\");\n\n    constant(\"(number)\", \"number\");\n    constant(\"(regexp)\", \"regexp\");\n    constant(\"(string)\", \"string\");\n    constant(\"arguments\", \"object\", function () {\n        if (option.es6) {\n            warn(\"unexpected_a\", token);\n        }\n        return token;\n    });\n    constant(\"eval\", \"function\", function () {\n        if (!option.eval) {\n            warn(\"unexpected_a\", token);\n        } else if (next_token.id !== \"(\") {\n            warn(\"expected_a_before_b\", next_token, \"(\", artifact());\n        }\n        return token;\n    });\n    constant(\"false\", \"boolean\", false);\n    constant(\"Function\", \"function\", function () {\n        if (!option.eval) {\n            warn(\"unexpected_a\", token);\n        } else if (next_token.id !== \"(\") {\n            warn(\"expected_a_before_b\", next_token, \"(\", artifact());\n        }\n        return token;\n    });\n    constant(\"ignore\", \"undefined\", function () {\n        warn(\"unexpected_a\", token);\n        return token;\n    });\n    constant(\"Infinity\", \"number\", Infinity);\n    constant(\"isNaN\", \"function\", function () {\n        if (option.es6) {\n            warn(\"expected_a_b\", token, \"Number.isNaN\", \"isNaN\");\n        }\n        return token;\n    });\n    constant(\"NaN\", \"number\", NaN);\n    constant(\"null\", \"null\", null);\n    constant(\"this\", \"object\", function () {\n        if (!option.this) {\n            warn(\"unexpected_a\", token);\n        }\n        return token;\n    });\n    constant(\"true\", \"boolean\", true);\n    constant(\"undefined\", \"undefined\");\n\n    assignment(\"=\");\n    assignment(\"+=\");\n    assignment(\"-=\");\n    assignment(\"*=\");\n    assignment(\"/=\");\n    assignment(\"%=\");\n    assignment(\"&=\");\n    assignment(\"|=\");\n    assignment(\"^=\");\n    assignment(\"<<=\");\n    assignment(\">>=\");\n    assignment(\">>>=\");\n\n    infix(\"||\", 40);\n    infix(\"&&\", 50);\n    infix(\"|\", 70);\n    infix(\"^\", 80);\n    infix(\"&\", 90);\n    infix(\"==\", 100);\n    infix(\"===\", 100);\n    infix(\"!=\", 100);\n    infix(\"!==\", 100);\n    infix(\"<\", 110);\n    infix(\">\", 110);\n    infix(\"<=\", 110);\n    infix(\">=\", 110);\n    infix(\"in\", 110);\n    infix(\"instanceof\", 110);\n    infix(\"<<\", 120);\n    infix(\">>\", 120);\n    infix(\">>>\", 120);\n    infix(\"+\", 130);\n    infix(\"-\", 130);\n    infix(\"*\", 140);\n    infix(\"/\", 140);\n    infix(\"%\", 140);\n    infix(\"(\", 160, function (left) {\n        var the_paren = token;\n        var the_argument;\n        if (left.id !== \"function\") {\n            left_check(left, the_paren);\n        }\n        if (functionage.arity === \"statement\" && left.identifier) {\n            functionage.name.calls[left.id] = left;\n        }\n        the_paren.expression = [left];\n        if (next_token.id !== \")\") {\n            (function next() {\n                var ellipsis;\n                if (next_token.id === \"...\") {\n                    if (!option.es6) {\n                        warn(\"es6\");\n                    }\n                    ellipsis = true;\n                    advance(\"...\");\n                }\n                the_argument = expression(10);\n                if (ellipsis) {\n                    the_argument.ellipsis = true;\n                }\n                the_paren.expression.push(the_argument);\n                if (next_token.id === \",\") {\n                    advance(\",\");\n                    return next();\n                }\n            }());\n        }\n        advance(\")\", the_paren);\n        if (the_paren.expression.length === 2) {\n            the_paren.free = true;\n            if (the_argument.wrapped === true) {\n                warn(\"unexpected_a\", the_paren);\n            }\n            if (the_argument.id === \"(\") {\n                the_argument.wrapped = true;\n            }\n        } else {\n            the_paren.free = false;\n        }\n        return the_paren;\n    });\n    infix(\".\", 170, function (left) {\n        var the_token = token;\n        var name = next_token;\n        if (\n            (left.id !== \"(string)\" || name.id !== \"indexOf\") &&\n            (left.id !== \"[\" || (\n                name.id !== \"concat\" && name.id !== \"forEach\"\n            )) &&\n            (left.id !== \"+\" || name.id !== \"slice\") &&\n            (left.id !== \"(regexp)\" || (\n                name.id !== \"exec\" && name.id !== \"test\"\n            ))\n        ) {\n            left_check(left, the_token);\n        }\n        if (!name.identifier) {\n            stop(\"expected_identifier_a\");\n        }\n        advance();\n        survey(name);\n\n// The property name is not an expression.\n\n        the_token.name = name;\n        the_token.expression = left;\n        return the_token;\n    });\n    infix(\"[\", 170, function (left) {\n        var the_token = token;\n        var the_subscript = expression(0);\n        if (the_subscript.id === \"(string)\" || the_subscript.id === \"`\") {\n            var name = survey(the_subscript);\n            if (rx_identifier.test(name)) {\n                warn(\"subscript_a\", the_subscript, name);\n            }\n        }\n        left_check(left, the_token);\n        the_token.expression = [left, the_subscript];\n        advance(\"]\");\n        return the_token;\n    });\n    infix(\"=>\", 170, function (left) {\n        return stop(\"wrap_parameter\", left);\n    });\n\n    function do_tick() {\n        var the_tick = token;\n        if (!option.es6) {\n            warn(\"es6\", the_tick);\n        }\n        the_tick.value = [];\n        the_tick.expression = [];\n        if (next_token.id !== \"`\") {\n            (function part() {\n                advance(\"(string)\");\n                the_tick.value.push(token);\n                if (next_token.id === \"${\") {\n                    advance(\"${\");\n                    the_tick.expression.push(expression(0));\n                    advance(\"}\");\n                    return part();\n                }\n            }());\n        }\n        advance(\"`\");\n        return the_tick;\n    }\n\n    infix(\"`\", 160, function (left) {\n        var the_tick = do_tick();\n        left_check(left, the_tick);\n        the_tick.expression = [left].concat(the_tick.expression);\n        return the_tick;\n    });\n\n    post(\"++\");\n    post(\"--\");\n    pre(\"++\");\n    pre(\"--\");\n\n    prefix(\"+\");\n    prefix(\"-\");\n    prefix(\"~\");\n    prefix(\"!\");\n    prefix(\"!!\");\n    prefix(\"[\", function () {\n        var the_token = token;\n        the_token.expression = [];\n        if (next_token.id !== \"]\") {\n            (function next() {\n                var element;\n                var ellipsis = false;\n                if (next_token.id === \"...\") {\n                    ellipsis = true;\n                    if (!option.es6) {\n                        warn(\"es6\");\n                    }\n                    advance(\"...\");\n                }\n                element = expression(10);\n                if (ellipsis) {\n                    element.ellipsis = true;\n                }\n                the_token.expression.push(element);\n                if (next_token.id === \",\") {\n                    advance(\",\");\n                    return next();\n                }\n            }());\n        }\n        advance(\"]\");\n        return the_token;\n    });\n    prefix(\"/=\", function () {\n        stop(\"expected_a_b\", token, \"/\\\\=\", \"/=\");\n    });\n    prefix(\"=>\", function () {\n        return stop(\"expected_a_before_b\", token, \"()\", \"=>\");\n    });\n    prefix(\"new\", function () {\n        var the_new = token;\n        var right = expression(160);\n        if (next_token.id !== \"(\") {\n            warn(\"expected_a_before_b\", next_token, \"()\", artifact(next_token));\n        }\n        the_new.expression = right;\n        return the_new;\n    });\n    prefix(\"typeof\");\n    prefix(\"void\", function () {\n        var the_void = token;\n        warn(\"unexpected_a\", the_void);\n        the_void.expression = expression(0);\n        return the_void;\n    });\n\n    function parameter_list() {\n        var complex = false;\n        var list = [];\n        var signature = [\"(\"];\n        if (next_token.id !== \")\" && next_token.id !== \"(end)\") {\n            (function parameter() {\n                var ellipsis = false;\n                var param;\n                if (next_token.id === \"{\") {\n                    complex = true;\n                    if (!option.es6) {\n                        warn(\"es6\");\n                    }\n                    param = next_token;\n                    param.names = [];\n                    advance(\"{\");\n                    signature.push(\"{\");\n                    (function subparameter() {\n                        var subparam = next_token;\n                        if (!subparam.identifier) {\n                            return stop(\"expected_identifier_a\");\n                        }\n                        survey(subparam);\n                        advance();\n                        signature.push(subparam.id);\n                        if (next_token.id === \":\") {\n                            advance(\":\");\n                            advance();\n                            token.label = subparam;\n                            subparam = token;\n                            if (!subparam.identifier) {\n                                return stop(\"expected_identifier_a\");\n                            }\n                        }\n                        param.names.push(subparam);\n                        if (next_token.id === \",\") {\n                            advance(\",\");\n                            signature.push(\", \");\n                            return subparameter();\n                        }\n                    }());\n                    list.push(param);\n                    advance(\"}\");\n                    signature.push(\"}\");\n                    if (next_token.id === \",\") {\n                        advance(\",\");\n                        signature.push(\", \");\n                        return parameter();\n                    }\n                } else if (next_token.id === \"[\") {\n                    complex = true;\n                    if (!option.es6) {\n                        warn(\"es6\");\n                    }\n                    param = next_token;\n                    param.names = [];\n                    advance(\"[\");\n                    signature.push(\"[]\");\n                    (function subparameter() {\n                        var subparam = next_token;\n                        if (!subparam.identifier) {\n                            return stop(\"expected_identifier_a\");\n                        }\n                        advance();\n                        param.names.push(subparam);\n                        if (next_token.id === \",\") {\n                            advance(\",\");\n                            return subparameter();\n                        }\n                    }());\n                    list.push(param);\n                    advance(\"]\");\n                    if (next_token.id === \",\") {\n                        advance(\",\");\n                        signature.push(\", \");\n                        return parameter();\n                    }\n                } else {\n                    if (next_token.id === \"...\") {\n                        complex = true;\n                        if (!option.es6) {\n                            warn(\"es6\");\n                        }\n                        ellipsis = true;\n                        signature.push(\"...\");\n                        advance(\"...\");\n                    }\n                    if (!next_token.identifier) {\n                        return stop(\"expected_identifier_a\");\n                    }\n                    param = next_token;\n                    list.push(param);\n                    advance();\n                    signature.push(param.id);\n                    if (ellipsis) {\n                        param.ellipsis = true;\n                    } else {\n                        if (next_token.id === \"=\") {\n                            complex = true;\n                            if (!option.es6) {\n                                stop(\"unexpected_statement_a\");\n                            }\n                            advance(\"=\");\n                            param.expression = expression(0);\n                        }\n                        if (next_token.id === \",\") {\n                            advance(\",\");\n                            signature.push(\", \");\n                            return parameter();\n                        }\n                    }\n                }\n            }());\n        }\n        advance(\")\");\n        signature.push(\")\");\n        return [list, signature.join(\"\"), complex];\n    }\n\n    function do_function(the_function) {\n        var name;\n        if (the_function === undefined) {\n            the_function = token;\n\n// A function statement must have a name that will be in the parent's scope.\n\n            if (the_function.arity === \"statement\") {\n                if (!next_token.identifier) {\n                    return stop(\"expected_identifier_a\", next_token);\n                }\n                name = next_token;\n                enroll(name, \"variable\", true);\n                the_function.name = name;\n                name.init = true;\n                name.calls = empty();\n                advance();\n            } else if (name === undefined) {\n\n// A function expression may have an optional name.\n\n                if (next_token.identifier) {\n                    name = next_token;\n                    the_function.name = name;\n                    advance();\n                } else {\n                    the_function.name = anon;\n                }\n            }\n        } else {\n            name = the_function.name;\n        }\n        the_function.level = functionage.level + 1;\n        if (mega_mode) {\n            warn(\"unexpected_a\", the_function);\n        }\n\n// Don't make functions in loops. It is inefficient, and it can lead to scoping\n// errors.\n\n        if (functionage.loop > 0) {\n            warn(\"function_in_loop\", the_function);\n        }\n\n// Give the function properties for storing its names and for observing the\n// depth of loops and switches.\n\n        the_function.context = empty();\n        the_function.loop = 0;\n        the_function.switch = 0;\n\n// Push the current function context and establish a new one.\n\n        stack.push(functionage);\n        functions.push(the_function);\n        functionage = the_function;\n        if (the_function.arity !== \"statement\" && typeof name === \"object\") {\n            enroll(name, \"function\", true);\n            name.dead = false;\n            name.init = true;\n            name.used = 1;\n        }\n\n// Parse the parameter list.\n\n        advance(\"(\");\n        token.free = false;\n        token.arity = \"function\";\n        var pl = parameter_list();\n        functionage.parameters = pl[0];\n        functionage.signature = pl[1];\n        functionage.complex = pl[2];\n        functionage.parameters.forEach(function enroll_parameter(name) {\n            if (name.identifier) {\n                enroll(name, \"parameter\", false);\n            } else {\n                name.names.forEach(enroll_parameter);\n            }\n        });\n\n// The function's body is a block.\n\n        the_function.block = block(\"body\");\n        if (\n            the_function.arity === \"statement\" &&\n            next_token.line === token.line\n        ) {\n            return stop(\"unexpected_a\", next_token);\n        }\n        if (next_token.id === \".\" || next_token.id === \"[\") {\n            warn(\"unexpected_a\");\n        }\n\n// Restore the previous context.\n\n        functionage = stack.pop();\n        return the_function;\n    }\n\n    prefix(\"function\", do_function);\n\n    function fart(pl) {\n        if (next_token.id === \";\") {\n            stop(\"wrap_assignment\", token);\n        }\n        advance(\"=>\");\n        var the_arrow = token;\n        the_arrow.arity = \"binary\";\n        the_arrow.name = \"=>\";\n        the_arrow.level = functionage.level + 1;\n        functions.push(the_arrow);\n        if (functionage.loop > 0) {\n            warn(\"function_in_loop\", the_arrow);\n        }\n\n// Give the function properties storing its names and for observing the depth\n// of loops and switches.\n\n        the_arrow.context = empty();\n        the_arrow.loop = 0;\n        the_arrow.switch = 0;\n\n// Push the current function context and establish a new one.\n\n        stack.push(functionage);\n        functionage = the_arrow;\n        the_arrow.parameters = pl[0];\n        the_arrow.signature = pl[1];\n        the_arrow.complex = true;\n        the_arrow.parameters.forEach(function (name) {\n            enroll(name, \"parameter\", true);\n        });\n        if (!option.es6) {\n            warn(\"es6\", the_arrow);\n        }\n        if (next_token.id === \"{\") {\n            warn(\"expected_a_b\", the_arrow, \"function\", \"=>\");\n            the_arrow.block = block(\"body\");\n        } else {\n            the_arrow.expression = expression(0);\n        }\n        functionage = stack.pop();\n        return the_arrow;\n    }\n\n    prefix(\"(\", function () {\n        var the_paren = token;\n        var the_value;\n        var cadet = lookahead().id;\n\n// We can distinguish between a parameter list for => and a wrapped expression\n// with one token of lookahead.\n\n        if (\n            next_token.id === \")\" ||\n            next_token.id === \"...\" ||\n            (next_token.identifier && (cadet === \",\" || cadet === \"=\"))\n        ) {\n            the_paren.free = false;\n            return fart(parameter_list());\n        }\n        the_paren.free = true;\n        the_value = expression(0);\n        if (the_value.wrapped === true) {\n            warn(\"unexpected_a\", the_paren);\n        }\n        the_value.wrapped = true;\n        advance(\")\", the_paren);\n        if (next_token.id === \"=>\") {\n            if (the_value.arity !== \"variable\") {\n                if (the_value.id === \"{\" || the_value.id === \"[\") {\n                    warn(\"expected_a_before_b\", the_paren, \"function\", \"(\");\n                    return stop(\"expected_a_b\", next_token, \"{\", \"=>\");\n                }\n                return stop(\"expected_identifier_a\", the_value);\n            }\n            the_paren.expression = [the_value];\n            return fart([the_paren.expression, \"(\" + the_value.id + \")\"]);\n        }\n        return the_value;\n    });\n    prefix(\"`\", do_tick);\n    prefix(\"{\", function () {\n        var the_brace = token;\n        var seen = empty();\n        the_brace.expression = [];\n        if (next_token.id !== \"}\") {\n            (function member() {\n                var extra;\n                var id;\n                var name = next_token;\n                var value;\n                advance();\n                if (\n                    (name.id === \"get\" || name.id === \"set\") &&\n                    next_token.identifier\n                ) {\n                    extra = name.id + \" \" + next_token.id;\n                    name = next_token;\n                    advance();\n                    id = survey(name);\n                    if (seen[extra] === true || seen[id] === true) {\n                        warn(\"duplicate_a\", name);\n                    }\n                    seen[id] = false;\n                    seen[extra] = true;\n                } else {\n                    id = survey(name);\n                    if (typeof seen[id] === \"boolean\") {\n                        warn(\"duplicate_a\", name);\n                    }\n                    seen[id] = true;\n                }\n                if (name.identifier) {\n                    switch (next_token.id) {\n                    case \"}\":\n                    case \",\":\n                        if (!option.es6) {\n                            warn(\"es6\");\n                        }\n                        if (typeof extra === \"string\") {\n                            advance(\"(\");\n                        }\n                        value = expression(Infinity, true);\n                        break;\n                    case \"(\":\n                        if (!option.es6 && typeof extra !== \"string\") {\n                            warn(\"es6\");\n                        }\n                        value = do_function({\n                            arity: \"unary\",\n                            from: name.from,\n                            id: \"function\",\n                            line: name.line,\n                            name: (typeof extra === \"string\")\n                                ? extra\n                                : id,\n                            thru: name.from\n                        });\n                        break;\n                    default:\n                        if (typeof extra === \"string\") {\n                            advance(\"(\");\n                        }\n                        advance(\":\");\n                        value = expression(0);\n                    }\n                    value.label = name;\n                    if (typeof extra === \"string\") {\n                        value.extra = extra;\n                    }\n                    the_brace.expression.push(value);\n                } else {\n                    advance(\":\");\n                    value = expression(0);\n                    value.label = name;\n                    the_brace.expression.push(value);\n                }\n                if (next_token.id === \",\") {\n                    advance(\",\");\n                    return member();\n                }\n            }());\n        }\n        advance(\"}\");\n        return the_brace;\n    });\n\n    stmt(\";\", function () {\n        warn(\"unexpected_a\", token);\n        return token;\n    });\n    stmt(\"{\", function () {\n        warn(\"naked_block\", token);\n        return block(\"naked\");\n    });\n    stmt(\"break\", function () {\n        var the_break = token;\n        var the_label;\n        if (functionage.loop < 1 && functionage.switch < 1) {\n            warn(\"unexpected_a\", the_break);\n        }\n        the_break.disrupt = true;\n        if (next_token.identifier && token.line === next_token.line) {\n            the_label = functionage.context[next_token.id];\n            if (\n                the_label === undefined ||\n                the_label.role !== \"label\" ||\n                the_label.dead\n            ) {\n                warn((the_label !== undefined && the_label.dead)\n                    ? \"out_of_scope_a\"\n                    : \"not_label_a\");\n            } else {\n                the_label.used += 1;\n            }\n            the_break.label = next_token;\n            advance();\n        }\n        advance(\";\");\n        return the_break;\n    });\n\n    function do_var() {\n        var the_statement = token;\n        var is_const = the_statement.id === \"const\";\n        the_statement.names = [];\n\n// A program may use var or let, but not both, and let and const require\n// option.es6.\n\n        if (is_const) {\n            if (!option.es6) {\n                warn(\"es6\", the_statement);\n            }\n        } else if (var_mode === undefined) {\n            var_mode = the_statement.id;\n            if (!option.es6 && var_mode !== \"var\") {\n                warn(\"es6\", the_statement);\n            }\n        } else if (the_statement.id !== var_mode) {\n            warn(\n                \"expected_a_b\",\n                the_statement,\n                var_mode,\n                the_statement.id\n            );\n        }\n\n// We don't expect to see variables created in switch statements.\n\n        if (functionage.switch > 0) {\n            warn(\"var_switch\", the_statement);\n        }\n        if (functionage.loop > 0 && the_statement.id === \"var\") {\n            warn(\"var_loop\", the_statement);\n        }\n        (function next() {\n            if (next_token.id === \"{\" && the_statement.id !== \"var\") {\n                var the_brace = next_token;\n                the_brace.names = [];\n                advance(\"{\");\n                (function pair() {\n                    if (!next_token.identifier) {\n                        return stop(\"expected_identifier_a\", next_token);\n                    }\n                    var name = next_token;\n                    survey(name);\n                    advance();\n                    if (next_token.id === \":\") {\n                        advance(\":\");\n                        if (!next_token.identifier) {\n                            return stop(\"expected_identifier_a\", next_token);\n                        }\n                        next_token.label = name;\n                        the_brace.names.push(next_token);\n                        enroll(next_token, \"variable\", is_const);\n                        advance();\n                    } else {\n                        the_brace.names.push(name);\n                        enroll(name, \"variable\", is_const);\n                    }\n                    if (next_token.id === \",\") {\n                        advance(\",\");\n                        return pair();\n                    }\n                }());\n                advance(\"}\");\n                advance(\"=\");\n                the_brace.expression = expression(0);\n                the_statement.names.push(the_brace);\n            } else if (next_token.id === \"[\" && the_statement.id !== \"var\") {\n                var the_bracket = next_token;\n                the_bracket.names = [];\n                advance(\"[\");\n                (function element() {\n                    var ellipsis;\n                    if (next_token.id === \"...\") {\n                        ellipsis = true;\n                        advance(\"...\");\n                    }\n                    if (!next_token.identifier) {\n                        return stop(\"expected_identifier_a\", next_token);\n                    }\n                    var name = next_token;\n                    advance();\n                    the_bracket.names.push(name);\n                    enroll(name, \"variable\", the_statement.id === \"const\");\n                    if (ellipsis) {\n                        name.ellipsis = true;\n                    } else if (next_token.id === \",\") {\n                        advance(\",\");\n                        return element();\n                    }\n                }());\n                advance(\"]\");\n                advance(\"=\");\n                the_bracket.expression = expression(0);\n                the_statement.names.push(the_bracket);\n            } else if (next_token.identifier) {\n                var name = next_token;\n                advance();\n                if (name.id === \"ignore\") {\n                    warn(\"unexpected_a\", name);\n                }\n                enroll(name, \"variable\", is_const);\n                if (next_token.id === \"=\" || is_const) {\n                    advance(\"=\");\n                    name.expression = expression(0);\n                    name.init = true;\n                }\n                the_statement.names.push(name);\n            } else {\n                return stop(\"expected_identifier_a\", next_token);\n            }\n            if (next_token.id === \",\") {\n                if (!option.multivar) {\n                    warn(\"expected_a_b\", next_token, \";\", \",\");\n                }\n                advance(\",\");\n                return next();\n            }\n        }());\n        the_statement.open =\n                the_statement.names.length > 1 &&\n                the_statement.line !== the_statement.names[1].line;\n        semicolon();\n        return the_statement;\n    }\n\n    stmt(\"const\", do_var);\n    stmt(\"continue\", function () {\n        var the_continue = token;\n        if (functionage.loop < 1) {\n            warn(\"unexpected_a\", the_continue);\n        }\n        not_top_level(the_continue);\n        the_continue.disrupt = true;\n        warn(\"unexpected_a\", the_continue);\n        advance(\";\");\n        return the_continue;\n    });\n    stmt(\"debugger\", function () {\n        var the_debug = token;\n        if (!option.devel) {\n            warn(\"unexpected_a\", the_debug);\n        }\n        semicolon();\n        return the_debug;\n    });\n    stmt(\"delete\", function () {\n        var the_token = token;\n        var the_value = expression(0);\n        if (\n            (the_value.id !== \".\" && the_value.id !== \"[\") ||\n            the_value.arity !== \"binary\"\n        ) {\n            stop(\"expected_a_b\", the_value, \".\", artifact(the_value));\n        }\n        the_token.expression = the_value;\n        semicolon();\n        return the_token;\n    });\n    stmt(\"do\", function () {\n        var the_do = token;\n        not_top_level(the_do);\n        functionage.loop += 1;\n        the_do.block = block();\n        advance(\"while\");\n        the_do.expression = condition();\n        semicolon();\n        if (the_do.block.disrupt === true) {\n            warn(\"weird_loop\", the_do);\n        }\n        functionage.loop -= 1;\n        return the_do;\n    });\n    stmt(\"export\", function () {\n        var the_export = token;\n        if (!option.es6) {\n            warn(\"es6\", the_export);\n        }\n        if (typeof module_mode === \"object\") {\n            warn(\"unexpected_directive_a\", module_mode, module_mode.directive);\n        }\n        advance(\"default\");\n        if (export_mode) {\n            warn(\"duplicate_a\", token);\n        }\n        module_mode = true;\n        export_mode = true;\n        the_export.expression = expression(0);\n        semicolon();\n        return the_export;\n    });\n    stmt(\"for\", function () {\n        var first;\n        var the_for = token;\n        if (!option.for) {\n            warn(\"unexpected_a\", the_for);\n        }\n        not_top_level(the_for);\n        functionage.loop += 1;\n        advance(\"(\");\n        token.free = true;\n        if (next_token.id === \";\") {\n            return stop(\"expected_a_b\", the_for, \"while (\", \"for (;\");\n        }\n        if (\n            next_token.id === \"var\" ||\n            next_token.id === \"let\" ||\n            next_token.id === \"const\"\n        ) {\n            return stop(\"unexpected_a\");\n        }\n        first = expression(0);\n        if (first.id === \"in\") {\n            if (first.expression[0].arity !== \"variable\") {\n                warn(\"bad_assignment_a\", first.expression[0]);\n            }\n            the_for.name = first.expression[0];\n            the_for.expression = first.expression[1];\n            warn(\"expected_a_b\", the_for, \"Object.keys\", \"for in\");\n        } else {\n            the_for.initial = first;\n            advance(\";\");\n            the_for.expression = expression(0);\n            advance(\";\");\n            the_for.inc = expression(0);\n            if (the_for.inc.id === \"++\") {\n                warn(\"expected_a_b\", the_for.inc, \"+= 1\", \"++\");\n            }\n        }\n        advance(\")\");\n        the_for.block = block();\n        if (the_for.block.disrupt === true) {\n            warn(\"weird_loop\", the_for);\n        }\n        functionage.loop -= 1;\n        return the_for;\n    });\n    stmt(\"function\", do_function);\n    stmt(\"if\", function () {\n        var the_else;\n        var the_if = token;\n        the_if.expression = condition();\n        the_if.block = block();\n        if (next_token.id === \"else\") {\n            advance(\"else\");\n            the_else = token;\n            the_if.else = (next_token.id === \"if\")\n                ? statement()\n                : block();\n            if (the_if.block.disrupt === true) {\n                if (the_if.else.disrupt === true) {\n                    the_if.disrupt = true;\n                } else {\n                    warn(\"unexpected_a\", the_else);\n                }\n            }\n        }\n        return the_if;\n    });\n    stmt(\"import\", function () {\n        var the_import = token;\n        var name;\n        if (!option.es6) {\n            warn(\"es6\", the_import);\n        } else if (typeof module_mode === \"object\") {\n            warn(\"unexpected_directive_a\", module_mode, module_mode.directive);\n        }\n        module_mode = true;\n        if (next_token.identifier) {\n            name = next_token;\n            advance();\n            if (name.id === \"ignore\") {\n                warn(\"unexpected_a\", name);\n            }\n            enroll(name, \"variable\", true);\n            the_import.name = name;\n        } else {\n            var names = [];\n            advance(\"{\");\n            if (next_token.id !== \"}\") {\n                while (true) {\n                    if (!next_token.identifier) {\n                        stop(\"expected_identifier_a\");\n                    }\n                    name = next_token;\n                    advance();\n                    if (name.id === \"ignore\") {\n                        warn(\"unexpected_a\", name);\n                    }\n                    enroll(name, \"variable\", true);\n                    names.push(name);\n                    if (next_token.id !== \",\") {\n                        break;\n                    }\n                    advance(\",\");\n                }\n            }\n            advance(\"}\");\n            the_import.name = names;\n        }\n        advance(\"from\");\n        advance(\"(string)\");\n        the_import.import = token;\n        if (!rx_module.test(token.value)) {\n            warn(\"bad_module_name_a\", token);\n        }\n        imports.push(token.value);\n        semicolon();\n        return the_import;\n    });\n    stmt(\"let\", do_var);\n    stmt(\"return\", function () {\n        var the_return = token;\n        not_top_level(the_return);\n        the_return.disrupt = true;\n        if (next_token.id !== \";\" && the_return.line === next_token.line) {\n            the_return.expression = expression(10);\n        }\n        advance(\";\");\n        return the_return;\n    });\n    stmt(\"switch\", function () {\n        var dups = [];\n        var last;\n        var stmts;\n        var the_cases = [];\n        var the_disrupt = true;\n        var the_switch = token;\n        not_top_level(the_switch);\n        functionage.switch += 1;\n        advance(\"(\");\n        token.free = true;\n        the_switch.expression = expression(0);\n        the_switch.block = the_cases;\n        advance(\")\");\n        advance(\"{\");\n        (function major() {\n            var the_case = next_token;\n            the_case.arity = \"statement\";\n            the_case.expression = [];\n            (function minor() {\n                advance(\"case\");\n                token.switch = true;\n                var exp = expression(0);\n                if (dups.some(function (thing) {\n                    return are_similar(thing, exp);\n                })) {\n                    warn(\"unexpected_a\", exp);\n                }\n                dups.push(exp);\n                the_case.expression.push(exp);\n                advance(\":\");\n                if (next_token.id === \"case\") {\n                    return minor();\n                }\n            }());\n            stmts = statements();\n            if (stmts.length < 1) {\n                warn(\"expected_statements_a\");\n                return;\n            }\n            the_case.block = stmts;\n            the_cases.push(the_case);\n            last = stmts[stmts.length - 1];\n            if (last.disrupt) {\n                if (last.id === \"break\" && last.label === undefined) {\n                    the_disrupt = false;\n                }\n            } else {\n                warn(\n                    \"expected_a_before_b\",\n                    next_token,\n                    \"break;\",\n                    artifact(next_token)\n                );\n            }\n            if (next_token.id === \"case\") {\n                return major();\n            }\n        }());\n        dups = undefined;\n        if (next_token.id === \"default\") {\n            var the_default = next_token;\n            advance(\"default\");\n            token.switch = true;\n            advance(\":\");\n            the_switch.else = statements();\n            if (the_switch.else.length < 1) {\n                warn(\"unexpected_a\", the_default);\n                the_disrupt = false;\n            } else {\n                var the_last = the_switch.else[the_switch.else.length - 1];\n                if (the_last.id === \"break\" && the_last.label === undefined) {\n                    warn(\"unexpected_a\", the_last);\n                    the_last.disrupt = false;\n                }\n                the_disrupt = the_disrupt && the_last.disrupt;\n            }\n        } else {\n            the_disrupt = false;\n        }\n        advance(\"}\", the_switch);\n        functionage.switch -= 1;\n        the_switch.disrupt = the_disrupt;\n        return the_switch;\n    });\n    stmt(\"throw\", function () {\n        var the_throw = token;\n        the_throw.disrupt = true;\n        the_throw.expression = expression(10);\n        semicolon();\n        return the_throw;\n    });\n    stmt(\"try\", function () {\n        var clause = false;\n        var the_catch;\n        var the_disrupt;\n        var the_try = token;\n        the_try.block = block();\n        the_disrupt = the_try.block.disrupt;\n        if (next_token.id === \"catch\") {\n            var ignored = \"ignore\";\n            clause = true;\n            the_catch = next_token;\n            the_try.catch = the_catch;\n            advance(\"catch\");\n            advance(\"(\");\n            if (!next_token.identifier) {\n                return stop(\"expected_identifier_a\", next_token);\n            }\n            if (next_token.id !== \"ignore\") {\n                ignored = undefined;\n                the_catch.name = next_token;\n                enroll(next_token, \"exception\", true);\n            }\n            advance();\n            advance(\")\");\n            the_catch.block = block(ignored);\n            if (the_catch.block.disrupt !== true) {\n                the_disrupt = false;\n            }\n        }\n        if (next_token.id === \"finally\") {\n            clause = true;\n            advance(\"finally\");\n            the_try.else = block();\n            the_disrupt = the_try.else.disrupt;\n        }\n        the_try.disrupt = the_disrupt;\n        if (!clause) {\n            warn(\n                \"expected_a_before_b\",\n                next_token,\n                \"catch\",\n                artifact(next_token)\n            );\n        }\n        return the_try;\n    });\n    stmt(\"var\", do_var);\n    stmt(\"while\", function () {\n        var the_while = token;\n        not_top_level(the_while);\n        functionage.loop += 1;\n        the_while.expression = condition();\n        the_while.block = block();\n        if (the_while.block.disrupt === true) {\n            warn(\"weird_loop\", the_while);\n        }\n        functionage.loop -= 1;\n        return the_while;\n    });\n    stmt(\"with\", function () {\n        stop(\"unexpected_a\", token);\n    });\n\n    ternary(\"?\", \":\");\n\n// Ambulation of the parse tree.\n\n    function action(when) {\n\n// Produce a function that will register task functions that will be called as\n// the tree is traversed.\n\n        return function (arity, id, task) {\n            var a_set = when[arity];\n            var i_set;\n\n// The id parameter is optional. If excluded, the task will be applied to all\n// ids.\n\n            if (typeof id !== \"string\") {\n                task = id;\n                id = \"(all)\";\n            }\n\n// If this arity has no registrations yet, then create a set object to hold\n// them.\n\n            if (a_set === undefined) {\n                a_set = empty();\n                when[arity] = a_set;\n            }\n\n// If this id has no registrations yet, then create a set array to hold them.\n\n            i_set = a_set[id];\n            if (i_set === undefined) {\n                i_set = [];\n                a_set[id] = i_set;\n            }\n\n// Register the task with the arity and the id.\n\n            i_set.push(task);\n        };\n    }\n\n    function amble(when) {\n\n// Produce a function that will act on the tasks registered by an action\n// function while walking the tree.\n\n        return function (the_token) {\n\n// Given a task set that was built by an action function, run all of the\n// relevant tasks on the token.\n\n            var a_set = when[the_token.arity];\n            var i_set;\n\n// If there are tasks associated with the token's arity...\n\n            if (a_set !== undefined) {\n\n// If there are tasks associated with the token's id...\n\n                i_set = a_set[the_token.id];\n                if (i_set !== undefined) {\n                    i_set.forEach(function (task) {\n                        return task(the_token);\n                    });\n                }\n\n// If there are tasks for all ids.\n\n                i_set = a_set[\"(all)\"];\n                if (i_set !== undefined) {\n                    i_set.forEach(function (task) {\n                        return task(the_token);\n                    });\n                }\n            }\n        };\n    }\n\n    var posts = empty();\n    var pres = empty();\n    var preaction = action(pres);\n    var postaction = action(posts);\n    var preamble = amble(pres);\n    var postamble = amble(posts);\n\n    function walk_expression(thing) {\n        if (thing) {\n            if (Array.isArray(thing)) {\n                thing.forEach(walk_expression);\n            } else {\n                preamble(thing);\n                walk_expression(thing.expression);\n                if (thing.id === \"function\") {\n                    walk_statement(thing.block);\n                }\n                switch (thing.arity) {\n                case \"post\":\n                case \"pre\":\n                    warn(\"unexpected_a\", thing);\n                    break;\n                case \"statement\":\n                case \"assignment\":\n                    warn(\"unexpected_statement_a\", thing);\n                    break;\n                }\n                postamble(thing);\n            }\n        }\n    }\n\n    function walk_statement(thing) {\n        if (thing) {\n            if (Array.isArray(thing)) {\n                thing.forEach(walk_statement);\n            } else {\n                preamble(thing);\n                walk_expression(thing.expression);\n                switch (thing.arity) {\n                case \"statement\":\n                case \"assignment\":\n                    break;\n                case \"binary\":\n                    if (thing.id !== \"(\") {\n                        warn(\"unexpected_expression_a\", thing);\n                    }\n                    break;\n                default:\n                    warn((\n                        thing.id === \"(string)\" &&\n                        thing.value === \"use strict\"\n                    )\n                        ? \"unexpected_a\"\n                        : \"unexpected_expression_a\", thing);\n                }\n                walk_statement(thing.block);\n                walk_statement(thing.else);\n                postamble(thing);\n            }\n        }\n    }\n\n    function lookup(thing) {\n        if (thing.arity === \"variable\") {\n\n// Look up the variable in the current context.\n\n            var the_variable = functionage.context[thing.id];\n\n// If it isn't local, search all the other contexts. If there are name\n// collisions, take the most recent.\n\n            if (the_variable === undefined) {\n                stack.forEach(function (outer) {\n                    var a_variable = outer.context[thing.id];\n                    if (\n                        a_variable !== undefined &&\n                        a_variable.role !== \"label\"\n                    ) {\n                        the_variable = a_variable;\n                    }\n                });\n\n// If it isn't in any of those either, perhaps it is a predefined global.\n// If so, add it to the global context.\n\n                if (the_variable === undefined) {\n                    if (declared_globals[thing.id] === undefined) {\n                        warn(\"undeclared_a\", thing);\n                        return;\n                    }\n                    the_variable = {\n                        dead: false,\n                        function: global,\n                        id: thing.id,\n                        init: true,\n                        role: \"variable\",\n                        used: 0,\n                        writable: false\n                    };\n                    global.context[thing.id] = the_variable;\n                }\n                the_variable.closure = true;\n                functionage.context[thing.id] = the_variable;\n            } else if (the_variable.role === \"label\") {\n                warn(\"label_a\", thing);\n            }\n            if (the_variable.dead) {\n                warn(\"out_of_scope_a\", thing);\n            }\n            return the_variable;\n        }\n    }\n\n    function subactivate(name) {\n        name.init = true;\n        name.dead = false;\n        blockage.live.push(name);\n    }\n\n    function preaction_function(thing) {\n        if (thing.arity === \"statement\" && blockage.body !== true) {\n            warn(\"unexpected_a\", thing);\n        }\n        if (thing.level === 1) {\n            if (\n                module_mode === true ||\n                global.strict !== undefined ||\n                thing.complex\n            ) {\n                if (thing.id !== \"=>\" && thing.block.strict !== undefined) {\n                    warn(\"unexpected_a\", thing.block.strict);\n                }\n            } else {\n                if (thing.block.strict === undefined) {\n                    warn(\"use_strict\", thing);\n                }\n            }\n        }\n        stack.push(functionage);\n        block_stack.push(blockage);\n        functionage = thing;\n        blockage = thing;\n        thing.live = [];\n        if (typeof thing.name === \"object\") {\n            thing.name.dead = false;\n            thing.name.init = true;\n        }\n        switch (thing.extra) {\n        case \"get\":\n            if (thing.parameters.length !== 0) {\n                warn(\"bad_get\", thing);\n            }\n            break;\n        case \"set\":\n            if (thing.parameters.length !== 1) {\n                warn(\"bad_set\", thing);\n            }\n            break;\n        }\n        thing.parameters.forEach(function (name) {\n            walk_expression(name.expression);\n            if (name.id === \"{\" || name.id === \"[\") {\n                name.names.forEach(subactivate);\n            } else {\n                name.dead = false;\n                name.init = true;\n            }\n        });\n    }\n\n    function bitwise_check(thing) {\n        if (!option.bitwise && bitwiseop[thing.id] === true) {\n            warn(\"unexpected_a\", thing);\n        }\n        if (\n            thing.id !== \"(\" &&\n            thing.id !== \"&&\" &&\n            thing.id !== \"||\" &&\n            thing.id !== \"=\" &&\n            Array.isArray(thing.expression) &&\n            thing.expression.length === 2 && (\n                relationop[thing.expression[0].id] === true ||\n                relationop[thing.expression[1].id] === true\n            )\n        ) {\n            warn(\"unexpected_a\", thing);\n        }\n    }\n\n    function pop_block() {\n        blockage.live.forEach(function (name) {\n            name.dead = true;\n        });\n        delete blockage.live;\n        blockage = block_stack.pop();\n    }\n\n    function activate(name) {\n        if (name.expression !== undefined) {\n            walk_expression(name.expression);\n            if (name.id === \"{\" || name.id === \"[\") {\n                name.names.forEach(subactivate);\n            } else {\n                name.init = true;\n            }\n        }\n        name.dead = false;\n        blockage.live.push(name);\n    }\n\n    function action_var(thing) {\n        thing.names.forEach(activate);\n    }\n\n    preaction(\"assignment\", bitwise_check);\n    preaction(\"binary\", bitwise_check);\n    preaction(\"binary\", function (thing) {\n        if (relationop[thing.id] === true) {\n            var left = thing.expression[0];\n            var right = thing.expression[1];\n            if (left.id === \"NaN\" || right.id === \"NaN\") {\n                if (option.es6) {\n                    warn(\"number_isNaN\", thing);\n                } else {\n                    warn(\"isNaN\", thing);\n                }\n            } else if (left.id === \"typeof\") {\n                if (right.id !== \"(string)\") {\n                    if (right.id !== \"typeof\") {\n                        warn(\"expected_string_a\", right);\n                    }\n                } else {\n                    var value = right.value;\n                    if (value === \"symbol\") {\n                        if (!option.es6) {\n                            warn(\"es6\", right, value);\n                        }\n                    } else if (value === \"null\" || value === \"undefined\") {\n                        warn(\"unexpected_typeof_a\", right, value);\n                    } else if (\n                        value !== \"boolean\" &&\n                        value !== \"function\" &&\n                        value !== \"number\" &&\n                        value !== \"object\" &&\n                        value !== \"string\"\n                    ) {\n                        warn(\"expected_type_string_a\", right, value);\n                    }\n                }\n            }\n        }\n    });\n    preaction(\"binary\", \"==\", function (thing) {\n        warn(\"expected_a_b\", thing, \"===\", \"==\");\n    });\n    preaction(\"binary\", \"!=\", function (thing) {\n        warn(\"expected_a_b\", thing, \"!==\", \"!=\");\n    });\n    preaction(\"binary\", \"=>\", preaction_function);\n    preaction(\"binary\", \"||\", function (thing) {\n        thing.expression.forEach(function (thang) {\n            if (thang.id === \"&&\" && !thang.wrapped) {\n                warn(\"and\", thang);\n            }\n        });\n    });\n    preaction(\"binary\", \"(\", function (thing) {\n        var left = thing.expression[0];\n        if (\n            left.identifier &&\n            functionage.context[left.id] === undefined &&\n            typeof functionage.name === \"object\"\n        ) {\n            var parent = functionage.name.function;\n            if (parent) {\n                var left_variable = parent.context[left.id];\n                if (\n                    left_variable !== undefined &&\n                    left_variable.dead &&\n                    left_variable.function === parent &&\n                    left_variable.calls !== undefined &&\n                    left_variable.calls[functionage.name.id] !== undefined\n                ) {\n                    left_variable.dead = false;\n                }\n            }\n        }\n    });\n    preaction(\"binary\", \"in\", function (thing) {\n        warn(\"infix_in\", thing);\n    });\n    preaction(\"binary\", \"instanceof\", function (thing) {\n        warn(\"unexpected_a\", thing);\n    });\n    preaction(\"binary\", \".\", function (thing) {\n        if (thing.expression.new) {\n            thing.new = true;\n        }\n    });\n    preaction(\"statement\", \"{\", function (thing) {\n        block_stack.push(blockage);\n        blockage = thing;\n        thing.live = [];\n    });\n    preaction(\"statement\", \"for\", function (thing) {\n        if (thing.name !== undefined) {\n            var the_variable = lookup(thing.name);\n            if (the_variable !== undefined) {\n                the_variable.init = true;\n                if (!the_variable.writable) {\n                    warn(\"bad_assignment_a\", thing.name);\n                }\n            }\n        }\n        walk_statement(thing.initial);\n    });\n    preaction(\"statement\", \"function\", preaction_function);\n    preaction(\"unary\", \"~\", bitwise_check);\n    preaction(\"unary\", \"function\", preaction_function);\n    preaction(\"variable\", function (thing) {\n        var the_variable = lookup(thing);\n        if (the_variable !== undefined) {\n            thing.variable = the_variable;\n            the_variable.used += 1;\n        }\n    });\n\n    function init_variable(name) {\n        var the_variable = lookup(name);\n        if (the_variable !== undefined) {\n            if (the_variable.writable) {\n                the_variable.init = true;\n                return;\n            }\n        }\n        warn(\"bad_assignment_a\", name);\n    }\n\n    postaction(\"assignment\", function (thing) {\n\n// Assignment using = sets the init property of a variable. No other assignment\n// operator can do this. A = token keeps that variable (or array of variables\n// in case of destructuring) in its name property.\n\n        var lvalue = thing.expression[0];\n        if (thing.id === \"=\") {\n            if (thing.names !== undefined) {\n                if (Array.isArray(thing.names)) {\n                    thing.names.forEach(init_variable);\n                } else {\n                    init_variable(thing.names);\n                }\n            } else {\n                if (\n                    lvalue.id === \".\" &&\n                    thing.expression[1].id === \"undefined\"\n                ) {\n                    warn(\n                        \"expected_a_b\",\n                        lvalue.expression,\n                        \"delete\",\n                        \"undefined\"\n                    );\n                }\n            }\n        } else {\n            if (lvalue.arity === \"variable\") {\n                if (!lvalue.variable || lvalue.variable.writable !== true) {\n                    warn(\"bad_assignment_a\", lvalue);\n                }\n            }\n            var right = syntax[thing.expression[1].id];\n            if (\n                right !== undefined &&\n                (\n                    right.id === \"function\" ||\n                    right.id === \"=>\" ||\n                    (\n                        right.constant &&\n                        right.id !== \"(number)\" &&\n                        (right.id !== \"(string)\" || thing.id !== \"+=\")\n                    )\n                )\n            ) {\n                warn(\"unexpected_a\", thing.expression[1]);\n            }\n        }\n    });\n\n    function postaction_function(thing) {\n        delete functionage.loop;\n        delete functionage.switch;\n        functionage = stack.pop();\n        if (thing.wrapped) {\n            warn(\"unexpected_parens\", thing);\n        }\n        if (typeof thing.name === \"object\") {\n            thing.name.used = 0;\n        }\n        return pop_block();\n    }\n\n    postaction(\"binary\", function (thing) {\n        var right;\n        if (relationop[thing.id]) {\n            if (\n                is_weird(thing.expression[0]) ||\n                is_weird(thing.expression[1]) ||\n                are_similar(thing.expression[0], thing.expression[1]) ||\n                (\n                    thing.expression[0].constant === true &&\n                    thing.expression[1].constant === true\n                )\n            ) {\n                warn(\"weird_relation_a\", thing);\n            }\n        }\n        switch (thing.id) {\n        case \"+\":\n        case \"-\":\n            right = thing.expression[1];\n            if (\n                right.id === thing.id &&\n                right.arity === \"unary\" &&\n                !right.wrapped\n            ) {\n                warn(\"wrap_unary\", right);\n            }\n            break;\n        case \"=>\":\n        case \"(\":\n            break;\n        case \".\":\n            if (thing.expression.id === \"RegExp\") {\n                warn(\"weird_expression_a\", thing);\n            }\n            break;\n        default:\n            if (\n                thing.expression[0].constant === true &&\n                thing.expression[1].constant === true\n            ) {\n                thing.constant = true;\n            }\n        }\n    });\n    postaction(\"binary\", \"&&\", function (thing) {\n        if (\n            is_weird(thing.expression[0]) ||\n            are_similar(thing.expression[0], thing.expression[1]) ||\n            thing.expression[0].constant === true ||\n            thing.expression[1].constant === true\n        ) {\n            warn(\"weird_condition_a\", thing);\n        }\n    });\n    postaction(\"binary\", \"||\", function (thing) {\n        if (\n            is_weird(thing.expression[0]) ||\n            are_similar(thing.expression[0], thing.expression[1]) ||\n            thing.expression[0].constant === true\n        ) {\n            warn(\"weird_condition_a\", thing);\n        }\n    });\n    postaction(\"binary\", \"=>\", postaction_function);\n    postaction(\"binary\", \"(\", function (thing) {\n        var left = thing.expression[0];\n        var the_new;\n        if (left.id === \"new\") {\n            the_new = left;\n            left = left.expression;\n        }\n        if (left.id === \"function\") {\n            if (!thing.wrapped) {\n                warn(\"wrap_immediate\", thing);\n            }\n        } else if (left.identifier) {\n            if (the_new !== undefined) {\n                if (\n                    left.id.charAt(0) > \"Z\" ||\n                    left.id === \"Boolean\" ||\n                    left.id === \"Number\" ||\n                    left.id === \"String\" ||\n                    (left.id === \"Symbol\" && option.es6)\n                ) {\n                    warn(\"unexpected_a\", the_new);\n                } else if (left.id === \"Function\") {\n                    if (!option.eval) {\n                        warn(\"unexpected_a\", left, \"new Function\");\n                    }\n                } else if (left.id === \"Array\") {\n                    warn(\"expected_a_b\", left, \"[]\", \"new Array\");\n                } else if (left.id === \"Object\") {\n                    warn(\n                        \"expected_a_b\",\n                        left,\n                        \"Object.create(null)\",\n                        \"new Object\"\n                    );\n                }\n            } else {\n                if (\n                    left.id.charAt(0) >= \"A\" &&\n                    left.id.charAt(0) <= \"Z\" &&\n                    left.id !== \"Boolean\" &&\n                    left.id !== \"Number\" &&\n                    left.id !== \"String\" &&\n                    left.id !== \"Symbol\"\n                ) {\n                    warn(\n                        \"expected_a_before_b\",\n                        left,\n                        \"new\",\n                        artifact(left)\n                    );\n                }\n            }\n        } else if (left.id === \".\") {\n            var cack = the_new !== undefined;\n            if (left.expression.id === \"Date\" && left.name.id === \"UTC\") {\n                cack = !cack;\n            }\n            if (rx_cap.test(left.name.id) !== cack) {\n                if (the_new !== undefined) {\n                    warn(\"unexpected_a\", the_new);\n                } else {\n                    warn(\n                        \"expected_a_before_b\",\n                        left.expression,\n                        \"new\",\n                        left.name.id\n                    );\n                }\n            }\n            if (left.name.id === \"getTime\") {\n                var l1 = left.expression;\n                if (l1.id === \"(\") {\n                    var l2 = l1.expression;\n                    if (l2.length === 1) {\n                        var l3 = l2[0];\n                        if (l3.id === \"new\" && l3.expression.id === \"Date\") {\n                            warn(\n                                \"expected_a_b\",\n                                l3,\n                                \"Date.now()\",\n                                \"new Date().getTime()\"\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    });\n    postaction(\"binary\", \"[\", function (thing) {\n        if (thing.expression[0].id === \"RegExp\") {\n            warn(\"weird_expression_a\", thing);\n        }\n        if (is_weird(thing.expression[1])) {\n            warn(\"weird_expression_a\", thing.expression[1]);\n        }\n    });\n    postaction(\"statement\", \"{\", pop_block);\n    postaction(\"statement\", \"const\", action_var);\n    postaction(\"statement\", \"export\", top_level_only);\n    postaction(\"statement\", \"for\", function (thing) {\n        walk_statement(thing.inc);\n    });\n    postaction(\"statement\", \"function\", postaction_function);\n    postaction(\"statement\", \"import\", function (the_thing) {\n        var name = the_thing.name;\n        if (Array.isArray(name)) {\n            name.forEach(function (name) {\n                name.dead = false;\n                name.init = true;\n                blockage.live.push(name);\n            });\n        } else {\n            name.dead = false;\n            name.init = true;\n            blockage.live.push(name);\n        }\n        return top_level_only(the_thing);\n    });\n    postaction(\"statement\", \"let\", action_var);\n    postaction(\"statement\", \"try\", function (thing) {\n        if (thing.catch !== undefined) {\n            var the_name = thing.catch.name;\n            if (the_name !== undefined) {\n                var the_variable = functionage.context[the_name.id];\n                the_variable.dead = false;\n                the_variable.init = true;\n            }\n            walk_statement(thing.catch.block);\n        }\n    });\n    postaction(\"statement\", \"var\", action_var);\n    postaction(\"ternary\", function (thing) {\n        if (\n            is_weird(thing.expression[0]) ||\n            thing.expression[0].constant === true ||\n            are_similar(thing.expression[1], thing.expression[2])\n        ) {\n            warn(\"unexpected_a\", thing);\n        } else if (are_similar(thing.expression[0], thing.expression[1])) {\n            warn(\"expected_a_b\", thing, \"||\", \"?\");\n        } else if (are_similar(thing.expression[0], thing.expression[2])) {\n            warn(\"expected_a_b\", thing, \"&&\", \"?\");\n        } else if (\n            thing.expression[1].id === \"true\" &&\n            thing.expression[2].id === \"false\"\n        ) {\n            warn(\"expected_a_b\", thing, \"!!\", \"?\");\n        } else if (\n            thing.expression[1].id === \"false\" &&\n            thing.expression[2].id === \"true\"\n        ) {\n            warn(\"expected_a_b\", thing, \"!\", \"?\");\n        } else if (thing.expression[0].wrapped !== true && (\n            thing.expression[0].id === \"||\" ||\n            thing.expression[0].id === \"&&\"\n        )) {\n            warn(\"wrap_condition\", thing.expression[0]);\n        }\n    });\n    postaction(\"unary\", function (thing) {\n        switch (thing.id) {\n        case \"[\":\n        case \"{\":\n        case \"function\":\n        case \"new\":\n            break;\n        case \"`\":\n            if (thing.expression.every(function (thing) {\n                return thing.constant;\n            })) {\n                thing.constant = true;\n            }\n            break;\n        default:\n            if (thing.expression.constant === true) {\n                thing.constant = true;\n            }\n        }\n    });\n    postaction(\"unary\", \"function\", postaction_function);\n\n    function delve(the_function) {\n        Object.keys(the_function.context).forEach(function (id) {\n            if (id !== \"ignore\") {\n                var name = the_function.context[id];\n                if (name.function === the_function) {\n                    if (name.used === 0 && (\n                        name.role !== \"function\" ||\n                        name.function.arity !== \"unary\"\n                    )) {\n                        warn(\"unused_a\", name);\n                    } else if (!name.init) {\n                        warn(\"uninitialized_a\", name);\n                    }\n                }\n            }\n        });\n    }\n\n    function uninitialized_and_unused() {\n\n// Delve into the functions looking for variables that were not initialized\n// or used. If the file imports or exports, then its global object is also\n// delved.\n\n        if (module_mode === true || option.node) {\n            delve(global);\n        }\n        functions.forEach(delve);\n    }\n\n// Go through the token list, looking at usage of whitespace.\n\n    function whitage() {\n        var closer = \"(end)\";\n        var free = false;\n        var left = global;\n        var margin = 0;\n        var nr_comments_skipped = 0;\n        var open = true;\n        var qmark = \"\";\n        var result;\n        var right;\n\n        function expected_at(at) {\n            warn(\n                \"expected_a_at_b_c\",\n                right,\n                artifact(right),\n                fudge + at,\n                artifact_column(right)\n            );\n        }\n\n        function at_margin(fit) {\n            var at = margin + fit;\n            if (right.from !== at) {\n                return expected_at(at);\n            }\n        }\n\n        function no_space_only() {\n            if (\n                left.id !== \"(global)\" &&\n                left.nr + 1 === right.nr && (\n                    left.line !== right.line ||\n                    left.thru !== right.from\n                )\n            ) {\n                warn(\n                    \"unexpected_space_a_b\",\n                    right,\n                    artifact(left),\n                    artifact(right)\n                );\n            }\n        }\n\n        function no_space() {\n            if (left.line === right.line) {\n                if (left.thru !== right.from && nr_comments_skipped === 0) {\n                    warn(\n                        \"unexpected_space_a_b\",\n                        right,\n                        artifact(left),\n                        artifact(right)\n                    );\n                }\n            } else {\n                if (open) {\n                    var at = (free)\n                        ? margin\n                        : margin + 8;\n                    if (right.from < at) {\n                        expected_at(at);\n                    }\n                } else {\n                    if (right.from !== margin + 8) {\n                        expected_at(margin + 8);\n                    }\n                }\n            }\n        }\n\n        function one_space_only() {\n            if (left.line !== right.line || left.thru + 1 !== right.from) {\n                warn(\n                    \"expected_space_a_b\",\n                    right,\n                    artifact(left),\n                    artifact(right)\n                );\n            }\n        }\n\n        function one_space() {\n            if (left.line === right.line) {\n                if (left.thru + 1 !== right.from && nr_comments_skipped === 0) {\n                    warn(\n                        \"expected_space_a_b\",\n                        right,\n                        artifact(left),\n                        artifact(right)\n                    );\n                }\n            } else {\n                if (free) {\n                    if (right.from < margin) {\n                        expected_at(margin);\n                    }\n                } else {\n                    if (right.from !== margin + 8) {\n                        expected_at(margin + 8);\n                    }\n                }\n            }\n        }\n\n        function unqmark() {\n\n// Undo the effects of dangling nested ternary operators.\n\n            var level = qmark.length;\n            if (level > 0) {\n                margin -= level * 4;\n            }\n            qmark = \"\";\n        }\n\n        stack = [];\n        tokens.forEach(function (the_token) {\n            right = the_token;\n            if (right.id === \"(comment)\" || right.id === \"(end)\") {\n                nr_comments_skipped += 1;\n            } else {\n\n// If left is an opener and right is not the closer, then push the previous\n// state. If the token following the opener is on the next line, then this is\n// an open form. If the tokens are on the same line, then it is a closed form.\n// Open form is more readable, with each item (statement, argument, parameter,\n// etc) starting on its own line. Closed form is more compact. Statement blocks\n// are always in open form.\n\n                var new_closer = opener[left.id];\n                if (typeof new_closer === \"string\") {\n                    if (new_closer !== right.id) {\n                        stack.push({\n                            closer: closer,\n                            free: free,\n                            margin: margin,\n                            open: open,\n                            qmark: qmark\n                        });\n                        qmark = \"\";\n                        closer = new_closer;\n                        if (left.line !== right.line) {\n                            free = closer === \")\" && left.free;\n                            open = true;\n                            margin += 4;\n                            if (right.role === \"label\") {\n                                if (right.from !== 0) {\n                                    expected_at(0);\n                                }\n                            } else if (right.switch) {\n                                unqmark();\n                                at_margin(-4);\n                            } else {\n                                at_margin(0);\n                            }\n                        } else {\n                            if (right.statement || right.role === \"label\") {\n                                warn(\n                                    \"expected_line_break_a_b\",\n                                    right,\n                                    artifact(left),\n                                    artifact(right)\n                                );\n                            }\n                            free = false;\n                            open = false;\n                            no_space_only();\n                        }\n                    } else {\n\n// If left and right are opener and closer, then the placement of right depends\n// on the openness. Illegal pairs (like {]) have already been detected.\n\n                        if (left.line === right.line) {\n                            no_space();\n                        } else {\n                            at_margin(0);\n                        }\n                    }\n                } else {\n\n// If right is a closer, then pop the previous state.\n\n                    if (right.id === closer) {\n                        var previous = stack.pop();\n                        margin = previous.margin;\n                        if (open && right.id !== \";\") {\n                            at_margin(0);\n                        } else {\n                            no_space_only();\n                        }\n                        closer = previous.closer;\n                        free = previous.free;\n                        open = previous.open;\n                        qmark = previous.qmark;\n                    } else {\n\n// Left is not an opener, and right is not a closer. The nature of left and\n// right will determine the space between them.\n\n// If left is , or ; or right is a statement then if open, right must go at the\n// margin, or if closed, a space between.\n\n\n                        if (right.switch) {\n                            unqmark();\n                            at_margin(-4);\n                        } else if (right.role === \"label\") {\n                            if (right.from !== 0) {\n                                expected_at(0);\n                            }\n                        } else if (left.id === \",\") {\n                            unqmark();\n                            if (!open || (\n                                (free || closer === \"]\") &&\n                                left.line === right.line\n                            )) {\n                                one_space();\n                            } else {\n                                at_margin(0);\n                            }\n\n// If right is a ternary operator, line it up on the margin. Use qmark to\n// deal with nested ternary operators.\n\n                        } else if (right.arity === \"ternary\") {\n                            if (right.id === \"?\") {\n                                margin += 4;\n                                qmark += \"?\";\n                            } else {\n                                result = qmark.match(rx_colons);\n                                qmark = result[1] + \":\";\n                                margin -= 4 * result[2].length;\n                            }\n                            at_margin(0);\n                        } else if (\n                            right.arity === \"binary\" &&\n                            right.id === \"(\" &&\n                            free\n                        ) {\n                            no_space();\n                        } else if (\n                            left.id === \".\" ||\n                            left.id === \"...\" ||\n                            right.id === \",\" ||\n                            right.id === \";\" ||\n                            right.id === \":\" ||\n                            (right.arity === \"binary\" && (\n                                right.id === \"(\" ||\n                                right.id === \"[\"\n                            )) ||\n                            (\n                                right.arity === \"function\" &&\n                                left.id !== \"function\"\n                            )\n                        ) {\n                            no_space_only();\n                        } else if (right.id === \".\") {\n                            if (left.line === right.line) {\n                                no_space();\n                            } else {\n                                if (!rx_dot.test(qmark)) {\n                                    qmark += \".\";\n                                    margin += 4;\n                                }\n                                at_margin(0);\n                            }\n                        } else if (left.id === \";\") {\n                            unqmark();\n                            if (open) {\n                                at_margin(0);\n                            } else {\n                                one_space();\n                            }\n                        } else if (\n                            left.arity === \"ternary\" ||\n                            left.id === \"case\" ||\n                            left.id === \"catch\" ||\n                            left.id === \"else\" ||\n                            left.id === \"finally\" ||\n                            left.id === \"while\" ||\n                            right.id === \"catch\" ||\n                            right.id === \"else\" ||\n                            right.id === \"finally\" ||\n                            (right.id === \"while\" && !right.statement) ||\n                            (left.id === \")\" && right.id === \"{\")\n                        ) {\n                            one_space_only();\n                        } else if (right.statement === true) {\n                            if (open) {\n                                at_margin(0);\n                            } else {\n                                one_space();\n                            }\n                        } else if (\n                            left.id === \"var\" ||\n                            left.id === \"const\" ||\n                            left.id === \"let\"\n                        ) {\n                            stack.push({\n                                closer: closer,\n                                free: free,\n                                margin: margin,\n                                open: open,\n                                qmark: qmark\n                            });\n                            closer = \";\";\n                            free = false;\n                            open = left.open;\n                            qmark = \"\";\n                            if (open) {\n                                margin = margin + 4;\n                                at_margin(0);\n                            } else {\n                                one_space_only();\n                            }\n                        } else if (\n\n// There is a space between left and right.\n\n                            spaceop[left.id] === true ||\n                            spaceop[right.id] === true ||\n                            (\n                                left.arity === \"binary\" &&\n                                (left.id === \"+\" || left.id === \"-\")\n                            ) ||\n                            (\n                                right.arity === \"binary\" &&\n                                (right.id === \"+\" || right.id === \"-\")\n                            ) ||\n                            left.id === \"function\" ||\n                            left.id === \":\" ||\n                            (\n                                (\n                                    left.identifier ||\n                                    left.id === \"(string)\" ||\n                                    left.id === \"(number)\"\n                                ) &&\n                                (\n                                    right.identifier ||\n                                    right.id === \"(string)\" ||\n                                    right.id === \"(number)\"\n                                )\n                            ) ||\n                            (left.arity === \"statement\" && right.id !== \";\")\n                        ) {\n                            one_space();\n                        } else if (left.arity === \"unary\" && left.id !== \"`\") {\n                            no_space_only();\n                        }\n                    }\n                }\n                nr_comments_skipped = 0;\n                delete left.calls;\n                delete left.dead;\n                delete left.free;\n                delete left.init;\n                delete left.open;\n                delete left.used;\n                left = right;\n            }\n        });\n    }\n\n// The jslint function itself.\n\n    return function (source, option_object, global_array) {\n        try {\n            warnings = [];\n            option = option_object || empty();\n            anon = \"anonymous\";\n            block_stack = [];\n            declared_globals = empty();\n            directive_mode = true;\n            directives = [];\n            early_stop = true;\n            export_mode = false;\n            fudge = (option.fudge)\n                ? 1\n                : 0;\n            functions = [];\n            global = {\n                id: \"(global)\",\n                body: true,\n                context: empty(),\n                from: 0,\n                level: 0,\n                line: 0,\n                live: [],\n                loop: 0,\n                switch: 0,\n                thru: 0\n            };\n            blockage = global;\n            functionage = global;\n            imports = [];\n            json_mode = false;\n            mega_mode = false;\n            module_mode = false;\n            next_token = global;\n            property = empty();\n            stack = [];\n            tenure = undefined;\n            token = global;\n            token_nr = 0;\n            var_mode = undefined;\n            populate(declared_globals, standard, false);\n            if (global_array !== undefined) {\n                populate(declared_globals, global_array, false);\n            }\n            Object.keys(option).forEach(function (name) {\n                if (option[name] === true) {\n                    var allowed = allowed_option[name];\n                    if (Array.isArray(allowed)) {\n                        populate(declared_globals, allowed, false);\n                    }\n                }\n            });\n            tokenize(source);\n            advance();\n            if (tokens[0].id === \"{\" || tokens[0].id === \"[\") {\n                json_mode = true;\n                tree = json_value();\n                advance(\"(end)\");\n            } else {\n\n// Because browsers encourage combining of script files, the first token might\n// be a semicolon to defend against a missing semicolon in the preceding file.\n\n                if (option.browser) {\n                    if (next_token.id === \";\") {\n                        advance(\";\");\n                    }\n                } else {\n\n// If we are not in a browser, then the file form of strict pragma may be used.\n\n                    if (\n                        next_token.value === \"use strict\"\n                    ) {\n                        global.strict = next_token;\n                        advance(\"(string)\");\n                        advance(\";\");\n                    }\n                }\n                tree = statements();\n                advance(\"(end)\");\n                functionage = global;\n                walk_statement(tree);\n                if (module_mode && global.strict !== undefined) {\n                    warn(\"unexpected_a\", global.strict);\n                }\n                uninitialized_and_unused();\n                if (!option.white) {\n                    whitage();\n                }\n            }\n            if (!option.browser) {\n                directives.forEach(function (comment) {\n                    if (comment.directive === \"global\") {\n                        warn(\"missing_browser\", comment);\n                    }\n                });\n            }\n            early_stop = false;\n        } catch (e) {\n            if (e.name !== \"JSLintError\") {\n                warnings.push(e);\n            }\n        }\n        return {\n            directives: directives,\n            edition: \"2016-07-13\",\n            functions: functions,\n            global: global,\n            id: \"(JSLint)\",\n            imports: imports,\n            json: json_mode,\n            lines: lines,\n            module: module_mode === true,\n            ok: warnings.length === 0 && !early_stop,\n            option: option,\n            property: property,\n            stop: early_stop,\n            tokens: tokens,\n            tree: tree,\n            warnings: warnings.sort(function (a, b) {\n                return a.line - b.line || a.column - b.column;\n            })\n        };\n    };\n}());\n\n/*node module.exports = jslint;*/\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jslint-latest.js":"// jslint.js\n// 2015-10-29\n// Copyright (c) 2015 Douglas Crockford  (www.JSLint.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// The Software shall be used for Good, not Evil.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// jslint is a function that takes 3 arguments:\n\n//      source          A text to analyze, a string or an array of strings.\n//      option_object   An object whose keys correspond to option names.\n//      global_array    An array of strings containing global variables that\n//                      the file is allowed readonly access.\n\n// jslint returns an object containing its results. The object contains a lot\n// of valuable information. It can be used to generate reports. The object\n// contains:\n\n//      edition: the version of JSLint that did the analysis.\n//      functions: an array of objects that represent all of the functions\n//              declared in the file.\n//      global: an object representing the global object. Its .context property\n//              is an object containing a property for each global variable.\n//      id: \"(JSLint)\"\n//      imports: an array of strings representing each of the imports.\n//      json: true if the file is a JSON text.\n//      lines: an array of strings, the source.\n//      module: true if an import or export statement was used.\n//      ok: true if no warnings were generated. This is what you want.\n//      option: the option argument.\n//      property: a property object.\n//      stop: true if JSLint was unable to finish. You don't want this.\n//      tokens: an array of objects representing the tokens in the file.\n//      tree: the token objects arranged in a tree.\n//      warnings: an array of warning objects. A warning object can contain:\n//          name: 'JSLintError'\n//          column: A column number in the file.\n//          line: A line number in the file.\n//          code: A warning code string.\n//          message: The warning message string.\n//          a: Exhibit A.\n//          b: Exhibit B.\n//          c: Exhibit C.\n//          d: Exhibit D.\n\n// jslint works in several phases. In any of these phases, errors might be\n// found. Sometimes JSLint is able to recover from an error and continue\n// parsing. In some cases, it cannot and will stop early. If that should happen,\n// repair your code and try again.\n\n// Phases:\n\n//      1. If the source is a single string, split it into an array of strings.\n//      2. Turn the source into an array of tokens.\n//      3. Furcate the tokens into a parse tree.\n//      4. Walk the tree, traversing all of the nodes of the tree. It is a\n//          recursive traversal. Each node may be processed on the way down\n//          (preaction) and on the way up (postaction).\n//      5. Check the whitespace between the tokens.\n\n// jslint can also examine JSON text. It decides that a file is JSON text if\n// the first token is '[' or '{'. Processing of JSON text is much simpler than\n// the processing of JavaScript programs. Only the first three phases are\n// required.\n\n// WARNING: JSLint will hurt your feelings.\n\n/*property\n    a, and, arity, b, bad_assignment_a, bad_character_number_a,\n    bad_directive_a, bad_get, bad_module_name_a, bad_option_a, bad_property_a,\n    bad_set, bitwise, block, body, browser, c, calls, catch, charAt,\n    charCodeAt, closer, closure, code, column, concat, constant, context,\n    couch, create, d, dead, devel, directive, disrupt, dot, duplicate_a,\n    edition, ellipsis, else, empty_block, es6, eval, every, expected_a_at_b_c,\n    expected_a_b, expected_a_b_from_c_d, expected_a_before_b,\n    expected_digits_after_a, expected_four_digits, expected_identifier_a,\n    expected_line_break_a_b, expected_regexp_factor_a, expected_space_a_b,\n    expected_statements_a, expected_string_a, expected_type_string_a,\n    expression, extra, flag, for, forEach, free, from, fud, fudge, function,\n    function_in_loop, functions, g, global, i, id, identifier, import, imports,\n    inc, indexOf, infix_in, init, initial, isArray, isNaN, join, json, keys,\n    label, label_a, lbp, led, length, level, line, lines, live, loop, m,\n    margin, match, maxerr, maxlen, message, misplaced_a, misplaced_directive_a,\n    module, naked_block, name, names, nested_comment, new, node, not_label_a,\n    nud, ok, open, option, out_of_scope_a, parameters, pop, property, push,\n    qmark, quote, redefinition_a_b, replace, reserved_a, role, search,\n    signature, slash_equal, slice, some, sort, split, statement, stop, strict,\n    subscript_a, switch, test, this, thru, toString, todo_comment, tokens,\n    too_long, too_many, tree, type, u, unclosed_comment, unclosed_mega,\n    unclosed_string, undeclared_a, unexpected_a, unexpected_a_after_b,\n    unexpected_at_top_level_a, unexpected_char_a, unexpected_comment,\n    unexpected_directive_a, unexpected_expression_a, unexpected_label_a,\n    unexpected_parens, unexpected_space_a_b,\n    unexpected_statement_a, unexpected_trailing_space, unexpected_typeof_a,\n    uninitialized_a, unreachable_a, unregistered_property_a, unsafe, unused_a,\n    use_spaces, used, value, var_loop, var_switch, variable, warning, warnings,\n    weird_condition_a, weird_expression_a, weird_loop, weird_relation_a, white,\n    wrap_assignment, wrap_condition, wrap_immediate, wrap_regexp, wrap_unary,\n    wrapped, writable, y\n*/\n\nvar jslint = (function JSLint() {\n    'use strict';\n\n    function empty() {\n\n// The empty function produces a new empty object that inherits nothing. This is\n// much better than {} because confusions around accidental method names like\n// 'constructor' are completely avoided.\n\n        return Object.create(null);\n    }\n\n    function populate(object, array, value) {\n\n// Augment an object by taking property names from an array of strings.\n\n        array.forEach(function (name) {\n            object[name] = value;\n        });\n    }\n\n    var allowed_option = {\n\n// These are the options that are recognized in the option object or that may\n// appear in a /*jslint*/ directive. Most options will have a boolean value,\n// usually true. Some options will also predefine some number of global\n// variables.\n\n        bitwise: true,\n        browser: [\n            'Audio', 'clearInterval', 'clearTimeout', 'document', 'event',\n            'FormData', 'history', 'Image', 'localStorage', 'location', 'name',\n            'navigator', 'Option', 'screen', 'sessionStorage', 'setInterval',\n            'setTimeout', 'Storage', 'XMLHttpRequest'\n        ],\n        couch: [\n            'emit', 'getRow', 'isArray', 'log', 'provides', 'registerType',\n            'require', 'send', 'start', 'sum', 'toJSON'\n        ],\n        devel: [\n            'alert', 'confirm', 'console', 'Debug', 'opera', 'prompt', 'WSH'\n        ],\n        es6: [\n            'ArrayBuffer', 'DataView', 'Float32Array', 'Float64Array',\n            'Generator', 'GeneratorFunction', 'Int8Array', 'Int16Array',\n            'Int32Array', 'Intl', 'Map', 'Promise', 'Proxy', 'Reflect',\n            'Set', 'Symbol', 'System', 'Uint8Array', 'Uint8ClampedArray',\n            'Uint16Array', 'Uint32Array', 'WeakMap', 'WeakSet'\n        ],\n        eval: true,\n        for: true,\n        fudge: true,\n        maxerr: 10000,\n        maxlen: 10000,\n        node: [\n            'Buffer', 'clearImmediate', 'clearInterval', 'clearTimeout',\n            'console', 'exports', 'global', 'module', 'process',\n            'require', 'setImmediate', 'setInterval', 'setTimeout',\n            '__dirname', '__filename'\n        ],\n        this: true,\n        white: true\n    };\n\n    var spaceop = {\n\n// This is the set of infix operators that require a space on each side.\n\n        '!=': true,\n        '!==': true,\n        '%': true,\n        '%=': true,\n        '&': true,\n        '&=': true,\n        '&&': true,\n        '*': true,\n        '*=': true,\n        '+=': true,\n        '-=': true,\n        '/': true,\n        '/=': true,\n        '<': true,\n        '<=': true,\n        '<<': true,\n        '<<=': true,\n        '=': true,\n        '==': true,\n        '===': true,\n        '=>': true,\n        '>': true,\n        '>=': true,\n        '>>': true,\n        '>>=': true,\n        '>>>': true,\n        '>>>=': true,\n        '^': true,\n        '^=': true,\n        '|': true,\n        '|=': true,\n        '||': true\n    };\n\n    var bitwiseop = {\n\n// These are the bitwise operators.\n\n        '~': true,\n        '^': true,\n        '^=': true,\n        '&': true,\n        '&=': true,\n        '|': true,\n        '|=': true,\n        '<<': true,\n        '<<=': true,\n        '>>': true,\n        '>>=': true,\n        '>>>': true,\n        '>>>=': true\n    };\n\n    var opener = {\n\n// The open and close pairs.\n\n        '(': ')',       // paren\n        '[': ']',       // bracket\n        '{': '}',       // brace\n        '${': '}'       // mega\n    };\n\n    var relationop = {\n\n// The relational operators.\n\n        '!=': true,\n        '!==': true,\n        '==': true,\n        '===': true,\n        '<': true,\n        '<=': true,\n        '>': true,\n        '>=': true\n    };\n\n    var standard = [\n\n// These are the globals that are provided by the ES5 language standard.\n\n        'Array', 'Boolean', 'Date', 'decodeURI', 'decodeURIComponent',\n        'encodeURI', 'encodeURIComponent', 'Error', 'EvalError', 'Function',\n        'isFinite', 'isNaN', 'JSON', 'Math', 'Number', 'Object', 'parseInt',\n        'parseFloat', 'RangeError', 'ReferenceError', 'RegExp', 'String',\n        'SyntaxError', 'TypeError', 'URIError'\n    ];\n\n    var bundle = {\n\n// The bundle contains the raw text messages that are generated by jslint. It\n// seems that they are all error messages and warnings. There are no \"Atta\n// boy!\" or \"You are so awesome!\" messages. There is no positive reinforcement\n// or encouragement. This relentless negativity can undermine self-esteem and\n// wound the inner child. But if you accept it as sound advice rather than as\n// personal criticism, it can make your programs better.\n\n        and: \"The '&&' subexpression should be wrapped in parens.\",\n        bad_assignment_a: \"Bad assignment to '{a}'.\",\n        bad_character_number_a: \"Bad character code: '{a}'\",\n        bad_directive_a: \"Bad directive '{a}'.\",\n        bad_get: \"A get function takes no parameters.\",\n        bad_module_name_a: \"Bad module name '{a}'.\",\n        bad_option_a: \"Bad option '{a}'.\",\n        bad_property_a: \"Bad property name '{a}'.\",\n        bad_set: \"A set function takes one parameter.\",\n        duplicate_a: \"Duplicate '{a}'.\",\n        empty_block: \"Empty block.\",\n        es6: \"Unexpected ES6 feature.\",\n        expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n        expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n        expected_a_b_from_c_d: \"Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.\",\n        expected_a_before_b: \"Expected '{a}' before '{b}'.\",\n        expected_digits_after_a: \"Expected digits after '{a}'.\",\n        expected_four_digits: \"Expected four digits after '\\\\u'.\",\n        expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n        expected_line_break_a_b: \"Expected a line break between '{a}' and '{b}'.\",\n        expected_regexp_factor_a: \"Expected a regexp factor and instead saw '{a}'.\",\n        expected_space_a_b: \"Expected one space between '{a}' and '{b}'.\",\n        expected_statements_a: \"Expected statements before '{a}'.\",\n        expected_string_a: \"Expected a string and instead saw '{a}'.\",\n        expected_type_string_a: \"Expected a type string and instead saw '{a}'.\",\n        function_in_loop: \"Don't make functions within a loop.\",\n        infix_in: \"Unexpected 'in'. Compare with undefined, or use the hasOwnProperty method instead.\",\n        isNaN: \"Use the isNaN function to compare with NaN.\",\n        label_a: \"'{a}' is a statement label.\",\n        misplaced_a: \"Place '{a}' at the outermost level.\",\n        misplaced_directive_a: \"Place the '/*{a}*/' directive before the first statement.\",\n        naked_block: \"Naked block.\",\n        nested_comment: \"Nested comment.\",\n        not_label_a: \"'{a}' is not a label.\",\n        out_of_scope_a: \"'{a}' is out of scope.\",\n        redefinition_a_b: \"Redefinition of '{a}' from line {b}.\",\n        reserved_a: \"Reserved name '{a}'.\",\n        slash_equal: \"A regular expression literal can be confused with '/='.\",\n        subscript_a: \"['{a}'] is better written in dot notation.\",\n        todo_comment: \"Unexpected TODO comment.\",\n        too_long: \"Line too long.\",\n        too_many: \"Too many warnings.\",\n        unclosed_comment: \"Unclosed comment.\",\n        unclosed_mega: \"Unclosed mega literal.\",\n        unclosed_string: \"Unclosed string.\",\n        undeclared_a: \"Undeclared '{a}'.\",\n        unexpected_a: \"Unexpected '{a}'.\",\n        unexpected_a_after_b: \"Unexpected '{a}' after '{b}'.\",\n        unexpected_at_top_level_a: \"Unexpected '{a}' at top level.\",\n        unexpected_char_a: \"Unexpected character '{a}'.\",\n        unexpected_comment: \"Unexpected comment.\",\n        unexpected_directive_a: \"When using modules, don't use directive '/*{a}'.\",\n        unexpected_expression_a: \"Unexpected expression '{a}' in statement position.\",\n        unexpected_label_a: \"Unexpected label '{a}'.\",\n        unexpected_parens: \"Don't wrap function literals in parens.\",\n        unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n        unexpected_statement_a: \"Unexpected statement '{a}' in expression position.\",\n        unexpected_trailing_space: \"Unexpected trailing space.\",\n        unexpected_typeof_a: \"Unexpected 'typeof'. Use '===' to compare directly with {a}.\",\n        uninitialized_a: \"Uninitialized '{a}'.\",\n        unreachable_a: \"Unreachable '{a}'.\",\n        unregistered_property_a: \"Unregistered property name '{a}'.\",\n        unsafe: \"Unsafe character '{a}'.\",\n        unused_a: \"Unused '{a}'.\",\n        use_spaces: \"Use spaces, not tabs.\",\n        var_loop: \"Don't declare variables in a loop.\",\n        var_switch: \"Don't declare variables in a switch.\",\n        weird_condition_a: \"Weird condition '{a}'.\",\n        weird_expression_a: \"Weird expression '{a}'.\",\n        weird_loop: \"Weird loop.\",\n        weird_relation_a: \"Weird relation '{a}'.\",\n        wrap_assignment: \"Don't wrap assignment statements in parens.\",\n        wrap_condition: \"Wrap the condition in parens.\",\n        wrap_immediate: \"Wrap an immediate function invocation in \" +\n                \"parentheses to assist the reader in understanding that the \" +\n                \"expression is the result of a function, and not the \" +\n                \"function itself.\",\n        wrap_regexp: \"Wrap this regexp in parens to avoid confusion.\",\n        wrap_unary: \"Wrap the unary expression in parens.\"\n    };\n\n// Regular expression literals:\n\n// supplant {variables}\n    var rx_supplant = /\\{([^{}]*)\\}/g,\n// carriage return, carriage return linefeed, or linefeed\n        rx_crlf = /\\n|\\r\\n?/,\n// unsafe characters that are silently deleted by one or more browsers\n        rx_unsafe = /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n// identifier\n        rx_identifier = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,\n        rx_bad_property = /^_|\\$|Sync$|_$/,\n// star slash\n        rx_star_slash = /\\*\\//,\n// slash star\n        rx_slash_star = /\\/\\*/,\n// slash star or ending slash\n        rx_slash_star_or_slash = /\\/\\*|\\/$/,\n// uncompleted work comment\n        rx_todo = /\\b(?:todo|TO\\s?DO|HACK)\\b/,\n// tab\n        rx_tab = /\\t/g,\n// directive\n        rx_directive = /^(jslint|property|global)\\s*(.*)$/,\n        rx_directive_part = /^([a-zA-Z$_][a-zA-Z0-9$_]*)\\s*(?::\\s*(true|false|[0-9]+)\\s*)?(?:,\\s*)?(.*)$/,\n// token (sorry it is so long)\n        rx_token = /^((\\s+)|([a-zA-Z_$][a-zA-Z0-9_$]*)|[(){}\\[\\]\\?,:;'\"~`]|=(?:==?|>)?|\\.+|\\/[=*\\/]?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|[\\^%]=?|&[&=]?|\\|[\\|=]?|>{1,3}=?|<<?=?|!={0,2}|(0|[1-9][0-9]*))(.*)$/,\n        rx_digits = /^([0-9]+)(.*)$/,\n        rx_hexs = /^([0-9a-fA-F]+)(.*)$/,\n        rx_octals = /^([0-7]+)(.*)$/,\n        rx_bits = /^([01]+)(.*)$/,\n// mega\n        rx_mega = /`|\\$\\{/,\n// indentation\n        rx_colons = /^(.*)\\?([:.]*)$/,\n        rx_dot = /\\.$/,\n// JSON number\n        rx_JSON_number = /^-?\\d+(?:\\.\\d*)?(?:e[\\-+]?\\d+)?$/i;\n\n    function is_letter(string) {\n        return (string >= 'a' && string <= 'z\\uffff') ||\n                (string >= 'A' && string <= 'Z\\uffff');\n    }\n\n    function supplant(string, object) {\n        return string.replace(rx_supplant, function (found, filling) {\n            var replacement = object[filling];\n            return (replacement !== undefined)\n                ? replacement\n                : found;\n        });\n    }\n\n    var anon = \"anonymous\", // The guessed name for anonymous functions.\n        blockage,           // The current block.\n        block_stack,        // The stack of blocks.\n        declared_globals,   // The object containing the global declarations.\n        directive_mode,     // true if directives are still allowed.\n        early_stop,         // true if JSLint cannot finish.\n        export_mode,        // true if an export statement was seen.\n        fudge,              // true if the natural numbers start with 1.\n        functionage,        // The current function.\n        functions,          // The array containing all of the functions.\n        global,             // The global object, the outermost context.\n        imports,            // The array collecting all import-from strings.\n        json_mode,          // true if parsing JSON.\n        lines,              // The array containing source lines.\n        module_mode,        // true if import or export was used.\n        next_token,         // The next token to be examined in the parse.\n        option,             // The options parameter.\n        property,           // The object containing the tallied property names.\n        mega_mode,          // true if currently parsing a megastring literal.\n        stack,              // The stack of functions.\n        syntax,             // The object containing the parser.\n        token,              // The current token being examined in the parse.\n        token_nr,           // The number of the next token.\n        tokens,             // The array of tokens.\n        tenure,             // The predefined property registry.\n        tree,               // The abstract parse tree.\n        var_mode,           // true if using var, false if using let.\n        warnings;           // The array collecting all generated warnings.\n\n// Error reportage functions:\n\n    function artifact(the_token) {\n\n// Return a string representing an artifact.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        return (the_token.id === '(string)' || the_token.id === '(number)')\n            ? String(the_token.value)\n            : the_token.id;\n    }\n\n    function artifact_line(the_token) {\n\n// Return the fudged line number of an artifact.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        return the_token.line + fudge;\n    }\n\n    function artifact_column(the_token) {\n\n// Return the fudged column number of an artifact.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        return the_token.from + fudge;\n    }\n\n    function warn_at(code, line, column, a, b, c, d) {\n\n// Report an error at some line and column of the program. The warning object\n// resembles an exception.\n\n        var warning = {         // ~~\n            name: 'JSLintError',\n            column: column,\n            line: line,\n            code: code\n        };\n        if (a !== undefined) {\n            warning.a = a;\n        }\n        if (b !== undefined) {\n            warning.b = b;\n        }\n        if (c !== undefined) {\n            warning.c = c;\n        }\n        if (d !== undefined) {\n            warning.d = d;\n        }\n        warning.message = supplant(bundle[code] || code, warning);\n        warnings.push(warning);\n        return (typeof option.maxerr === 'number' &&\n                warnings.length === option.maxerr)\n            ? stop_at('too_many', line, column)\n            : warning;\n    }\n\n    function stop_at(code, line, column, a, b, c, d) {\n\n// Same as warn_at, except that it stops the analysis.\n\n        throw warn_at(code, line, column, a, b, c, d);\n    }\n\n    function warn(code, the_token, a, b, c, d) {\n\n// Same as warn_at, except the warning will be associated with a specific token.\n// If there is already a warning on this token, suppress the new one. It is\n// likely that the first warning will be the most meaningful.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        if (the_token.warning === undefined) {\n            the_token.warning = warn_at(\n                code,\n                the_token.line,\n                the_token.from,\n                a || artifact(the_token),\n                b,\n                c,\n                d\n            );\n            return the_token.warning;\n        }\n    }\n\n    function stop(code, the_token, a, b, c, d) {\n\n// Similar to warn and stop_at. If the token already had a warning, that\n// warning will be replaced with this new one. It is likely that the stopping\n// warning will be the most meaningful.\n\n        if (the_token === undefined) {\n            the_token = next_token;\n        }\n        the_token.warning = undefined;\n        throw warn(code, the_token, a, b, c, d);\n    }\n\n// Tokenize:\n\n    function tokenize(source) {\n\n// tokenize takes a source and produces from it an array of token objects.\n// JavaScript is notoriously difficult to tokenize because of the horrible\n// interactions between automatic semicolon insertion, regular expression\n// literals, and now megastring literals. JSLint benefits from eliminating\n// automatic semicolon insertion and nested megastring literals, which allows\n// full tokenization to precede parsing.\n\n// If the source is not an array, then it is split into lines at the\n// carriage return/linefeed.\n\n        lines = (Array.isArray(source))\n            ? source\n            : source.split(rx_crlf);\n        tokens = [];\n\n        var char,                   // a popular character\n            column = 0,             // the column number of the next character\n            from,                   // the starting column number of the token\n            line = -1,              // the line number of the next character\n            previous = global,      // the previous token including comments\n            prior = global,         // the previous token excluding comments\n            mega_from,              // the starting column of megastring\n            mega_line,              // the starting line of megastring\n            snippet,                // a piece of string\n            source_line;            // the current line source string\n\n        function next_line() {\n\n// Put the next line of source in source_line. If the line contains tabs,\n// replace them with spaces and give a warning. Also warn if the line contains\n// unsafe characters or is too damn long.\n\n            var at;\n            column = 0;\n            line += 1;\n            source_line = lines[line];\n            if (source_line !== undefined) {\n                at = source_line.search(rx_tab);\n                if (at >= 0) {\n                    if (!option.white) {\n                        warn_at('use_spaces', line, at + 1);\n                    }\n                    source_line = source_line.replace(rx_tab, ' ');\n                }\n                at = source_line.search(rx_unsafe);\n                if (at >= 0) {\n                    warn_at(\n                        'unsafe',\n                        line,\n                        column + at,\n                        'U+' + source_line.charCodeAt(at).toString(16)\n                    );\n                }\n                if (option.maxlen && option.maxlen < source_line.length) {\n                    warn_at('too_long', line, source_line.length);\n                } else if (!option.white && source_line.slice(-1) === ' ') {\n                    warn_at(\n                        'unexpected_trailing_space',\n                        line,\n                        source_line.length - 1\n                    );\n                }\n            }\n            return source_line;\n        }\n\n// Most tokens, including the identifiers, operators, and punctuators, can be\n// found with a regular expression. Regular expressions cannot correctly match\n// regular expression literals, so we will match those the hard way. String\n// literals and number literals can be matched by regular expressions, but they\n// don't provide good warnings. The functions snip, next_char, prev_char,\n// some_digits, and escape help in the parsing of literals.\n\n        function snip() {\n\n// Remove the last character from snippet.\n\n            snippet = snippet.slice(0, -1);\n        }\n\n        function next_char(match) {\n\n// Get the next character from the source line. Remove it from the source_line,\n// and append it to the snippet. Optionally check that the previous character\n// matched an expected value.\n\n            if (match !== undefined && char !== match) {\n                return stop_at('expected_a_b', line, column, match, char);\n            }\n            if (source_line) {\n                char = source_line.charAt(0);\n                source_line = source_line.slice(1);\n                snippet += char;\n            } else {\n                char = '';\n                snippet += ' ';\n            }\n            column += 1;\n            return char;\n        }\n\n        function back_char() {\n\n// Back up one character by moving a character from the end of the snippet to\n// the front of the source_line.\n\n            if (snippet) {\n                char = snippet.slice(-1);\n                source_line = char + source_line;\n                column -= 1;\n                snip();\n            } else {\n                char = '';\n            }\n            return char;\n        }\n\n        function some_digits(rx, quiet) {\n            var result = source_line.match(rx);\n            if (result) {\n                char = result[1];\n                column += char.length;\n                source_line = result[2];\n                snippet += char;\n            } else {\n                char = '';\n                if (!quiet) {\n                    warn_at(\n                        'expected_digits_after_a',\n                        line,\n                        column,\n                        snippet\n                    );\n                }\n            }\n            return char.length;\n        }\n\n        function escape(extra) {\n            switch (next_char('\\\\')) {\n            case '\\\\':\n            case '\\'':\n            case '\"':\n            case '/':\n            case ':':\n            case '=':\n            case '|':\n            case 'b':\n            case 'f':\n            case 'n':\n            case 'r':\n            case 't':\n            case ' ':\n                break;\n            case 'u':\n                if (next_char('u') === '{') {\n                    if (some_digits(rx_hexs) > 5) {\n                        warn_at('too_many_digits', line, column - 1);\n                    }\n                    if (!option.es6) {\n                        warn_at('es6', line, column);\n                    }\n                    if (next_char() !== '}') {\n                        stop_at('expected_a_before_b', line, column, '}', char);\n                    }\n                    return;\n                }\n                back_char();\n                if (some_digits(rx_hexs, true) < 4) {\n                    warn_at('expected_four_digits', line, column - 1);\n                }\n                break;\n            case '':\n                return stop_at('unclosed_string', line, column);\n            default:\n                if (extra && extra.indexOf(char) < 0) {\n                    warn_at('unexpected_a_after_b', line, column, char, '\\\\');\n                }\n            }\n            next_char();\n        }\n\n        function make(id, value, identifier) {\n\n// Make the token object and append it to the tokens list.\n\n            var the_token = {\n                id: id,\n                identifier: !!identifier,\n                from: from,\n                thru: column,\n                line: line\n            };\n            tokens.push(the_token);\n\n// Directives must appear before the first statement.\n\n            if (id !== '(comment)') {\n                directive_mode = false;\n            }\n\n// If the token is to have a value, give it one.\n\n            if (value !== undefined) {\n                the_token.value = value;\n            }\n\n// If this token is an identifier that touches a preceding number, or\n// a '/', comment, or regular expression literal that touches a preceding\n// comment or regular expression literal, then give a missing space warning.\n// This warning is not suppressed by option.white.\n\n            if (\n                previous.line === line &&\n                previous.thru === from &&\n                (\n                    (id === '(comment)' || id === '(regexp)' || id === '/') &&\n                    (\n                        previous.id === '(comment)' ||\n                        previous.id === '(regexp)'\n                    )\n                )\n            ) {\n                warn(\n                    'expected_space_a_b',\n                    the_token,\n                    artifact(previous),\n                    artifact(the_token)\n                );\n            }\n            if (previous.id === '.' && id === '(number)') {\n                warn('expected_a_before_b', previous, '0', '.');\n            }\n            if (prior.id === '.' && the_token.identifier) {\n                the_token.dot = true;\n            }\n\n// The previous token is used to detect adjacency problems.\n\n            previous = the_token;\n\n// The prior token is a previous token that was not a comment. The prior token\n// is used to disambiguate '/', which can mean division or regular expression\n// literal.\n\n            if (previous.id !== '(comment)') {\n                prior = previous;\n            }\n            return the_token;\n        }\n\n        function directive(the_comment, body) {\n\n// JSLint recognizes three directives that can be encoded in comments. This\n// function processes one item, and calls itself recursively to process the\n// next one.\n\n            var result = body.match(rx_directive_part);\n            if (result) {\n                var allowed,\n                    name = result[1],\n                    value = result[2];\n                switch (the_comment.directive) {\n                case 'jslint':\n                    allowed = allowed_option[name];\n                    switch (typeof allowed) {\n                    case 'boolean':\n                    case 'object':\n                        switch (value) {\n                        case 'true':\n                        case '':\n                        case undefined:\n                            option[name] = true;\n                            if (Array.isArray(allowed)) {\n                                populate(declared_globals, allowed, false);\n                            }\n                            break;\n                        case 'false':\n                            option[name] = false;\n                            break;\n                        default:\n                            warn('bad_option_a', the_comment, name + ':' + value);\n                        }\n                        break;\n                    case 'number':\n                        if (isFinite(+value)) {\n                            option[name] = +value;\n                        } else {\n                            warn('bad_option_a', the_comment, name + ':' + value);\n                        }\n                        break;\n                    default:\n                        warn('bad_option_a', the_comment, name);\n                    }\n                    break;\n                case 'property':\n                    if (tenure === undefined) {\n                        tenure = empty();\n                    }\n                    tenure[name] = true;\n                    break;\n                case 'global':\n                    if (value) {\n                        warn('bad_option_a', the_comment, name + ':' + value);\n                    }\n                    declared_globals[name] = false;\n                    module_mode = the_comment;\n                    break;\n                }\n                return directive(the_comment, result[3]);\n            }\n            if (body) {\n                return stop('bad_directive_a', the_comment, body);\n            }\n        }\n\n        function comment(snippet) {\n\n// Make a comment object. Comments are not allowed in JSON text. Comments can\n// include directives and notices of incompletion.\n\n            var the_comment = make('(comment)', snippet);\n            if (Array.isArray(snippet)) {\n                snippet = snippet.join(' ');\n            }\n            if (!option.devel && rx_todo.test(snippet)) {\n                warn('todo_comment', the_comment);\n            }\n            var result = snippet.match(rx_directive);\n            if (result) {\n                if (!directive_mode) {\n                    warn_at('misplaced_directive_a', line, from, result[1]);\n                } else {\n                    the_comment.directive = result[1];\n                    directive(the_comment, result[2]);\n                }\n            }\n            return the_comment;\n        }\n\n        function regexp() {\n\n// Parse a regular expression literal.\n\n            var result,\n                u_mode = false,\n                value;\n\n            function quantifier() {\n\n// Match an optional quantifier.\n\n                switch (char) {\n                case '?':\n                case '*':\n                case '+':\n                    next_char();\n                    break;\n                case '{':\n                    if (some_digits(rx_digits, true) === 0) {\n                        warn_at('expected_a', line, column, '0');\n                    }\n                    if (next_char() === ',') {\n                        some_digits(rx_digits, true);\n                        next_char();\n                    }\n                    next_char('}');\n                    break;\n                default:\n                    return;\n                }\n                if (char === '?') {\n                    next_char('?');\n                }\n            }\n\n            function subklass() {\n\n// Match a character in a character class.\n\n                switch (char) {\n                case '\\\\':\n                    escape();\n                    return true;\n                case '[':\n                case ']':\n                case '/':\n                case '^':\n                case '-':\n                case '|':\n                case '':\n                    return false;\n                case '`':\n                    if (mega_mode) {\n                        warn_at('unexpected_a', line, column, '`');\n                    }\n                    next_char();\n                    return true;\n                case ' ':\n                    warn_at('expected_a_before_b', line, column, '\\\\', ' ');\n                    next_char();\n                    return true;\n                default:\n                    next_char();\n                    return true;\n                }\n            }\n\n            function range() {\n\n// Match a range of subclasses.\n\n                if (subklass()) {\n                    if (char === '-') {\n                        next_char('-');\n                        if (!subklass()) {\n                            return stop_at('unexpected_a', line, column - 1, '-');\n                        }\n                    }\n                    return range();\n                }\n            }\n\n            function klass() {\n\n// Match a class.\n\n                next_char('[');\n                if (char === '^') {\n                    next_char('^');\n                }\n                range();\n                next_char(']');\n            }\n\n            function choice() {\n\n                function group() {\n\n// Match a group that starts with left paren.\n\n                    next_char('(');\n                    if (char === '?') {\n                        next_char('?');\n                        switch (char) {\n                        case ':':\n                        case '=':\n                        case '!':\n                            next_char();\n                            break;\n                        default:\n                            next_char(':');\n                        }\n                    } else if (char === ':') {\n                        warn_at('expected_a_before_b', line, column, '?', ':');\n                    }\n                    choice();\n                    next_char(')');\n                }\n\n                function factor() {\n                    switch (char) {\n                    case '[':\n                        klass();\n                        return true;\n                    case '\\\\':\n                        escape('BbDdSsWw^${}[]().|*+?');\n                        return true;\n                    case '(':\n                        group();\n                        return true;\n                    case '/':\n                    case '|':\n                    case ']':\n                    case ')':\n                    case '}':\n                    case '{':\n                    case '?':\n                    case '+':\n                    case '*':\n                    case '':\n                        return false;\n                    case '`':\n                        if (mega_mode) {\n                            warn_at('unexpected_a', line, column, '`');\n                        }\n                        break;\n                    case ' ':\n                        warn_at('expected_a_before_b', line, column, '\\\\', ' ');\n                        break;\n                    }\n                    next_char();\n                    return true;\n                }\n\n                function sequence(follow) {\n                    if (factor()) {\n                        quantifier();\n                        return sequence(true);\n                    }\n                    if (!follow) {\n                        warn_at('expected_regexp_factor_a', line, column, char);\n                    }\n                }\n\n// Match a choice (a sequence that can be followed by | and another choice).\n\n                sequence();\n                if (char === '|') {\n                    next_char('|');\n                    return choice();\n                }\n            }\n\n// Scan the regexp literal. Give a warning if the first character is = because\n// /= looks like a division assignment operator.\n\n            snippet = '';\n            next_char();\n            if (char === '=') {\n                warn_at('expected_a_before_b', line, column, '\\\\', '=');\n            }\n            choice();\n\n// Make sure there is a closing slash.\n\n            snip();\n            value = snippet;\n            next_char('/');\n\n// Process dangling flag letters.\n\n            var allowed = {\n                    g: true,\n                    i: true,\n                    m: true,\n                    u: u_mode,\n                    y: option.es6\n                },\n                flag = empty();\n            (function make_flag() {\n                if (is_letter(char)) {\n                    if (allowed[char] !== true) {\n                        warn_at('unexpected_a', line, column, char);\n                    }\n                    allowed[char] = false;\n                    flag[char] = true;\n                    next_char();\n                    return make_flag();\n                }\n            }());\n            if (u_mode && !flag.u) {\n                warn_at('expected_a_before_b', line, column, 'u', char);\n            }\n            back_char();\n            if (char === '/' || char === '*') {\n                return stop_at('unexpected_a', line, from, char);\n            }\n            result = make('(regexp)', char);\n            result.flag = flag;\n            result.value = value;\n            return result;\n        }\n\n        function string(quote) {\n\n// Make a string token.\n\n            var the_token;\n            snippet = '';\n            next_char();\n\n            return (function next() {\n                switch (char) {\n                case quote:\n                    snip();\n                    the_token = make('(string)', snippet);\n                    the_token.quote = quote;\n                    return the_token;\n                case '\\\\':\n                    escape();\n                    break;\n                case '':\n                    return stop_at('unclosed_string', line, column);\n                case '`':\n                    if (mega_mode) {\n                        warn_at('unexpected_a', line, column, '`');\n                    }\n                    next_char('`');\n                    break;\n                default:\n                    next_char();\n                }\n                return next();\n            }());\n        }\n\n        function frack() {\n            if (char === '.') {\n                some_digits(rx_digits);\n                next_char();\n            }\n            if (char === 'E' || char === 'e') {\n                next_char();\n                if (char !== '+' && char !== '-') {\n                    back_char();\n                }\n                some_digits(rx_digits);\n                next_char();\n            }\n        }\n\n        function number() {\n            if (snippet === '0') {\n                switch (next_char()) {\n                case '.':\n                    frack();\n                    break;\n                case 'b':\n                    some_digits(rx_bits);\n                    next_char();\n                    break;\n                case 'o':\n                    some_digits(rx_octals);\n                    next_char();\n                    break;\n                case 'x':\n                    some_digits(rx_hexs);\n                    next_char();\n                    break;\n                }\n            } else {\n                next_char();\n                frack();\n            }\n\n// If the next character after a number is a digit or letter, then something\n// unexpected is going on.\n\n            if (\n                (char >= '0' && char <= '9') ||\n                (char >= 'a' && char <= 'z') ||\n                (char >= 'A' && char <= 'Z')\n            ) {\n                return stop_at(\n                    'unexpected_a_after_b',\n                    line,\n                    column - 1,\n                    snippet.slice(-1),\n                    snippet.slice(0, -1)\n                );\n            }\n            back_char();\n            return make('(number)', snippet);\n        }\n\n        function lex() {\n            var array,\n                i = 0,\n                j = 0,\n                last,\n                result,\n                the_token;\n            if (!source_line) {\n                source_line = next_line();\n                from = 0;\n                return (source_line === undefined)\n                    ? (mega_mode)\n                        ? stop_at('unclosed_mega', mega_line, mega_from)\n                        : make('(end)')\n                    : lex();\n            }\n            from = column;\n            result = source_line.match(rx_token);\n\n// result[1] token\n// result[2] whitespace\n// result[3] identifier\n// result[4] number\n// result[5] rest\n\n            if (!result) {\n                return stop_at('unexpected_char_a', line, column, source_line.charAt(0));\n            }\n\n            snippet = result[1];\n            column += snippet.length;\n            source_line = result[5];\n\n// Whitespace was matched. Call lex again to get more.\n\n            if (result[2]) {\n                return lex();\n            }\n\n// The token is an identifier.\n\n            if (result[3]) {\n                return make(snippet, undefined, true);\n            }\n\n// The token is a number.\n\n            if (result[4]) {\n                return number(snippet);\n            }\n\n// The token is something miscellaneous.\n\n            switch (snippet) {\n\n// The token is a single or double quote string.\n\n            case '\\'':\n            case '\"':\n                return string(snippet);\n\n// The token is a megastring. We don't allow any kind if mega nesting.\n\n            case '`':\n                if (mega_mode) {\n                    return stop_at('expected_a_b', line, column, '}', '`');\n                }\n                snippet = '';\n                mega_from = from;\n                mega_line = line;\n                mega_mode = true;\n\n// Parsing a mega literal is tricky. First make a ` token.\n\n                make('`');\n                from += 1;\n\n// Then loop, building up a string, possibly from many lines, until seeing\n// the end of file, a closing `, or a ${ indicting an expression within the\n// string.\n\n                (function part() {\n                    var at = source_line.search(rx_mega);\n\n// If neither ` nor ${ is seen, then the whole line joins the snippet.\n\n                    if (at < 0) {\n                        snippet += source_line + '\\n';\n                        return (next_line() === undefined)\n                            ? stop_at('unclosed_mega', mega_line, mega_from)\n                            : part();\n                    }\n\n// if either ` or ${ was found, then the preceding joins the snippet to become\n// a string token.\n\n                    snippet += source_line.slice(0, at);\n                    column += at;\n                    source_line = source_line.slice(at);\n                    make('(string)', snippet).quote = '`';\n                    snippet = '';\n\n// If ${, then make tokens that will become part of an expression until\n// a } token is made.\n\n                    if (source_line.charAt(0) === '$') {\n                        column += 2;\n                        make('${');\n                        source_line = source_line.slice(2);\n                        (function expr() {\n                            var id = lex().id;\n                            if (id === '{') {\n                                return stop_at(\n                                    'expected_a_b',\n                                    line,\n                                    column,\n                                    '}',\n                                    '{'\n                                );\n                            }\n                            if (id !== '}') {\n                                return expr();\n                            }\n                        }());\n                        return part();\n                    }\n                }());\n                source_line = source_line.slice(1);\n                column += 1;\n                mega_mode = false;\n                return make('`');\n\n// The token is a // comment.\n\n            case '//':\n                snippet = source_line;\n                source_line = '';\n                the_token = comment(snippet);\n                if (mega_mode) {\n                    warn('unexpected_comment', the_token, '`');\n                }\n                return the_token;\n\n// The token is a /* comment.\n\n            case '/*':\n                array = [];\n                if (source_line.charAt(0) === '/') {\n                    warn_at('unexpected_a', line, column + i, '/');\n                }\n                (function next() {\n                    if (source_line > '') {\n                        i = source_line.search(rx_star_slash);\n                        if (i >= 0) {\n                            return;\n                        }\n                        j = source_line.search(rx_slash_star);\n                        if (j >= 0) {\n                            warn_at('nested_comment', line, column + j);\n                        }\n                    }\n                    array.push(source_line);\n                    source_line = next_line();\n                    if (source_line === undefined) {\n                        return stop_at('unclosed_comment', line, column);\n                    }\n                    return next();\n                }());\n                snippet = source_line.slice(0, i);\n                j = snippet.search(rx_slash_star_or_slash);\n                if (j >= 0) {\n                    warn_at('nested_comment', line, column + j);\n                }\n                array.push(snippet);\n                column += i + 2;\n                source_line = source_line.slice(i + 2);\n                return comment(array);\n\n// The token is a slash.\n\n            case '/':\n\n// The / can be a division operator or the beginning of a regular expression\n// literal. It is not possible to know which without doing a complete parse.\n// We want to complete the tokenization before we begin to parse, so we will\n// estimate. This estimator can fail in some cases. For example, it cannot\n// know if '}' is ending a block or ending an object literal, so it can\n// behave incorrectly in that case; it is not meaningful to divide an\n// object, so it is likely that we can get away with it. We avoided the worst\n// cases by eliminating automatic semicolon insertion.\n\n                if (prior.identifier) {\n                    if (!prior.dot) {\n                        switch (prior.id) {\n                        case 'return':\n                            return regexp();\n                        case '(begin)':\n                        case 'case':\n                        case 'delete':\n                        case 'in':\n                        case 'instanceof':\n                        case 'new':\n                        case 'typeof':\n                        case 'void':\n                        case 'yield':\n                            the_token = regexp();\n                            return stop('unexpected_a', the_token);\n                        }\n                    }\n                } else {\n                    last = prior.id.charAt(prior.id.length - 1);\n                    if ('(,=:?['.indexOf(last) >= 0) {\n                        return regexp();\n                    }\n                    if ('!&|{};~+-*%/^<>'.indexOf(last) >= 0) {\n                        the_token = regexp();\n                        warn('wrap_regexp', the_token);\n                        return the_token;\n                    }\n                }\n                if (source_line.charAt(0) === '/') {\n                    column += 1;\n                    source_line = source_line.slice(1);\n                    snippet = '/=';\n                    warn_at('unexpected_a', line, column, '/=');\n                }\n                break;\n            }\n            return make(snippet);\n        }\n\n// This is the only loop in JSLint. It will turn into a recursive call to lex\n// when ES6 has been finished and widely deployed and adopted.\n\n        while (true) {\n            if (lex().id === '(end)') {\n                break;\n            }\n        }\n    }\n\n// Parsing:\n\n// Parsing weaves the tokens into an abstract syntax tree. During that process,\n// a token may be given any of these properties:\n\n//      arity       string\n//      label       identifier\n//      name        identifier\n//      expression  expressions\n//      block       statements\n//      else        statements (else, default, catch)\n\n// Specialized tokens may have additional properties.\n\n    function survey(name) {\n        var id = name.id;\n\n// Tally the property name. If it is a string, only tally strings that conform\n// to the identifier rules.\n\n        if (id === '(string)') {\n            id = name.value;\n            if (!rx_identifier.test(id)) {\n                return id;\n            }\n        } else {\n            if (!name.identifier) {\n                return stop('expected_identifier_a', name);\n            }\n        }\n\n// If we have seen this name before, increment its count.\n\n        if (typeof property[id] === 'number') {\n            property[id] += 1;\n\n// If this is the first time seeing this property name, and if there is a\n// tenure list, then it must be on the list. Otherwise, it must conform to\n// the rules for good property names.\n\n        } else {\n            if (tenure !== undefined) {\n                if (tenure[id] !== true) {\n                    warn('unregistered_property_a', name);\n                }\n            } else {\n                if (name.identifier && rx_bad_property.test(id)) {\n                    warn('bad_property_a', name);\n                }\n            }\n            property[id] = 1;\n        }\n        return id;\n    }\n\n    function dispense() {\n\n// Deliver the next token, skipping the comments.\n\n        var cadet = tokens[token_nr];\n        token_nr += 1;\n        if (cadet.id === '(comment)') {\n            if (json_mode) {\n                warn('unexpected_a', cadet);\n            }\n            return dispense();\n        } else {\n            return cadet;\n        }\n    }\n\n    function lookahead() {\n\n// Look ahead one token without advancing.\n\n        var old_token_nr = token_nr,\n            cadet = dispense(true);\n        token_nr = old_token_nr;\n        return cadet;\n    }\n\n    function advance(id, match) {\n\n// Produce the next token.\n\n// Attempt to give helpful names to anonymous functions.\n\n        if (token.identifier && token.id !== 'function') {\n            anon = token.id;\n        } else if (token.id === '(string)' && rx_identifier.test(token.value)) {\n            anon = token.value;\n        }\n\n// Attempt to match next_token with an expected id.\n\n        if (id !== undefined && next_token.id !== id) {\n            return (match === undefined)\n                ? stop('expected_a_b', next_token, id, artifact())\n                : stop(\n                    'expected_a_b_from_c_d',\n                    next_token,\n                    id,\n                    artifact(match),\n                    artifact_line(match),\n                    artifact(next_token)\n                );\n        }\n\n// Promote the tokens, skipping comments.\n\n        token = next_token;\n        next_token = dispense();\n        if (next_token.id === '(end)') {\n            token_nr -= 1;\n        }\n    }\n\n// Parsing of JSON is simple:\n\n    function json_value() {\n\n        function json_object() {\n            var brace = next_token,\n                object = empty();\n            advance('{');\n            if (next_token.id !== '}') {\n                (function next() {\n                    if (next_token.quote !== '\"') {\n                        warn('unexpected_a', next_token, next_token.quote);\n                    }\n                    advance('(string)');\n                    if (object[token.value] !== undefined) {\n                        warn('duplicate_a', token);\n                    } else if (token.value === '__proto__') {\n                        warn('bad_property_name_a', token);\n                    } else {\n                        object[token.value] = token;\n                    }\n                    advance(':');\n                    json_value();\n                    if (next_token.id === ',') {\n                        advance(',');\n                        return next();\n                    }\n                }());\n            }\n            advance('}', brace);\n        }\n\n        function json_array() {\n            var bracket = next_token;\n            advance('[');\n            if (next_token.id !== ']') {\n                (function next() {\n                    json_value();\n                    if (next_token.id === ',') {\n                        advance(',');\n                        return next();\n                    }\n                }());\n            }\n            advance(']', bracket);\n        }\n\n        switch (next_token.id) {\n        case '{':\n            json_object();\n            break;\n        case '[':\n            json_array();\n            break;\n        case 'true':\n        case 'false':\n        case 'null':\n            advance();\n            break;\n        case '(number)':\n            if (!rx_JSON_number.test(next_token.value)) {\n                warn('unexpected_a');\n            }\n            advance();\n            break;\n        case '(string)':\n            if (next_token.quote !== '\"') {\n                warn('unexpected_a', next_token, next_token.quote);\n            }\n            advance();\n            break;\n        case '-':\n            advance('-');\n            advance('(number)');\n            break;\n        default:\n            stop('unexpected_a');\n        }\n    }\n\n// Now we parse JavaScript.\n\n    function enroll(name, role, readonly) {\n\n// Enroll a name into the current function context. The role can be exception,\n// function, label, parameter, or variable. We look for variable redefinition\n// because it causes confusion.\n\n        var id = name.id;\n\n// Reserved words may not be enrolled.\n\n        if (syntax[id] !== undefined && id !== 'ignore') {\n            warn('reserved_a', name);\n        } else {\n\n// Has the name been enrolled in this context?\n\n            var earlier = functionage.context[id];\n            if (earlier) {\n                warn(\n                    'redefinition_a_b',\n                    name,\n                    name.id,\n                    earlier.line + fudge\n                );\n\n// Has the name been enrolled in an outer context?\n\n            } else {\n                stack.forEach(function (value) {\n                    var item = value.context[id];\n                    if (item !== undefined) {\n                        earlier = item;\n                    }\n                });\n                if (earlier) {\n                    if (id === 'ignore') {\n                        if (earlier.role === 'variable') {\n                            warn('unexpected_a', name);\n                        }\n                    } else {\n                        if ((\n                            role !== 'exception' ||\n                            earlier.role !== 'exception'\n                        ) && role !== 'parameter') {\n                            warn(\n                                'redefinition_a_b',\n                                name,\n                                name.id,\n                                earlier.line + fudge\n                            );\n                        }\n                    }\n                }\n\n// Enroll it.\n\n                functionage.context[id] = name;\n                name.dead = true;\n                name.function = functionage;\n                name.init = false;\n                name.role = role;\n                name.used = 0;\n                name.writable = !readonly;\n            }\n        }\n    }\n\n    function expression(rbp, initial) {\n\n// This is the heart of the Pratt parser. I retained Pratt's nomenclature.\n// They are elements of the parsing method called Top Down Operator Precedence.\n\n// nud     Null denotation\n// led     Left denotation\n// lbp     Left binding power\n// rbp     Right binding power\n\n// It processes a nud (variable, constant, prefix operator). It will then\n// process leds (infix operators) until the bind powers cause it to stop. It\n// returns the expression's parse tree.\n\n        var left, the_symbol;\n\n// Statements will have already advanced, so advance now only if the token is\n// not the first of a statement,\n\n        if (!initial) {\n            advance();\n        }\n        the_symbol = syntax[token.id];\n        if (the_symbol !== undefined && the_symbol.nud !== undefined) {\n            left = the_symbol.nud();\n        } else if (token.identifier) {\n            left = token;\n            left.arity = 'variable';\n        } else {\n            return stop('unexpected_a', token);\n        }\n        (function right() {\n            the_symbol = syntax[next_token.id];\n            if (\n                the_symbol !== undefined &&\n                the_symbol.led !== undefined &&\n                rbp < the_symbol.lbp\n            ) {\n                advance();\n                left = the_symbol.led(left);\n                return right();\n            }\n        }());\n        return left;\n    }\n\n    function condition() {\n\n// Parse the condition part of a do, if, while.\n\n        var the_paren = next_token,\n            the_value;\n        the_paren.free = true;\n        advance('(');\n        the_value = expression(0);\n        advance(')');\n        if (the_value.wrapped === true) {\n            warn('unexpected_a', the_paren);\n        }\n        switch (the_value.id) {\n        case '?':\n        case '~':\n        case '&':\n        case '|':\n        case '^':\n        case '<<':\n        case '>>':\n        case '>>>':\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n        case '%':\n        case 'typeof':\n        case '(number)':\n        case '(string)':\n            warn('unexpected_a', the_value);\n            break;\n        }\n        return the_value;\n    }\n\n    function is_weird(thing) {\n        return (\n            thing.id === '(regexp)' ||\n            thing.id === '{' ||\n            thing.id === '=>' ||\n            thing.id === 'function' ||\n            (thing.id === '[' && thing.arity === 'unary')\n        );\n    }\n\n    function are_similar(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (Array.isArray(a)) {\n            return (\n                Array.isArray(b) &&\n                a.length === b.length &&\n                a.every(function (value, index) {\n                    return are_similar(value, b[index]);\n                })\n            );\n        }\n        if (Array.isArray(b)) {\n            return false;\n        }\n        if (a.id === '(number)' && b.id === '(number)') {\n            return a.value === b.value;\n        }\n        var a_string, b_string;\n        if (a.id === '(string)') {\n            a_string = a.value;\n        } else if (a.id === '`' && a.constant) {\n            a_string = a.value[0];\n        }\n        if (b.id === '(string)') {\n            b_string = b.value;\n        } else if (b.id === '`' && b.constant) {\n            b_string = b.value[0];\n        }\n        if (typeof a_string === 'string') {\n            return a_string === b_string;\n        }\n        if (is_weird(a) || is_weird(b)) {\n            return false;\n        }\n        if (a.arity === b.arity && a.id === b.id) {\n            if (a.id === '.') {\n                return are_similar(a.expression, b.expression) &&\n                        are_similar(a.name, b.name);\n            }\n            switch (a.arity) {\n            case 'unary':\n                return are_similar(a.expression, b.expression);\n            case 'binary':\n                return a.id !== '(' &&\n                        are_similar(a.expression[0], b.expression[0]) &&\n                        are_similar(a.expression[1], b.expression[1]);\n            case 'ternary':\n                return are_similar(a.expression[0], b.expression[0]) &&\n                        are_similar(a.expression[1], b.expression[1]) &&\n                        are_similar(a.expression[2], b.expression[2]);\n            case 'function':\n            case 'regexp':\n                return false;\n            default:\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function semicolon() {\n\n// Try to match a semicolon.\n\n        if (next_token.id === ';') {\n            advance(';');\n        } else {\n            warn_at(\n                'expected_a_b',\n                token.line,\n                token.thru,\n                ';',\n                artifact(next_token)\n            );\n        }\n        anon = 'anonymous';\n    }\n\n    function statement() {\n\n// Parse a statement. Any statement may have a label, but only four statements\n// have use for one. A statement can be one of the standard statements, or\n// an assignment expression, or an invocation expression.\n\n        var first,\n            the_label,\n            the_statement,\n            the_symbol;\n        advance();\n        if (token.identifier && next_token.id === ':') {\n            the_label = token;\n            if (the_label.id === 'ignore') {\n                warn('unexpected_a', the_label);\n            }\n            advance(':');\n            switch (next_token.id) {\n            case 'do':\n            case 'for':\n            case 'switch':\n            case 'while':\n                enroll(the_label, 'label', true);\n                the_label.init = true;\n                the_label.dead = false;\n                the_statement = statement();\n                the_statement.label = the_label;\n                the_statement.statement = true;\n                return the_statement;\n            default:\n                advance();\n                warn('unexpected_label_a', the_label);\n            }\n        }\n\n// Parse the statement.\n\n        first = token;\n        first.statement = true;\n        the_symbol = syntax[first.id];\n        if (the_symbol !== undefined && the_symbol.fud !== undefined) {\n            the_symbol.disrupt = false;\n            the_symbol.statement = true;\n            the_statement = the_symbol.fud();\n        } else {\n\n// It is an expression statement.\n\n            the_statement = expression(0, true);\n            if (the_statement.wrapped && the_statement.id !== '(') {\n                warn('unexpected_a', first);\n            }\n            semicolon();\n        }\n        if (the_label !== undefined) {\n            the_label.dead = true;\n        }\n        return the_statement;\n    }\n\n    function statements() {\n\n// Parse a list of statements. Give a warning if an unreachable statement\n// follows a disruptive statement.\n\n        var array = [];\n        (function next(disrupt) {\n            var a_statement;\n            switch (next_token.id) {\n            case '}':\n            case 'case':\n            case 'default':\n            case 'else':\n            case '(end)':\n                break;\n            default:\n                a_statement = statement();\n                array.push(a_statement);\n                if (disrupt) {\n                    warn('unreachable_a', a_statement);\n                }\n                return next(a_statement.disrupt);\n            }\n        }(false));\n        return array;\n    }\n\n    function not_top_level(thing) {\n\n// Some features should not be at the outermost level.\n\n        if (functionage === global) {\n            warn('unexpected_at_top_level_a', thing);\n        }\n    }\n\n    function top_level_only(the_thing) {\n\n// Some features must be at the most outermost level.\n\n        if (blockage !== global) {\n            warn('misplaced_a', the_thing);\n        }\n    }\n\n    function block(special) {\n\n// Parse a block, a sequence of statements wrapped in braces.\n//  special 'body'      The block is a function body.\n//          'ignore'    No warning on an empty block.\n//          'naked'     No advance.\n//          undefined   Not special.\n\n        var stmts, the_block;\n        if (special !== 'naked') {\n            advance('{');\n        }\n        the_block = token;\n        the_block.arity = 'statement';\n        the_block.body = special === 'body';\n\n// All top level function bodies should include the 'use strict' pragma unless\n// the whole file is strict.\n\n        if (the_block.body && stack.length <= 1 && !global.strict) {\n            if (\n                next_token.id === '(string)' ||\n                next_token.value === 'use strict'\n            ) {\n                next_token.statement = true;\n                functionage.strict = true;\n                advance('(string)');\n                advance(';');\n            } else {\n                warn(\n                    'expected_a_before_b',\n                    next_token,\n                    (next_token.id === '`')\n                        ? '\\''\n                        : 'use strict',\n                    artifact(next_token)\n                );\n            }\n        }\n        stmts = statements();\n        the_block.block = stmts;\n        if (stmts.length === 0) {\n            if (!option.devel && special !== 'ignore') {\n                warn('empty_block', the_block);\n            }\n            the_block.disrupt = false;\n        } else {\n            the_block.disrupt = stmts[stmts.length - 1].disrupt;\n        }\n        advance('}');\n        return the_block;\n    }\n\n    function mutation_check(the_thing) {\n\n// The only expressions that may be assigned to are\n//      e.b\n//      e[b]\n//      v\n\n        if (\n            the_thing.id !== '.' &&\n            (the_thing.id !== '[' || the_thing.arity !== 'binary') &&\n            the_thing.arity !== 'variable'\n        ) {\n            warn('bad_assignment_a', the_thing);\n            return false;\n        }\n        return true;\n    }\n\n    function left_check(left, right) {\n\n// Warn if the left is not one of these:\n//      e.b\n//      e[b]\n//      e()\n//      identifier\n\n        var id = left.id;\n        if (\n            !left.identifier &&\n            (\n                left.arity !== 'binary' ||\n                (id !== '.' && id !== '(' && id !== '[')\n            )\n        ) {\n            warn('unexpected_a', right);\n            return false;\n        }\n        return true;\n    }\n\n// These functions are used to specify the grammar of our language:\n\n    function symbol(id, bp) {\n\n// Make a symbol if it does not already exist in the language's syntax.\n\n        var the_symbol = syntax[id];\n        if (the_symbol === undefined) {\n            the_symbol = empty();\n            the_symbol.id = id;\n            the_symbol.lbp = bp || 0;\n            syntax[id] = the_symbol;\n        }\n        return the_symbol;\n    }\n\n    function assignment(id) {\n\n// Make an assignment operator. The one true assignment is different because\n// its left side, when it is a variable, is not treated as an expression.\n// That case is special because that is when a variable gets initialized. The\n// other assignment operators can modify, but they cannot initialize.\n\n        var the_symbol = symbol(id, 20);\n        the_symbol.led = function (left) {\n            var the_token = token,\n                right;\n            the_token.arity = 'assignment';\n            right = expression(20 - 1);\n            if (id === '=' && left.arity === 'variable') {\n                the_token.names = left;\n                the_token.expression = right;\n            } else {\n                the_token.expression = [left, right];\n            }\n            switch (right.arity) {\n            case 'assignment':\n            case 'pre':\n            case 'post':\n                warn('unexpected_a', right);\n                break;\n            }\n            if (\n                option.es6 &&\n                left.arity === 'unary' &&\n                (left.id === '[' || left.id === '{')\n            ) {\n                warn('expected_a_before_b', left, 'const', left.id);\n            } else {\n                mutation_check(left);\n            }\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function constant(id, type, value) {\n\n// Make a constant symbol.\n\n        var the_symbol = symbol(id);\n        the_symbol.nud = (typeof value === 'function')\n            ? value\n            : function () {\n                token.constant = true;\n                if (value !== undefined) {\n                    token.value = value;\n                }\n                return token;\n            };\n        the_symbol.type = type;\n        the_symbol.value = value;\n        return the_symbol;\n    }\n\n    function infix(id, bp, f) {\n\n// Make an infix operator.\n\n        var the_symbol = symbol(id, bp);\n        the_symbol.led = function (left) {\n            var the_token = token;\n            the_token.arity = 'binary';\n            if (f !== undefined) {\n                return f(left);\n            }\n            the_token.expression = [left, expression(bp)];\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function post(id) {\n\n// Make one of the post operators.\n\n        var the_symbol = symbol(id, 150);\n        the_symbol.led = function (left) {\n            token.expression = left;\n            token.arity = 'post';\n            mutation_check(token.expression);\n            return token;\n        };\n        return the_symbol;\n    }\n\n    function pre(id) {\n\n// Make one of the pre operators.\n\n        var the_symbol = symbol(id);\n        the_symbol.nud = function () {\n            var the_token = token;\n            the_token.arity = 'pre';\n            the_token.expression = expression(150);\n            mutation_check(the_token.expression);\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function prefix(id, f) {\n\n// Make a prefix operator.\n\n        var the_symbol = symbol(id);\n        the_symbol.nud = function () {\n            var the_token = token;\n            the_token.arity = 'unary';\n            if (typeof f === 'function') {\n                return f();\n            }\n            the_token.expression = expression(150);\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n    function stmt(id, f) {\n\n// Make a statement.\n\n        var the_symbol = symbol(id);\n        the_symbol.fud = function () {\n            token.arity = 'statement';\n            return f();\n        };\n        return the_symbol;\n    }\n\n    function ternary(id1, id2) {\n\n// Make a ternary operator.\n\n        var the_symbol = symbol(id1, 30);\n        the_symbol.led = function (left) {\n            var the_token = token,\n                second = expression(20);\n            advance(id2);\n            token.arity = 'ternary';\n            the_token.arity = 'ternary';\n            the_token.expression = [left, second, expression(10)];\n            return the_token;\n        };\n        return the_symbol;\n    }\n\n// Begin defining the language.\n\n    syntax = empty();\n\n    symbol('}');\n    symbol(')');\n    symbol(']');\n    symbol(',');\n    symbol(';');\n    symbol(':');\n    symbol('*/');\n    symbol('await');\n    symbol('case');\n    symbol('catch');\n    symbol('class');\n    symbol('default');\n    symbol('else');\n    symbol('enum');\n    symbol('finally');\n    symbol('implements');\n    symbol('interface');\n    symbol('package');\n    symbol('private');\n    symbol('protected');\n    symbol('public');\n    symbol('static');\n    symbol('super');\n    symbol('void');\n    symbol('yield');\n\n    constant('(number)', 'number');\n    constant('(regexp)', 'regexp');\n    constant('(string)', 'string');\n    constant('arguments', 'object', function () {\n        warn('unexpected_a', token);\n        return token;\n    });\n    constant('eval', 'function', function () {\n        if (!option.eval) {\n            warn('unexpected_a', token);\n        } else if (next_token.id !== '(') {\n            warn('expected_a_before_b', next_token, '(', artifact());\n        }\n        return token;\n    });\n    constant('false', 'boolean', false);\n    constant('ignore', 'undefined', function () {\n        warn('unexpected_a', token);\n        return token;\n    });\n    constant('Infinity', 'number', Infinity);\n    constant('NaN', 'number', NaN);\n    constant('null', 'null', null);\n    constant('this', 'object', function () {\n        if (!option.this) {\n            warn('unexpected_a', token);\n        }\n        return token;\n    });\n    constant('true', 'boolean', true);\n    constant('undefined', 'undefined');\n\n    assignment('=');\n    assignment('+=');\n    assignment('-=');\n    assignment('*=');\n    assignment('/=');\n    assignment('%=');\n    assignment('&=');\n    assignment('|=');\n    assignment('^=');\n    assignment('<<=');\n    assignment('>>=');\n    assignment('>>>=');\n\n    infix('||', 40);\n    infix('&&', 50);\n    infix('|', 70);\n    infix('^', 80);\n    infix('&', 90);\n    infix('==', 100);\n    infix('===', 100);\n    infix('!=', 100);\n    infix('!==', 100);\n    infix('<', 110);\n    infix('>', 110);\n    infix('<=', 110);\n    infix('>=', 110);\n    infix('in', 110);\n    infix('instanceof', 110);\n    infix('<<', 120);\n    infix('>>', 120);\n    infix('>>>', 120);\n    infix('+', 130);\n    infix('-', 130);\n    infix('*', 140);\n    infix('/', 140);\n    infix('%', 140);\n    infix('(', 160, function (left) {\n        var the_paren = token,\n            the_argument;\n        if (left.id !== 'function') {\n            left_check(left, the_paren);\n        }\n        the_paren.expression = [left];\n        if (left.identifier) {\n            if (left.new) {\n                if (\n                    left.id.charAt(0) > 'Z' ||\n                    left.id === 'Boolean' ||\n                    left.id === 'Number' ||\n                    left.id === 'String' ||\n                    (left.id === 'Symbol' && option.es6)\n                ) {\n                    warn('unexpected_a', left, 'new');\n                } else if (left.id === 'Function') {\n                    if (!option.eval) {\n                        warn('unexpected_a', left, 'new Function');\n                    }\n                } else if (left.id === 'Array') {\n                    warn('expected_a_b', left, '[]', 'new Array');\n                } else if (left.id === 'Object') {\n                    warn(\n                        'expected_a_b',\n                        left,\n                        'Object.create(null)',\n                        'new Object'\n                    );\n                }\n            } else {\n                if (\n                    left.id.charAt(0) >= 'A' &&\n                    left.id.charAt(0) <= 'Z' &&\n                    left.id !== 'Boolean' &&\n                    left.id !== 'Number' &&\n                    left.id !== 'String' &&\n                    left.id !== 'Symbol'\n                ) {\n                    warn(\n                        'expected_a_before_b',\n                        left,\n                        'new',\n                        artifact(left)\n                    );\n                }\n                if (functionage.arity === 'statement') {\n                    functionage.name.calls[left.id] = left;\n                }\n            }\n        }\n        if (next_token.id !== ')') {\n            (function next() {\n                var ellipsis;\n                if (next_token.id === '...') {\n                    if (!option.es6) {\n                        warn('es6');\n                    }\n                    ellipsis = true;\n                    advance('...');\n                }\n                the_argument = expression(10);\n                if (ellipsis) {\n                    the_argument.ellipsis = true;\n                }\n                the_paren.expression.push(the_argument);\n                if (next_token.id === ',') {\n                    advance(',');\n                    return next();\n                }\n            }());\n        }\n        advance(')', the_paren);\n        if (the_paren.expression.length === 2) {\n            the_paren.free = true;\n            if (the_argument.wrapped === true) {\n                warn('unexpected_a', the_paren);\n            }\n            if (the_argument.id === '(') {\n                the_argument.wrapped = true;\n            }\n        } else {\n            the_paren.free = false;\n        }\n        return the_paren;\n    });\n    infix('.', 170, function (left) {\n        var the_token = token,\n            name = next_token;\n        if (\n            (left.id !== '(string)' || name.id !== 'indexOf') &&\n            (left.id !== '[' || (\n                name.id !== 'concat' && name.id !== 'forEach'\n            )) &&\n            (left.id !== '+' || name.id !== 'slice') &&\n            (left.id !== '(regexp)' || (\n                name.id !== 'exec' && name.id !== 'test'\n            ))\n        ) {\n            left_check(left, the_token);\n        }\n        if (!name.identifier) {\n            stop('expected_identifier_a');\n        }\n        advance();\n        survey(name);\n\n// The property name is not an expression.\n\n        the_token.name = name;\n        the_token.expression = left;\n        return the_token;\n    });\n    infix('[', 170, function (left) {\n        var the_token = token,\n            the_subscript = expression(0);\n        if (\n            the_subscript.id === '(string)' &&\n            rx_identifier.test(the_subscript.value)\n        ) {\n            warn('subscript_a', the_subscript);\n            survey(the_subscript);\n        } else if (the_subscript.id === '`') {\n            warn('unexpected_a', the_subscript);\n        }\n        left_check(left, the_token);\n        the_token.expression = [left, the_subscript];\n        advance(']');\n        return the_token;\n    });\n    infix('=>', 170, function (left) {\n        return stop('expected_a_before_b', left, '(', artifact(left));\n    });\n\n    function do_tick() {\n        var the_tick = token;\n        if (!option.es6) {\n            warn('es6', the_tick);\n        }\n        the_tick.value = [];\n        the_tick.expression = [];\n        if (next_token.id !== '`') {\n            (function part() {\n                advance('(string)');\n                the_tick.value.push(token);\n                if (next_token.id === '${') {\n                    advance('${');\n                    the_tick.expression.push(expression(0));\n                    advance('}');\n                    return part();\n                }\n            }());\n        }\n        advance('`');\n        return the_tick;\n    }\n\n    infix('`', 160, function (left) {\n        var the_tick = do_tick();\n        left_check(left, the_tick);\n        the_tick.expression = [left].concat(the_tick.expression);\n        return the_tick;\n    });\n\n    post('++');\n    post('--');\n    pre('++');\n    pre('--');\n\n    prefix('+');\n    prefix('-');\n    prefix('~');\n    prefix('!');\n    prefix('!!');\n    prefix('[', function () {\n        var the_token = token;\n        the_token.expression = [];\n        if (next_token.id !== ']') {\n            (function next() {\n                var element,\n                    ellipsis = false;\n                if (next_token.id === '...') {\n                    ellipsis = true;\n                    if (!option.es6) {\n                        warn('es6');\n                    }\n                    advance('...');\n                }\n                element = expression(10);\n                if (ellipsis) {\n                    element.ellipsis = true;\n                }\n                the_token.expression.push(element);\n                if (next_token.id === ',') {\n                    advance(',');\n                    return next();\n                }\n            }());\n        }\n        advance(']');\n        return the_token;\n    });\n    prefix('/=', function () {\n        stop('expected_a_b', token, '/\\\\=', '/=');\n    });\n    prefix('=>', function () {\n        return stop('expected_a_before_b', token, '()', '=>');\n    });\n    prefix('new', function () {\n        var the_new = token;\n        next_token.new = true;\n        the_new.expression = expression(150);\n        if (the_new.expression.id !== '(') {\n            warn('expected_a_before_b', next_token, '()', artifact(next_token));\n        }\n        return the_new;\n    });\n    prefix('typeof');\n    prefix('void', function () {\n        var the_void = token;\n        warn('unexpected_a', the_void);\n        the_void.expression = expression(0);\n        return the_void;\n    });\n\n    function parameter(list, signature) {\n        var ellipsis = false,\n            param;\n        if (next_token.id === '{') {\n            if (!option.es6) {\n                warn('es6');\n            }\n            param = next_token;\n            param.names = [];\n            advance('{');\n            signature.push('{');\n            (function subparameter() {\n                var subparam = next_token;\n                if (!subparam.identifier) {\n                    return stop('expected_identifier_a');\n                }\n                survey(subparam);\n                advance();\n                signature.push(subparam.id);\n                if (next_token.id === ':') {\n                    advance(':');\n                    advance();\n                    token.label = subparam;\n                    subparam = token;\n                    if (!subparam.identifier) {\n                        return stop('expected_identifier_a');\n                    }\n                }\n                param.names.push(subparam);\n                if (next_token.id === ',') {\n                    advance(',');\n                    signature.push(\", \");\n                    return subparameter();\n                }\n            }());\n            list.push(param);\n            advance('}');\n            signature.push('}');\n            if (next_token.id === ',') {\n                advance(',');\n                signature.push(\", \");\n                return parameter(list, signature);\n            }\n        } else if (next_token.id === '[') {\n            if (!option.es6) {\n                warn('es6');\n            }\n            param = next_token;\n            param.names = [];\n            advance('[');\n            signature.push(\"[]\");\n            (function subparameter() {\n                var subparam = next_token;\n                if (!subparam.identifier) {\n                    return stop('expected_identifier_a');\n                }\n                advance();\n                param.names.push(subparam);\n                if (next_token.id === ',') {\n                    advance(',');\n                    return subparameter();\n                }\n            }());\n            list.push(param);\n            advance(']');\n            if (next_token.id === ',') {\n                advance(',');\n                signature.push(\", \");\n                return parameter(list, signature);\n            }\n        } else {\n            if (next_token.id === '...') {\n                if (!option.es6) {\n                    warn('es6');\n                }\n                ellipsis = true;\n                signature.push(\"...\");\n                advance('...');\n            }\n            if (!next_token.identifier) {\n                return stop('expected_identifier_a');\n            }\n            param = next_token;\n            list.push(param);\n            advance();\n            signature.push(param.id);\n            if (ellipsis) {\n                param.ellipsis = true;\n            } else {\n                if (next_token.id === '=') {\n                    if (!option.es6) {\n                        warn('es6');\n                    }\n                    advance('=');\n                    param.expression = expression(0);\n                }\n                if (next_token.id === ',') {\n                    advance(',');\n                    signature.push(\", \");\n                    return parameter(list, signature);\n                }\n            }\n        }\n    }\n\n    function parameter_list() {\n        var list = [], signature = ['('];\n        if (next_token.id !== ')' && next_token.id !== '(end)') {\n            parameter(list, signature);\n        }\n        advance(')');\n        signature.push(')');\n        return [list, signature.join('')];\n    }\n\n    function do_function(the_function) {\n        var name;\n        if (the_function === undefined) {\n            the_function = token;\n\n// A function statement must have a name that will be in the parent's scope.\n\n            if (the_function.arity === 'statement') {\n                if (!next_token.identifier) {\n                    return stop('expected_identifier_a', next_token);\n                }\n                name = next_token;\n                enroll(name, 'variable', true);\n                the_function.name = name;\n                name.init = true;\n                name.calls = empty();\n                advance();\n            } else if (name === undefined) {\n\n// A function expression may have an optional name.\n\n                if (next_token.identifier) {\n                    name = next_token;\n                    the_function.name = name;\n                    advance();\n                } else {\n                    the_function.name = anon;\n                }\n            }\n        } else {\n            name = the_function.name;\n        }\n        the_function.level = functionage.level + 1;\n        if (mega_mode) {\n            warn('unexpected_a', the_function);\n        }\n\n// Don't make functions in loops. It is inefficient, and it can lead to scoping\n// errors.\n\n        if (functionage.loop > 0) {\n            warn('function_in_loop', the_function);\n        }\n\n// Give the function properties for storing its names and for observing the\n// depth of loops and switches.\n\n        the_function.context = empty();\n        the_function.loop = 0;\n        the_function.switch = 0;\n\n// Push the current function context and establish a new one.\n\n        stack.push(functionage);\n        functions.push(the_function);\n        functionage = the_function;\n        if (the_function.arity !== 'statement' && name) {\n            enroll(name, 'function', true);\n            name.dead = false;\n            name.init = true;\n            name.used = 1;\n        }\n\n// Parse the parameter list.\n\n        advance('(');\n        token.free = false;\n        token.arity = 'function';\n        var pl = parameter_list();\n        functionage.parameters = pl[0];\n        functionage.signature = pl[1];\n        functionage.parameters.forEach(function enroll_parameter(name) {\n            if (name.identifier) {\n                enroll(name, 'parameter', false);\n            } else {\n                name.names.forEach(enroll_parameter);\n            }\n        });\n\n// The function's body is a block.\n\n        the_function.block = block('body');\n        if (the_function.arity === 'statement' && next_token.line === token.line) {\n            return stop('unexpected_a', next_token);\n        }\n        if (next_token.id === '.' || next_token.id === '[') {\n            warn('unexpected_a');\n        }\n\n// Restore the previous context.\n\n        functionage = stack.pop();\n        return the_function;\n    }\n\n    prefix('function', do_function);\n\n    function fart(pl) {\n        if (next_token.id === ';') {\n            stop('wrap_assignment', token);\n        }\n        advance('=>');\n        var the_arrow = token;\n        the_arrow.arity = 'binary';\n        the_arrow.name = \"=>\";\n        the_arrow.level = functionage.level + 1;\n        functions.push(the_arrow);\n        if (functionage.loop > 0) {\n            warn('function_in_loop', the_arrow);\n        }\n\n// Give the function properties storing its names and for observing the depth\n// of loops and switches.\n\n        the_arrow.context = empty();\n        the_arrow.loop = 0;\n        the_arrow.switch = 0;\n\n// Push the current function context and establish a new one.\n\n        stack.push(functionage);\n        functionage = the_arrow;\n        the_arrow.parameters = pl[0];\n        the_arrow.signature = pl[1];\n        the_arrow.parameters.forEach(function (name) {\n            enroll(name, 'parameter', true);\n        });\n        if (!option.es6) {\n            warn('es6', the_arrow);\n        }\n        if (next_token.id === '{') {\n            warn('expected_a_b', the_arrow, \"function\", \"=>\");\n            the_arrow.block = block('body');\n        } else {\n            the_arrow.expression = expression(0);\n        }\n        functionage = stack.pop();\n        return the_arrow;\n    }\n\n    prefix('(', function () {\n        var the_paren = token,\n            the_value,\n            cadet = lookahead().id;\n\n// We can distinguish between a parameter list for => and a wrapped expression\n// with one token of lookahead.\n\n        if (\n            next_token.id === ')' ||\n            next_token.id === '...' ||\n            (next_token.identifier && (cadet === ',' || cadet === '='))\n        ) {\n            the_paren.free = false;\n            return fart(parameter_list());\n        }\n        the_paren.free = true;\n        the_value = expression(0);\n        if (the_value.wrapped === true) {\n            warn('unexpected_a', the_paren);\n        }\n        the_value.wrapped = true;\n        advance(')', the_paren);\n        if (next_token.id === \"=>\") {\n            if (the_value.arity !== 'variable') {\n                return stop('expected_identifier_a', the_value);\n            }\n            the_paren.expression = [the_value];\n            return fart([the_paren.expression, \"(\" + the_value.id + \")\"]);\n        }\n        return the_value;\n    });\n    prefix('`', do_tick);\n    prefix('{', function () {\n        var the_brace = token,\n            seen = empty();\n        the_brace.expression = [];\n        if (next_token.id !== '}') {\n            (function member() {\n                var extra = true,\n                    id,\n                    name = next_token,\n                    value;\n                advance();\n                if (\n                    (name.id === 'get' || name.id === 'set') &&\n                    next_token.identifier\n                ) {\n                    extra = name.id;\n                    name = next_token;\n                    advance();\n                }\n                id = survey(name);\n                if (seen[id] === true) {\n                    warn('duplicate_a', name);\n                } else if (seen[id] === 'get' && extra !== 'set') {\n                    warn('expected_a_before_b', name, 'set', artifact(name));\n                }\n                seen[id] = (extra === 'get')\n                    ? 'get'\n                    : true;\n                if (name.identifier) {\n                    switch (next_token.id) {\n                    case '}':\n                    case ',':\n                        if (!option.es6) {\n                            warn('es6');\n                        } else if (extra !== true) {\n                            advance(':');\n                        }\n                        value = expression(Infinity, true);\n                        break;\n                    case '(':\n                        if (!option.es6 && typeof extra !== 'string') {\n                            warn('es6');\n                        }\n                        value = do_function({\n                            arity: 'unary',\n                            from: name.from,\n                            id: 'function',\n                            line: name.line,\n                            name: name,\n                            thru: name.from\n                        }, name);\n                        break;\n                    default:\n                        advance(':');\n                        value = expression(0);\n                    }\n                    value.label = name;\n                    if (typeof extra === 'string') {\n                        value.extra = extra;\n                    }\n                    the_brace.expression.push(value);\n                } else {\n                    advance(':');\n                    value = expression(0);\n                    value.label = name;\n                    the_brace.expression.push(value);\n                }\n                if (next_token.id === ',') {\n                    advance(',');\n                    return member();\n                }\n            }());\n        }\n        advance('}');\n        return the_brace;\n    });\n\n    stmt(';', function () {\n        warn('unexpected_a', token);\n        return token;\n    });\n    stmt('{', function () {\n        warn('naked_block', token);\n        return block('naked');\n    });\n    stmt('break', function () {\n        var the_break = token,\n            the_label;\n        if (functionage.loop < 1 && functionage.switch < 1) {\n            warn('unexpected_a', the_break);\n        }\n        the_break.disrupt = true;\n        if (next_token.identifier && token.line === next_token.line) {\n            the_label = functionage.context[next_token.id];\n            if (\n                the_label === undefined ||\n                the_label.role !== 'label' ||\n                the_label.dead\n            ) {\n                warn((the_label !== undefined && the_label.dead)\n                    ? 'out_of_scope_a'\n                    : 'not_label_a');\n            } else {\n                the_label.used += 1;\n            }\n            the_break.label = next_token;\n            advance();\n        }\n        advance(';');\n        return the_break;\n    });\n\n    function do_var() {\n        var the_statement = token,\n            is_const = the_statement.id === 'const';\n        the_statement.names = [];\n\n// A program may use var or let, but not both, and let and const require\n// option.es6.\n\n        if (is_const) {\n            if (!option.es6) {\n                warn('es6', the_statement);\n            }\n        } else if (var_mode === undefined) {\n            var_mode = the_statement.id;\n            if (!option.es6 && var_mode !== 'var') {\n                warn('es6', the_statement);\n            }\n        } else if (the_statement.id !== var_mode) {\n            warn(\n                'expected_a_b',\n                the_statement,\n                var_mode,\n                the_statement.id\n            );\n        }\n\n// We don't expect to see variables created in switch statements.\n\n        if (functionage.switch > 0) {\n            warn('var_switch', the_statement);\n        }\n        if (functionage.loop > 0 && the_statement.id === 'var') {\n            warn('var_loop', the_statement);\n        }\n        (function next() {\n            if (next_token.id === '{' && the_statement.id !== 'var') {\n                var the_brace = next_token;\n                the_brace.names = [];\n                advance('{');\n                (function pair() {\n                    if (!next_token.identifier) {\n                        return stop('expected_identifier_a', next_token);\n                    }\n                    var name = next_token;\n                    survey(name);\n                    advance();\n                    if (next_token.id === ':') {\n                        advance(':');\n                        if (!next_token.identifier) {\n                            return stop('expected_identifier_a', next_token);\n                        }\n                        next_token.label = name;\n                        the_brace.names.push(next_token);\n                        enroll(next_token, 'variable', is_const);\n                        advance();\n                    } else {\n                        the_brace.names.push(name);\n                        enroll(name, 'variable', is_const);\n                    }\n                    if (next_token.id === ',') {\n                        advance(',');\n                        return pair();\n                    }\n                }());\n                advance('}');\n                advance('=');\n                the_brace.expression = expression(0);\n                the_statement.names.push(the_brace);\n            } else if (next_token.id === '[' && the_statement.id !== 'var') {\n                var the_bracket = next_token;\n                the_bracket.names = [];\n                advance('[');\n                (function element() {\n                    var ellipsis;\n                    if (next_token.id === '...') {\n                        ellipsis = true;\n                        advance('...');\n                    }\n                    if (!next_token.identifier) {\n                        return stop('expected_identifier_a', next_token);\n                    }\n                    var name = next_token;\n                    advance();\n                    the_bracket.names.push(name);\n                    enroll(name, 'variable', the_statement.id === 'const');\n                    if (ellipsis) {\n                        name.ellipsis = true;\n                    } else if (next_token.id === ',') {\n                        advance(',');\n                        return element();\n                    }\n                }());\n                advance(']');\n                advance('=');\n                the_bracket.expression = expression(0);\n                the_statement.names.push(the_bracket);\n            } else if (next_token.identifier) {\n                var name = next_token;\n                advance();\n                if (name.id === 'ignore') {\n                    warn('unexpected_a', name);\n                }\n                enroll(name, 'variable', is_const);\n                if (next_token.id === '=' || is_const) {\n                    advance('=');\n                    name.expression = expression(0);\n                    name.init = true;\n                }\n                the_statement.names.push(name);\n            } else {\n                return stop('expected_identifier_a', next_token);\n            }\n            if (next_token.id === ',') {\n                advance(',');\n                return next();\n            }\n        }());\n        the_statement.open =\n                the_statement.names.length > 1 &&\n                the_statement.line !== the_statement.names[1].line;\n        semicolon();\n        return the_statement;\n    }\n\n    stmt('const', do_var);\n    stmt('continue', function () {\n        var the_continue = token;\n        if (functionage.loop < 1) {\n            warn('unexpected_a', the_continue);\n        }\n        not_top_level(the_continue);\n        the_continue.disrupt = true;\n        warn('unexpected_a', the_continue);\n        advance(';');\n        return the_continue;\n    });\n    stmt('debugger', function () {\n        var the_debug = token;\n        if (!option.devel) {\n            warn('unexpected_a', the_debug);\n        }\n        semicolon();\n        return the_debug;\n    });\n    stmt('delete', function () {\n        var the_token = token,\n            the_value = expression(0);\n        if (\n            (the_value.id !== '.' && the_value.id !== '[') ||\n            the_value.arity !== 'binary'\n        ) {\n            stop('expected_a_b', the_value, '.', artifact(the_value));\n        }\n        the_token.expression = the_value;\n        semicolon();\n        return the_token;\n    });\n    stmt('do', function () {\n        var the_do = token;\n        not_top_level(the_do);\n        functionage.loop += 1;\n        the_do.block = block();\n        advance('while');\n        the_do.expression = condition();\n        semicolon();\n        if (the_do.block.disrupt === true) {\n            warn('weird_loop', the_do);\n        }\n        functionage.loop -= 1;\n        return the_do;\n    });\n    stmt('export', function () {\n        var the_export = token;\n        if (!option.es6) {\n            warn('es6', the_export);\n        }\n        if (typeof module_mode === 'object') {\n            warn('unexpected_directive_a', module_mode, module_mode.directive);\n        }\n        advance('default');\n        if (export_mode) {\n            warn('duplicate_a', token);\n        }\n        module_mode = true;\n        export_mode = true;\n        the_export.expression = expression(0);\n        semicolon();\n        return the_export;\n    });\n    stmt('for', function () {\n        var first,\n            the_for = token;\n        if (!option.for) {\n            warn('unexpected_a', the_for);\n        }\n        not_top_level(the_for);\n        functionage.loop += 1;\n        advance('(');\n        token.free = true;\n        if (next_token.id === ';') {\n            return stop('expected_a_b', the_for, 'while (', 'for (;');\n        }\n        if (\n            next_token.id === 'var' ||\n            next_token.id === 'let' ||\n            next_token.id === 'const'\n        ) {\n            return stop('unexpected_a');\n        }\n        first = expression(0);\n        if (first.id === 'in') {\n            if (first.expression[0].arity !== 'variable') {\n                warn('bad_assignment_a', first.expression[0]);\n            }\n            the_for.name = first.expression[0];\n            the_for.expression = first.expression[1];\n            warn('expected_a_b', the_for, 'Object.keys', 'for in');\n        } else {\n            the_for.initial = first;\n            advance(';');\n            the_for.expression = expression(0);\n            advance(';');\n            the_for.inc = expression(0);\n            if (the_for.inc.id === '++') {\n                warn('expected_a_b', the_for.inc, '+= 1', '++');\n            }\n        }\n        advance(')');\n        the_for.block = block();\n        if (the_for.block.disrupt === true) {\n            warn('weird_loop', the_for);\n        }\n        functionage.loop -= 1;\n        return the_for;\n    });\n    stmt('function', do_function);\n    stmt('if', function () {\n        var the_else,\n            the_if = token;\n        the_if.expression = condition();\n        the_if.block = block();\n        if (next_token.id === 'else') {\n            advance('else');\n            the_else = token;\n            the_if.else = (next_token.id === 'if')\n                ? statement()\n                : block();\n            if (the_if.block.disrupt === true) {\n                if (the_if.else.disrupt === true) {\n                    the_if.disrupt = true;\n                } else {\n                    warn('unexpected_a', the_else);\n                }\n            }\n        }\n        return the_if;\n    });\n    stmt('import', function () {\n        var the_import = token;\n        if (!option.es6) {\n            warn('es6', the_import);\n        } else if (typeof module_mode === 'object') {\n            warn('unexpected_directive_a', module_mode, module_mode.directive);\n        }\n        module_mode = true;\n        if (!next_token.identifier) {\n            return stop('expected_identifier_a');\n        }\n        var name = next_token;\n        advance();\n        if (name.id === 'ignore') {\n            warn('unexpected_a', name);\n        }\n        enroll(name, 'variable', true);\n        advance('from');\n        advance('(string)');\n        the_import.import = token;\n        the_import.name = name;\n        if (!rx_identifier.test(token.value)) {\n            warn('bad_module_name_a', token);\n        }\n        imports.push(token.value);\n        semicolon();\n        return the_import;\n    });\n    stmt('let', do_var);\n    stmt('return', function () {\n        var the_return = token;\n        not_top_level(the_return);\n        the_return.disrupt = true;\n        if (next_token.id !== ';' && the_return.line === next_token.line) {\n            the_return.expression = expression(10);\n        }\n        advance(';');\n        return the_return;\n    });\n    stmt('switch', function () {\n        var dups = [],\n            last,\n            stmts,\n            the_cases = [],\n            the_disrupt = true,\n            the_switch = token;\n        not_top_level(the_switch);\n        functionage.switch += 1;\n        advance('(');\n        token.free = true;\n        the_switch.expression = expression(0);\n        the_switch.block = the_cases;\n        advance(')');\n        advance('{');\n        (function major() {\n            var the_case = next_token;\n            the_case.arity = 'statement';\n            the_case.expression = [];\n            (function minor() {\n                advance('case');\n                token.switch = true;\n                var exp = expression(0);\n                if (dups.some(function (thing) {\n                    return are_similar(thing, exp);\n                })) {\n                    warn('unexpected_a', exp);\n                }\n                dups.push(exp);\n                the_case.expression.push(exp);\n                advance(':');\n                if (next_token.id === 'case') {\n                    return minor();\n                }\n            }());\n            stmts = statements();\n            if (stmts.length < 1) {\n                warn('expected_statements_a');\n                return;\n            }\n            the_case.block = stmts;\n            the_cases.push(the_case);\n            last = stmts[stmts.length - 1];\n            if (last.disrupt) {\n                if (last.id === 'break' && last.label === undefined) {\n                    the_disrupt = false;\n                }\n            } else {\n                warn(\n                    'expected_a_before_b',\n                    next_token,\n                    'break;',\n                    artifact(next_token)\n                );\n            }\n            if (next_token.id === 'case') {\n                return major();\n            }\n        }());\n        dups = undefined;\n        if (next_token.id === 'default') {\n            advance('default');\n            token.switch = true;\n            advance(':');\n            the_switch.else = statements();\n            if (the_switch.else.length < 1) {\n                warn('expected_statements_a');\n                the_disrupt = false;\n            } else {\n                the_disrupt =\n                        the_disrupt &&\n                        the_switch.else[the_switch.else.length - 1].disrupt;\n            }\n        } else {\n            the_disrupt = false;\n        }\n        advance('}', the_switch);\n        functionage.switch -= 1;\n        the_switch.disrupt = the_disrupt;\n        return the_switch;\n    });\n    stmt('throw', function () {\n        var the_throw = token;\n        the_throw.disrupt = true;\n        the_throw.expression = expression(10);\n        semicolon();\n        return the_throw;\n    });\n    stmt('try', function () {\n        var clause = false,\n            the_catch,\n            the_disrupt,\n            the_try = token;\n        the_try.block = block();\n        the_disrupt = the_try.block.disrupt;\n        if (next_token.id === 'catch') {\n            var ignored = 'ignore';\n            clause = true;\n            the_catch = next_token;\n            the_try.catch = the_catch;\n            advance('catch');\n            advance('(');\n            if (!next_token.identifier) {\n                return stop('expected_identifier_a', next_token);\n            }\n            if (next_token.id !== 'ignore') {\n                ignored = undefined;\n                the_catch.name = next_token;\n                enroll(next_token, 'exception', true);\n            }\n            advance();\n            advance(')');\n            the_catch.block = block(ignored);\n            if (the_catch.block.disrupt !== true) {\n                the_disrupt = false;\n            }\n        }\n        if (next_token.id === 'finally') {\n            clause = true;\n            advance('finally');\n            the_try.else = block();\n            the_disrupt = the_try.else.disrupt;\n        }\n        the_try.disrupt = the_disrupt;\n        if (!clause) {\n            warn('expected_a_before_b', next_token, 'catch', artifact(next_token));\n        }\n        return the_try;\n    });\n    stmt('var', do_var);\n    stmt('while', function () {\n        var the_while = token;\n        not_top_level(the_while);\n        functionage.loop += 1;\n        the_while.expression = condition();\n        the_while.block = block();\n        if (the_while.block.disrupt === true) {\n            warn('weird_loop', the_while);\n        }\n        functionage.loop -= 1;\n        return the_while;\n    });\n    stmt('with', function () {\n        stop('unexpected_a', token);\n    });\n\n    ternary('?', ':');\n\n// Ambulation of the parse tree.\n\n    function action(when) {\n\n// Produce a function that will register task functions that will be called as\n// the tree is traversed.\n\n        return function (arity, id, task) {\n            var a_set = when[arity],\n                i_set;\n\n// The id parameter is optional. If excluded, the task will be applied to all\n// ids.\n\n            if (typeof id !== 'string') {\n                task = id;\n                id = '(all)';\n            }\n\n// If this arity has no registrations yet, then create a set object to hold\n// them.\n\n            if (a_set === undefined) {\n                a_set = empty();\n                when[arity] = a_set;\n            }\n\n// If this id has no registrations yet, then create a set array to hold them.\n\n            i_set = a_set[id];\n            if (i_set === undefined) {\n                i_set = [];\n                a_set[id] = i_set;\n            }\n\n// Register the task with the arity and the id.\n\n            i_set.push(task);\n        };\n    }\n\n    function amble(when) {\n\n// Produce a function that will act on the tasks registered by an action\n// function while walking the tree.\n\n        return function (the_token) {\n\n// Given a task set that was built by an action function, run all of the\n// relevant tasks on the token.\n\n            var a_set = when[the_token.arity],\n                i_set;\n\n// If there are tasks associated with the token's arity...\n\n            if (a_set !== undefined) {\n\n// If there are tasks associated with the token's id...\n\n                i_set = a_set[the_token.id];\n                if (i_set !== undefined) {\n                    i_set.forEach(function (task) {\n                        return task(the_token);\n                    });\n                }\n\n// If there are tasks for all ids.\n\n                i_set = a_set['(all)'];\n                if (i_set !== undefined) {\n                    i_set.forEach(function (task) {\n                        return task(the_token);\n                    });\n                }\n            }\n        };\n    }\n\n    var posts = empty(),\n        pres = empty(),\n        preaction = action(pres),\n        postaction = action(posts),\n        preamble = amble(pres),\n        postamble = amble(posts);\n\n    function walk_expression(thing) {\n        if (thing) {\n            if (Array.isArray(thing)) {\n                thing.forEach(walk_expression);\n            } else {\n                preamble(thing);\n                walk_expression(thing.expression);\n                if (thing.id === 'function') {\n                    walk_statement(thing.block);\n                }\n                switch (thing.arity) {\n                case 'post':\n                case 'pre':\n                    warn('unexpected_a', thing);\n                    break;\n                case 'statement':\n                case 'assignment':\n                    warn('unexpected_statement_a', thing);\n                    break;\n                }\n                postamble(thing);\n            }\n        }\n    }\n\n    function walk_statement(thing) {\n        if (thing) {\n            if (Array.isArray(thing)) {\n                thing.forEach(walk_statement);\n            } else {\n                preamble(thing);\n                walk_expression(thing.expression);\n                switch (thing.arity) {\n                case 'statement':\n                case 'assignment':\n                    break;\n                case 'binary':\n                    if (thing.id !== '(') {\n                        warn('unexpected_expression_a', thing);\n                    }\n                    break;\n                default:\n                    warn('unexpected_expression_a', thing);\n                }\n                walk_statement(thing.block);\n                walk_statement(thing.else);\n                postamble(thing);\n            }\n        }\n    }\n\n    function lookup(thing) {\n        if (thing.arity === 'variable') {\n\n// Look up the variable in the current context.\n\n            var the_variable = functionage.context[thing.id];\n\n// If it isn't local, search all the other contexts. If there are name\n// collisions, take the most recent.\n\n            if (the_variable === undefined) {\n                stack.forEach(function (outer) {\n                    var a_variable = outer.context[thing.id];\n                    if (\n                        a_variable !== undefined &&\n                        a_variable.role !== 'label'\n                    ) {\n                        the_variable = a_variable;\n                    }\n                });\n\n// If it isn't in any of those either, perhaps it is a predefined global.\n// If so, add it to the global context.\n\n                if (the_variable === undefined) {\n                    if (declared_globals[thing.id] === undefined) {\n                        warn('undeclared_a', thing);\n                        return;\n                    }\n                    the_variable = {\n                        dead: false,\n                        function: global,\n                        id: thing.id,\n                        init: true,\n                        role: 'variable',\n                        used: 0,\n                        writable: false\n                    };\n                    global.context[thing.id] = the_variable;\n                }\n                the_variable.closure = true;\n                functionage.context[thing.id] = the_variable;\n            } else if (the_variable.role === 'label') {\n                warn('label_a', thing);\n            }\n            if (the_variable.dead) {\n                warn('out_of_scope_a', thing);\n            }\n            return the_variable;\n        }\n    }\n\n    function subactivate(name) {\n        name.init = true;\n        name.dead = false;\n        blockage.live.push(name);\n    }\n\n    function preaction_function(thing) {\n        if (thing.arity === 'statement' && blockage.body !== true) {\n            warn('unexpected_a', thing);\n        }\n        stack.push(functionage);\n        block_stack.push(blockage);\n        functionage = thing;\n        blockage = thing;\n        thing.live = [];\n        if (typeof thing.name === 'object') {\n            thing.name.dead = false;\n            thing.name.init = true;\n        }\n        switch (thing.extra) {\n        case 'get':\n            if (thing.parameters.length !== 0) {\n                warn('bad_get', thing);\n            }\n            break;\n        case 'set':\n            if (thing.parameters.length !== 1) {\n                warn('bad_set', thing);\n            }\n            break;\n        }\n        thing.parameters.forEach(function (name) {\n            walk_expression(name.expression);\n            if (name.id === '{' || name.id === '[') {\n                name.names.forEach(subactivate);\n            } else {\n                name.dead = false;\n                name.init = true;\n            }\n        });\n    }\n\n    function bitwise_check(thing) {\n        if (!option.bitwise && bitwiseop[thing.id] === true) {\n            warn('unexpected_a', thing);\n        }\n        if (\n            thing.id !== '(' &&\n            thing.id !== '&&' &&\n            thing.id !== '||' &&\n            thing.id !== '=' &&\n            Array.isArray(thing.expression) &&\n            thing.expression.length === 2 && (\n                relationop[thing.expression[0].id] === true ||\n                relationop[thing.expression[1].id] === true\n            )\n        ) {\n            warn('unexpected_a', thing);\n        }\n    }\n\n    function pop_block() {\n        blockage.live.forEach(function (name) {\n            name.dead = true;\n        });\n        delete blockage.live;\n        blockage = block_stack.pop();\n    }\n\n    function activate(name) {\n        if (name.expression !== undefined) {\n            walk_expression(name.expression);\n            if (name.id === '{' || name.id === '[') {\n                name.names.forEach(subactivate);\n            } else {\n                name.init = true;\n            }\n        }\n        name.dead = false;\n        blockage.live.push(name);\n    }\n\n    function action_var(thing) {\n        thing.names.forEach(activate);\n    }\n\n    preaction('assignment', bitwise_check);\n    preaction('binary', bitwise_check);\n    preaction('binary', function (thing) {\n        if (relationop[thing.id] === true) {\n            var left = thing.expression[0],\n                right = thing.expression[1];\n            if (left.id === 'NaN' || right.id === 'NaN') {\n                warn('isNaN', thing);\n            } else if (left.id === 'typeof') {\n                if (right.id !== '(string)') {\n                    if (right.id !== 'typeof') {\n                        warn('expected_string_a', right);\n                    }\n                } else {\n                    var value = right.value;\n                    if (value === 'symbol') {\n                        if (!option.es6) {\n                            warn('es6', right, value);\n                        }\n                    } else if (value === 'null' || value === 'undefined') {\n                        warn('unexpected_typeof_a', right, value);\n                    } else if (\n                        value !== 'boolean' &&\n                        value !== 'function' &&\n                        value !== 'number' &&\n                        value !== 'object' &&\n                        value !== 'string'\n                    ) {\n                        warn('expected_type_string_a', right, value);\n                    }\n                }\n            }\n        }\n    });\n    preaction('binary', '==', function (thing) {\n        warn('expected_a_b', thing, '===', '==');\n    });\n    preaction('binary', '!=', function (thing) {\n        warn('expected_a_b', thing, '!==', '!=');\n    });\n    preaction('binary', '=>', preaction_function);\n    preaction('binary', '||', function (thing) {\n        thing.expression.forEach(function (thang) {\n            if (thang.id === '&&' && !thang.wrapped) {\n                warn('and', thang);\n            }\n        });\n    });\n    preaction('binary', '(', function (thing) {\n        var left = thing.expression[0];\n        if (\n            left.identifier &&\n            functionage.context[left.id] === undefined &&\n            typeof functionage.name === 'object'\n        ) {\n            var parent = functionage.name.function;\n            if (parent) {\n                var left_variable = parent.context[left.id];\n                if (\n                    left_variable !== undefined &&\n                    left_variable.dead &&\n                    left_variable.function === parent &&\n                    left_variable.calls !== undefined &&\n                    left_variable.calls[functionage.name.id] !== undefined\n                ) {\n                    left_variable.dead = false;\n                }\n            }\n        }\n    });\n    preaction('binary', 'in', function (thing) {\n        warn('infix_in', thing);\n    });\n    preaction('statement', '{', function (thing) {\n        block_stack.push(blockage);\n        blockage = thing;\n        thing.live = [];\n    });\n    preaction('statement', 'for', function (thing) {\n        if (thing.name !== undefined) {\n            var the_variable = lookup(thing.name);\n            if (the_variable !== undefined) {\n                the_variable.init = true;\n                if (!the_variable.writable) {\n                    warn('bad_assignment_a', thing.name);\n                }\n            }\n        }\n        walk_statement(thing.initial);\n    });\n    preaction('statement', 'function', preaction_function);\n    preaction('unary', '~', bitwise_check);\n    preaction('unary', 'function', preaction_function);\n    preaction('variable', function (thing) {\n        var the_variable = lookup(thing);\n        if (the_variable !== undefined) {\n            thing.variable = the_variable;\n            the_variable.used += 1;\n        }\n    });\n\n    function init_variable(name) {\n        var the_variable = lookup(name);\n        if (the_variable !== undefined) {\n            if (the_variable.writable) {\n                the_variable.init = true;\n                return;\n            }\n        }\n        warn('bad_assignment_a', name);\n    }\n\n    postaction('assignment', function (thing) {\n\n// Assignment using = sets the init property of a variable. No other assignment\n// operator can do this. A = token keeps that variable (or array of variables\n// in case of destructuring) in its name property.\n\n        if (thing.id === '=') {\n            if (thing.names !== undefined) {\n                if (Array.isArray(thing.names)) {\n                    thing.names.forEach(init_variable);\n                } else {\n                    init_variable(thing.names);\n                }\n            }\n        } else {\n            var lvalue = thing.expression[0];\n            if (lvalue.arity === 'variable') {\n                if (!lvalue.variable || lvalue.variable.writable !== true) {\n                    warn('bad_assignment_a', lvalue);\n                }\n            }\n        }\n    });\n\n    function postaction_function(thing) {\n        delete functionage.loop;\n        delete functionage.switch;\n        functionage = stack.pop();\n        if (thing.wrapped) {\n            warn('unexpected_parens', thing);\n        }\n        return pop_block();\n    }\n\n    postaction('binary', function (thing) {\n        var right;\n        if (relationop[thing.id]) {\n            if (\n                is_weird(thing.expression[0]) ||\n                is_weird(thing.expression[1]) ||\n                are_similar(thing.expression[0], thing.expression[1]) ||\n                (\n                    thing.expression[0].constant === true &&\n                    thing.expression[1].constant === true\n                )\n            ) {\n                warn('weird_relation_a', thing);\n            }\n        }\n        switch (thing.id) {\n        case '+':\n        case '-':\n            right = thing.expression[1];\n            if (\n                right.id === thing.id &&\n                right.arity === 'unary' &&\n                !right.wrapped\n            ) {\n                warn('wrap_unary', right);\n            }\n            break;\n        case '=>':\n        case '(':\n            break;\n        case '.':\n            if (thing.expression.id === 'RegExp') {\n                warn('weird_expression_a', thing);\n            }\n            break;\n        default:\n            if (\n                thing.expression[0].constant === true &&\n                thing.expression[1].constant === true\n            ) {\n                thing.constant = true;\n            }\n        }\n    });\n    postaction('binary', '&&', function (thing) {\n        if (\n            is_weird(thing.expression[0]) ||\n            are_similar(thing.expression[0], thing.expression[1]) ||\n            thing.expression[0].constant === true ||\n            thing.expression[1].constant === true\n        ) {\n            warn('weird_condition_a', thing);\n        }\n    });\n    postaction('binary', '||', function (thing) {\n        if (\n            is_weird(thing.expression[0]) ||\n            are_similar(thing.expression[0], thing.expression[1]) ||\n            thing.expression[0].constant === true\n        ) {\n            warn('weird_condition_a', thing);\n        }\n    });\n    postaction('binary', '=>', postaction_function);\n    postaction('binary', '(', function (thing) {\n        if (!thing.wrapped && thing.expression[0].id === 'function') {\n            warn('wrap_immediate', thing);\n        }\n    });\n    postaction('binary', '[', function (thing) {\n        if (thing.expression[0].id === 'RegExp') {\n            warn('weird_expression_a', thing);\n        }\n        if (is_weird(thing.expression[1])) {\n            warn('weird_expression_a', thing.expression[1]);\n        }\n    });\n    postaction('statement', '{', pop_block);\n    postaction('statement', 'const', action_var);\n    postaction('statement', 'export', top_level_only);\n    postaction('statement', 'for', function (thing) {\n        walk_statement(thing.inc);\n    });\n    postaction('statement', 'function', postaction_function);\n    postaction('statement', 'import', function (the_thing) {\n        var name = the_thing.name;\n        name.init = true;\n        name.dead = false;\n        blockage.live.push(name);\n        return top_level_only(the_thing);\n    });\n    postaction('statement', 'let', action_var);\n    postaction('statement', 'try', function (thing) {\n        if (thing.catch !== undefined) {\n            var the_name = thing.catch.name;\n            if (the_name !== undefined) {\n                var the_variable = functionage.context[the_name.id];\n                the_variable.dead = false;\n                the_variable.init = true;\n            }\n            walk_statement(thing.catch.block);\n        }\n    });\n    postaction('statement', 'var', action_var);\n    postaction('ternary', function (thing) {\n        if (\n            is_weird(thing.expression[0]) ||\n            thing.expression[0].constant === true ||\n            are_similar(thing.expression[1], thing.expression[2])\n        ) {\n            warn('unexpected_a', thing);\n        } else if (are_similar(thing.expression[0], thing.expression[1])) {\n            warn('expected_a_b', thing, '||', '?');\n        } else if (are_similar(thing.expression[0], thing.expression[2])) {\n            warn('expected_a_b', thing, '&&', '?');\n        } else if (\n            thing.expression[1].id === 'true' &&\n            thing.expression[2].id === 'false'\n        ) {\n            warn('expected_a_b', thing, '!!', '?');\n        } else if (\n            thing.expression[1].id === 'false' &&\n            thing.expression[2].id === 'true'\n        ) {\n            warn('expected_a_b', thing, '!', '?');\n        } else if (thing.expression[0].wrapped !== true && (\n            thing.expression[0].id === '||' ||\n            thing.expression[0].id === '&&'\n        )) {\n            warn('wrap_condition', thing.expression[0]);\n        }\n    });\n    postaction('unary', function (thing) {\n        switch (thing.id) {\n        case '[':\n        case '{':\n        case 'function':\n        case 'new':\n            break;\n        case '`':\n            if (thing.expression.every(function (thing) {\n                return thing.constant;\n            })) {\n                thing.constant = true;\n            }\n            break;\n        default:\n            if (thing.expression.constant === true) {\n                thing.constant = true;\n            }\n        }\n    });\n    postaction('unary', 'function', postaction_function);\n\n    function delve(the_function) {\n        Object.keys(the_function.context).forEach(function (id) {\n            if (id !== 'ignore') {\n                var name = the_function.context[id];\n                if (name.function === the_function) {\n                    if (name.used === 0) {\n                        warn('unused_a', name);\n                    } else if (!name.init) {\n                        warn('uninitialized_a', name);\n                    }\n                }\n            }\n        });\n    }\n\n    function uninitialized_and_unused() {\n\n// Delve into the functions looking for variables that were not initialized\n// or used. If the file imports or exports, then its global object is also\n// delved.\n\n        if (module_mode === true || option.node) {\n            delve(global);\n        }\n        functions.forEach(delve);\n    }\n\n// Go through the token list, looking at usage of whitespace.\n\n    function whitage() {\n        var closer = '(end)',\n            free = false,\n            left = global,\n            margin = 0,\n            nr_comments_skipped = 0,\n            open = true,\n            qmark = '',\n            result,\n            right;\n\n        function expected_at(at) {\n            warn(\n                'expected_a_at_b_c',\n                right,\n                artifact(right),\n                fudge + at,\n                artifact_column(right)\n            );\n        }\n\n        function at_margin(fit) {\n            var at = margin + fit;\n            if (right.from !== at) {\n                return expected_at(at);\n            }\n        }\n\n        function no_space_only() {\n            if (left.line !== right.line || left.thru !== right.from) {\n                warn(\n                    'unexpected_space_a_b',\n                    right,\n                    artifact(left),\n                    artifact(right)\n                );\n            }\n        }\n\n        function no_space() {\n            if (left.line === right.line) {\n                if (left.thru !== right.from && nr_comments_skipped === 0) {\n                    warn(\n                        'unexpected_space_a_b',\n                        right,\n                        artifact(left),\n                        artifact(right)\n                    );\n                }\n            } else {\n                if (open) {\n                    var at = (free)\n                        ? margin\n                        : margin + 8;\n                    if (right.from < at) {\n                        expected_at(at);\n                    }\n                } else {\n                    if (right.from !== margin + 8) {\n                        expected_at(margin + 8);\n                    }\n                }\n            }\n        }\n\n        function one_space_only() {\n            if (left.line !== right.line || left.thru + 1 !== right.from) {\n                warn(\n                    'expected_space_a_b',\n                    right,\n                    artifact(left),\n                    artifact(right)\n                );\n            }\n        }\n\n        function one_space() {\n            if (left.line === right.line) {\n                if (left.thru + 1 !== right.from && nr_comments_skipped === 0) {\n                    warn(\n                        'expected_space_a_b',\n                        right,\n                        artifact(left),\n                        artifact(right)\n                    );\n                }\n            } else {\n                if (free) {\n                    if (right.from < margin) {\n                        expected_at(margin);\n                    }\n                } else {\n                    if (right.from !== margin + 8) {\n                        expected_at(margin + 8);\n                    }\n                }\n            }\n        }\n\n        function unqmark() {\n\n// Undo the effects of dangling nested ternary operators.\n\n            var level = qmark.length;\n            if (level > 0) {\n                margin -= level * 4;\n            }\n            qmark = '';\n        }\n\n        stack = [];\n        tokens.forEach(function (the_token) {\n            right = the_token;\n            if (right.id === '(comment)' || right.id === '(end)') {\n                nr_comments_skipped += 1;\n            } else {\n\n// If left is an opener and right is not the closer, then push the previous\n// state. If the token following the opener is on the next line, then this is\n// an open form. If the tokens are on different lines, then it is a closed for.\n// Open form is more readable, with each item (statement, argument, parameter,\n// etc) starting on its own line. Closed form is more compact. Statement blocks\n// are always in open form.\n\n                var new_closer = opener[left.id];\n                if (typeof new_closer === 'string') {\n                    if (new_closer !== right.id) {\n                        stack.push({\n                            closer: closer,\n                            free: free,\n                            margin: margin,\n                            open: open,\n                            qmark: qmark\n                        });\n                        qmark = '';\n                        closer = new_closer;\n                        if (left.line !== right.line) {\n                            free = closer === ')' && left.free;\n                            open = true;\n                            margin += 4;\n                            if (right.role === 'label') {\n                                if (right.from !== 0) {\n                                    expected_at(0);\n                                }\n                            } else if (right.switch) {\n                                unqmark();\n                                at_margin(-4);\n                            } else {\n                                at_margin(0);\n                            }\n                        } else {\n                            if (right.statement || right.role === 'label') {\n                                warn(\n                                    'expected_line_break_a_b',\n                                    right,\n                                    artifact(left),\n                                    artifact(right)\n                                );\n                            }\n                            free = false;\n                            open = false;\n                            no_space_only();\n                        }\n                    } else {\n\n// If left and right are opener and closer, then the placement of right depends\n// on the openness. Illegal pairs (like {]) have already been detected.\n\n                        if (left.line === right.line) {\n                            no_space();\n                        } else {\n                            at_margin(0);\n                        }\n                    }\n                } else {\n\n// If right is a closer, then pop the previous state,\n\n                    if (right.id === closer) {\n                        var previous = stack.pop();\n                        margin = previous.margin;\n                        if (open && right.id !== ';') {\n                            at_margin(0);\n                        } else {\n                            no_space_only();\n                        }\n                        closer = previous.closer;\n                        free = previous.free;\n                        open = previous.open;\n                        qmark = previous.qmark;\n                    } else {\n\n// Left is not an opener, and right is not a closer. The nature of left and\n// right will determine the space between them.\n\n// If left is , or ; or right is a statement then if open, right must go at the\n// margin, or if closed, a space before.\n\n\n                        if (right.switch) {\n                            unqmark();\n                            at_margin(-4);\n                        } else if (right.role === 'label') {\n                            if (right.from !== 0) {\n                                expected_at(0);\n                            }\n                        } else if (left.id === ',') {\n                            unqmark();\n                            if (!open || (\n                                (free || closer === ']') &&\n                                left.line === right.line\n                            )) {\n                                one_space();\n                            } else {\n                                at_margin(0);\n                            }\n\n// If right is a ternary operator, line it up on the margin. Use qmark to\n// deal with nested ternary operators.\n\n                        } else if (right.arity === 'ternary') {\n                            if (right.id === '?') {\n                                margin += 4;\n                                qmark += '?';\n                            } else {\n                                result = qmark.match(rx_colons);\n                                qmark = result[1] + ':';\n                                margin -= 4 * result[2].length;\n                            }\n                            at_margin(0);\n                        } else if (right.arity === 'binary' && right.id === '(' && free) {\n                            no_space();\n                        } else if (\n                            left.id === '.' ||\n                            left.id === '...' ||\n                            right.id === ',' ||\n                            right.id === ';' ||\n                            right.id === ':' ||\n                            (right.arity === 'binary' && (\n                                right.id === '(' ||\n                                right.id === '['\n                            )) ||\n                            (right.arity === 'function' && left.id !== 'function')\n                        ) {\n                            no_space_only();\n                        } else if (right.id === '.') {\n                            if (left.line === right.line) {\n                                no_space();\n                            } else {\n                                if (!rx_dot.test(qmark)) {\n                                    qmark += '.';\n                                    margin += 4;\n                                }\n                                at_margin(0);\n                            }\n                        } else if (left.id === ';') {\n                            unqmark();\n                            if (open) {\n                                at_margin(0);\n                            } else {\n                                one_space();\n                            }\n                        } else if (\n                            left.arity === 'ternary' ||\n                            left.id === 'case' ||\n                            left.id === 'catch' ||\n                            left.id === 'else' ||\n                            left.id === 'finally' ||\n                            left.id === 'while' ||\n                            right.id === 'catch' ||\n                            right.id === 'else' ||\n                            right.id === 'finally' ||\n                            (right.id === 'while' && !right.statement) ||\n                            (left.id === ')' && right.id === '{')\n                        ) {\n                            one_space_only();\n                        } else if (right.statement === true) {\n                            if (open) {\n                                at_margin(0);\n                            } else {\n                                one_space();\n                            }\n                        } else if (\n                            left.id === 'var' ||\n                            left.id === 'const' ||\n                            left.id === 'let'\n                        ) {\n                            stack.push({\n                                closer: closer,\n                                free: free,\n                                margin: margin,\n                                open: open,\n                                qmark: qmark\n                            });\n                            closer = ';';\n                            free = false;\n                            open = left.open;\n                            qmark = '';\n                            if (open) {\n                                margin = margin + 4;\n                                at_margin(0);\n                            } else {\n                                one_space_only();\n                            }\n                        } else if (\n\n// There is a space between left and right.\n\n                            spaceop[left.id] === true ||\n                            spaceop[right.id] === true ||\n                            (\n                                left.arity === 'binary' &&\n                                (left.id === '+' || left.id === '-')\n                            ) ||\n                            (\n                                right.arity === 'binary' &&\n                                (right.id === '+' || right.id === '-')\n                            ) ||\n                            left.id === 'function' ||\n                            left.id === ':' ||\n                            (\n                                (\n                                    left.identifier ||\n                                    left.id === '(string)' ||\n                                    left.id === '(number)'\n                                ) &&\n                                (\n                                    right.identifier ||\n                                    right.id === '(string)' ||\n                                    right.id === '(number)'\n                                )\n                            ) ||\n                            (left.arity === 'statement' && right.id !== ';')\n                        ) {\n                            one_space();\n                        } else if (left.arity === 'unary') {\n                            no_space_only();\n                        }\n                    }\n                }\n                nr_comments_skipped = 0;\n                delete left.calls;\n                delete left.dead;\n                delete left.free;\n                delete left.init;\n                delete left.open;\n                delete left.used;\n                left = right;\n            }\n        });\n    }\n\n// The jslint function itself.\n\n    return function (source, option_object, global_array) {\n        try {\n            warnings = [];\n            option = option_object || empty();\n            anon = \"anonymous\";\n            block_stack = [];\n            declared_globals = empty();\n            directive_mode = true;\n            early_stop = true;\n            export_mode = false;\n            fudge = (option.fudge)\n                ? 1\n                : 0;\n            functions = [];\n            global = {\n                id: '(global)',\n                body: true,\n                context: empty(),\n                from: 0,\n                level: 0,\n                line: 0,\n                live: [],\n                loop: 0,\n                switch: 0,\n                thru: 0\n            };\n            blockage = global;\n            functionage = global;\n            imports = [];\n            json_mode = false;\n            mega_mode = false;\n            module_mode = false;\n            next_token = global;\n            property = empty();\n            stack = [];\n            tenure = undefined;\n            token = global;\n            token_nr = 0;\n            var_mode = undefined;\n            populate(declared_globals, standard, false);\n            if (global_array !== undefined) {\n                populate(declared_globals, global_array, false);\n            }\n            Object.keys(option).forEach(function (name) {\n                if (option[name] === true) {\n                    var allowed = allowed_option[name];\n                    if (Array.isArray(allowed)) {\n                        populate(declared_globals, allowed, false);\n                    }\n                }\n            });\n            tokenize(source);\n            advance();\n            if (tokens[0].id === '{' || tokens[0].id === '[') {\n                json_mode = true;\n                tree = json_value();\n                advance('(end)');\n            } else {\n\n// Because browsers encourage combining of script files, the first token might\n// be a semicolon to defend against a missing semicolon in the preceding file.\n\n                if (option.browser) {\n                    if (next_token.id === ';') {\n                        advance(';');\n                    }\n                } else {\n\n// If we are not in a browser, then the file form of strict pragma may be used.\n\n                    if (\n                        next_token.id === '(string)' &&\n                        next_token.value === 'use strict'\n                    ) {\n                        advance('(string)');\n                        advance(';');\n                        global.strict = true;\n                    }\n                }\n                tree = statements();\n                advance('(end)');\n                functionage = global;\n                walk_statement(tree);\n                uninitialized_and_unused();\n                if (!option.white) {\n                    whitage();\n                }\n            }\n            early_stop = false;\n        } catch (e) {\n            if (e.name !== 'JSLintError') {\n                warnings.push(e);\n            }\n        }\n        return {\n            edition: \"2015-10-29\",\n            functions: functions,\n            global: global,\n            id: \"(JSLint)\",\n            imports: imports,\n            json: json_mode,\n            lines: lines,\n            module: module_mode === true,\n            ok: warnings.length === 0 && !early_stop,\n            option: option,\n            property: property,\n            stop: early_stop,\n            tokens: tokens,\n            tree: tree,\n            warnings: warnings.sort(function (a, b) {\n                return a.line - b.line || a.column - b.column;\n            })\n        };\n    };\n}());\n","/home/travis/build/npmtest/node-npmtest-jslint/node_modules/jslint/lib/jslint.js":"// jslint.js\n// 2013-08-26\n\n// Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// The Software shall be used for Good, not Evil.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// WARNING: JSLint will hurt your feelings.\n\n// JSLINT is a global function. It takes two parameters.\n\n//     var myResult = JSLINT(source, option);\n\n// The first parameter is either a string or an array of strings. If it is a\n// string, it will be split on '\\n' or '\\r'. If it is an array of strings, it\n// is assumed that each string represents one line. The source can be a\n// JavaScript text or a JSON text.\n\n// The second parameter is an optional object of options that control the\n// operation of JSLINT. Most of the options are booleans: They are all\n// optional and have a default value of false. One of the options, predef,\n// can be an array of names, which will be used to declare global variables,\n// or an object whose keys are used as global names, with a boolean value\n// that determines if they are assignable.\n\n// If it checks out, JSLINT returns true. Otherwise, it returns false.\n\n// If false, you can inspect JSLINT.errors to find out the problems.\n// JSLINT.errors is an array of objects containing these properties:\n\n//  {\n//      line      : The line (relative to 0) at which the lint was found\n//      character : The character (relative to 0) at which the lint was found\n//      reason    : The problem\n//      evidence  : The text line in which the problem occurred\n//      raw       : The raw message before the details were inserted\n//      a         : The first detail\n//      b         : The second detail\n//      c         : The third detail\n//      d         : The fourth detail\n//  }\n\n// If a stopping error was found, a null will be the last element of the\n// JSLINT.errors array. A stopping error means that JSLint was not confident\n// enough to continue. It does not necessarily mean that the error was\n// especially heinous.\n\n// You can request a data structure that contains JSLint's results.\n\n//     var myData = JSLINT.data();\n\n// It returns a structure with this form:\n\n//     {\n//         errors: [\n//             {\n//                 line: NUMBER,\n//                 character: NUMBER,\n//                 reason: STRING,\n//                 evidence: STRING\n//             }\n//         ],\n//         functions: [\n//             {\n//                 name: STRING,\n//                 line: NUMBER,\n//                 level: NUMBER,\n//                 parameter: [\n//                     STRING\n//                 ],\n//                 var: [\n//                     STRING\n//                 ],\n//                 exception: [\n//                     STRING\n//                 ],\n//                 closure: [\n//                     STRING\n//                 ],\n//                 outer: [\n//                     STRING\n//                 ],\n//                 global: [\n//                     STRING\n//                 ],\n//                 label: [\n//                     STRING\n//                 ]\n//             }\n//         ],\n//         global: [\n//             STRING\n//         ],\n//         member: {\n//             STRING: NUMBER\n//         },\n//         json: BOOLEAN\n//     }\n\n// You can request a Function Report, which shows all of the functions\n// and the parameters and vars that they use. This can be used to find\n// implied global variables and other problems. The report is in HTML and\n// can be inserted into an HTML <body>. It should be given the result of the\n// JSLINT.data function.\n\n//     var myReport = JSLINT.report(data);\n\n// You can request an HTML error report.\n\n//     var myErrorReport = JSLINT.error_report(data);\n\n// You can obtain an object containing all of the properties found in the\n// file. JSLINT.property contains an object containing a key for each\n// property used in the program, the value being the number of times that\n// property name was used in the file.\n\n// You can request a properties report, which produces a list of the program's\n// properties in the form of a /*properties*/ declaration.\n\n//      var myPropertyReport = JSLINT.properties_report(JSLINT.property);\n\n// You can obtain the parse tree that JSLint constructed while parsing. The\n// latest tree is kept in JSLINT.tree. A nice stringification can be produced\n// with\n\n//     JSON.stringify(JSLINT.tree, [\n//         'string',  'arity', 'name',  'first',\n//         'second', 'third', 'block', 'else'\n//     ], 4));\n\n// You can request a context coloring table. It contains information that can be\n// applied to the file that was analyzed. Context coloring colors functions\n// based on their nesting level, and variables on the color of the functions\n// in which they are defined.\n\n//      var myColorization = JSLINT.color(data);\n\n// It returns an array containing objects of this form:\n\n//      {\n//          from: COLUMN,\n//          thru: COLUMN,\n//          line: ROW,\n//          level: 0 or higher\n//      }\n\n// JSLint provides three inline directives. They look like slashstar comments,\n// and allow for setting options, declaring global variables, and establishing a\n// set of allowed property names.\n\n// These directives respect function scope.\n\n// The jslint directive is a special comment that can set one or more options.\n// For example:\n\n/*jslint\n    es5: true, evil: true, nomen: true, regexp: true, todo: true\n*/\n\n// The current option set is\n\n//     ass        true, if assignment expressions should be allowed\n//     bitwise    true, if bitwise operators should be allowed\n//     browser    true, if the standard browser globals should be predefined\n//     closure    true, if Google Closure idioms should be tolerated\n//     continue   true, if the continuation statement should be tolerated\n//     debug      true, if debugger statements should be allowed\n//     devel      true, if logging should be allowed (console, alert, etc.)\n//     eqeq       true, if == should be allowed\n//     es5        true, if ES5 syntax should be allowed\n//     evil       true, if eval should be allowed\n//     forin      true, if for in statements need not filter\n//     indent     the indentation factor\n//     maxerr     the maximum number of errors to allow\n//     maxlen     the maximum length of a source line\n//     newcap     true, if constructor names capitalization is ignored\n//     node       true, if Node.js globals should be predefined\n//     nomen      true, if names may have dangling _\n//     passfail   true, if the scan should stop on first error\n//     plusplus   true, if increment/decrement should be allowed\n//     properties true, if all property names must be declared with /*properties*/\n//     regexp     true, if the . should be allowed in regexp literals\n//     rhino      true, if the Rhino environment globals should be predefined\n//     unparam    true, if unused parameters should be tolerated\n//     sloppy     true, if the 'use strict'; pragma is optional\n//     stupid     true, if really stupid practices are tolerated\n//     sub        true, if all forms of subscript notation are tolerated\n//     todo       true, if TODO comments are tolerated\n//     vars       true, if multiple var statements per function should be allowed\n//     white      true, if sloppy whitespace is tolerated\n\n// The properties directive declares an exclusive list of property names.\n// Any properties named in the program that are not in the list will\n// produce a warning.\n\n// For example:\n\n/*properties\n    '\\b', '\\t', '\\n', '\\f', '\\r', '!', '!=', '!==', '\"', '%', '\\'', '(begin)',\n    '(error)', '*', '+', '-', '/', '<', '<=', '==', '===', '>', '>=', '\\\\', a,\n    a_label, a_scope, already_defined, and, arguments, arity, ass, assign,\n    assignment_expression, assignment_function_expression, at, avoid_a, b,\n    bad_assignment, bad_constructor, bad_in_a, bad_invocation, bad_new,\n    bad_number, bad_operand, bad_wrap, bitwise, block, browser, c, call, charAt,\n    charCodeAt, character, closure, code, color, combine_var, comments,\n    conditional_assignment, confusing_a, confusing_regexp, constructor_name_a,\n    continue, control_a, couch, create, d, dangling_a, data, dead, debug,\n    deleted, devel, disrupt, duplicate_a, edge, edition, else, empty_block,\n    empty_case, empty_class, entityify, eqeq, error_report, errors, es5,\n    evidence, evil, exception, exec, expected_a_at_b_c, expected_a_b,\n    expected_a_b_from_c_d, expected_id_a, expected_identifier_a,\n    expected_identifier_a_reserved, expected_number_a, expected_operator_a,\n    expected_positive_a, expected_small_a, expected_space_a_b,\n    expected_string_a, f, first, flag, floor, forEach, for_if, forin, from,\n    fromCharCode, fud, function, function_block, function_eval, function_loop,\n    function_statement, function_strict, functions, global, hasOwnProperty, id,\n    identifier, identifier_function, immed, implied_evil, indent, indexOf,\n    infix_in, init, insecure_a, isAlpha, isArray, isDigit, isNaN, join, jslint,\n    json, keys, kind, label, labeled, lbp, leading_decimal_a, led, left, length,\n    level, line, loopage, master, match, maxerr, maxlen, message, missing_a,\n    missing_a_after_b, missing_property, missing_space_a_b, missing_use_strict,\n    mode, move_invocation, move_var, n, name, name_function, nested_comment,\n    newcap, node, nomen, not, not_a_constructor, not_a_defined, not_a_function,\n    not_a_label, not_a_scope, not_greater, nud, number, octal_a, open, outer,\n    parameter, parameter_a_get_b, parameter_arguments_a, parameter_set_a,\n    params, paren, passfail, plusplus, postscript, predef, properties,\n    properties_report, property, prototype, push, quote, r, radix, raw,\n    read_only, reason, redefinition_a_b, regexp, relation, replace, report,\n    reserved, reserved_a, rhino, right, scanned_a_b, scope, search, second,\n    shift, slash_equal, slice, sloppy, sort, split, statement, statement_block,\n    stop, stopping, strange_loop, strict, string, stupid, sub, subscript,\n    substr, supplant, sync_a, t, tag_a_in_b, test, third, thru, toString, todo,\n    todo_comment, token, tokens, too_long, too_many, trailing_decimal_a, tree,\n    unclosed, unclosed_comment, unclosed_regexp, unescaped_a, unexpected_a,\n    unexpected_char_a, unexpected_comment, unexpected_label_a,\n    unexpected_property_a, unexpected_space_a_b, unexpected_typeof_a,\n    uninitialized_a, unnecessary_else, unnecessary_initialize, unnecessary_use,\n    unparam, unreachable_a_b, unsafe, unused_a, url, use_array, use_braces,\n    use_object, use_or, use_param, use_spaces, used, used_before_a, var,\n    var_a_not, var_loop, vars, varstatement, warn, warning, was,\n    weird_assignment, weird_condition, weird_new, weird_program, weird_relation,\n    weird_ternary, white, wrap, wrap_immediate, wrap_regexp, write_is_wrong,\n    writeable\n*/\n\n// The global directive is used to declare global variables that can\n// be accessed by the program. If a declaration is true, then the variable\n// is writeable. Otherwise, it is read-only.\n\n// We build the application inside a function so that we produce only a single\n// global variable. That function will be invoked immediately, and its return\n// value is the JSLINT function itself. That function is also an object that\n// can contain data and other functions.\n\nvar JSLINT = (function () {\n    'use strict';\n\n    function array_to_object(array, value) {\n\n// Make an object from an array of keys and a common value.\n\n        var i, length = array.length, object = Object.create(null);\n        for (i = 0; i < length; i += 1) {\n            object[array[i]] = value;\n        }\n        return object;\n    }\n\n\n    var allowed_option = {\n            ass       : true,\n            bitwise   : true,\n            browser   : true,\n            closure   : true,\n            continue  : true,\n            couch     : true,\n            debug     : true,\n            devel     : true,\n            eqeq      : true,\n            es5       : true,\n            evil      : true,\n            forin     : true,\n            indent    :   10,\n            maxerr    : 1000,\n            maxlen    :  256,\n            newcap    : true,\n            node      : true,\n            nomen     : true,\n            passfail  : true,\n            plusplus  : true,\n            properties: true,\n            regexp    : true,\n            rhino     : true,\n            unparam   : true,\n            sloppy    : true,\n            stupid    : true,\n            sub       : true,\n            todo      : true,\n            vars      : true,\n            white     : true\n        },\n        anonname,       // The guessed name for anonymous functions.\n\n// These are operators that should not be used with the ! operator.\n\n        bang = {\n            '<'  : true,\n            '<=' : true,\n            '==' : true,\n            '===': true,\n            '!==': true,\n            '!=' : true,\n            '>'  : true,\n            '>=' : true,\n            '+'  : true,\n            '-'  : true,\n            '*'  : true,\n            '/'  : true,\n            '%'  : true\n        },\n        begin,          // The root token\n        block_var,     // vars defined in the current block\n\n// browser contains a set of global names that are commonly provided by a\n// web browser environment.\n\n        browser = array_to_object([\n            'clearInterval', 'clearTimeout', 'document', 'event', 'FormData',\n            'frames', 'history', 'Image', 'localStorage', 'location', 'name',\n            'navigator', 'Option', 'parent', 'screen', 'sessionStorage',\n            'setInterval', 'setTimeout', 'Storage', 'window', 'XMLHttpRequest'\n        ], false),\n\n// bundle contains the text messages.\n\n        bundle = {\n            a_label: \"'{a}' is a statement label.\",\n            a_scope: \"'{a}' used out of scope.\",\n            already_defined: \"'{a}' is already defined.\",\n            and: \"The '&&' subexpression should be wrapped in parens.\",\n            assignment_expression: \"Unexpected assignment expression.\",\n            assignment_function_expression: \"Expected an assignment or \" +\n                \"function call and instead saw an expression.\",\n            avoid_a: \"Avoid '{a}'.\",\n            bad_assignment: \"Bad assignment.\",\n            bad_constructor: \"Bad constructor.\",\n            bad_in_a: \"Bad for in variable '{a}'.\",\n            bad_invocation: \"Bad invocation.\",\n            bad_new: \"Do not use 'new' for side effects.\",\n            bad_number: \"Bad number '{a}'.\",\n            bad_operand: \"Bad operand.\",\n            bad_wrap: \"Do not wrap function literals in parens unless they \" +\n                \"are to be immediately invoked.\",\n            combine_var: \"Combine this with the previous 'var' statement.\",\n            conditional_assignment: \"Expected a conditional expression and \" +\n                \"instead saw an assignment.\",\n            confusing_a: \"Confusing use of '{a}'.\",\n            confusing_regexp: \"Confusing regular expression.\",\n            constructor_name_a: \"A constructor name '{a}' should start with \" +\n                \"an uppercase letter.\",\n            control_a: \"Unexpected control character '{a}'.\",\n            dangling_a: \"Unexpected dangling '_' in '{a}'.\",\n            deleted: \"Only properties should be deleted.\",\n            duplicate_a: \"Duplicate '{a}'.\",\n            empty_block: \"Empty block.\",\n            empty_case: \"Empty case.\",\n            empty_class: \"Empty class.\",\n            es5: \"This is an ES5 feature.\",\n            evil: \"eval is evil.\",\n            expected_a_b: \"Expected '{a}' and instead saw '{b}'.\",\n            expected_a_b_from_c_d: \"Expected '{a}' to match '{b}' from line \" +\n                \"{c} and instead saw '{d}'.\",\n            expected_a_at_b_c: \"Expected '{a}' at column {b}, not column {c}.\",\n            expected_id_a: \"Expected an id, and instead saw #{a}.\",\n            expected_identifier_a: \"Expected an identifier and instead saw '{a}'.\",\n            expected_identifier_a_reserved: \"Expected an identifier and \" +\n                \"instead saw '{a}' (a reserved word).\",\n            expected_number_a: \"Expected a number and instead saw '{a}'.\",\n            expected_operator_a: \"Expected an operator and instead saw '{a}'.\",\n            expected_positive_a: \"Expected a positive number and instead saw '{a}'\",\n            expected_small_a: \"Expected a small positive integer and instead saw '{a}'\",\n            expected_space_a_b: \"Expected exactly one space between '{a}' and '{b}'.\",\n            expected_string_a: \"Expected a string and instead saw '{a}'.\",\n            for_if: \"The body of a for in should be wrapped in an if \" +\n                \"statement to filter unwanted properties from the prototype.\",\n            function_block: \"Function statements should not be placed in blocks.\" +\n                \"Use a function expression or move the statement to the top of \" +\n                \"the outer function.\",\n            function_eval: \"The Function constructor is eval.\",\n            function_loop: \"Don't make functions within a loop.\",\n            function_statement: \"Function statements are not invocable. \" +\n                \"Wrap the whole function invocation in parens.\",\n            function_strict: \"Use the function form of 'use strict'.\",\n            identifier_function: \"Expected an identifier in an assignment \" +\n                \"and instead saw a function invocation.\",\n            implied_evil: \"Implied eval is evil. Pass a function instead of a string.\",\n            infix_in: \"Unexpected 'in'. Compare with undefined, or use the \" +\n                \"hasOwnProperty method instead.\",\n            insecure_a: \"Insecure '{a}'.\",\n            isNaN: \"Use the isNaN function to compare with NaN.\",\n            leading_decimal_a: \"A leading decimal point can be confused with a dot: '.{a}'.\",\n            missing_a: \"Missing '{a}'.\",\n            missing_a_after_b: \"Missing '{a}' after '{b}'.\",\n            missing_property: \"Missing property name.\",\n            missing_space_a_b: \"Missing space between '{a}' and '{b}'.\",\n            missing_use_strict: \"Missing 'use strict' statement.\",\n            move_invocation: \"Move the invocation into the parens that \" +\n                \"contain the function.\",\n            move_var: \"Move 'var' declarations to the top of the function.\",\n            name_function: \"Missing name in function statement.\",\n            nested_comment: \"Nested comment.\",\n            not: \"Nested not.\",\n            not_a_constructor: \"Do not use {a} as a constructor.\",\n            not_a_defined: \"'{a}' has not been fully defined yet.\",\n            not_a_function: \"'{a}' is not a function.\",\n            not_a_label: \"'{a}' is not a label.\",\n            not_a_scope: \"'{a}' is out of scope.\",\n            not_greater: \"'{a}' should not be greater than '{b}'.\",\n            octal_a: \"Don't use octal: '{a}'. Use '\\\\u....' instead.\",\n            parameter_arguments_a: \"Do not mutate parameter '{a}' when using 'arguments'.\",\n            parameter_a_get_b: \"Unexpected parameter '{a}' in get {b} function.\",\n            parameter_set_a: \"Expected parameter (value) in set {a} function.\",\n            radix: \"Missing radix parameter.\",\n            read_only: \"Read only.\",\n            redefinition_a_b: \"Redefinition of '{a}' from line {b}.\",\n            reserved_a: \"Reserved name '{a}'.\",\n            scanned_a_b: \"{a} ({b}% scanned).\",\n            slash_equal: \"A regular expression literal can be confused with '/='.\",\n            statement_block: \"Expected to see a statement and instead saw a block.\",\n            stopping: \"Stopping.\",\n            strange_loop: \"Strange loop.\",\n            strict: \"Strict violation.\",\n            subscript: \"['{a}'] is better written in dot notation.\",\n            sync_a: \"Unexpected sync method: '{a}'.\",\n            tag_a_in_b: \"A '<{a}>' must be within '<{b}>'.\",\n            todo_comment: \"Unexpected TODO comment.\",\n            too_long: \"Line too long.\",\n            too_many: \"Too many errors.\",\n            trailing_decimal_a: \"A trailing decimal point can be confused \" +\n                \"with a dot: '.{a}'.\",\n            unclosed: \"Unclosed string.\",\n            unclosed_comment: \"Unclosed comment.\",\n            unclosed_regexp: \"Unclosed regular expression.\",\n            unescaped_a: \"Unescaped '{a}'.\",\n            unexpected_a: \"Unexpected '{a}'.\",\n            unexpected_char_a: \"Unexpected character '{a}'.\",\n            unexpected_comment: \"Unexpected comment.\",\n            unexpected_label_a: \"Unexpected label '{a}'.\",\n            unexpected_property_a: \"Unexpected /*property*/ '{a}'.\",\n            unexpected_space_a_b: \"Unexpected space between '{a}' and '{b}'.\",\n            unexpected_typeof_a: \"Unexpected 'typeof'. \" +\n                \"Use '===' to compare directly with {a}.\",\n            uninitialized_a: \"Uninitialized '{a}'.\",\n            unnecessary_else: \"Unnecessary 'else' after disruption.\",\n            unnecessary_initialize: \"It is not necessary to initialize '{a}' \" +\n                \"to 'undefined'.\",\n            unnecessary_use: \"Unnecessary 'use strict'.\",\n            unreachable_a_b: \"Unreachable '{a}' after '{b}'.\",\n            unsafe: \"Unsafe character.\",\n            unused_a: \"Unused '{a}'.\",\n            url: \"JavaScript URL.\",\n            use_array: \"Use the array literal notation [].\",\n            use_braces: \"Spaces are hard to count. Use {{a}}.\",\n            use_object: \"Use the object literal notation {} or Object.create(null).\",\n            use_or: \"Use the || operator.\",\n            use_param: \"Use a named parameter.\",\n            use_spaces: \"Use spaces, not tabs.\",\n            used_before_a: \"'{a}' was used before it was defined.\",\n            var_a_not: \"Variable {a} was not declared correctly.\",\n            var_loop: \"Don't declare variables in a loop.\",\n            weird_assignment: \"Weird assignment.\",\n            weird_condition: \"Weird condition.\",\n            weird_new: \"Weird construction. Delete 'new'.\",\n            weird_program: \"Weird program.\",\n            weird_relation: \"Weird relation.\",\n            weird_ternary: \"Weird ternary.\",\n            wrap_immediate: \"Wrap an immediate function invocation in \" +\n                \"parentheses to assist the reader in understanding that the \" +\n                \"expression is the result of a function, and not the \" +\n                \"function itself.\",\n            wrap_regexp: \"Wrap the /regexp/ literal in parens to \" +\n                \"disambiguate the slash operator.\",\n            write_is_wrong: \"document.write can be a form of eval.\"\n        },\n        closure = array_to_object([\n            'goog'\n        ], false),\n        comments,\n        comments_off,\n        couch = array_to_object([\n            'emit', 'getRow', 'isArray', 'log', 'provides', 'registerType',\n            'require', 'send', 'start', 'sum', 'toJSON'\n        ], false),\n\n        descapes = {\n            'b': '\\b',\n            't': '\\t',\n            'n': '\\n',\n            'f': '\\f',\n            'r': '\\r',\n            '\"': '\"',\n            '/': '/',\n            '\\\\': '\\\\',\n            '!': '!'\n        },\n\n        devel = array_to_object([\n            'alert', 'confirm', 'console', 'Debug', 'opera', 'prompt', 'WSH'\n        ], false),\n        directive,\n        escapes = {\n            '\\b': '\\\\b',\n            '\\t': '\\\\t',\n            '\\n': '\\\\n',\n            '\\f': '\\\\f',\n            '\\r': '\\\\r',\n            '\\'': '\\\\\\'',\n            '\"' : '\\\\\"',\n            '/' : '\\\\/',\n            '\\\\': '\\\\\\\\'\n        },\n\n        funct,          // The current function\n\n        functions,      // All of the functions\n        global_funct,   // The global body\n        global_scope,   // The global scope\n        in_block,       // Where function statements are not allowed\n        indent,\n        itself,         // JSLINT itself\n        json_mode,\n        lex,            // the tokenizer\n        lines,\n        lookahead,\n        node = array_to_object([\n            'Buffer', 'clearImmediate', 'clearInterval', 'clearTimeout',\n            'console', 'exports', 'global', 'module', 'process', 'querystring',\n            'require', 'setImmediate', 'setInterval', 'setTimeout',\n            '__dirname', '__filename'\n        ], false),\n        node_js,\n        numbery = array_to_object(['indexOf', 'lastIndexOf', 'search'], true),\n        next_token,\n        option,\n        predefined,     // Global variables defined by option\n        prereg,\n        prev_token,\n        property,\n        protosymbol,\n        regexp_flag = array_to_object(['g', 'i', 'm'], true),\n        return_this = function return_this() {\n            return this;\n        },\n        rhino = array_to_object([\n            'defineClass', 'deserialize', 'gc', 'help', 'load', 'loadClass',\n            'print', 'quit', 'readFile', 'readUrl', 'runCommand', 'seal',\n            'serialize', 'spawn', 'sync', 'toint32', 'version'\n        ], false),\n\n        scope,      // An object containing an object for each variable in scope\n        semicolon_coda = array_to_object([';', '\"', '\\'', ')'], true),\n\n// standard contains the global names that are provided by the\n// ECMAScript standard.\n\n        standard = array_to_object([\n            'Array', 'Boolean', 'Date', 'decodeURI', 'decodeURIComponent',\n            'encodeURI', 'encodeURIComponent', 'Error', 'eval', 'EvalError',\n            'Function', 'isFinite', 'isNaN', 'JSON', 'Math', 'Number',\n            'Object', 'parseInt', 'parseFloat', 'RangeError', 'ReferenceError',\n            'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError'\n        ], false),\n\n        strict_mode,\n        syntax = Object.create(null),\n        token,\n        tokens,\n        var_mode,\n        warnings,\n\n// Regular expressions. Some of these are stupidly long.\n\n// carriage return, carriage return linefeed, or linefeed\n        crlfx = /\\r\\n?|\\n/,\n// unsafe characters that are silently deleted by one or more browsers\n        cx = /[\\u0000-\\u0008\\u000a-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,\n// identifier\n        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,\n// javascript url\n        jx = /^(?:javascript|jscript|ecmascript|vbscript)\\s*:/i,\n// star slash\n        lx = /\\*\\/|\\/\\*/,\n// characters in strings that need escapement\n        nx = /[\\u0000-\\u001f'\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n// sync\n        syx = /Sync$/,\n// comment todo\n        tox = /^\\W*to\\s*do(?:\\W|$)/i,\n// token\n        tx = /^\\s*([(){}\\[\\]\\?.,:;'\"~#@`]|={1,3}|\\/(\\*(jslint|properties|property|members?|globals?)?|=|\\/)?|\\*[\\/=]?|\\+(?:=|\\++)?|-(?:=|-+)?|[\\^%]=?|&[&=]?|\\|[|=]?|>{1,3}=?|<(?:[\\/=!]|\\!(\\[|--)?|<=?)?|\\!(\\!|==?)?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+(?:[xX][0-9a-fA-F]+|\\.[0-9]*)?(?:[eE][+\\-]?[0-9]+)?)/;\n\n\n    if (typeof String.prototype.entityify !== 'function') {\n        String.prototype.entityify = function () {\n            return this\n                .replace(/&/g, '&amp;')\n                .replace(/</g, '&lt;')\n                .replace(/>/g, '&gt;');\n        };\n    }\n\n    if (typeof String.prototype.isAlpha !== 'function') {\n        String.prototype.isAlpha = function () {\n            return (this >= 'a' && this <= 'z\\uffff') ||\n                (this >= 'A' && this <= 'Z\\uffff');\n        };\n    }\n\n    if (typeof String.prototype.isDigit !== 'function') {\n        String.prototype.isDigit = function () {\n            return (this >= '0' && this <= '9');\n        };\n    }\n\n    if (typeof String.prototype.supplant !== 'function') {\n        String.prototype.supplant = function (o) {\n            return this.replace(/\\{([^{}]*)\\}/g, function (a, b) {\n                var replacement = o[b];\n                return typeof replacement === 'string' ||\n                    typeof replacement === 'number' ? replacement : a;\n            });\n        };\n    }\n\n\n    function sanitize(a) {\n\n//  Escapify a troublesome character.\n\n        return escapes[a] ||\n            '\\\\u' + ('0000' + a.charCodeAt().toString(16)).slice(-4);\n    }\n\n\n    function add_to_predefined(group) {\n        Object.keys(group).forEach(function (name) {\n            predefined[name] = group[name];\n        });\n    }\n\n\n    function assume() {\n        if (option.browser) {\n            add_to_predefined(browser);\n            option.browser = false;\n        }\n        if (option.closure) {\n            add_to_predefined(closure);\n        }\n        if (option.couch) {\n            add_to_predefined(couch);\n            option.couch = false;\n            option.es5 = true;\n        }\n        if (option.devel) {\n            add_to_predefined(devel);\n            option.devel = false;\n        }\n        if (option.node) {\n            add_to_predefined(node);\n            option.node = false;\n            option.es5 = true;\n            node_js = true;\n        }\n        if (option.rhino) {\n            add_to_predefined(rhino);\n            option.rhino = false;\n        }\n    }\n\n\n// Produce an error warning.\n\n    function artifact(tok) {\n        if (!tok) {\n            tok = next_token;\n        }\n        return tok.id === '(number)' ? tok.number : tok.string;\n    }\n\n    function quit(message, line, character) {\n        throw {\n            name: 'JSLintError',\n            line: line,\n            character: character,\n            message: bundle.scanned_a_b.supplant({\n                a: bundle[message] || message,\n                b: Math.floor((line / lines.length) * 100)\n            })\n        };\n    }\n\n    function warn(code, line, character, a, b, c, d) {\n        var warning = {         // ~~\n            id: '(error)',\n            raw: bundle[code] || code,\n            code: code,\n            evidence: lines[line - 1] || '',\n            line: line,\n            character: character,\n            a: a || artifact(this),\n            b: b,\n            c: c,\n            d: d\n        };\n        warning.reason = warning.raw.supplant(warning);\n        itself.errors.push(warning);\n        if (option.passfail) {\n            quit('stopping', line, character);\n        }\n        warnings += 1;\n        if (warnings >= option.maxerr) {\n            quit('too_many', line, character);\n        }\n        return warning;\n    }\n\n    function stop(code, line, character, a, b, c, d) {\n        var warning = warn(code, line, character, a, b, c, d);\n        quit('stopping', warning.line, warning.character);\n    }\n\n    function expected_at(at) {\n        if (!option.white && next_token.from !== at) {\n            next_token.warn('expected_a_at_b_c', '', at, next_token.from);\n        }\n    }\n\n// lexical analysis and token construction\n\n    lex = (function lex() {\n        var character, c, from, length, line, pos, source_row;\n\n// Private lex methods\n\n        function next_line() {\n            var at;\n            character = 1;\n            source_row = lines[line];\n            line += 1;\n            if (source_row === undefined) {\n                return false;\n            }\n            at = source_row.search(/\\t/);\n            if (at >= 0) {\n                if (option.white) {\n                    source_row = source_row.replace(/\\t/g, ' ');\n                } else {\n                    warn('use_spaces', line, at + 1);\n                }\n            }\n            at = source_row.search(cx);\n            if (at >= 0) {\n                warn('unsafe', line, at);\n            }\n            if (option.maxlen && option.maxlen < source_row.length) {\n                warn('too_long', line, source_row.length);\n            }\n            return true;\n        }\n\n// Produce a token object.  The token inherits from a syntax symbol.\n\n        function it(type, value) {\n            var id, the_token;\n            if (type === '(string)') {\n                if (jx.test(value)) {\n                    warn('url', line, from);\n                }\n            }\n            the_token = Object.create(syntax[(\n                type === '(punctuator)' || (type === '(identifier)' &&\n                        Object.prototype.hasOwnProperty.call(syntax, value))\n                    ? value\n                    : type\n            )] || syntax['(error)']);\n            if (type === '(identifier)') {\n                the_token.identifier = true;\n                if (value === '__iterator__' || value === '__proto__') {\n                    stop('reserved_a', line, from, value);\n                } else if (!option.nomen &&\n                        (value.charAt(0) === '_' ||\n                        value.charAt(value.length - 1) === '_')) {\n                    warn('dangling_a', line, from, value);\n                }\n            }\n            if (type === '(number)') {\n                the_token.number = +value;\n            } else if (value !== undefined) {\n                the_token.string = String(value);\n            }\n            the_token.line = line;\n            the_token.from = from;\n            the_token.thru = character;\n            if (comments.length) {\n                the_token.comments = comments;\n                comments = [];\n            }\n            id = the_token.id;\n            prereg = id && (\n                ('(,=:[!&|?{};~+-*%^<>'.indexOf(id.charAt(id.length - 1)) >= 0) ||\n                id === 'return' || id === 'case'\n            );\n            return the_token;\n        }\n\n        function match(x) {\n            var exec = x.exec(source_row), first;\n            if (exec) {\n                length = exec[0].length;\n                first = exec[1];\n                c = first.charAt(0);\n                source_row = source_row.slice(length);\n                from = character + length - first.length;\n                character += length;\n                return first;\n            }\n            for (;;) {\n                if (!source_row) {\n                    if (!option.white) {\n                        warn('unexpected_char_a', line, character - 1, '(space)');\n                    }\n                    return;\n                }\n                c = source_row.charAt(0);\n                if (c !== ' ') {\n                    break;\n                }\n                source_row = source_row.slice(1);\n                character += 1;\n            }\n            stop('unexpected_char_a', line, character, c);\n\n        }\n\n        function string(x) {\n            var ch, at = 0, r = '', result;\n\n            function hex(n) {\n                var i = parseInt(source_row.substr(at + 1, n), 16);\n                at += n;\n                if (i >= 32 && i <= 126 &&\n                        i !== 34 && i !== 92 && i !== 39) {\n                    warn('unexpected_a', line, character, '\\\\');\n                }\n                character += n;\n                ch = String.fromCharCode(i);\n            }\n\n            if (json_mode && x !== '\"') {\n                warn('expected_a_b', line, character, '\"', x);\n            }\n\n            for (;;) {\n                while (at >= source_row.length) {\n                    at = 0;\n                    if (!next_line()) {\n                        stop('unclosed', line - 1, from);\n                    }\n                }\n                ch = source_row.charAt(at);\n                if (ch === x) {\n                    character += 1;\n                    source_row = source_row.slice(at + 1);\n                    result = it('(string)', r);\n                    result.quote = x;\n                    return result;\n                }\n                if (ch < ' ') {\n                    if (ch === '\\n' || ch === '\\r') {\n                        break;\n                    }\n                    warn('control_a', line, character + at,\n                        source_row.slice(0, at));\n                } else if (ch === '\\\\') {\n                    at += 1;\n                    character += 1;\n                    ch = source_row.charAt(at);\n                    switch (ch) {\n                    case '':\n                        if (!option.es5) {\n                            warn('es5', line, character);\n                        }\n                        next_line();\n                        at = -1;\n                        break;\n                    case '\\'':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\\\'');\n                        }\n                        break;\n                    case 'u':\n                        hex(4);\n                        break;\n                    case 'v':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\v');\n                        }\n                        ch = '\\v';\n                        break;\n                    case 'x':\n                        if (json_mode) {\n                            warn('unexpected_a', line, character, '\\\\x');\n                        }\n                        hex(2);\n                        break;\n                    default:\n                        if (typeof descapes[ch] !== 'string') {\n                            warn(ch >= '0' && ch <= '7' ? 'octal_a' : 'unexpected_a',\n                                line, character, '\\\\' + ch);\n                        } else {\n                            ch = descapes[ch];\n                        }\n                    }\n                }\n                r += ch;\n                character += 1;\n                at += 1;\n            }\n        }\n\n        function number(snippet) {\n            var digit;\n            if (source_row.charAt(0).isAlpha()) {\n                warn('expected_space_a_b',\n                    line, character, c, source_row.charAt(0));\n            }\n            if (c === '0') {\n                digit = snippet.charAt(1);\n                if (digit.isDigit()) {\n                    if (token.id !== '.') {\n                        warn('unexpected_a', line, character, snippet);\n                    }\n                } else if (json_mode && (digit === 'x' || digit === 'X')) {\n                    warn('unexpected_a', line, character, '0x');\n                }\n            }\n            if (snippet.slice(snippet.length - 1) === '.') {\n                warn('trailing_decimal_a', line, character, snippet);\n            }\n            digit = +snippet;\n            if (!isFinite(digit)) {\n                warn('bad_number', line, character, snippet);\n            }\n            snippet = digit;\n            return it('(number)', snippet);\n        }\n\n        function comment(snippet, type) {\n            if (comments_off) {\n                warn('unexpected_comment', line, character);\n            } else if (!option.todo && tox.test(snippet)) {\n                warn('todo_comment', line, character);\n            }\n            comments.push({\n                id: type,\n                from: from,\n                thru: character,\n                line: line,\n                string: snippet\n            });\n        }\n\n        function regexp() {\n            var at = 0,\n                b,\n                bit,\n                depth = 0,\n                flag = '',\n                high,\n                letter,\n                low,\n                potential,\n                quote,\n                result;\n            for (;;) {\n                b = true;\n                c = source_row.charAt(at);\n                at += 1;\n                switch (c) {\n                case '':\n                    stop('unclosed_regexp', line, from);\n                    return;\n                case '/':\n                    if (depth > 0) {\n                        warn('unescaped_a', line, from + at, '/');\n                    }\n                    c = source_row.slice(0, at - 1);\n                    potential = Object.create(regexp_flag);\n                    for (;;) {\n                        letter = source_row.charAt(at);\n                        if (potential[letter] !== true) {\n                            break;\n                        }\n                        potential[letter] = false;\n                        at += 1;\n                        flag += letter;\n                    }\n                    if (source_row.charAt(at).isAlpha()) {\n                        stop('unexpected_a', line, from, source_row.charAt(at));\n                    }\n                    character += at;\n                    source_row = source_row.slice(at);\n                    quote = source_row.charAt(0);\n                    if (quote === '/' || quote === '*') {\n                        stop('confusing_regexp', line, from);\n                    }\n                    result = it('(regexp)', c);\n                    result.flag = flag;\n                    return result;\n                case '\\\\':\n                    c = source_row.charAt(at);\n                    if (c < ' ') {\n                        warn('control_a', line, from + at, String(c));\n                    } else if (c === '<') {\n                        warn('unexpected_a', line, from + at, '\\\\');\n                    }\n                    at += 1;\n                    break;\n                case '(':\n                    depth += 1;\n                    b = false;\n                    if (source_row.charAt(at) === '?') {\n                        at += 1;\n                        switch (source_row.charAt(at)) {\n                        case ':':\n                        case '=':\n                        case '!':\n                            at += 1;\n                            break;\n                        default:\n                            warn('expected_a_b', line, from + at,\n                                ':', source_row.charAt(at));\n                        }\n                    }\n                    break;\n                case '|':\n                    b = false;\n                    break;\n                case ')':\n                    if (depth === 0) {\n                        warn('unescaped_a', line, from + at, ')');\n                    } else {\n                        depth -= 1;\n                    }\n                    break;\n                case ' ':\n                    pos = 1;\n                    while (source_row.charAt(at) === ' ') {\n                        at += 1;\n                        pos += 1;\n                    }\n                    if (pos > 1) {\n                        warn('use_braces', line, from + at, pos);\n                    }\n                    break;\n                case '[':\n                    c = source_row.charAt(at);\n                    if (c === '^') {\n                        at += 1;\n                        if (!option.regexp) {\n                            warn('insecure_a', line, from + at, c);\n                        } else if (source_row.charAt(at) === ']') {\n                            stop('unescaped_a', line, from + at, '^');\n                        }\n                    }\n                    bit = false;\n                    if (c === ']') {\n                        warn('empty_class', line, from + at - 1);\n                        bit = true;\n                    }\nklass:              do {\n                        c = source_row.charAt(at);\n                        at += 1;\n                        switch (c) {\n                        case '[':\n                        case '^':\n                            warn('unescaped_a', line, from + at, c);\n                            bit = true;\n                            break;\n                        case '-':\n                            if (bit) {\n                                bit = false;\n                            } else {\n                                warn('unescaped_a', line, from + at, '-');\n                                bit = true;\n                            }\n                            break;\n                        case ']':\n                            if (!bit) {\n                                warn('unescaped_a', line, from + at - 1, '-');\n                            }\n                            break klass;\n                        case '\\\\':\n                            c = source_row.charAt(at);\n                            if (c < ' ') {\n                                warn('control_a', line, from + at, String(c));\n                            } else if (c === '<') {\n                                warn('unexpected_a', line, from + at, '\\\\');\n                            }\n                            at += 1;\n                            bit = true;\n                            break;\n                        case '/':\n                            warn('unescaped_a', line, from + at - 1, '/');\n                            bit = true;\n                            break;\n                        default:\n                            bit = true;\n                        }\n                    } while (c);\n                    break;\n                case '.':\n                    if (!option.regexp) {\n                        warn('insecure_a', line, from + at, c);\n                    }\n                    break;\n                case ']':\n                case '?':\n                case '{':\n                case '}':\n                case '+':\n                case '*':\n                    warn('unescaped_a', line, from + at, c);\n                    break;\n                }\n                if (b) {\n                    switch (source_row.charAt(at)) {\n                    case '?':\n                    case '+':\n                    case '*':\n                        at += 1;\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        break;\n                    case '{':\n                        at += 1;\n                        c = source_row.charAt(at);\n                        if (c < '0' || c > '9') {\n                            warn('expected_number_a', line,\n                                from + at, c);\n                        }\n                        at += 1;\n                        low = +c;\n                        for (;;) {\n                            c = source_row.charAt(at);\n                            if (c < '0' || c > '9') {\n                                break;\n                            }\n                            at += 1;\n                            low = +c + (low * 10);\n                        }\n                        high = low;\n                        if (c === ',') {\n                            at += 1;\n                            high = Infinity;\n                            c = source_row.charAt(at);\n                            if (c >= '0' && c <= '9') {\n                                at += 1;\n                                high = +c;\n                                for (;;) {\n                                    c = source_row.charAt(at);\n                                    if (c < '0' || c > '9') {\n                                        break;\n                                    }\n                                    at += 1;\n                                    high = +c + (high * 10);\n                                }\n                            }\n                        }\n                        if (source_row.charAt(at) !== '}') {\n                            warn('expected_a_b', line, from + at,\n                                '}', c);\n                        } else {\n                            at += 1;\n                        }\n                        if (source_row.charAt(at) === '?') {\n                            at += 1;\n                        }\n                        if (low > high) {\n                            warn('not_greater', line, from + at,\n                                low, high);\n                        }\n                        break;\n                    }\n                }\n            }\n            c = source_row.slice(0, at - 1);\n            character += at;\n            source_row = source_row.slice(at);\n            return it('(regexp)', c);\n        }\n\n// Public lex methods\n\n        return {\n            init: function (source) {\n                if (typeof source === 'string') {\n                    lines = source.split(crlfx);\n                } else {\n                    lines = source;\n                }\n                line = 0;\n                next_line();\n                from = 1;\n            },\n\n// token -- this is called by advance to get the next token.\n\n            token: function () {\n                var first, i, snippet;\n\n                for (;;) {\n                    while (!source_row) {\n                        if (!next_line()) {\n                            return it('(end)');\n                        }\n                    }\n                    snippet = match(tx);\n                    if (snippet) {\n\n//      identifier\n\n                        first = snippet.charAt(0);\n                        if (first.isAlpha() || first === '_' || first === '$') {\n                            return it('(identifier)', snippet);\n                        }\n\n//      number\n\n                        if (first.isDigit()) {\n                            return number(snippet);\n                        }\n                        switch (snippet) {\n\n//      string\n\n                        case '\"':\n                        case \"'\":\n                            return string(snippet);\n\n//      // comment\n\n                        case '//':\n                            comment(source_row, '//');\n                            source_row = '';\n                            break;\n\n//      /* comment\n\n                        case '/*':\n                            for (;;) {\n                                i = source_row.search(lx);\n                                if (i >= 0) {\n                                    break;\n                                }\n                                character = source_row.length;\n                                comment(source_row);\n                                from = 0;\n                                if (!next_line()) {\n                                    stop('unclosed_comment', line, character);\n                                }\n                            }\n                            comment(source_row.slice(0, i), '/*');\n                            character += i + 2;\n                            if (source_row.charAt(i) === '/') {\n                                stop('nested_comment', line, character);\n                            }\n                            source_row = source_row.slice(i + 2);\n                            break;\n\n                        case '':\n                            break;\n//      /\n                        case '/':\n                            if (token.id === '/=') {\n                                stop('slash_equal', line, from);\n                            }\n                            return prereg\n                                ? regexp()\n                                : it('(punctuator)', snippet);\n\n//      punctuator\n                        default:\n                            return it('(punctuator)', snippet);\n                        }\n                    }\n                }\n            }\n        };\n    }());\n\n    function define(kind, token) {\n\n// Define a name.\n\n        var name = token.string,\n            master = scope[name];       // The current definition of the name\n\n// vars are created with a deadzone, so that the expression that initializes\n// the var cannot access the var. Functions are not writeable.\n\n        token.dead = false;\n        token.init = false;\n        token.kind = kind;\n        token.master = master;\n        token.used = 0;\n        token.writeable = false;\n\n// Global variables are a little weird. They can be defined multiple times.\n// Some predefined global vars are (or should) not be writeable.\n\n        if (kind === 'var' && funct === global_funct) {\n            if (!master) {\n                if (predefined[name] === false) {\n                    token.writeable = false;\n                }\n                global_scope[name] = token;\n            }\n        } else {\n\n// It is an error if the name has already been defined in this scope, except\n// when reusing an exception variable name.\n\n            if (master) {\n                if (master.function === funct) {\n                    if (master.kind !== 'exception' || kind !== 'exception' ||\n                            !master.dead) {\n                        token.warn('already_defined', name);\n                    }\n                } else if (master.function !== global_funct) {\n                    if (kind === 'var') {\n                        token.warn('redefinition_a_b', name, master.line);\n                    }\n                }\n            }\n            scope[name] = token;\n            if (kind === 'var') {\n                block_var.push(name);\n            }\n        }\n    }\n\n    function peek(distance) {\n\n// Peek ahead to a future token. The distance is how far ahead to look. The\n// default is the next token.\n\n        var found, slot = 0;\n\n        distance = distance || 0;\n        while (slot <= distance) {\n            found = lookahead[slot];\n            if (!found) {\n                found = lookahead[slot] = lex.token();\n            }\n            slot += 1;\n        }\n        return found;\n    }\n\n\n    function advance(id, match) {\n\n// Produce the next token, also looking for programming errors.\n\n        if (indent) {\n\n// If indentation checking was requested, then inspect all of the line breakings.\n// The var statement is tricky because the names might be aligned or not. We\n// look at the first line break after the var to determine the programmer's\n// intention.\n\n            if (var_mode && next_token.line !== token.line) {\n                if ((var_mode !== indent || !next_token.edge) &&\n                        next_token.from === indent.at -\n                        (next_token.edge ? option.indent : 0)) {\n                    var dent = indent;\n                    for (;;) {\n                        dent.at -= option.indent;\n                        if (dent === var_mode) {\n                            break;\n                        }\n                        dent = dent.was;\n                    }\n                    dent.open = false;\n                }\n                var_mode = null;\n            }\n            if (next_token.id === '?' && indent.mode === ':' &&\n                    token.line !== next_token.line) {\n                indent.at -= option.indent;\n            }\n            if (indent.open) {\n\n// If the token is an edge.\n\n                if (next_token.edge) {\n                    if (next_token.edge === 'label') {\n                        expected_at(1);\n                    } else if (next_token.edge === 'case' || indent.mode === 'statement') {\n                        expected_at(indent.at - option.indent);\n                    } else if (indent.mode !== 'array' || next_token.line !== token.line) {\n                        expected_at(indent.at);\n                    }\n\n// If the token is not an edge, but is the first token on the line.\n\n                } else if (next_token.line !== token.line) {\n                    if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                    indent.wrap = true;\n                }\n            } else if (next_token.line !== token.line) {\n                if (next_token.edge) {\n                    expected_at(indent.at);\n                } else {\n                    indent.wrap = true;\n                    if (indent.mode === 'statement' || indent.mode === 'var') {\n                        expected_at(indent.at + option.indent);\n                    } else if (next_token.from < indent.at + (indent.mode ===\n                            'expression' ? 0 : option.indent)) {\n                        expected_at(indent.at + option.indent);\n                    }\n                }\n            }\n        }\n\n        switch (token.id) {\n        case '(number)':\n            if (next_token.id === '.') {\n                next_token.warn('trailing_decimal_a');\n            }\n            break;\n        case '-':\n            if (next_token.id === '-' || next_token.id === '--') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        case '+':\n            if (next_token.id === '+' || next_token.id === '++') {\n                next_token.warn('confusing_a');\n            }\n            break;\n        }\n        if (token.id === '(string)' || token.identifier) {\n            anonname = token.string;\n        }\n\n        if (id && next_token.id !== id) {\n            if (match) {\n                next_token.warn('expected_a_b_from_c_d', id,\n                    match.id, match.line, artifact());\n            } else if (!next_token.identifier || next_token.string !== id) {\n                next_token.warn('expected_a_b', id, artifact());\n            }\n        }\n        prev_token = token;\n        token = next_token;\n        next_token = lookahead.shift() || lex.token();\n        next_token.function = funct;\n        tokens.push(next_token);\n    }\n\n\n    function do_globals() {\n        var name, writeable;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            writeable = false;\n            if (next_token.id === ':') {\n                advance(':');\n                switch (next_token.id) {\n                case 'true':\n                    writeable = predefined[name] !== false;\n                    advance('true');\n                    break;\n                case 'false':\n                    advance('false');\n                    break;\n                default:\n                    next_token.stop('unexpected_a');\n                }\n            }\n            predefined[name] = writeable;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    function do_jslint() {\n        var name, value;\n        while (next_token.id === '(string)' || next_token.identifier) {\n            name = next_token.string;\n            if (!allowed_option[name]) {\n                next_token.stop('unexpected_a');\n            }\n            advance();\n            if (next_token.id !== ':') {\n                next_token.stop('expected_a_b', ':', artifact());\n            }\n            advance(':');\n            if (typeof allowed_option[name] === 'number') {\n                value = next_token.number;\n                if (value > allowed_option[name] || value <= 0 ||\n                        Math.floor(value) !== value) {\n                    next_token.stop('expected_small_a');\n                }\n                option[name] = value;\n            } else {\n                if (next_token.id === 'true') {\n                    option[name] = true;\n                } else if (next_token.id === 'false') {\n                    option[name] = false;\n                } else {\n                    next_token.stop('unexpected_a');\n                }\n            }\n            advance();\n            if (next_token.id === ',') {\n                advance(',');\n            }\n        }\n        assume();\n    }\n\n\n    function do_properties() {\n        var name;\n        option.properties = true;\n        for (;;) {\n            if (next_token.id !== '(string)' && !next_token.identifier) {\n                return;\n            }\n            name = next_token.string;\n            advance();\n            if (next_token.id === ':') {\n                for (;;) {\n                    advance();\n                    if (next_token.id !== '(string)' && !next_token.identifier) {\n                        break;\n                    }\n                }\n            }\n            property[name] = 0;\n            if (next_token.id !== ',') {\n                return;\n            }\n            advance(',');\n        }\n    }\n\n\n    directive = function directive() {\n        var command = this.id,\n            old_comments_off = comments_off,\n            old_indent = indent;\n        comments_off = true;\n        indent = null;\n        if (next_token.line === token.line && next_token.from === token.thru) {\n            next_token.warn('missing_space_a_b', artifact(token), artifact());\n        }\n        if (lookahead.length > 0) {\n            this.warn('unexpected_a');\n        }\n        switch (command) {\n        case '/*properties':\n        case '/*property':\n        case '/*members':\n        case '/*member':\n            do_properties();\n            break;\n        case '/*jslint':\n            do_jslint();\n            break;\n        case '/*globals':\n        case '/*global':\n            do_globals();\n            break;\n        default:\n            this.stop('unexpected_a');\n        }\n        comments_off = old_comments_off;\n        advance('*/');\n        indent = old_indent;\n    };\n\n\n// Indentation intention\n\n    function edge(mode) {\n        next_token.edge = indent ? indent.open && (mode || 'edge') : '';\n    }\n\n\n    function step_in(mode) {\n        var open;\n        if (typeof mode === 'number') {\n            indent = {\n                at: +mode,\n                open: true,\n                was: indent\n            };\n        } else if (!indent) {\n            indent = {\n                at: 1,\n                mode: 'statement',\n                open: true\n            };\n        } else if (mode === 'statement') {\n            indent = {\n                at: indent.at,\n                open: true,\n                was: indent\n            };\n        } else {\n            open = mode === 'var' || next_token.line !== token.line;\n            indent = {\n                at: (open || mode === 'control'\n                    ? indent.at + option.indent\n                    : indent.at) + (indent.wrap ? option.indent : 0),\n                mode: mode,\n                open: open,\n                was: indent\n            };\n            if (mode === 'var' && open) {\n                var_mode = indent;\n            }\n        }\n    }\n\n    function step_out(id, symbol) {\n        if (id) {\n            if (indent && indent.open) {\n                indent.at -= option.indent;\n                edge();\n            }\n            advance(id, symbol);\n        }\n        if (indent) {\n            indent = indent.was;\n        }\n    }\n\n// Functions for conformance of whitespace.\n\n    function one_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && !option.white &&\n                (token.line !== right.line ||\n                token.thru + 1 !== right.from)) {\n            right.warn('expected_space_a_b', artifact(token), artifact(right));\n        }\n    }\n\n    function one_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru + 1 !== right.from))) {\n            right.warn('expected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if ((!option.white) &&\n                left.thru !== right.from && left.line === right.line) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function no_space_only(left, right) {\n        left = left || token;\n        right = right || next_token;\n        if (right.id !== '(end)' && (left.line !== right.line ||\n                (!option.white && left.thru !== right.from))) {\n            right.warn('unexpected_space_a_b', artifact(left), artifact(right));\n        }\n    }\n\n    function spaces(left, right) {\n        if (!option.white) {\n            left = left || token;\n            right = right || next_token;\n            if (left.thru === right.from && left.line === right.line) {\n                right.warn('missing_space_a_b', artifact(left), artifact(right));\n            }\n        }\n    }\n\n    function comma() {\n        if (next_token.id !== ',') {\n            warn('expected_a_b', token.line, token.thru, ',', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(',');\n            spaces();\n        }\n    }\n\n\n    function semicolon() {\n        if (next_token.id !== ';') {\n            warn('expected_a_b', token.line, token.thru, ';', artifact());\n        } else {\n            if (!option.white) {\n                no_space_only();\n            }\n            advance(';');\n            if (semicolon_coda[next_token.id] !== true) {\n                spaces();\n            }\n        }\n    }\n\n    function use_strict() {\n        if (next_token.string === 'use strict') {\n            if (strict_mode) {\n                next_token.warn('unnecessary_use');\n            }\n            edge();\n            advance();\n            semicolon();\n            strict_mode = true;\n            return true;\n        }\n        return false;\n    }\n\n\n    function are_similar(a, b) {\n        if (a === b) {\n            return true;\n        }\n        if (Array.isArray(a)) {\n            if (Array.isArray(b) && a.length === b.length) {\n                var i;\n                for (i = 0; i < a.length; i += 1) {\n                    if (!are_similar(a[i], b[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return false;\n        }\n        if (Array.isArray(b)) {\n            return false;\n        }\n        if (a.id === '(number)' && b.id === '(number)') {\n            return a.number === b.number;\n        }\n        if (a.arity === b.arity && a.string === b.string) {\n            switch (a.arity) {\n            case undefined:\n                return a.string === b.string;\n            case 'prefix':\n            case 'suffix':\n                return a.id === b.id && are_similar(a.first, b.first) &&\n                    a.id !== '{' && a.id !== '[';\n            case 'infix':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second);\n            case 'ternary':\n                return are_similar(a.first, b.first) &&\n                    are_similar(a.second, b.second) &&\n                    are_similar(a.third, b.third);\n            case 'function':\n            case 'regexp':\n                return false;\n            default:\n                return true;\n            }\n        }\n        if (a.id === '.' && b.id === '[' && b.arity === 'infix') {\n            return a.second.string === b.second.string && b.second.id === '(string)';\n        }\n        if (a.id === '[' && a.arity === 'infix' && b.id === '.') {\n            return a.second.string === b.second.string && a.second.id === '(string)';\n        }\n        return false;\n    }\n\n\n// This is the heart of JSLINT, the Pratt parser. In addition to parsing, it\n// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is\n// like .nud except that it is only used on the first token of a statement.\n// Having .fud makes it much easier to define statement-oriented languages like\n// JavaScript. I retained Pratt's nomenclature.\n\n// .nud     Null denotation\n// .fud     First null denotation\n// .led     Left denotation\n//  lbp     Left binding power\n//  rbp     Right binding power\n\n// They are elements of the parsing method called Top Down Operator Precedence.\n\n    function expression(rbp, initial) {\n\n// rbp is the right binding power.\n// initial indicates that this is the first expression of a statement.\n\n        var left;\n        if (next_token.id === '(end)') {\n            token.stop('unexpected_a', next_token.id);\n        }\n        advance();\n        if (initial) {\n            anonname = 'anonymous';\n        }\n        if (initial === true && token.fud) {\n            left = token.fud();\n        } else {\n            if (token.nud) {\n                left = token.nud();\n            } else {\n                if (next_token.id === '(number)' && token.id === '.') {\n                    token.warn('leading_decimal_a', artifact());\n                    advance();\n                    return token;\n                }\n                token.stop('expected_identifier_a', artifact(token));\n            }\n            while (rbp < next_token.lbp) {\n                advance();\n                left = token.led(left);\n            }\n        }\n        if (left && left.assign && !initial) {\n            if (!option.ass) {\n                left.warn('assignment_expression');\n            }\n            if (left.id !== '=' && left.first.master) {\n                left.first.master.used = true;\n            }\n        }\n        return left;\n    }\n\n    protosymbol = {\n        nud: function () {\n            this.stop('unexpected_a');\n        },\n        led: function () {\n            this.stop('expected_operator_a');\n        },\n        warn: function (code, a, b, c, d) {\n            if (!this.warning) {\n                this.warning = warn(code, this.line || 0, this.from || 0,\n                    a || artifact(this), b, c, d);\n            }\n        },\n        stop: function (code, a, b, c, d) {\n            this.warning = undefined;\n            this.warn(code, a, b, c, d);\n            return quit('stopping', this.line, this.character);\n        },\n        lbp: 0\n    };\n\n// Functional constructors for making the symbols that will be inherited by\n// tokens.\n\n    function symbol(s, bp) {\n        var x = syntax[s];\n        if (!x) {\n            x = Object.create(protosymbol);\n            x.id = x.string = s;\n            x.lbp = bp || 0;\n            syntax[s] = x;\n        }\n        return x;\n    }\n\n    function postscript(x) {\n        x.postscript = true;\n        return x;\n    }\n\n    function ultimate(s) {\n        var x = symbol(s, 0);\n        x.from = 1;\n        x.thru = 1;\n        x.line = 0;\n        x.edge = 'edge';\n        x.string = s;\n        return postscript(x);\n    }\n\n    function reserve_name(x) {\n        var c = x.id.charAt(0);\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            x.identifier = x.reserved = true;\n        }\n        return x;\n    }\n\n    function stmt(s, f) {\n        var x = symbol(s);\n        x.fud = f;\n        return reserve_name(x);\n    }\n\n    function disrupt_stmt(s, f) {\n        var x = stmt(s, f);\n        x.disrupt = true;\n    }\n\n    function labeled_stmt(s, f) {\n        var x = stmt(s, f);\n        x.labeled = true;\n    }\n\n    function prefix(s, f) {\n        var x = symbol(s, 150);\n        reserve_name(x);\n        x.nud = function () {\n            var that = this;\n            that.arity = 'prefix';\n            if (typeof f === 'function') {\n                that = f(that);\n                if (that.arity !== 'prefix') {\n                    return that;\n                }\n            } else {\n                if (s === 'typeof') {\n                    one_space();\n                } else {\n                    no_space_only();\n                }\n                that.first = expression(150);\n            }\n            switch (that.id) {\n            case '++':\n            case '--':\n                if (!option.plusplus) {\n                    that.warn('unexpected_a');\n                } else if ((!that.first.identifier || that.first.reserved) &&\n                        that.first.id !== '.' && that.first.id !== '[') {\n                    that.warn('bad_operand');\n                }\n                break;\n            default:\n                if (that.first.arity === 'prefix' ||\n                        that.first.arity === 'function') {\n                    that.warn('unexpected_a');\n                }\n            }\n            return that;\n        };\n        return x;\n    }\n\n\n    function type(s, t, nud) {\n        var x = symbol(s);\n        x.arity = t;\n        if (nud) {\n            x.nud = nud;\n        }\n        return x;\n    }\n\n\n    function reserve(s, f) {\n        var x = symbol(s);\n        x.identifier = x.reserved = true;\n        if (typeof f === 'function') {\n            x.nud = f;\n        }\n        return x;\n    }\n\n\n    function constant(name) {\n        var x = reserve(name);\n        x.string = name;\n        x.nud = return_this;\n        return x;\n    }\n\n\n    function reservevar(s, v) {\n        return reserve(s, function () {\n            if (typeof v === 'function') {\n                v(this);\n            }\n            return this;\n        });\n    }\n\n\n    function infix(s, p, f, w) {\n        var x = symbol(s, p);\n        reserve_name(x);\n        x.led = function (left) {\n            this.arity = 'infix';\n            if (!w) {\n                spaces(prev_token, token);\n                spaces();\n            }\n            if (!option.bitwise && this.bitwise) {\n                this.warn('unexpected_a');\n            }\n            if (typeof f === 'function') {\n                return f(left, this);\n            }\n            this.first = left;\n            this.second = expression(p);\n            return this;\n        };\n        return x;\n    }\n\n    function expected_relation(node, message) {\n        if (node.assign) {\n            node.warn(message || 'conditional_assignment');\n        }\n        return node;\n    }\n\n    function expected_condition(node, message) {\n        switch (node.id) {\n        case '[':\n        case '-':\n            if (node.arity !== 'infix') {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        case 'false':\n        case 'function':\n        case 'Infinity':\n        case 'NaN':\n        case 'null':\n        case 'true':\n        case 'undefined':\n        case 'void':\n        case '(number)':\n        case '(regexp)':\n        case '(string)':\n        case '{':\n        case '?':\n        case '~':\n            node.warn(message || 'weird_condition');\n            break;\n        case '(':\n            if (node.first.id === 'new' ||\n                    (node.first.string === 'Boolean') ||\n                    (node.first.id === '.' &&\n                        numbery[node.first.second.string] === true)) {\n                node.warn(message || 'weird_condition');\n            }\n            break;\n        }\n        return node;\n    }\n\n    function check_relation(node) {\n        switch (node.arity) {\n        case 'prefix':\n            switch (node.id) {\n            case '{':\n            case '[':\n                node.warn('unexpected_a');\n                break;\n            case '!':\n                node.warn('confusing_a');\n                break;\n            }\n            break;\n        case 'function':\n        case 'regexp':\n            node.warn('unexpected_a');\n            break;\n        default:\n            if (node.id  === 'NaN') {\n                node.warn('isNaN');\n            } else if (node.relation) {\n                node.warn('weird_relation');\n            }\n        }\n        return node;\n    }\n\n\n    function relation(s, eqeq) {\n        var x = infix(s, 100, function (left, that) {\n            check_relation(left);\n            if (eqeq && !option.eqeq) {\n                that.warn('expected_a_b', eqeq, that.id);\n            }\n            var right = expression(100);\n            if (are_similar(left, right) ||\n                    ((left.id === '(string)' || left.id === '(number)') &&\n                    (right.id === '(string)' || right.id === '(number)'))) {\n                that.warn('weird_relation');\n            } else if (left.id === 'typeof') {\n                if (right.id !== '(string)') {\n                    right.warn(\"expected_string_a\", artifact(right));\n                } else if (right.string === 'undefined' ||\n                        right.string === 'null') {\n                    left.warn(\"unexpected_typeof_a\", right.string);\n                }\n            } else if (right.id === 'typeof') {\n                if (left.id !== '(string)') {\n                    left.warn(\"expected_string_a\", artifact(left));\n                } else if (left.string === 'undefined' ||\n                        left.string === 'null') {\n                    right.warn(\"unexpected_typeof_a\", left.string);\n                }\n            }\n            that.first = left;\n            that.second = check_relation(right);\n            return that;\n        });\n        x.relation = true;\n        return x;\n    }\n\n    function lvalue(that, s) {\n        var master;\n        if (that.identifier) {\n            master = scope[that.string];\n            if (master) {\n                if (scope[that.string].writeable !== true) {\n                    that.warn('read_only');\n                }\n                master.used -= 1;\n                if (s === '=') {\n                    master.init = true;\n                }\n            }\n        } else if (that.id === '.' || that.id === '[') {\n            if (!that.first || that.first.string === 'arguments') {\n                that.warn('bad_assignment');\n            }\n        } else {\n            that.warn('bad_assignment');\n        }\n    }\n\n\n    function assignop(s, op) {\n        var x = infix(s, 20, function (left, that) {\n            var next;\n            that.first = left;\n            lvalue(left, s);\n            that.second = expression(20);\n            if (that.id === '=' && are_similar(that.first, that.second)) {\n                that.warn('weird_assignment');\n            }\n            next = that;\n            while (next_token.id === '=') {\n                lvalue(next.second, '=');\n                next_token.first = next.second;\n                next.second = next_token;\n                next = next_token;\n                advance('=');\n                next.second = expression(20);\n            }\n            return that;\n        });\n        x.assign = true;\n        if (op) {\n            if (syntax[op].bitwise) {\n                x.bitwise = true;\n            }\n        }\n        return x;\n    }\n\n\n    function bitwise(s, p) {\n        var x = infix(s, p, 'number');\n        x.bitwise = true;\n        return x;\n    }\n\n\n    function suffix(s) {\n        var x = symbol(s, 150);\n        x.led = function (left) {\n            no_space_only(prev_token, token);\n            if (!option.plusplus) {\n                this.warn('unexpected_a');\n            } else if ((!left.identifier || left.reserved) &&\n                    left.id !== '.' && left.id !== '[') {\n                this.warn('bad_operand');\n            }\n            this.first = left;\n            this.arity = 'suffix';\n            return this;\n        };\n        return x;\n    }\n\n\n    function optional_identifier(variable) {\n        if (next_token.identifier) {\n            advance();\n            if (token.reserved && (!option.es5 || variable)) {\n                token.warn('expected_identifier_a_reserved');\n            }\n            return token.string;\n        }\n    }\n\n\n    function identifier(variable) {\n        var i = optional_identifier(variable);\n        if (!i) {\n            next_token.stop(token.id === 'function' && next_token.id === '('\n                ? 'name_function'\n                : 'expected_identifier_a');\n        }\n        return i;\n    }\n\n\n    function statement() {\n\n        var label, preamble, the_statement;\n\n// We don't like the empty statement.\n\n        if (next_token.id === ';') {\n            next_token.warn('unexpected_a');\n            semicolon();\n            return;\n        }\n\n// Is this a labeled statement?\n\n        if (next_token.identifier && !next_token.reserved && peek().id === ':') {\n            edge('label');\n            label = next_token;\n            advance();\n            advance(':');\n            define('label', label);\n            if (next_token.labeled !== true || funct === global_funct) {\n                label.stop('unexpected_label_a');\n            } else if (jx.test(label.string + ':')) {\n                label.warn('url');\n            }\n            next_token.label = label;\n            label.init = true;\n        }\n\n// Parse the statement.\n\n        preamble = next_token;\n        if (token.id !== 'else') {\n            edge();\n        }\n        step_in('statement');\n        the_statement = expression(0, true);\n        if (the_statement) {\n\n// Look for the final semicolon.\n\n            if (the_statement.arity === 'statement') {\n                if (the_statement.id === 'switch' ||\n                        (the_statement.block && the_statement.id !== 'do')) {\n                    spaces();\n                } else {\n                    semicolon();\n                }\n            } else {\n\n// If this is an expression statement, determine if it is acceptable.\n// We do not like\n//      new Blah;\n// statements. If it is to be used at all, new should only be used to make\n// objects, not side effects. The expression statements we do like do\n// assignment or invocation or delete.\n\n                if (the_statement.id === '(') {\n                    if (the_statement.first.id === 'new') {\n                        next_token.warn('bad_new');\n                    }\n                } else if (the_statement.id === '++' ||\n                        the_statement.id === '--') {\n                    lvalue(the_statement.first);\n                } else if (!the_statement.assign &&\n                        the_statement.id !== 'delete') {\n                    if (!option.closure || !preamble.comments) {\n                        preamble.warn('assignment_function_expression');\n                    }\n                }\n                semicolon();\n            }\n        }\n        step_out();\n        if (label) {\n            label.dead = true;\n        }\n        return the_statement;\n    }\n\n\n    function statements() {\n        var array = [], disruptor, the_statement;\n\n// A disrupt statement may not be followed by any other statement.\n// If the last statement is disrupt, then the sequence is disrupt.\n\n        while (next_token.postscript !== true) {\n            if (next_token.id === ';') {\n                next_token.warn('unexpected_a');\n                semicolon();\n            } else {\n                if (next_token.string === 'use strict') {\n                    if ((!node_js) || funct !== global_funct || array.length > 0) {\n                        next_token.warn('function_strict');\n                    }\n                    use_strict();\n                }\n                if (disruptor) {\n                    next_token.warn('unreachable_a_b', next_token.string,\n                        disruptor.string);\n                    disruptor = null;\n                }\n                the_statement = statement();\n                if (the_statement) {\n                    array.push(the_statement);\n                    if (the_statement.disrupt) {\n                        disruptor = the_statement;\n                        array.disrupt = true;\n                    }\n                }\n            }\n        }\n        return array;\n    }\n\n\n    function block(kind) {\n\n// A block is a sequence of statements wrapped in braces.\n\n        var array,\n            curly = next_token,\n            old_block_var = block_var,\n            old_in_block = in_block,\n            old_strict_mode = strict_mode;\n\n        in_block = kind !== 'function' && kind !== 'try' && kind !== 'catch';\n        block_var = [];\n        if (curly.id === '{') {\n            spaces();\n            advance('{');\n            step_in();\n            if (kind === 'function' && !use_strict() && !old_strict_mode &&\n                    !option.sloppy && funct.level === 1) {\n                next_token.warn('missing_use_strict');\n            }\n            array = statements();\n            strict_mode = old_strict_mode;\n            step_out('}', curly);\n        } else if (in_block) {\n            curly.stop('expected_a_b', '{', artifact());\n        } else {\n            curly.warn('expected_a_b', '{', artifact());\n            array = [statement()];\n            array.disrupt = array[0].disrupt;\n        }\n        if (kind !== 'catch' && array.length === 0) {\n            curly.warn('empty_block');\n        }\n        block_var.forEach(function (name) {\n            scope[name].dead = true;\n        });\n        block_var = old_block_var;\n        in_block = old_in_block;\n        return array;\n    }\n\n\n    function tally_property(name) {\n        if (option.properties && typeof property[name] !== 'number') {\n            token.warn('unexpected_property_a', name);\n        }\n        if (property[name]) {\n            property[name] += 1;\n        } else {\n            property[name] = 1;\n        }\n    }\n\n\n// ECMAScript parser\n\n    (function () {\n        var x = symbol('(identifier)');\n        x.nud = function () {\n            var name = this.string,\n                master = scope[name],\n                writeable;\n\n// If the master is not in scope, then we may have an undeclared variable.\n// Check the predefined list. If it was predefined, create the global\n// variable.\n\n            if (!master) {\n                writeable = predefined[name];\n                if (typeof writeable === 'boolean') {\n                    global_scope[name] = master = {\n                        dead: false,\n                        function: global_funct,\n                        kind: 'var',\n                        string: name,\n                        writeable: writeable\n                    };\n\n// But if the variable is not in scope, and is not predefined, and if we are not\n// in the global scope, then we have an undefined variable error.\n\n                } else {\n                    token.warn('used_before_a');\n                }\n            } else {\n                this.master = master;\n            }\n\n// Annotate uses that cross scope boundaries.\n\n            if (master) {\n                if (master.kind === 'label') {\n                    this.warn('a_label');\n                } else {\n                    if (master.dead === true || master.dead === funct) {\n                        this.warn('a_scope');\n                    }\n                    master.used += 1;\n                    if (master.function !== funct) {\n                        if (master.function === global_funct) {\n                            funct.global.push(name);\n                        } else {\n                            master.function.closure.push(name);\n                            funct.outer.push(name);\n                        }\n                    }\n                }\n            }\n            return this;\n        };\n        x.identifier = true;\n    }());\n\n\n// Build the syntax table by declaring the syntactic elements.\n\n    type('(array)', 'array');\n    type('(function)', 'function');\n    type('(number)', 'number', return_this);\n    type('(object)', 'object');\n    type('(string)', 'string', return_this);\n    type('(boolean)', 'boolean', return_this);\n    type('(regexp)', 'regexp', return_this);\n\n    ultimate('(begin)');\n    ultimate('(end)');\n    ultimate('(error)');\n    postscript(symbol('}'));\n    symbol(')');\n    symbol(']');\n    postscript(symbol('\"'));\n    postscript(symbol('\\''));\n    symbol(';');\n    symbol(':');\n    symbol(',');\n    symbol('#');\n    symbol('@');\n    symbol('*/');\n    postscript(reserve('case'));\n    reserve('catch');\n    postscript(reserve('default'));\n    reserve('else');\n    reserve('finally');\n\n    reservevar('arguments', function (x) {\n        if (strict_mode && funct === global_funct) {\n            x.warn('strict');\n        }\n        funct.arguments = true;\n    });\n    reservevar('eval');\n    constant('false', 'boolean');\n    constant('Infinity', 'number');\n    constant('NaN', 'number');\n    constant('null', '');\n    reservevar('this', function (x) {\n        if (strict_mode && funct.statement && funct.name.charAt(0) > 'Z') {\n            x.warn('strict');\n        }\n    });\n    constant('true', 'boolean');\n    constant('undefined', '');\n\n    infix('?', 30, function (left, that) {\n        step_in('?');\n        that.first = expected_condition(expected_relation(left));\n        that.second = expression(0);\n        spaces();\n        step_out();\n        var colon = next_token;\n        advance(':');\n        step_in(':');\n        spaces();\n        that.third = expression(10);\n        that.arity = 'ternary';\n        if (are_similar(that.second, that.third)) {\n            colon.warn('weird_ternary');\n        } else if (are_similar(that.first, that.second)) {\n            that.warn('use_or');\n        }\n        step_out();\n        return that;\n    });\n\n    infix('||', 40, function (left, that) {\n        function paren_check(that) {\n            if (that.id === '&&' && !that.paren) {\n                that.warn('and');\n            }\n            return that;\n        }\n\n        that.first = paren_check(expected_condition(expected_relation(left)));\n        that.second = paren_check(expected_relation(expression(40)));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    infix('&&', 50, function (left, that) {\n        that.first = expected_condition(expected_relation(left));\n        that.second = expected_relation(expression(50));\n        if (are_similar(that.first, that.second)) {\n            that.warn('weird_condition');\n        }\n        return that;\n    });\n\n    prefix('void', function (that) {\n        that.first = expression(0);\n        if (option.es5 || strict_mode) {\n            that.warn('expected_a_b', 'undefined', 'void');\n        } else if (that.first.number !== 0) {\n            that.first.warn('expected_a_b', '0', artifact(that.first));\n        }\n        return that;\n    });\n\n    bitwise('|', 70);\n    bitwise('^', 80);\n    bitwise('&', 90);\n\n    relation('==', '===');\n    relation('===');\n    relation('!=', '!==');\n    relation('!==');\n    relation('<');\n    relation('>');\n    relation('<=');\n    relation('>=');\n\n    bitwise('<<', 120);\n    bitwise('>>', 120);\n    bitwise('>>>', 120);\n\n    infix('in', 120, function (left, that) {\n        that.warn('infix_in');\n        that.left = left;\n        that.right = expression(130);\n        return that;\n    });\n    infix('instanceof', 120);\n    infix('+', 130, function (left, that) {\n        if (left.id === '(number)') {\n            if (left.number === 0) {\n                left.warn('unexpected_a', '0');\n            }\n        } else if (left.id === '(string)') {\n            if (left.string === '') {\n                left.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        var right = expression(130);\n        if (right.id === '(number)') {\n            if (right.number === 0) {\n                right.warn('unexpected_a', '0');\n            }\n        } else if (right.id === '(string)') {\n            if (right.string === '') {\n                right.warn('expected_a_b', 'String', '\\'\\'');\n            }\n        }\n        if (left.id === right.id) {\n            if (left.id === '(string)' || left.id === '(number)') {\n                if (left.id === '(string)') {\n                    left.string += right.string;\n                    if (jx.test(left.string)) {\n                        left.warn('url');\n                    }\n                } else {\n                    left.number += right.number;\n                }\n                left.thru = right.thru;\n                return left;\n            }\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('+');\n    prefix('+++', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('+++', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('-', 130, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(130);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number -= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    prefix('-');\n    prefix('---', function () {\n        token.warn('confusing_a');\n        this.first = expression(150);\n        this.arity = 'prefix';\n        return this;\n    });\n    infix('---', 130, function (left) {\n        token.warn('confusing_a');\n        this.first = left;\n        this.second = expression(130);\n        return this;\n    });\n    infix('*', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number *= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('/', 140, function (left, that) {\n        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number /= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n    infix('%', 140, function (left, that) {\n        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {\n            left.warn('unexpected_a');\n        }\n        var right = expression(140);\n        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {\n            right.warn('unexpected_a');\n        }\n        if (left.id === right.id && left.id === '(number)') {\n            left.number %= right.number;\n            left.thru = right.thru;\n            return left;\n        }\n        that.first = left;\n        that.second = right;\n        return that;\n    });\n\n    suffix('++');\n    prefix('++');\n\n    suffix('--');\n    prefix('--');\n    prefix('delete', function (that) {\n        one_space();\n        var p = expression(0);\n        if (!p || (p.id !== '.' && p.id !== '[')) {\n            next_token.warn('deleted');\n        }\n        that.first = p;\n        return that;\n    });\n\n\n    prefix('~', function (that) {\n        no_space_only();\n        if (!option.bitwise) {\n            that.warn('unexpected_a');\n        }\n        that.first = expression(150);\n        return that;\n    });\n    function banger(that) {\n        no_space_only();\n        that.first = expected_condition(expression(150));\n        if (bang[that.first.id] === that || that.first.assign) {\n            that.warn('confusing_a');\n        }\n        return that;\n    }\n    prefix('!', banger);\n    prefix('!!', banger);\n    prefix('typeof');\n    prefix('new', function (that) {\n        one_space();\n        var c = expression(160), n, p, v;\n        that.first = c;\n        if (c.id !== 'function') {\n            if (c.identifier) {\n                switch (c.string) {\n                case 'Object':\n                    token.warn('use_object');\n                    break;\n                case 'Array':\n                    if (next_token.id === '(') {\n                        p = next_token;\n                        p.first = this;\n                        advance('(');\n                        if (next_token.id !== ')') {\n                            n = expression(0);\n                            p.second = [n];\n                            if (n.id !== '(number)' || next_token.id === ',') {\n                                p.warn('use_array');\n                            }\n                            while (next_token.id === ',') {\n                                advance(',');\n                                p.second.push(expression(0));\n                            }\n                        } else {\n                            token.warn('use_array');\n                        }\n                        advance(')', p);\n                        return p;\n                    }\n                    token.warn('use_array');\n                    break;\n                case 'Number':\n                case 'String':\n                case 'Boolean':\n                case 'Math':\n                case 'JSON':\n                    c.warn('not_a_constructor');\n                    break;\n                case 'Function':\n                    if (!option.evil) {\n                        next_token.warn('function_eval');\n                    }\n                    break;\n                case 'Date':\n                case 'RegExp':\n                case 'this':\n                    break;\n                default:\n                    if (c.id !== 'function') {\n                        v = c.string.charAt(0);\n                        if (!option.newcap && (v < 'A' || v > 'Z')) {\n                            token.warn('constructor_name_a');\n                        }\n                    }\n                }\n            } else {\n                if (c.id !== '.' && c.id !== '[' && c.id !== '(') {\n                    token.warn('bad_constructor');\n                }\n            }\n        } else {\n            that.warn('weird_new');\n        }\n        if (next_token.id !== '(') {\n            next_token.warn('missing_a', '()');\n        }\n        return that;\n    });\n\n    infix('(', 160, function (left, that) {\n        var e, p;\n        if (indent && indent.mode === 'expression') {\n            no_space(prev_token, token);\n        } else {\n            no_space_only(prev_token, token);\n        }\n        if (!left.immed && left.id === 'function') {\n            next_token.warn('wrap_immediate');\n        }\n        p = [];\n        if (left.identifier) {\n            if (left.string.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {\n                if (left.string !== 'Number' && left.string !== 'String' &&\n                        left.string !== 'Boolean' && left.string !== 'Date') {\n                    if (left.string === 'Math') {\n                        left.warn('not_a_function');\n                    } else if (left.string === 'Object') {\n                        token.warn('use_object');\n                    } else if (left.string === 'Array' || !option.newcap) {\n                        left.warn('missing_a', 'new');\n                    }\n                }\n            } else if (left.string === 'JSON') {\n                left.warn('not_a_function');\n            }\n        } else if (left.id === '.') {\n            if (left.second.string === 'split' &&\n                    left.first.id === '(string)') {\n                left.second.warn('use_array');\n            }\n        }\n        step_in();\n        if (next_token.id !== ')') {\n            no_space();\n            for (;;) {\n                edge();\n                e = expression(10);\n                if (left.string === 'Boolean' && (e.id === '!' || e.id === '~')) {\n                    e.warn('weird_condition');\n                }\n                p.push(e);\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', that);\n        if (typeof left === 'object') {\n            if (left.string === 'parseInt' && p.length === 1) {\n                left.warn('radix');\n            } else if (left.string === 'String' && p.length >= 1 && p[0].id === '(string)') {\n                left.warn('unexpected_a');\n            }\n            if (!option.evil) {\n                if (left.string === 'eval' || left.string === 'Function' ||\n                        left.string === 'execScript') {\n                    left.warn('evil');\n                } else if (p[0] && p[0].id === '(string)' &&\n                        (left.string === 'setTimeout' ||\n                        left.string === 'setInterval')) {\n                    left.warn('implied_evil');\n                }\n            }\n            if (!left.identifier && left.id !== '.' && left.id !== '[' &&\n                    left.id !== '(' && left.id !== '&&' && left.id !== '||' &&\n                    left.id !== '?') {\n                left.warn('bad_invocation');\n            }\n            if (left.id === '.') {\n                if (p.length > 0 &&\n                        left.first && left.first.first &&\n                        are_similar(p[0], left.first.first)) {\n                    if (left.second.string === 'call' ||\n                            (left.second.string === 'apply' && (p.length === 1 ||\n                            (p[1].arity === 'prefix' && p[1].id === '[')))) {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n                if (left.second.string === 'toString') {\n                    if (left.first.id === '(string)' || left.first.id === '(number)') {\n                        left.second.warn('unexpected_a');\n                    }\n                }\n            }\n        }\n        that.first = left;\n        that.second = p;\n        return that;\n    }, true);\n\n    prefix('(', function (that) {\n        step_in('expression');\n        no_space();\n        edge();\n        if (next_token.id === 'function') {\n            next_token.immed = true;\n        }\n        var value = expression(0);\n        value.paren = true;\n        no_space();\n        step_out(')', that);\n        if (value.id === 'function') {\n            switch (next_token.id) {\n            case '(':\n                next_token.warn('move_invocation');\n                break;\n            case '.':\n            case '[':\n                next_token.warn('unexpected_a');\n                break;\n            default:\n                that.warn('bad_wrap');\n            }\n        } else if (!value.arity) {\n            if (!option.closure || !that.comments) {\n                that.warn('unexpected_a');\n            }\n        }\n        return value;\n    });\n\n    infix('.', 170, function (left, that) {\n        no_space(prev_token, token);\n        no_space();\n        var name = identifier();\n        if (typeof name === 'string') {\n            tally_property(name);\n        }\n        that.first = left;\n        that.second = token;\n        if (left && left.string === 'arguments' &&\n                (name === 'callee' || name === 'caller')) {\n            left.warn('avoid_a', 'arguments.' + name);\n        } else if (!option.evil && left && left.string === 'document' &&\n                (name === 'write' || name === 'writeln')) {\n            left.warn('write_is_wrong');\n        } else if (!option.stupid && syx.test(name)) {\n            token.warn('sync_a');\n        }\n        if (!option.evil && (name === 'eval' || name === 'execScript')) {\n            next_token.warn('evil');\n        }\n        return that;\n    }, true);\n\n    infix('[', 170, function (left, that) {\n        var e, s;\n        no_space_only(prev_token, token);\n        no_space();\n        step_in();\n        edge();\n        e = expression(0);\n        switch (e.id) {\n        case '(number)':\n            if (e.id === '(number)' && left.id === 'arguments') {\n                left.warn('use_param');\n            }\n            break;\n        case '(string)':\n            if (!option.evil &&\n                    (e.string === 'eval' || e.string === 'execScript')) {\n                e.warn('evil');\n            } else if (!option.sub && ix.test(e.string)) {\n                s = syntax[e.string];\n                if (!s || !s.reserved) {\n                    e.warn('subscript');\n                }\n            }\n            tally_property(e.string);\n            break;\n        }\n        step_out(']', that);\n        no_space(prev_token, token);\n        that.first = left;\n        that.second = e;\n        return that;\n    }, true);\n\n    prefix('[', function (that) {\n        that.first = [];\n        step_in('array');\n        while (next_token.id !== '(end)') {\n            while (next_token.id === ',') {\n                next_token.warn('unexpected_a');\n                advance(',');\n            }\n            if (next_token.id === ']') {\n                break;\n            }\n            indent.wrap = false;\n            edge();\n            that.first.push(expression(10));\n            if (next_token.id === ',') {\n                comma();\n                if (next_token.id === ']' && !option.es5) {\n                    token.warn('unexpected_a');\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n        step_out(']', that);\n        return that;\n    }, 170);\n\n\n    function property_name() {\n        var id = optional_identifier();\n        if (!id) {\n            if (next_token.id === '(string)') {\n                id = next_token.string;\n                advance();\n            } else if (next_token.id === '(number)') {\n                id = next_token.number.toString();\n                advance();\n            }\n        }\n        return id;\n    }\n\n\n\n    assignop('=');\n    assignop('+=', '+');\n    assignop('-=', '-');\n    assignop('*=', '*');\n    assignop('/=', '/').nud = function () {\n        next_token.stop('slash_equal');\n    };\n    assignop('%=', '%');\n    assignop('&=', '&');\n    assignop('|=', '|');\n    assignop('^=', '^');\n    assignop('<<=', '<<');\n    assignop('>>=', '>>');\n    assignop('>>>=', '>>>');\n\n    function function_parameters() {\n        var id, parameters = [], paren = next_token;\n        advance('(');\n        token.function = funct;\n        step_in();\n        no_space();\n        if (next_token.id !== ')') {\n            for (;;) {\n                edge();\n                id = identifier();\n                define('parameter', token);\n                parameters.push(id);\n                token.init = true;\n                token.writeable = true;\n                if (next_token.id !== ',') {\n                    break;\n                }\n                comma();\n            }\n        }\n        no_space();\n        step_out(')', paren);\n        return parameters;\n    }\n\n    function do_function(func, name) {\n        var old_funct = funct,\n            old_option = option,\n            old_scope = scope;\n        scope = Object.create(old_scope);\n        funct = {\n            closure: [],\n            global: [],\n            level: old_funct.level + 1,\n            line: next_token.line,\n            loopage: 0,\n            name: name || '\\'' + (anonname || '').replace(nx, sanitize) + '\\'',\n            outer: [],\n            scope: scope\n        };\n        funct.parameter = function_parameters();\n        func.function = funct;\n        option = Object.create(old_option);\n        functions.push(funct);\n        if (name) {\n            func.name = name;\n            func.string = name;\n            define('function', func);\n            func.init = true;\n            func.used += 1;\n        }\n        func.writeable = false;\n        one_space();\n        func.block = block('function');\n        Object.keys(scope).forEach(function (name) {\n            var master = scope[name];\n            if (!master.used && master.kind !== 'exception' &&\n                    (master.kind !== 'parameter' || !option.unparam)) {\n                master.warn('unused_a');\n            } else if (!master.init) {\n                master.warn('uninitialized_a');\n            }\n        });\n        funct = old_funct;\n        option = old_option;\n        scope = old_scope;\n    }\n\n    prefix('{', function (that) {\n        var get, i, j, name, set, seen = Object.create(null);\n        that.first = [];\n        step_in();\n        while (next_token.id !== '}') {\n            indent.wrap = false;\n\n// JSLint recognizes the ES5 extension for get/set in object literals,\n// but requires that they be used in pairs.\n\n            edge();\n            if (next_token.string === 'get' && peek().id !== ':') {\n                if (!option.es5) {\n                    next_token.warn('es5');\n                }\n                get = next_token;\n                advance('get');\n                one_space_only();\n                name = next_token;\n                i = property_name();\n                if (!i) {\n                    next_token.stop('missing_property');\n                }\n                get.string = '';\n                do_function(get);\n                if (funct.loopage) {\n                    get.warn('function_loop');\n                }\n                if (get.function.parameter.length) {\n                    get.warn('parameter_a_get_b', get.function.parameter[0], i);\n                }\n                comma();\n                set = next_token;\n                spaces();\n                edge();\n                advance('set');\n                set.string = '';\n                one_space_only();\n                j = property_name();\n                if (i !== j) {\n                    token.stop('expected_a_b', i, j || next_token.string);\n                }\n                do_function(set);\n                if (set.block.length === 0) {\n                    token.warn('missing_a', 'throw');\n                }\n                if (set.function.parameter.length === 0) {\n                    set.stop('parameter_set_a', 'value');\n                } else if (set.function.parameter[0] !== 'value') {\n                    set.stop('expected_a_b', 'value',\n                        set.function.parameter[0]);\n                }\n                name.first = [get, set];\n            } else {\n                name = next_token;\n                i = property_name();\n                if (typeof i !== 'string') {\n                    next_token.stop('missing_property');\n                }\n                advance(':');\n                spaces();\n                name.first = expression(10);\n            }\n            that.first.push(name);\n            if (seen[i] === true) {\n                next_token.warn('duplicate_a', i);\n            }\n            seen[i] = true;\n            tally_property(i);\n            if (next_token.id !== ',') {\n                break;\n            }\n            for (;;) {\n                comma();\n                if (next_token.id !== ',') {\n                    break;\n                }\n                next_token.warn('unexpected_a');\n            }\n            if (next_token.id === '}' && !option.es5) {\n                token.warn('unexpected_a');\n            }\n        }\n        step_out('}', that);\n        return that;\n    });\n\n    stmt('{', function () {\n        next_token.warn('statement_block');\n        this.arity = 'statement';\n        this.block = statements();\n        this.disrupt = this.block.disrupt;\n        advance('}', this);\n        return this;\n    });\n\n    stmt('/*global', directive);\n    stmt('/*globals', directive);\n    stmt('/*jslint', directive);\n    stmt('/*member', directive);\n    stmt('/*members', directive);\n    stmt('/*property', directive);\n    stmt('/*properties', directive);\n\n    stmt('var', function () {\n\n// JavaScript does not have block scope. It only has function scope. So,\n// declaring a variable in a block can have unexpected consequences.\n\n// var.first will contain an array, the array containing name tokens\n// and assignment tokens.\n\n        var assign, id, name;\n\n        if (funct.loopage) {\n            next_token.warn('var_loop');\n        } else if (funct.varstatement && !option.vars) {\n            next_token.warn('combine_var');\n        }\n        if (funct !== global_funct) {\n            funct.varstatement = true;\n        }\n        this.arity = 'statement';\n        this.first = [];\n        step_in('var');\n        for (;;) {\n            name = next_token;\n            id = identifier(true);\n            define('var', name);\n            name.dead = funct;\n            if (next_token.id === '=') {\n                assign = next_token;\n                assign.first = name;\n                spaces();\n                advance('=');\n                spaces();\n                if (next_token.id === 'undefined') {\n                    token.warn('unnecessary_initialize', id);\n                }\n                if (peek(0).id === '=' && next_token.identifier) {\n                    next_token.stop('var_a_not');\n                }\n                assign.second = expression(0);\n                assign.arity = 'infix';\n                name.init = true;\n                this.first.push(assign);\n            } else {\n                this.first.push(name);\n            }\n            name.dead = false;\n            name.writeable = true;\n            if (next_token.id !== ',') {\n                break;\n            }\n            comma();\n            indent.wrap = false;\n            if (var_mode && next_token.line === token.line &&\n                    this.first.length === 1) {\n                var_mode = null;\n                indent.open = false;\n                indent.at -= option.indent;\n            }\n            spaces();\n            edge();\n        }\n        var_mode = null;\n        step_out();\n        return this;\n    });\n\n    stmt('function', function () {\n        one_space();\n        if (in_block) {\n            token.warn('function_block');\n        }\n        var name = next_token,\n            id = identifier(true);\n        define('var', name);\n        name.init = true;\n        name.statement = true;\n        no_space();\n        this.arity = 'statement';\n        do_function(this, id);\n        if (next_token.id === '(' && next_token.line === token.line) {\n            next_token.stop('function_statement');\n        }\n        return this;\n    });\n\n    prefix('function', function (that) {\n        var id = optional_identifier(true), name;\n        if (id) {\n            name = token;\n            no_space();\n        } else {\n            id = '';\n            one_space();\n        }\n        do_function(that, id);\n        if (name) {\n            name.function = that.function;\n        }\n        if (funct.loopage) {\n            that.warn('function_loop');\n        }\n        switch (next_token.id) {\n        case ';':\n        case '(':\n        case ')':\n        case ',':\n        case ']':\n        case '}':\n        case ':':\n        case '(end)':\n            break;\n        case '.':\n            if (peek().string !== 'bind' || peek(1).id !== '(') {\n                next_token.warn('unexpected_a');\n            }\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n        that.arity = 'function';\n        return that;\n    });\n\n    stmt('if', function () {\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('if');\n        if (next_token.id === 'else') {\n            if (this.block.disrupt) {\n                next_token.warn('unnecessary_else');\n            }\n            one_space();\n            advance('else');\n            one_space();\n            this.else = next_token.id === 'if' || next_token.id === 'switch'\n                ? statement(true)\n                : block('else');\n            if (this.else.disrupt && this.block.disrupt) {\n                this.disrupt = true;\n            }\n        }\n        return this;\n    });\n\n    stmt('try', function () {\n\n// try.first    The catch variable\n// try.second   The catch clause\n// try.third    The finally clause\n// try.block    The try block\n\n        var exception_variable, paren;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('try');\n        if (next_token.id === 'catch') {\n            one_space();\n            advance('catch');\n            one_space();\n            paren = next_token;\n            advance('(');\n            step_in('control');\n            no_space();\n            edge();\n            exception_variable = next_token;\n            this.first = identifier();\n            define('exception', exception_variable);\n            exception_variable.init = true;\n            no_space();\n            step_out(')', paren);\n            one_space();\n            this.second = block('catch');\n            if (this.second.length) {\n                if (this.first === 'ignore') {\n                    exception_variable.warn('unexpected_a');\n                }\n            } else {\n                if (this.first !== 'ignore') {\n                    exception_variable.warn('expected_a_b', 'ignore',\n                        exception_variable.string);\n                }\n            }\n            exception_variable.dead = true;\n        }\n        if (next_token.id === 'finally') {\n            one_space();\n            advance('finally');\n            one_space();\n            this.third = block('finally');\n        } else if (!this.second) {\n            next_token.stop('expected_a_b', 'catch', artifact());\n        }\n        return this;\n    });\n\n    labeled_stmt('while', function () {\n        one_space();\n        var paren = next_token;\n        funct.loopage += 1;\n        advance('(');\n        step_in('control');\n        no_space();\n        edge();\n        this.arity = 'statement';\n        this.first = expected_relation(expression(0));\n        if (this.first.id !== 'true') {\n            expected_condition(this.first, 'unexpected_a');\n        }\n        no_space();\n        step_out(')', paren);\n        one_space();\n        this.block = block('while');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        funct.loopage -= 1;\n        return this;\n    });\n\n    reserve('with');\n\n    labeled_stmt('switch', function () {\n\n// switch.first         the switch expression\n// switch.second        the array of cases. A case is 'case' or 'default' token:\n//    case.first        the array of case expressions\n//    case.second       the array of statements\n// If all of the arrays of statements are disrupt, then the switch is disrupt.\n\n        var cases = [],\n            old_in_block = in_block,\n            particular,\n            that = token,\n            the_case = next_token,\n            unbroken = true;\n\n        function find_duplicate_case(value) {\n            if (are_similar(particular, value)) {\n                value.warn('duplicate_a');\n            }\n        }\n\n        one_space();\n        advance('(');\n        no_space();\n        step_in();\n        this.arity = 'statement';\n        this.first = expected_condition(expected_relation(expression(0)));\n        no_space();\n        step_out(')', the_case);\n        one_space();\n        advance('{');\n        step_in();\n        in_block = true;\n        this.second = [];\n        if (that.from !== next_token.from && !option.white) {\n            next_token.warn('expected_a_at_b_c', next_token.string, that.from, next_token.from);\n        }\n        while (next_token.id === 'case') {\n            the_case = next_token;\n            cases.forEach(find_duplicate_case);\n            the_case.first = [];\n            the_case.arity = 'case';\n            spaces();\n            edge('case');\n            advance('case');\n            for (;;) {\n                one_space();\n                particular = expression(0);\n                cases.forEach(find_duplicate_case);\n                cases.push(particular);\n                the_case.first.push(particular);\n                if (particular.id === 'NaN') {\n                    particular.warn('unexpected_a');\n                }\n                no_space_only();\n                advance(':');\n                if (next_token.id !== 'case') {\n                    break;\n                }\n                spaces();\n                edge('case');\n                advance('case');\n            }\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                particular = the_case.second[the_case.second.length - 1];\n                if (particular.disrupt) {\n                    if (particular.id === 'break') {\n                        unbroken = false;\n                    }\n                } else {\n                    next_token.warn('missing_a_after_b', 'break', 'case');\n                }\n            } else {\n                next_token.warn('empty_case');\n            }\n            this.second.push(the_case);\n        }\n        if (this.second.length === 0) {\n            next_token.warn('missing_a', 'case');\n        }\n        if (next_token.id === 'default') {\n            spaces();\n            the_case = next_token;\n            the_case.arity = 'case';\n            edge('case');\n            advance('default');\n            no_space_only();\n            advance(':');\n            spaces();\n            the_case.second = statements();\n            if (the_case.second && the_case.second.length > 0) {\n                particular = the_case.second[the_case.second.length - 1];\n                if (unbroken && particular.disrupt && particular.id !== 'break') {\n                    this.disrupt = true;\n                }\n            }\n            this.second.push(the_case);\n        }\n        spaces();\n        step_out('}', this);\n        in_block = old_in_block;\n        return this;\n    });\n\n    stmt('debugger', function () {\n        if (!option.debug) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        return this;\n    });\n\n    labeled_stmt('do', function () {\n        funct.loopage += 1;\n        one_space();\n        this.arity = 'statement';\n        this.block = block('do');\n        if (this.block.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        one_space();\n        advance('while');\n        var paren = next_token;\n        one_space();\n        advance('(');\n        step_in();\n        no_space();\n        edge();\n        this.first = expected_condition(expected_relation(expression(0)), 'unexpected_a');\n        no_space();\n        step_out(')', paren);\n        funct.loopage -= 1;\n        return this;\n    });\n\n    labeled_stmt('for', function () {\n\n        var blok, filter, master, ok = false, paren = next_token, value;\n        this.arity = 'statement';\n        funct.loopage += 1;\n        advance('(');\n        if (next_token.id === ';') {\n            no_space();\n            advance(';');\n            no_space();\n            advance(';');\n            no_space();\n            advance(')');\n            blok = block('for');\n        } else {\n            step_in('control');\n            spaces(this, paren);\n            no_space();\n            if (next_token.id === 'var') {\n                next_token.stop('move_var');\n            }\n            edge();\n            if (peek(0).id === 'in') {\n                this.forin = true;\n                value = expression(1000);\n                master = value.master;\n                if (master.kind !== 'var' || master.function !== funct ||\n                        !master.writeable || master.dead) {\n                    value.warn('bad_in_a');\n                }\n                master.init = true;\n                master.used -= 1;\n                this.first = value;\n                advance('in');\n                this.second = expression(20);\n                step_out(')', paren);\n                blok = block('for');\n                if (!option.forin) {\n                    if (blok.length === 1 && typeof blok[0] === 'object') {\n                        if (blok[0].id === 'if' && !blok[0].else) {\n                            filter = blok[0].first;\n                            while (filter.id === '&&') {\n                                filter = filter.first;\n                            }\n                            switch (filter.id) {\n                            case '===':\n                            case '!==':\n                                ok = filter.first.id === '['\n                                    ? are_similar(filter.first.first, this.second) &&\n                                        are_similar(filter.first.second, this.first)\n                                    : filter.first.id === 'typeof' &&\n                                        filter.first.first.id === '[' &&\n                                        are_similar(filter.first.first.first, this.second) &&\n                                        are_similar(filter.first.first.second, this.first);\n                                break;\n                            case '(':\n                                ok = filter.first.id === '.' && ((\n                                    are_similar(filter.first.first, this.second) &&\n                                    filter.first.second.string === 'hasOwnProperty' &&\n                                    are_similar(filter.second[0], this.first)\n                                ) || (\n                                    filter.first.first.id === '.' &&\n                                    filter.first.first.first.first &&\n                                    filter.first.first.first.first.string === 'Object' &&\n                                    filter.first.first.first.id === '.' &&\n                                    filter.first.first.first.second.string === 'prototype' &&\n                                    filter.first.first.second.string === 'hasOwnProperty' &&\n                                    filter.first.second.string === 'call' &&\n                                    are_similar(filter.second[0], this.second) &&\n                                    are_similar(filter.second[1], this.first)\n                                ));\n                                break;\n                            }\n                        } else if (blok[0].id === 'switch') {\n                            ok = blok[0].id === 'switch' &&\n                                blok[0].first.id === 'typeof' &&\n                                blok[0].first.first.id === '[' &&\n                                are_similar(blok[0].first.first.first, this.second) &&\n                                are_similar(blok[0].first.first.second, this.first);\n                        }\n                    }\n                    if (!ok) {\n                        this.warn('for_if');\n                    }\n                }\n            } else {\n                edge();\n                this.first = [];\n                for (;;) {\n                    this.first.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                semicolon();\n                edge();\n                this.second = expected_relation(expression(0));\n                if (this.second.id !== 'true') {\n                    expected_condition(this.second, 'unexpected_a');\n                }\n                semicolon(token);\n                if (next_token.id === ';') {\n                    next_token.stop('expected_a_b', ')', ';');\n                }\n                this.third = [];\n                edge();\n                for (;;) {\n                    this.third.push(expression(0, 'for'));\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    comma();\n                }\n                no_space();\n                step_out(')', paren);\n                one_space();\n                blok = block('for');\n            }\n        }\n        if (blok.disrupt) {\n            prev_token.warn('strange_loop');\n        }\n        this.block = blok;\n        funct.loopage -= 1;\n        return this;\n    });\n\n    function optional_label(that) {\n        var label = next_token.string,\n            master;\n        that.arity = 'statement';\n        if (next_token.identifier && token.line === next_token.line) {\n            one_space_only();\n            master = scope[label];\n            if (!master || master.kind !== 'label') {\n                next_token.warn('not_a_label');\n            } else if (master.dead || master.function !== funct) {\n                next_token.warn('not_a_scope');\n            } else {\n                master.used += 1;\n            }\n            that.first = next_token;\n            advance();\n        }\n        return that;\n\n    }\n\n    disrupt_stmt('break', function () {\n        return optional_label(this);\n    });\n\n    disrupt_stmt('continue', function () {\n        if (!option.continue) {\n            this.warn('unexpected_a');\n        }\n        return optional_label(this);\n    });\n\n    disrupt_stmt('return', function () {\n        if (funct === global_funct) {\n            this.warn('unexpected_a');\n        }\n        this.arity = 'statement';\n        if (next_token.id !== ';' && next_token.line === token.line) {\n            if (option.closure) {\n                spaces();\n            } else {\n                one_space_only();\n            }\n            if (next_token.id === '/' || next_token.id === '(regexp)') {\n                next_token.warn('wrap_regexp');\n            }\n            this.first = expression(0);\n            if (this.first.assign) {\n                this.first.warn('unexpected_a');\n            }\n        }\n        return this;\n    });\n\n    disrupt_stmt('throw', function () {\n        this.arity = 'statement';\n        one_space_only();\n        this.first = expression(20);\n        return this;\n    });\n\n\n//  Superfluous reserved words\n\n    reserve('class');\n    reserve('const');\n    reserve('enum');\n    reserve('export');\n    reserve('extends');\n    reserve('import');\n    reserve('super');\n\n// Harmony reserved words\n\n    reserve('implements');\n    reserve('interface');\n    reserve('let');\n    reserve('package');\n    reserve('private');\n    reserve('protected');\n    reserve('public');\n    reserve('static');\n    reserve('yield');\n\n\n// Parse JSON\n\n    function json_value() {\n\n        function json_object() {\n            var brace = next_token, object = Object.create(null);\n            advance('{');\n            if (next_token.id !== '}') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    if (next_token.id !== '(string)') {\n                        next_token.warn('expected_string_a');\n                    }\n                    if (object[next_token.string] === true) {\n                        next_token.warn('duplicate_a');\n                    } else if (next_token.string === '__proto__') {\n                        next_token.warn('dangling_a');\n                    } else {\n                        object[next_token.string] = true;\n                    }\n                    advance();\n                    advance(':');\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === '}') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance('}', brace);\n        }\n\n        function json_array() {\n            var bracket = next_token;\n            advance('[');\n            if (next_token.id !== ']') {\n                while (next_token.id !== '(end)') {\n                    while (next_token.id === ',') {\n                        next_token.warn('unexpected_a');\n                        advance(',');\n                    }\n                    json_value();\n                    if (next_token.id !== ',') {\n                        break;\n                    }\n                    advance(',');\n                    if (next_token.id === ']') {\n                        token.warn('unexpected_a');\n                        break;\n                    }\n                }\n            }\n            advance(']', bracket);\n        }\n\n        switch (next_token.id) {\n        case '{':\n            json_object();\n            break;\n        case '[':\n            json_array();\n            break;\n        case 'true':\n        case 'false':\n        case 'null':\n        case '(number)':\n        case '(string)':\n            advance();\n            break;\n        case '-':\n            advance('-');\n            no_space_only();\n            advance('(number)');\n            break;\n        default:\n            next_token.stop('unexpected_a');\n        }\n    }\n\n\n// The actual JSLINT function itself.\n\n    itself = function JSLint(the_source, the_option) {\n\n        var i, predef, tree;\n        itself.errors = [];\n        itself.tree = '';\n        itself.properties = '';\n        begin = prev_token = token = next_token =\n            Object.create(syntax['(begin)']);\n        tokens = [];\n        predefined = Object.create(null);\n        add_to_predefined(standard);\n        property = Object.create(null);\n        if (the_option) {\n            option = Object.create(the_option);\n            predef = option.predef;\n            if (predef) {\n                if (Array.isArray(predef)) {\n                    for (i = 0; i < predef.length; i += 1) {\n                        predefined[predef[i]] = true;\n                    }\n                } else if (typeof predef === 'object') {\n                    add_to_predefined(predef);\n                }\n            }\n        } else {\n            option = Object.create(null);\n        }\n        option.indent = +option.indent || 4;\n        option.maxerr = +option.maxerr || 50;\n        global_scope = scope = Object.create(null);\n        global_funct = funct = {\n            scope: scope,\n            loopage: 0,\n            level: 0\n        };\n        functions = [funct];\n        block_var = [];\n\n        comments = [];\n        comments_off = false;\n        in_block = false;\n        indent = null;\n        json_mode = false;\n        lookahead = [];\n        node_js = false;\n        prereg = true;\n        strict_mode = false;\n        var_mode = null;\n        warnings = 0;\n        lex.init(the_source);\n\n        assume();\n\n        try {\n            advance();\n            if (next_token.id === '(number)') {\n                next_token.stop('unexpected_a');\n            } else {\n                switch (next_token.id) {\n                case '{':\n                case '[':\n                    comments_off = true;\n                    json_mode = true;\n                    json_value();\n                    break;\n                default:\n\n// If the first token is a semicolon, ignore it. This is sometimes used when\n// files are intended to be appended to files that may be sloppy. A sloppy\n// file may be depending on semicolon insertion on its last line.\n\n                    step_in(1);\n                    if (next_token.id === ';' && !node_js) {\n                        semicolon();\n                    }\n                    tree = statements();\n                    begin.first = tree;\n                    itself.tree = begin;\n                    if (tree.disrupt) {\n                        prev_token.warn('weird_program');\n                    }\n                }\n            }\n            indent = null;\n            advance('(end)');\n            itself.property = property;\n        } catch (e) {\n            if (e) {        // ~~\n                itself.errors.push({\n                    reason    : e.message,\n                    line      : e.line || next_token.line,\n                    character : e.character || next_token.from\n                }, null);\n            }\n        }\n        return itself.errors.length === 0;\n    };\n\n    function unique(array) {\n        array = array.sort();\n        var i, length = 0, previous, value;\n        for (i = 0; i < array.length; i += 1) {\n            value = array[i];\n            if (value !== previous) {\n                array[length] = value;\n                previous = value;\n                length += 1;\n            }\n        }\n        array.length = length;\n        return array;\n    }\n\n// Data summary.\n\n    itself.data = function () {\n        var data = {functions: []},\n            function_data,\n            i,\n            the_function,\n            the_scope;\n        data.errors = itself.errors;\n        data.json = json_mode;\n        data.global = unique(Object.keys(global_scope));\n\n        function selects(name) {\n            var kind = the_scope[name].kind;\n            switch (kind) {\n            case 'var':\n            case 'exception':\n            case 'label':\n                function_data[kind].push(name);\n                break;\n            }\n        }\n\n        for (i = 1; i < functions.length; i += 1) {\n            the_function = functions[i];\n            function_data = {\n                name: the_function.name,\n                line: the_function.line,\n                level: the_function.level,\n                parameter: the_function.parameter,\n                var: [],\n                exception: [],\n                closure: unique(the_function.closure),\n                outer: unique(the_function.outer),\n                global: unique(the_function.global),\n                label: []\n            };\n            the_scope = the_function.scope;\n            Object.keys(the_scope).forEach(selects);\n            function_data.var.sort();\n            function_data.exception.sort();\n            function_data.label.sort();\n            data.functions.push(function_data);\n        }\n        data.tokens = tokens;\n        return data;\n    };\n\n    itself.error_report = function (data) {\n        var evidence, i, output = [], warning;\n        if (data.errors.length) {\n            if (data.json) {\n                output.push('<cite>JSON: bad.</cite><br>');\n            }\n            for (i = 0; i < data.errors.length; i += 1) {\n                warning = data.errors[i];\n                if (warning) {\n                    evidence = warning.evidence || '';\n                    output.push('<cite>');\n                    if (isFinite(warning.line)) {\n                        output.push('<address>line ' +\n                            String(warning.line) +\n                            ' character ' + String(warning.character) +\n                            '</address>');\n                    }\n                    output.push(warning.reason.entityify() + '</cite>');\n                    if (evidence) {\n                        output.push('<pre>' + evidence.entityify() + '</pre>');\n                    }\n                }\n            }\n        }\n        return output.join('');\n    };\n\n\n    itself.report = function (data) {\n        var dl, i, j, names, output = [], the_function;\n\n        function detail(h, array) {\n            var comma_needed = false;\n            if (array.length) {\n                output.push(\"<dt>\" + h + \"</dt><dd>\");\n                array.forEach(function (item) {\n                    output.push((comma_needed ? ', ' : '') + item);\n                    comma_needed = true;\n                });\n                output.push(\"</dd>\");\n            }\n        }\n\n        output.push('<dl class=level0>');\n        if (data.global.length) {\n            detail('global', data.global);\n            dl = true;\n        } else if (data.json) {\n            if (!data.errors.length) {\n                output.push(\"<dt>JSON: good.</dt>\");\n            }\n        } else {\n            output.push(\"<dt><i>No new global variables introduced.</i></dt>\");\n        }\n        if (dl) {\n            output.push(\"</dl>\");\n        } else {\n            output[0] = '';\n        }\n\n        if (data.functions) {\n            for (i = 0; i < data.functions.length; i += 1) {\n                the_function = data.functions[i];\n                names = [];\n                if (the_function.params) {\n                    for (j = 0; j < the_function.params.length; j += 1) {\n                        names[j] = the_function.params[j].string;\n                    }\n                }\n                output.push('<dl class=level' + the_function.level +\n                    '><address>line ' + String(the_function.line) +\n                    '</address>' + the_function.name.entityify());\n                detail('parameter', the_function.parameter);\n                detail('variable', the_function.var);\n                detail('exception', the_function.exception);\n                detail('closure', the_function.closure);\n                detail('outer', the_function.outer);\n                detail('global', the_function.global);\n                detail('label', the_function.label);\n                output.push('</dl>');\n            }\n        }\n        return output.join('');\n    };\n\n    itself.properties_report = function (property) {\n        if (!property) {\n            return '';\n        }\n        var i,\n            key,\n            keys = Object.keys(property).sort(),\n            mem = '    ',\n            name,\n            not_first = false,\n            output = ['/*properties'];\n        for (i = 0; i < keys.length; i += 1) {\n            key = keys[i];\n            if (property[key] > 0) {\n                if (not_first) {\n                    mem += ', ';\n                }\n                name = ix.test(key)\n                    ? key\n                    : '\\'' + key.replace(nx, sanitize) + '\\'';\n                if (mem.length + name.length >= 80) {\n                    output.push(mem);\n                    mem = '    ';\n                }\n                mem += name;\n                not_first = true;\n            }\n        }\n        output.push(mem, '*/\\n');\n        return output.join('\\n');\n    };\n\n    itself.color = function (data) {\n        var from,\n            i = 1,\n            level,\n            line,\n            result = [],\n            thru,\n            data_token = data.tokens[0];\n        while (data_token && data_token.id !== '(end)') {\n            from = data_token.from;\n            line = data_token.line;\n            thru = data_token.thru;\n            level = data_token.function.level;\n            do {\n                thru = data_token.thru;\n                data_token = data.tokens[i];\n                i += 1;\n            } while (data_token && data_token.line === line &&\n                    data_token.from - thru < 5 &&\n                    level === data_token.function.level);\n            result.push({\n                line: line,\n                level: level,\n                from: from,\n                thru: thru\n            });\n        }\n        return result;\n    };\n\n    itself.jslint = itself;\n\n    itself.edition = '2013-08-26';\n\n    return itself;\n}());\n"}